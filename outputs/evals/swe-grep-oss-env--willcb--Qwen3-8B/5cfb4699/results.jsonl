{"example_id":0,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"Modeling's `separability_matrix` does not compute separability correctly for nested CompoundModels\nConsider the following model:\r\n\r\n```python\r\nfrom astropy.modeling import models as m\r\nfrom astropy.modeling.separable import separability_matrix\r\n\r\ncm = m.Linear1D(10) & m.Linear1D(5)\r\n```\r\n\r\nIt's separability matrix as you might expect is a diagonal:\r\n\r\n```python\r\n>>> separability_matrix(cm)\r\narray([[ True, False],\r\n       [False,  True]])\r\n```\r\n\r\nIf I make the model more complex:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5))\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True, False],\r\n       [False, False, False,  True]])\r\n```\r\n\r\nThe output matrix is again, as expected, the outputs and inputs to the linear models are separable and independent of each other.\r\n\r\nIf however, I nest these compound models:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & cm)\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True,  True],\r\n       [False, False,  True,  True]])\r\n```\r\nSuddenly the inputs and outputs are no longer separable?\r\n\r\nThis feels like a bug to me, but I might be missing something?\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-43beedc45cf241bca2de998ae2a59b5d\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'separability_matrix' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-507d4699613f4cfba14deb81f335e7f4\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'CompoundModel' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-479acb808f2d46de8bf94fb97119fb88\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'separability_matrix' tests\/ -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"astropy\/modeling\/core.py:    def _calculate_separability_matrix(self):\nastropy\/modeling\/separable.py:__all__ = [\"is_separable\", \"separability_matrix\"]\nastropy\/modeling\/separable.py:def separability_matrix(transform):\nastropy\/modeling\/separable.py:    >>> separability_matrix(Shift(1) & Shift(2) | Scale(1) & Scale(2))\nastropy\/modeling\/separable.py:    >>> separability_matrix(Shift(1) & Shift(2) | Rotation2D(2))\nastropy\/modeling\/separable.py:    >>> separability_matrix(Shift(1) & Shift(2) | Mapping([0, 1, 0, 1]) | \\\nastropy\/modeling\/separable.py:    >>> separability_matrix(Shift(1) & Shift(2) | Mapping([0, 1, 0, 1]))\nastropy\/modeling\/separable.py:    if (transform_matrix := transform._calculate_separability_matrix()) is not NotImplemented:\nastropy\/modeling\/tests\/test_models.py:from astropy.modeling.separable import separability_matrix\nastropy\/modeling\/tests\/test_models.py:    def _calculate_separability_matrix(self):\nastropy\/modeling\/tests\/test_models.py:def test_custom_separability_matrix():\nastropy\/modeling\/tests\/test_models.py:    original = separability_matrix(ModelDefault(slope=1, intercept=2))\nastropy\/modeling\/tests\/test_models.py:    custom = separability_matrix(ModelCustom(slope=1, intercept=2))\nastropy\/modeling\/tests\/test_separable.py:                                        _cstack, _arith_oper, separability_matrix)\nastropy\/modeling\/tests\/test_separable.py:    assert_allclose(separability_matrix(compound_model), result[1])\nastropy\/modeling\/tests\/test_separable.py:    assert np.all(separability_matrix(model_c()) == [True, True])\nastropy\/modeling\/tests\/test_core.py:from astropy.modeling.separable import separability_matrix\nastropy\/modeling\/tests\/test_core.py:    assert (separability_matrix(m) == [[True, True],\nastropy\/modeling\/tests\/test_core.py:    assert (separability_matrix(m) == [[True, True, True],","role":"tool","tool_calls":null},{"content":"astropy\/convolution\/convolve.py:from astropy.modeling.core import SPECIAL_OPERATORS, CompoundModel\nastropy\/convolution\/convolve.py:    default : `~astropy.modeling.core.CompoundModel`\nastropy\/convolution\/convolve.py:    return CompoundModel(operator, model, kernel)\nastropy\/convolution\/convolve.py:    default : `~astropy.modeling.core.CompoundModel`\nastropy\/io\/misc\/asdf\/tags\/transform\/compound.py:from astropy.modeling.core import Model, CompoundModel\nastropy\/io\/misc\/asdf\/tags\/transform\/compound.py:    types = [CompoundModel]\nastropy\/io\/misc\/asdf\/tags\/transform\/compound.py:            model = CompoundModel('fix_inputs', left, right)\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:from astropy.modeling.core import CompoundModel\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:            if not isinstance(model, CompoundModel):\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:        if not isinstance(model, CompoundModel):\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:        if not isinstance(model, CompoundModel):\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    not available at the time that the CompoundModel is\nastropy\/modeling\/separable.py:from .core import Model, ModelDefinitionError, CompoundModel\nastropy\/modeling\/separable.py:    elif isinstance(transform, CompoundModel):\nastropy\/modeling\/core.py:           'CompoundModel', 'fix_inputs', 'custom_model', 'ModelDefinitionError',\nastropy\/modeling\/core.py:    return lambda left, right: CompoundModel(oper, left, right, **kwargs)\nastropy\/modeling\/core.py:        if isinstance(self, CompoundModel):\nastropy\/modeling\/core.py:        return (not isinstance(self, CompoundModel))\nastropy\/modeling\/core.py:        # prepare for model evaluation (overridden in CompoundModel)\nastropy\/modeling\/core.py:        # post-process evaluation results (overridden in CompoundModel)\nastropy\/modeling\/core.py:        if isinstance(model, CompoundModel):\nastropy\/modeling\/core.py:        `CompoundModel`\nastropy\/modeling\/core.py:            A `CompoundModel` composed of the current model plus\nastropy\/modeling\/core.py:class CompoundModel(Model):\nastropy\/modeling\/core.py:        \"\"\" Return the names of submodels in a ``CompoundModel``.\"\"\"\nastropy\/modeling\/core.py:            \"CompoundModel.both_inverses_exist is deprecated. \"\nastropy\/modeling\/core.py:        CompoundModel specific input setup that needs to occur prior to\nastropy\/modeling\/core.py:        CompoundModel specific post evaluation processing of outputs\nastropy\/modeling\/core.py:        \"\"\" Postorder traversal of the CompoundModel tree.\"\"\"\nastropy\/modeling\/core.py:        if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:        if isinstance(self.right, CompoundModel):\nastropy\/modeling\/core.py:            if not isinstance(node, CompoundModel):\nastropy\/modeling\/core.py:                if isinstance(node, CompoundModel):\nastropy\/modeling\/core.py:                    if (isinstance(node.left, CompoundModel) and\nastropy\/modeling\/core.py:                    if (isinstance(node.right, CompoundModel) and\nastropy\/modeling\/core.py:        if isinstance(branch, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:                if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.right, CompoundModel):\nastropy\/modeling\/core.py:                    if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:                    if isinstance(self.right, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:                if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.right, CompoundModel):\nastropy\/modeling\/core.py:                if isinstance(self.right, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.right, CompoundModel):\nastropy\/modeling\/core.py:                    if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:                    if isinstance(self.right, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:                if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:        Construct a new `~astropy.modeling.CompoundModel` instance from an\nastropy\/modeling\/core.py:        existing CompoundModel, replacing the named submodel with a new model.\nastropy\/modeling\/core.py:        necessary to rebuild the CompoundModel from the replaced node all the\nastropy\/modeling\/core.py:        way back to the base. The original CompoundModel is left untouched.\nastropy\/modeling\/core.py:            # although it would fail trying to construct the new CompoundModel\nastropy\/modeling\/core.py:                model = CompoundModel(branch.op, branch.left, branch.right,\nastropy\/modeling\/core.py:        model = CompoundModel(self.op, left, right)\nastropy\/modeling\/core.py:        `~astropy.modeling.CompoundModel.with_units_from_data`.\nastropy\/modeling\/core.py:        `~astropy.modeling.CompoundModel.without_units_for_data` passed as\nastropy\/modeling\/core.py:    \"\"\"Find the route down a CompoundModel's tree to the model with the\nastropy\/modeling\/core.py:    if isinstance(tree, CompoundModel):\nastropy\/modeling\/core.py:    model = CompoundModel('fix_inputs', modelinstance, values)\nastropy\/modeling\/convolution.py:from .core import CompoundModel, SPECIAL_OPERATORS\nastropy\/modeling\/convolution.py:class Convolution(CompoundModel):\nastropy\/modeling\/utils.py:    Operators for CompoundModels. This dictionary is structured so that\nastropy\/modeling\/bounding_box.py:        # NOTE: CompoundModel does not currently support units during\nastropy\/modeling\/bounding_box.py:        #   for CompoundModel(s).\nastropy\/modeling\/tests\/test_core.py:from astropy.modeling.core import (Model, CompoundModel, custom_model,\nastropy\/modeling\/tests\/test_core.py:def test_print_special_operator_CompoundModel(capsys):\nastropy\/modeling\/tests\/test_core.py:    true_out = \"Model: CompoundModel\\n\" +\\\nastropy\/modeling\/tests\/test_core.py:    assert isinstance(model, CompoundModel)\nastropy\/modeling\/tests\/test_compound.py:from astropy.modeling.core import Model, ModelDefinitionError, CompoundModel\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(s, CompoundModel)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(S1, CompoundModel)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(S2, CompoundModel)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(r1, CompoundModel)\nastropy\/modeling\/tests\/test_compound.py:    Test that CompoundModel.n_submodels properly returns the number\nastropy\/modeling\/tests\/test_compound.py:        CompoundModel('#', g1, g1)","role":"tool","tool_calls":null},{"content":"Error (exit code 2):\ntests\/: No such file or directory (os error 2)","role":"tool","tool_calls":null},{"content":"\n\n<files>\nastropy\/modeling\/separable.py\nastropy\/modeling\/core.py\nastropy\/modeling\/tests\/test_separable.py\n<\/files>","role":"assistant","tool_calls":null}],"task":"default","reward":0.5,"generation_ms":37644.957780838,"scoring_ms":0.17786026,"total_ms":37645.135641098,"info":{"instance_id":"astropy__astropy-12907","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/modeling\/separable.py\": {\"old_start\": 242, \"old_count\": 7, \"new_start\": 242, \"new_count\": 7, \"hunks\": [{\"old_start\": 242, \"old_count\": 7, \"new_start\": 242, \"new_count\": 7}]}}","file_localization_reward":0.5}
{"example_id":1,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"Please support header rows in RestructuredText output\n### Description\r\n\r\nIt would be great if the following would work:\r\n\r\n```Python\r\n>>> from astropy.table import QTable\r\n>>> import astropy.units as u\r\n>>> import sys\r\n>>> tbl = QTable({'wave': [350,950]*u.nm, 'response': [0.7, 1.2]*u.count})\r\n>>> tbl.write(sys.stdout,  format=\"ascii.rst\")\r\n===== ========\r\n wave response\r\n===== ========\r\n350.0      0.7\r\n950.0      1.2\r\n===== ========\r\n>>> tbl.write(sys.stdout,  format=\"ascii.fixed_width\", header_rows=[\"name\", \"unit\"])\r\n|  wave | response |\r\n|    nm |       ct |\r\n| 350.0 |      0.7 |\r\n| 950.0 |      1.2 |\r\n>>> tbl.write(sys.stdout,  format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/table\/connect.py\", line 129, in __call__\r\n    self.registry.write(instance, *args, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/registry\/core.py\", line 369, in write\r\n    return writer(data, *args, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/ascii\/connect.py\", line 26, in io_write\r\n    return write(table, filename, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/ascii\/ui.py\", line 856, in write\r\n    writer = get_writer(Writer=Writer, fast_writer=fast_writer, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/ascii\/ui.py\", line 800, in get_writer\r\n    writer = core._get_writer(Writer, fast_writer, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/ascii\/core.py\", line 1719, in _get_writer\r\n    writer = Writer(**writer_kwargs)\r\nTypeError: RST.__init__() got an unexpected keyword argument 'header_rows'\r\n```\r\n\r\n\r\n### Additional context\r\n\r\nRestructuredText output is a great way to fill autogenerated documentation with content, so having this flexible makes the life easier `:-)`\r\n\r\n\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-9c01ad714b7d49ee88215d1570ba7f39\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg \\\\\\\"rst\\\\\\\" -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-9dc427e83e894bed93413e36bc36d681\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg \\\\\\\"header_rows\\\\\\\" -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-0a333064e2d146358f33268a3790e6b4\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"find . -path \\\\\\\"*astropy\/io\/ascii*\\\\\\\" -type f -name \\\\\\\"*.py\\\\\\\"\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"setup.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nsetup.py:# First provide helpful messages if contributors try and run legacy commands\nastropy\/conftest.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/mpl_normalize.py:        All other keyword arguments are parsed first by the\nastropy\/visualization\/stretch.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/stretch.py:        with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/stretch.py:        with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/stretch.py:        with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/stretch.py:        The first stretch to apply.\nastropy\/visualization\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/time.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/time.py:        the scale of the first Time object passed to Matplotlib is used.\nastropy\/visualization\/time.py:        the format of the first Time object passed to Matplotlib is used.\nastropy\/visualization\/scripts\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/scripts\/fits2bitmap.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/units.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/core.py:        that the first WCS dimension (last Numpy dimension) will be sliced at\nastropy\/visualization\/wcsaxes\/core.py:        x axis, and the final WCS dimension (first Numpy dimension) will be\nastropy\/visualization\/wcsaxes\/core.py:            # Extract the frame from the first argument.\nastropy\/visualization\/wcsaxes\/core.py:        The first argument to\nastropy\/visualization\/wcsaxes\/core.py:        coordinate, which will then be converted to the first two parameters to\nastropy\/visualization\/wcsaxes\/core.py:            first two arguments to `matplotlib.axes.Axes.plot`.\nastropy\/visualization\/wcsaxes\/core.py:        The first argument to\nastropy\/visualization\/wcsaxes\/core.py:        coordinate, which will then be converted to the first two parameters to\nastropy\/visualization\/wcsaxes\/core.py:            the first two arguments to `matplotlib.axes.Axes.scatter`.\nastropy\/visualization\/wcsaxes\/core.py:                  common world coordinate system first.\nastropy\/visualization\/wcsaxes\/formatter_locator.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/formatter_locator.py:                # first compute the exact spacing\nastropy\/visualization\/wcsaxes\/formatter_locator.py:                # first compute the exact spacing\nastropy\/visualization\/wcsaxes\/coordinates_map.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/coordinates_map.py:            (``'contours'``). The first is recommended for 2-d images, while\nastropy\/visualization\/wcsaxes\/ticklabels.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/coordinate_range.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/coordinate_range.py:    with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/coordinate_range.py:        with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/coordinate_range.py:        with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/coordinate_range.py:            # Iron out coordinates along first row\nastropy\/visualization\/wcsaxes\/coordinate_range.py:            with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/coordinate_range.py:            # Now iron out coordinates along all columns, starting with first row.\nastropy\/visualization\/wcsaxes\/coordinate_range.py:            with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/wcsapi.py:            elif \"pos.heliographic.stonyhurst.lon\" in axis_type:\nastropy\/visualization\/wcsaxes\/wcsapi.py:            elif \"pos.heliographic.stonyhurst.lat\" in axis_type:\nastropy\/visualization\/scripts\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/ticks.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/axislabels.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/patches.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:    with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:            (``'contours'``). The first is recommended for 2-d images, while\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        # First find the ticks we want to show\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:                with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:                with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:                with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:                with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:            with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:            # calculating that patch requires updating all spines first, which is a\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:            with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:            with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        # First do some sanity checking on the keyword arguments\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/transforms.py:        with np.errstate(all=\"ignore\"):\nastropy\/visualization\/hist.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/interval.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/interval.py:    Licensed under a 3-clause BSD style license (see AURA_LICENSE.rst).\nastropy\/visualization\/lupton_rgb.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/lupton_rgb.py:        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):\nastropy\/visualization\/lupton_rgb.py:            with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/lupton_rgb.py:        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):\nastropy\/visualization\/lupton_rgb.py:        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):\nastropy\/visualization\/lupton_rgb.py:        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):\nastropy\/visualization\/wcsaxes\/frame.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/frame.py:            with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/frame.py:            with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/grid_paths.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/grid_paths.py:    # Define the relevant scale size using the separation between the first two points\nastropy\/visualization\/wcsaxes\/grid_paths.py:    with np.errstate(invalid=\"ignore\"):\nastropy\/visualization\/wcsaxes\/grid_paths.py:    # The above missed the first step, so check that too\nastropy\/visualization\/wcsaxes\/helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_formatter_locator.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_wcsapi.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_stretch.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_time.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_time.py:# We first check that we get the expected labels for different time intervals\nastropy\/visualization\/tests\/test_time.py:    # Check that the format\/scale is taken from the first time used.\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_units.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_norm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_interval.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_lupton_rgb.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_histogram.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_display_world_coordinates.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/transform.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/transform.py:        The first transform to apply.\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:        # The first subplot tests:\nastropy\/visualization\/wcsaxes\/tests\/test_coordinate_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/__init__.py:                \"modules first. Either run:\\n\\n\"\nastropy\/visualization\/mpl_style.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/version.py:# NOTE: First try _dev.scm_version if it exists and setuptools_scm is installed\nastropy\/visualization\/wcsaxes\/tests\/test_frame.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/logger.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/logger.py:                # First use our excepthook\nastropy\/wcs\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/kernels.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/kernels.py:        The radius of the Airy disk kernel (radius of the first zero).\nastropy\/convolution\/tests\/test_convolve_nddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/utils.py:    # Extract longitude and latitude. We first try and use lon\/lat directly,\nastropy\/wcs\/utils.py:    The first WCS specified is the one used for the pixel -> world\nastropy\/wcs\/utils.py:    form a new WCS. For example, in the case of a spectral cube with the first\nastropy\/wcs\/utils.py:        6 element array. First 4 elements are PC matrix, last 2 are CRPIX.\nastropy\/wcs\/utils.py:        Fittable parameters. First 4 elements are PC matrix, last 2 are CRPIX.\nastropy\/wcs\/utils.py:    where the first three elements are the coordinate in a cartesian\nastropy\/wcs\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/yaml.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/yaml.py:    \"\"\"Parse the first YAML document in a stream using the AstropyLoader and\nastropy\/table\/table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/table.py:        # Fill the missing entries with first values\nastropy\/table\/table.py:                first_val = next(val for val in col if val is not MISSING)\nastropy\/table\/table.py:                    col[index] = first_val\nastropy\/table\/table.py:                # Don't understand why this is forcing a value on the original column.\nastropy\/table\/table.py:                # Set an existing column by first trying to replace, and if\nastropy\/table\/table.py:        # For performance reasons (esp. in Row) cache the first column name\nastropy\/table\/table.py:            return len(OrderedDict.__getitem__(self.columns, self._first_colname))\nastropy\/table\/table.py:            # Get the first column name\nastropy\/table\/table.py:            self._first_colname = next(iter(self.columns))\nastropy\/table\/table.py:            return len(self.columns[self._first_colname])\nastropy\/table\/table.py:                    # try that first.\nastropy\/table\/table.py:            # If anything went wrong first revert the row update then raise\nastropy\/table\/table.py:            ...            [12, 15, 18]], names=('firstname', 'name', 'tel'))\nastropy\/table\/table.py:            firstname   name  tel\nastropy\/table\/table.py:        Sorting according to standard sorting rules, first 'name' then 'firstname'::\nastropy\/table\/table.py:            >>> t.sort(['name', 'firstname'])\nastropy\/table\/table.py:            firstname   name  tel\nastropy\/table\/table.py:        Sorting according to standard sorting rules, first 'firstname' then 'tel',\nastropy\/table\/table.py:            >>> t.sort(['firstname', 'tel'], reverse=True)\nastropy\/table\/table.py:            firstname   name  tel\nastropy\/table\/table.py:                # First statement in try: will succeed if the column supports an in-place\nastropy\/table\/table.py:            ...         [12,15,18]], names=('firstname','name','tel'))\nastropy\/table\/table.py:            firstname   name  tel\nastropy\/table\/table.py:            firstname   name  tel\nastropy\/table\/table.py:            # First statement in try: will succeed if the column supports an in-place\nastropy\/convolution\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/pickle_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/pickle_helpers.py:        If 0, a single object will be returned (the first in the file). If >0,\nastropy\/io\/misc\/pickle_helpers.py:        If ``number`` is 0, this is a individual object - the first one\nastropy\/io\/misc\/pandas\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/pandas\/connect.py:    # but make this done on a first use basis\nastropy\/io\/misc\/hdf5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/hdf5.py:    table is present in the HDF5 file or group, the first table is read in and\nastropy\/io\/misc\/hdf5.py:                        \" are present, reading in first available\"\nastropy\/table\/sorted_array.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/sorted_array.py:        pos = self.find_pos(key, row)  # first >= key\nastropy\/table\/sorted_array.py:            exclusive with respect to the endpoints. The first\nastropy\/io\/ascii\/latex.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/latex.py:    Find the first line which matches a pattern\nastropy\/io\/ascii\/latex.py:            line = line.rstrip(r\"\\\\\")\nastropy\/io\/ascii\/latex.py:        * tabletype : used for first and last line of table.\nastropy\/io\/ascii\/latex.py:    # problem with Jupyter notebook, which displays a table by first calling\nastropy\/io\/ascii\/basic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/basic.py:    Lines beginning with a comment character (default='#') as the first\nastropy\/io\/ascii\/basic.py:      # Column definition is the first uncommented line\nastropy\/io\/ascii\/basic.py:    Data starts at first uncommented line since there is no header line.\nastropy\/io\/ascii\/basic.py:        # commented_header format (first by default).\nastropy\/table\/index.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/index.py:        # deleting rows first and then reordering the remaining rows\nastropy\/table\/index.py:            exclusive with respect to the endpoints. The first\nastropy\/table\/index.py:            exclusive with respect to the endpoints. The first\nastropy\/table\/index.py:            If a tuple is provided, the first element must be\nastropy\/table\/index.py:              If a tuple is provided, the first element must be\nastropy\/table\/index.py:               If a tuple is provided, the first element must be\nastropy\/io\/ascii\/html.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/html.py:            use the first table found in the input file.\nastropy\/table\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_cds_header_from_readme.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/fastbasic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/row.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/__init__.py:from .rst import RST\nastropy\/io\/misc\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/cds.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/cds.py:            elif found_line:  # First line after list of file descriptions\nastropy\/io\/ascii\/cds.py:            # Replicate the first part of BaseReader.read up to the point where\nastropy\/io\/ascii\/tests\/test_cds.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_compressed.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/operations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/operations.py:def unique(input_table, keys=None, silent=False, keep=\"first\"):\nastropy\/table\/operations.py:    keep : {'first', 'last', 'none'}\nastropy\/table\/operations.py:        Whether to keep the first or last row for each set of\nastropy\/table\/operations.py:        Default is 'first'.\nastropy\/table\/operations.py:    if keep not in (\"first\", \"last\", \"none\"):\nastropy\/table\/operations.py:        raise ValueError(\"'keep' should be one of 'first', 'last', 'none'\")\nastropy\/table\/operations.py:    if keep == \"first\":\nastropy\/io\/ascii\/tests\/test_types.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_read.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_read.py:    # This is a Basic format table and the first row\nastropy\/io\/ascii\/tests\/test_read.py:    # This is also a Basic format table and the first row\nastropy\/io\/ascii\/tests\/test_read.py:    assert_equal(table.comment_lines, [\"# first comment\", \"  # second comment\"])\nastropy\/io\/ascii\/tests\/test_read.py:    assert_equal(data.meta[\"comments\"], [\"first comment\", \"second comment\"])\nastropy\/io\/ascii\/tests\/test_read.py:            \"\"\"# Column definition is the first uncommented line\nastropy\/io\/ascii\/tests\/test_html.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_html.py:    # First with default where blank => '0'\nastropy\/io\/ascii\/tests\/test_html.py:    # In absence of table_id, defaults to the first table\nastropy\/io\/ascii\/tests\/test_html.py:    returns the first line of header data. Uses t\/html.html\nastropy\/io\/ascii\/tests\/test_html.py:    of HTMLData returns the first line of table data. Uses\nastropy\/io\/ascii\/tests\/test_c_reader.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_c_reader.py:def test_rstrip_whitespace(parallel, read_basic):\nastropy\/io\/ascii\/tests\/test_c_reader.py:    text = \"# first commented line\\n # second commented line\\n\\n\" + text\nastropy\/io\/ascii\/tests\/test_c_reader.py:    first column is missing [#3545]\nastropy\/io\/ascii\/tests\/test_c_reader.py:    shows up first, it will produce a string column - with both readers.\nastropy\/io\/ascii\/tests\/test_c_reader.py:    # Tested entries and expected returns, first for auto-detect,\nastropy\/io\/ascii\/tests\/test_c_reader.py:    tabrst = dedent(\nastropy\/io\/ascii\/tests\/test_c_reader.py:    t3 = ascii.read(tabrst.split(\"\\n\"), format=\"rst\")\nastropy\/io\/ascii\/tests\/test_c_reader.py:    t4 = ascii.read(tabrst.split(\"\\n\"), guess=True)\nastropy\/io\/ascii\/tests\/test_c_reader.py:    t5 = ascii.read(tabrst.split(\"\\n\"), format=\"rst\", fast_reader=True)\nastropy\/io\/ascii\/tests\/test_c_reader.py:        ascii.read(tabrst.split(\"\\n\"), format=\"rst\", guess=False, fast_reader=\"force\")\nastropy\/io\/ascii\/tests\/test_c_reader.py:            tabrst.split(\"\\n\"),\nastropy\/io\/ascii\/tests\/test_c_reader.py:            format=\"rst\",\nastropy\/io\/ascii\/tests\/test_c_reader.py:    tabrst = tabrst.replace(\"E\", \"D\")\nastropy\/io\/ascii\/tests\/test_c_reader.py:            tabrst.split(\"\\n\"),\nastropy\/io\/ascii\/tests\/test_c_reader.py:            format=\"rst\",\nastropy\/io\/ascii\/tests\/test_rst.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/misc.py:def first_true_index(iterable, pred=None, default=None):\nastropy\/io\/ascii\/misc.py:    \"\"\"find the first index position for the which the callable pred returns True\"\"\"\nastropy\/io\/ascii\/misc.py:def first_false_index(iterable, pred=None, default=None):\nastropy\/io\/ascii\/misc.py:    \"\"\"find the first index position for the which the callable pred returns False\"\"\"\nastropy\/io\/ascii\/misc.py:    return first_true_index(iterable, func, default)\nastropy\/io\/ascii\/misc.py:        sorting done by value of first input list\nastropy\/io\/ascii\/misc.py:        (in this case the objects in the first iterable need the comparison\nastropy\/io\/ascii\/misc.py:        sorting done by value of key(item) for items in first iterable\nastropy\/io\/ascii\/misc.py:        the first n iterables (where n is the length of the key tuple)\nastropy\/io\/ascii\/misc.py:        i.e. the first callable is the primary sorting criterion, and the\nastropy\/io\/ascii\/misc.py:    first = list(args[0])\nastropy\/io\/ascii\/misc.py:    if not len(first):\nastropy\/io\/ascii\/tests\/common.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/common.py:        if not hasattr(newfunc, \"compat_co_firstlineno\"):\nastropy\/io\/ascii\/tests\/common.py:                newfunc.compat_co_firstlineno = func.func_code.co_firstlineno\nastropy\/io\/ascii\/tests\/common.py:                newfunc.compat_co_firstlineno = func.__code__.co_firstlineno\nastropy\/io\/ascii\/tests\/test_ecsv.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_ecsv.py:# First here is some helper code used to make the expected outputs code.\nastropy\/table\/soco.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/rst.py:    See: https:\/\/docutils.sourceforge.io\/docs\/ref\/rst\/restructuredtext.html#simple-tables\nastropy\/io\/ascii\/rst.py:    _format_name = \"rst\"\nastropy\/io\/ascii\/mrt.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/mrt.py:            \"heliographic\": (\"HLAT\", \"HLON\", \"lat\", \"lon\"),  # '_carrington|stonyhurst'\nastropy\/io\/ascii\/mrt.py:                    # If only the first value of the column is a ``SkyCoord`` object,\nastropy\/io\/ascii\/mrt.py:                # If there were any extra ``SkyCoord`` columns of one kind after the first one,\nastropy\/io\/ascii\/tests\/test_connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/table_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/table_helpers.py:    first_table = votable.get_first_table()\nastropy\/table\/table_helpers.py:    table = first_table.to_table()\nastropy\/io\/ascii\/fixedwidth.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/fixedwidth.py:        # determined from first data line and column names are either supplied by user\nastropy\/io\/ascii\/fixedwidth.py:            #    Two header lines where the first line defines the column names and\nastropy\/io\/ascii\/fixedwidth.py:        # First part is getting the widths of each column.\nastropy\/io\/ascii\/fixedwidth.py:    (``col_starts`` and ``col_stops`` keywords) or by splitting the first data\nastropy\/io\/ascii\/fixedwidth.py:    The first header line defines the column names and the second implicitly\nastropy\/table\/info.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/sextractor.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/ipac.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/ipac.py:            line = line.rstrip()\nastropy\/io\/ascii\/ipac.py:            # Keywords and comments start with \"\\\".  Once the first non-slash\nastropy\/io\/ascii\/ipac.py:        # first, we need that here.\nastropy\/table\/groups.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/groups.py:            # For key columns just pick off first in each group since they are identical\nastropy\/table\/serialize.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/serialize.py:        Returns the shape of the first item that has a shape at all,\nastropy\/table\/serialize.py:    # Keep the index of the first column, so we can insert the new one there later.\nastropy\/table\/serialize.py:        # col is the first and only serialized column; in that case, use info\nastropy\/table\/serialize.py:        # stored on the column. First step is to get that first column which\nastropy\/io\/ascii\/ecsv.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/ecsv.py:                # Stop iterating on first failed match for a non-blank line\nastropy\/io\/ascii\/ecsv.py:            'ECSV header line like \"# %ECSV <version>\" not found as first line.'\nastropy\/io\/ascii\/ecsv.py:        # Read the first non-commented line of table and split to get the CSV\nastropy\/io\/ascii\/ecsv.py:    See: https:\/\/github.com\/astropy\/astropy-APEs\/blob\/main\/APE6.rst\nastropy\/table\/ndarray_mixin.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_qdp.py:            \"table_id not specified. Reading the first available table\"\nastropy\/table\/column.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/column.py:# Always emit this warning, not just the first instance\nastropy\/table\/column.py:    # First convert data to a plain ndarray. If there are instances of np.ma.masked\nastropy\/table\/column.py:            # First try to interpret the data as Quantity. If that still fails then fall\nastropy\/table\/column.py:        # Use np.array first to convert `data` to ndarray (fast) and then make\nastropy\/table\/column.py:        # Alternatively: should we store info on the first part?\nastropy\/table\/column.py:        # Reconstruct a structured Column, by first making an empty column\nastropy\/table\/column.py:        # First just pass through all args and kwargs to BaseColumn, then wrap that object\nastropy\/table\/column.py:        # To handle this we are forced to reset a private variable first:\nastropy\/io\/ascii\/daophot.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/daophot.py:from .misc import first_false_index, first_true_index, groupmore\nastropy\/io\/ascii\/daophot.py:            N_multiline = len(self.data.first_block)\nastropy\/io\/ascii\/daophot.py:        # values from the first multiline data block\nastropy\/io\/ascii\/daophot.py:            # Grab the first column of the special block (aperture values) and\nastropy\/io\/ascii\/daophot.py:            aplist = next(zip(*map(str.split, self.first_block)))\nastropy\/io\/ascii\/daophot.py:        # Find first non-comment line\nastropy\/io\/ascii\/daophot.py:        data_start = first_false_index(comment)\nastropy\/io\/ascii\/daophot.py:        # Find first line ending on special row continuation character '*'\nastropy\/io\/ascii\/daophot.py:        first_special = first_true_index(special[data_start:depth])\nastropy\/io\/ascii\/daophot.py:        if first_special is None:  # no special lines\nastropy\/io\/ascii\/daophot.py:        last_special = first_false_index(special[data_start + first_special : depth])\nastropy\/io\/ascii\/daophot.py:        # index relative to first_special\nastropy\/io\/ascii\/daophot.py:        # if first_special is None: #no end of special lines within search\nastropy\/io\/ascii\/daophot.py:        markers = np.cumsum([data_start, first_special, last_special])\nastropy\/io\/ascii\/daophot.py:        # multiline portion of first data block\nastropy\/io\/ascii\/daophot.py:        self.data.first_block = block\nastropy\/io\/ascii\/daophot.py:    first aperture radius will be RAPERT and corresponding magnitude will be MAG,\nastropy\/io\/misc\/asdf\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/scripts\/showtable.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/tests\/test_yaml.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/extension.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_write.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/types.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/tests\/test_hdf5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/tests\/test_hdf5.py:    t1.meta[\"meta_biggerstill\"] = \"0\" * (2**18)\nastropy\/io\/misc\/tests\/test_hdf5.py:    t.meta[\"history\"] = [\"first\", \"second\", \"third\"]\nastropy\/io\/misc\/tests\/test_hdf5.py:    assert t2.meta[\"history\"] == [\"first\", \"second\", \"third\"]\nastropy\/io\/misc\/asdf\/tests\/test_io.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tests\/test_io.py:    return Table([a, b, c], names=(\"a\", \"b\", \"c\"), meta={\"name\": \"first table\"})\nastropy\/io\/misc\/tests\/test_pickle_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/tests\/test_parquet.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/tests\/test_parquet.py:    t1.meta[\"meta_biggerstill\"] = \"0\" * (2**18)\nastropy\/io\/misc\/tests\/test_parquet.py:    t.meta[\"history\"] = [\"first\", \"second\", \"third\"]\nastropy\/io\/misc\/tests\/test_parquet.py:    assert t2.meta[\"history\"] == [\"first\", \"second\", \"third\"]\nastropy\/io\/misc\/tests\/test_parquet.py:    t.meta[\"history\"] = [\"first\", \"second\", \"third\"]\nastropy\/io\/misc\/tests\/test_parquet.py:        assert t2.meta[\"history\"] == [\"first\", \"second\", \"third\"]\nastropy\/io\/misc\/tests\/test_parquet.py:    t.meta[\"history\"] = [\"first\", \"second\", \"third\"]\nastropy\/io\/misc\/tests\/test_parquet.py:    t.meta[\"history\"] = [\"first\", \"second\", \"third\"]\nastropy\/io\/misc\/tests\/test_parquet.py:    t.meta[\"history\"] = [\"first\", \"second\", \"third\"]\nastropy\/io\/misc\/tests\/test_parquet.py:    assert t2.meta[\"history\"] == [\"first\", \"second\", \"third\"]\nastropy\/convolution\/tests\/test_kernel_class.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/tests\/test_pandas.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/jsviewer.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/qdp.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/qdp.py:            # The first time I find commands, I save whatever comments into\nastropy\/io\/ascii\/qdp.py:            # The first time I find data, I define err_specs\nastropy\/io\/ascii\/qdp.py:                    # Understand if number is int or float\nastropy\/io\/ascii\/qdp.py:def _understand_err_col(colnames):\nastropy\/io\/ascii\/qdp.py:    >>> serr, terr = _understand_err_col(colnames)\nastropy\/io\/ascii\/qdp.py:    >>> serr, terr = _understand_err_col(['a', 'a_nerr'])\nastropy\/io\/ascii\/qdp.py:    >>> serr, terr = _understand_err_col(['a', 'a_perr'])\nastropy\/io\/ascii\/qdp.py:        when multiple tables present in the file. By default, the first is read.\nastropy\/io\/ascii\/qdp.py:            \"table_id not specified. Reading the first available table\",\nastropy\/io\/ascii\/qdp.py:        serr_cols, terr_cols = _understand_err_col(table.colnames)\nastropy\/io\/ascii\/qdp.py:    These readers and writer classes will strive to understand which of the\nastropy\/io\/misc\/asdf\/tags\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/functional_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/parquet.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/parquet.py:        signature = fileobj.read(4)  # read first 4 bytes\nastropy\/io\/misc\/asdf\/tags\/table\/table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/compound.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coordinates\/earthlocation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coordinates\/skycoord.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/time\/time.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/unit\/unit.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/math.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/fits\/tests\/test_fits.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/time\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coordinates\/spectralcoord.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coordinates\/tests\/test_earthlocation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coordinates\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coordinates\/tests\/test_angle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_units_mapping.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coordinates\/tests\/test_spectralcoord.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coordinates\/tests\/test_frames.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/fits\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/unit\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/unit\/quantity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/tabular.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_timedelta.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/powerlaws.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/unit\/tests\/test_equivalency.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coordinates\/tests\/test_representation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/unit\/tests\/test_quantity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/unit\/tests\/test_unit.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coordinates\/tests\/test_skycoord.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/table\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/time\/timedelta.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/tests\/helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coordinates\/frames.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:        first = True\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:            if first:\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:                first = False\nastropy\/io\/misc\/asdf\/tags\/transform\/physical_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coordinates\/angle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/pprint.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/pprint.py:# The first three functions are helpers for _auto_format_func\nastropy\/table\/pprint.py:        only done for the first value.\nastropy\/table\/pprint.py:        # version.  Some points to understand:\nastropy\/table\/pprint.py:        #    actually end up being called with itself as the first arg.  In\nastropy\/table\/pprint.py:        #    this case the function is expected to ignore its first arg.\nastropy\/table\/pprint.py:        # - auto_format_func is a function that gets called on the first\nastropy\/table\/pprint.py:        i0 = 0  # First table\/column row to show\nastropy\/convolution\/tests\/test_convolve_fft.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/table\/tests\/test_table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/conftest.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_item_access.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/convolve.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/convolve.py:        execution of the FFT, generally values factorizable into the first 3-5\nastropy\/convolution\/convolve.py:        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\nastropy\/table\/tests\/test_groups.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/docstrings.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/docstrings.py:The first three (the distortion corrections) are done in parallel.\nastropy\/wcs\/docstrings.py:- First digit (i.e. 1000s):\nastropy\/wcs\/docstrings.py:(Given) The first pair of values should be set to the celestial longitude and\nastropy\/wcs\/docstrings.py:native pole is not determined by the first three reference values and\nastropy\/wcs\/docstrings.py:intermediaries derived from the coordinate reference values. The first three\nastropy\/wcs\/docstrings.py:*Read-only.* Range of projection parameter indices: 100 times the first allowed\nastropy\/wcs\/docstrings.py:    Arrays corresponding to the first (``x``) and second (``y``) projected\nastropy\/wcs\/docstrings.py:    the first 6 decimal places.  The default value of 0.0 implies\nastropy\/wcs\/docstrings.py:understood by the lower-level projection routines.\nastropy\/wcs\/docstrings.py:in the first element of the compressed K_1 dimension, then the\nastropy\/wcs\/docstrings.py:``double`` Stonyhurst heliographic longitude of the observer. If\nastropy\/wcs\/docstrings.py:``double``  Heliographic latitude (Carrington or Stonyhurst) of the observer\nastropy\/wcs\/docstrings.py:\"DEC-\", \"GLON\", \"GLAT\", etc. in the first four characters of\nastropy\/wcs\/docstrings.py:\"DEC-\", \"GLON\", \"GLAT\", etc. in the first four characters of\nastropy\/wcs\/docstrings.py:    Required spectral ``CTYPEia``, maximum of 8 characters.  The first\nastropy\/wcs\/docstrings.py:    by, and must be consistent with, the first four characters.\nastropy\/wcs\/docstrings.py:    provided), it will be set to the first spectral axis identified\nastropy\/wcs\/docstrings.py:    - If an int, include the first *N* axes in their original order.\nastropy\/wcs\/docstrings.py:      that corresponds to the first axis in the subimage, etc.  Use an\nastropy\/wcs\/docstrings.py:longitude axis (if present) would be extracted first (via ``axes[0]``)\nastropy\/table\/tests\/test_subclass.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_column.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_showtable.py:    with np.errstate(over=\"ignore\"):\nastropy\/table\/tests\/test_index.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_index.py:            # last to ensure that the index column does not need to be the first\nastropy\/table\/tests\/test_index.py:        # first ten evens are now zero\nastropy\/table\/tests\/test_index.py:        # first, no special mode\nastropy\/table\/tests\/test_index.py:            meta={\"name\": \"first table\"},\nastropy\/table\/tests\/test_index.py:            meta={\"name\": \"first table\"},\nastropy\/table\/tests\/test_index.py:    t = Table([a, b], names=(\"a\", \"b\"), meta={\"name\": \"first table\"})\nastropy\/table\/tests\/test_array.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_array.py:    first_row = wide_array[:1].data\nastropy\/table\/tests\/test_array.py:    assert np.all(first_row == Table([[x] for x in np.arange(100)]))\nastropy\/io\/misc\/asdf\/tags\/unit\/equivalency.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_row.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_row.py:    # First one succeeds but second fails.\nastropy\/io\/ascii\/ui.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/ui.py:    rst,\nastropy\/io\/ascii\/ui.py:            # If table is an iterable (list of strings) then take the first\nastropy\/io\/ascii\/ui.py:        # Look for signs of an HTML table in the first maxchars characters\nastropy\/io\/ascii\/ui.py:        # Try the fast reader version of `format` first if applicable.  Note that\nastropy\/io\/ascii\/ui.py:    # FixedWidthTwoLine would also be read by Basic, so it needs to come first;\nastropy\/io\/ascii\/ui.py:        rst.RST,\nastropy\/io\/ascii\/ui.py:    first_chunk = True  # True for the first chunk, False afterward\nastropy\/io\/ascii\/ui.py:            # Step backwards from last character in chunk and find first newline\nastropy\/io\/ascii\/ui.py:            # last newline.  Make sure the small strings are concatenated first.\nastropy\/io\/ascii\/ui.py:            # For the first chunk pop the meta key which contains the header\nastropy\/io\/ascii\/ui.py:            if first_chunk:\nastropy\/io\/ascii\/ui.py:                first_chunk = False\nastropy\/table\/tests\/test_init_table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_table.py:            table_types.Column(name=\"firstname\", data=[b\"Max\", b\"Jo\", b\"John\"])\nastropy\/table\/tests\/test_table.py:        t.sort([\"name\", \"firstname\"])\nastropy\/table\/tests\/test_table.py:        assert np.all([t[\"firstname\"] == np.array([b\"John\", b\"Jo\", b\"Max\"])])\nastropy\/table\/tests\/test_table.py:                name=\"firstname\", data=[str(x) for x in [\"Max\", \"Jo\", \"John\"]]\nastropy\/table\/tests\/test_table.py:        t.sort([\"name\", \"firstname\"])\nastropy\/table\/tests\/test_table.py:            [t[\"firstname\"] == np.array([str(x) for x in [\"John\", \"Jo\", \"Max\"]])]\nastropy\/table\/tests\/test_table.py:            table_types.Column(name=\"firstname\", data=[b\"Max\", b\"Jo\", b\"John\"])\nastropy\/table\/tests\/test_table.py:        assert np.all(t.argsort([\"name\", \"firstname\"]) == np.array([2, 1, 0]))\nastropy\/table\/tests\/test_table.py:                name=\"firstname\", data=[str(x) for x in [\"Max\", \"Jo\", \"John\"]]\nastropy\/table\/tests\/test_table.py:        assert np.all(t.argsort([\"name\", \"firstname\"]) == np.array([2, 1, 0]))\nastropy\/table\/tests\/test_table.py:    # Compare table to its first row\nastropy\/table\/tests\/test_table.py:            \"\"\"Always index the first column\"\"\"\nastropy\/table\/tests\/test_table.py:                with np.errstate(invalid=\"ignore\"):\nastropy\/table\/tests\/test_table.py:        meta={\"name\": \"first table\"},\nastropy\/table\/tests\/test_table.py:    # __attributes__ created on the fly on the first access of an attribute\nastropy\/convolution\/tests\/test_convolve_kernels.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_pprint.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_operations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_operations.py:        # Key col 'a', should first value ('cm')\nastropy\/table\/tests\/test_operations.py:        # Key col 'b', take first value 't1_b'\nastropy\/table\/tests\/test_operations.py:        # Key col 'b', take first non-empty value 't1_b'\nastropy\/table\/tests\/test_operations.py:        # Key col 'b', take first value 't1_b'\nastropy\/table\/tests\/test_operations.py:        # Key col 'b', take first non-empty value '%6s'\nastropy\/table\/tests\/test_operations.py:        # Key col 'b', take first value 't1_b'\nastropy\/table\/tests\/test_operations.py:        # Key col 'b', take first non-empty value '%6s'\nastropy\/table\/tests\/test_operations.py:    assert exc.value.args[0] == \"'keep' should be one of 'first', 'last', 'none'\"\nastropy\/table\/tests\/test_info.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_info.py:        names=[\"sum\", \"first\"], funcs=[np.sum, lambda col: col[0]]\nastropy\/table\/tests\/test_info.py:        \"first\",\nastropy\/table\/tests\/test_info.py:    assert np.all(tinfo[\"first\"] == [\"1\", \"1\", \"a\", \"1.0\"])\nastropy\/config\/paths.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/paths.py:    # first look for XDG_CONFIG_HOME\nastropy\/config\/paths.py:    # first look for XDG_CACHE_HOME\nastropy\/config\/paths.py:        # first create .astropy dir if needed\nastropy\/table\/tests\/test_mixin.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/wcslint.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_bst.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_masked.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_masked.py:    # is taken), but since the first is hardcoded, we do not capture it\nastropy\/convolution\/tests\/test_convolve_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/bst.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/bst.py:            exclusive with respect to the endpoints. The first\nastropy\/io\/registry\/base.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/registry\/base.py:        filename as a first argument, you can do for example\nastropy\/io\/registry\/base.py:        Returns the first valid format that can be used to read\/write the data in\nastropy\/io\/registry\/base.py:        # Find the minimum indent, skipping the first line because it might be odd\nastropy\/io\/registry\/base.py:        table_rst_sep = re.sub(\"-\", \"=\", new_lines[1])\nastropy\/io\/registry\/base.py:        new_lines[1] = table_rst_sep\nastropy\/io\/registry\/base.py:        new_lines.insert(0, table_rst_sep)\nastropy\/io\/registry\/base.py:        new_lines.append(table_rst_sep)\nastropy\/io\/votable\/table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/table.py:        tables will be read.  If a number, 0 refers to the first table\nastropy\/io\/votable\/table.py:    returning only the first `~astropy.io.votable.tree.Table`\nastropy\/io\/votable\/table.py:    return votable.get_first_table()\nastropy\/io\/votable\/table.py:            \"first argument must be astropy.io.vo.VOTableFile or \"\nastropy\/io\/votable\/table.py:    #  warning out of this, we have to delete all of them first. #\nastropy\/io\/fits\/fitstime.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/fitstime.py:        # First warn the user if geocentric location is partially specified\nastropy\/io\/votable\/tests\/ucd_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/converters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/converters.py:        The bit array.  The most significant byte is read first.\nastropy\/io\/votable\/converters.py:        The first value in the input array will be the most\nastropy\/io\/votable\/converters.py:    first_dtype = False\nastropy\/io\/votable\/converters.py:    first_shape = ()\nastropy\/io\/votable\/converters.py:        if first_dtype is False:\nastropy\/io\/votable\/converters.py:            first_dtype = x.dtype\nastropy\/io\/votable\/converters.py:            first_shape = x.shape[1:]\nastropy\/io\/votable\/converters.py:        elif first_dtype != x.dtype:\nastropy\/io\/votable\/converters.py:        elif first_shape != x.shape[1:]:\nastropy\/io\/votable\/converters.py:            first_shape = ()\nastropy\/io\/votable\/converters.py:    return first_dtype, first_shape\nastropy\/io\/votable\/converters.py:         consistent shape in all but the first dimension, it creates a\nastropy\/io\/votable\/converters.py:    If the dtype of the input is not understood, it sets the data type\nastropy\/io\/votable\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/table_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/table_test.py:    with np.errstate(over=\"ignore\"):\nastropy\/io\/votable\/tests\/table_test.py:    table = votable.get_first_table()\nastropy\/io\/votable\/tests\/table_test.py:    t = votable2.get_first_table()\nastropy\/io\/votable\/tests\/table_test.py:    with np.errstate(over=\"ignore\"):\nastropy\/io\/votable\/tests\/table_test.py:    with np.errstate(over=\"ignore\"):\nastropy\/io\/votable\/tests\/table_test.py:    with np.errstate(over=\"ignore\"):\nastropy\/io\/votable\/tests\/table_test.py:    table = votable.get_first_table().to_table(use_names_over_ids=True)\nastropy\/io\/votable\/tests\/table_test.py:    table = votable.get_first_table().to_table(use_names_over_ids=False)\nastropy\/io\/votable\/tests\/table_test.py:    table = parse(fpath).get_first_table().to_table()\nastropy\/io\/votable\/tests\/table_test.py:    table = votable.get_first_table()\nastropy\/io\/votable\/tests\/table_test.py:    table = votable.get_first_table()\nastropy\/io\/votable\/tests\/table_test.py:    table = votable.get_first_table()\nastropy\/io\/votable\/tests\/exception_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/registry\/tests\/test_registry_help.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/card.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/card.py:            keyword = keyword.rstrip()\nastropy\/io\/fits\/card.py:            value = value.rstrip()\nastropy\/io\/fits\/card.py:            different = oldvalue.rstrip() != value.rstrip()\nastropy\/io\/fits\/card.py:            # there in the first place\nastropy\/io\/fits\/card.py:        # Test first for the most common case: a standard FITS keyword provided\nastropy\/io\/fits\/card.py:        and parsed as such.  If two arguments are given, the first is treated\nastropy\/io\/fits\/card.py:        intended as a RVKC), and the second as the card value OR the first value\nastropy\/io\/fits\/card.py:            return self._image[KEYWORD_LENGTH:].rstrip()\nastropy\/io\/fits\/card.py:                \"Unparsable card ({}), fix it first with .verify('fix').\".format(\nastropy\/io\/fits\/card.py:                comment = m.group(\"comm\").rstrip()\nastropy\/io\/fits\/card.py:            # first \/ was meant to be the comment\nastropy\/io\/fits\/card.py:                value = value.rstrip().replace(\"''\", \"'\")\nastropy\/io\/fits\/card.py:                    comments.append(comment.rstrip())\nastropy\/io\/fits\/card.py:        # Force the value to be parsed out first\nastropy\/io\/fits\/card.py:                    \"the first card or have commentary keywords like \"\nastropy\/io\/fits\/hdu\/streaming.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/streaming.py:        the first extension.  If the file does already exist, but the\nastropy\/io\/fits\/hdu\/streaming.py:            # This will not be the first extension in the file so we\nastropy\/io\/votable\/tests\/util_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/header.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/header.py:    only the value of the first card with the given keyword will be returned.\nastropy\/io\/fits\/header.py:        >>> header[0]  # Return the value of the first card in the header\nastropy\/io\/fits\/header.py:        This is the first history entry in this header.\nastropy\/io\/fits\/header.py:            # there in the first place--accepting it here still gives us the\nastropy\/io\/fits\/header.py:                if next_image.split(sep)[0].rstrip() == END:\nastropy\/io\/fits\/header.py:        # Read the first header block.\nastropy\/io\/fits\/header.py:                trailing = block[offset + 3 : offset + card_len - 3].rstrip()\nastropy\/io\/fits\/header.py:            first blank card so that the total number of cards in the Header\nastropy\/io\/fits\/header.py:        update_first=False,\nastropy\/io\/fits\/header.py:        update_first : bool, optional\nastropy\/io\/fits\/header.py:            If the first keyword in the header is 'SIMPLE', and the first\nastropy\/io\/fits\/header.py:            replaced by the 'XTENSION' keyword.  Likewise if the first keyword\nastropy\/io\/fits\/header.py:            in the header is 'XTENSION' and the first keyword in the input\nastropy\/io\/fits\/header.py:            first = self._cards[0].keyword\nastropy\/io\/fits\/header.py:            first = None\nastropy\/io\/fits\/header.py:        # We don't immediately modify the header, because first we need to sift\nastropy\/io\/fits\/header.py:                    if idx == 0 and update_first:\nastropy\/io\/fits\/header.py:                        # Dumbly update the first keyword to either SIMPLE or\nastropy\/io\/fits\/header.py:                        if (keyword == \"SIMPLE\" and first == \"XTENSION\") or (\nastropy\/io\/fits\/header.py:                            keyword == \"XTENSION\" and first == \"SIMPLE\"\nastropy\/io\/fits\/header.py:        Returns the index if the first instance of the given keyword in the\nastropy\/io\/fits\/header.py:            first blank card so that the total number of cards in the Header\nastropy\/io\/fits\/header.py:        Removes the first instance of the given keyword from the header similar\nastropy\/io\/fits\/header.py:            The keyword of which to remove the first instance in the header.\nastropy\/io\/fits\/header.py:            Otherwise only the first instance of the given keyword is removed.\nastropy\/io\/votable\/tests\/tree_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/scripts\/fitscheck.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/scripts\/fitsdiff.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/hdu\/table.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/table.py:            # if the file is read the first time, no need to copy, and keep it\nastropy\/io\/fits\/hdu\/table.py:                and self._header[0].rstrip() == self._extension\nastropy\/io\/fits\/hdu\/table.py:        # First collect all the table structure related keyword in the header\nastropy\/io\/fits\/hdu\/table.py:                # as we are first raising a deprecation warning that these will be\nastropy\/io\/fits\/hdu\/table.py:        # First delete\nastropy\/io\/fits\/hdu\/table.py:            xtension = xtension.rstrip()\nastropy\/io\/fits\/hdu\/table.py:            xtension = xtension.rstrip()\nastropy\/io\/fits\/hdu\/table.py:          8, sixteen-character fields.  The first field provides the column\nastropy\/io\/fits\/hdu\/table.py:                    Header.fromtextfile(hfile), update=True, update_first=True\nastropy\/io\/fits\/hdu\/table.py:        # First we need to do some preprocessing on the file to find out how\nastropy\/io\/fits\/scripts\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/hdu\/base.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/base.py:    first,\nastropy\/io\/fits\/hdu\/base.py:            corrupt HDU.  In this case the assumption is that the first 2880\nastropy\/io\/fits\/hdu\/base.py:                    # First we try to read the header with the fast parser\nastropy\/io\/fits\/hdu\/base.py:    FITS most significant byte first.  The header for this HDU should\nastropy\/io\/fits\/hdu\/base.py:    stream that begins at the first byte after the header ``END`` card\nastropy\/io\/fits\/hdu\/base.py:        # The SIMPLE keyword must be in the first card\nastropy\/io\/fits\/hdu\/base.py:        XTENSION keyword in its header's first card, but is nonetheless not\nastropy\/io\/fits\/hdu\/base.py:        return first(header.keys()) not in (\"SIMPLE\", \"XTENSION\")\nastropy\/io\/fits\/hdu\/base.py:        # Do the first card here, instead of in the respective HDU classes, so\nastropy\/io\/fits\/hdu\/base.py:            firstkey = \"XTENSION\"\nastropy\/io\/fits\/hdu\/base.py:            firstval = self._extension\nastropy\/io\/fits\/hdu\/base.py:            firstkey = \"SIMPLE\"\nastropy\/io\/fits\/hdu\/base.py:            firstval = True\nastropy\/io\/fits\/hdu\/base.py:        self.req_cards(firstkey, 0, None, firstval, option, errs)\nastropy\/io\/fits\/hdu\/base.py:            means ``pos=0`` requires the card to be the first card in the\nastropy\/io\/fits\/hdu\/base.py:        For testing purposes, first call `add_datasum` with a ``when``\nastropy\/io\/fits\/hdu\/base.py:    is read from the file as a byte stream that begins at the first\nastropy\/io\/fits\/hdu\/base.py:            xtension = xtension.rstrip()\nastropy\/io\/fits\/hdu\/hdulist.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/hdulist.py:        # The assumes that all HDUs have been written when we first opened the\nastropy\/io\/fits\/hdu\/hdulist.py:            # append method after the first HDU is read\nastropy\/io\/fits\/hdu\/hdulist.py:                    # comes first.\nastropy\/io\/fits\/hdu\/hdulist.py:            the first match is returned.  For a more precise match use the\nastropy\/io\/fits\/hdu\/hdulist.py:                    # simple Primary HDU and append that first before\nastropy\/io\/fits\/hdu\/hdulist.py:                    # simple Primary HDU and append that first before\nastropy\/io\/fits\/hdu\/hdulist.py:            the first match is returned.  For a more precise match use the\nastropy\/io\/fits\/hdu\/hdulist.py:            # 'PRIMARY' should always work as a reference to the first HDU\nastropy\/io\/fits\/hdu\/hdulist.py:        def get_first_ext():\nastropy\/io\/fits\/hdu\/hdulist.py:            if not hdr[\"EXTEND\"] and get_first_ext() is not None:\nastropy\/io\/fits\/hdu\/hdulist.py:        elif get_first_ext() is not None:\nastropy\/io\/fits\/hdu\/hdulist.py:            # FITS signature is supposed to be in the first 30 bytes, but to\nastropy\/io\/fits\/hdu\/hdulist.py:            # allow reading various invalid files we will check in the first\nastropy\/io\/fits\/hdu\/hdulist.py:        # the first (0th) element must be a primary HDU\nastropy\/io\/fits\/hdu\/hdulist.py:            # Need to all _prewriteto() for each HDU first to determine if\nastropy\/io\/fits\/scripts\/fitsheader.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/scripts\/fitsheader.py:10. Sort first by OBJECT, then DATE-OBS::\nastropy\/io\/fits\/scripts\/fitsheader.py:        # First we obtain the desired header\nastropy\/io\/votable\/validator\/result.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/validator\/html.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/__init__.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/votable\/validator\/main.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/validator\/main.py:    first.\nastropy\/io\/fits\/hdu\/image.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/image.py:        the \"rows\" or y-axis are the first dimension, and the \"columns\" or\nastropy\/io\/fits\/hdu\/image.py:            # First handle the special case where the data is unsigned integer\nastropy\/io\/fits\/hdu\/image.py:            xtension = xtension.rstrip()\nastropy\/io\/fits\/hdu\/compressed.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/compressed.py:               Astropy first uncompresses the entire file into a temporary file\nastropy\/io\/fits\/hdu\/compressed.py:        algorithm.  Consequently, floating point images are first quantized\nastropy\/io\/fits\/hdu\/compressed.py:        exactly like the first except that before dithering any pixel with a\nastropy\/io\/fits\/hdu\/compressed.py:        image's first tile (``DITHER_SEED_CHECKSUM``).  The clock-based method\nastropy\/io\/fits\/hdu\/compressed.py:                    # Keep the first (they are all the same)\nastropy\/io\/fits\/hdu\/compressed.py:            xtension = xtension.rstrip()\nastropy\/io\/fits\/hdu\/compressed.py:        # Set the label for the first column in the table\nastropy\/io\/fits\/hdu\/compressed.py:        # Set the data format for the first column.  It is dependent\nastropy\/io\/fits\/hdu\/compressed.py:        # Create the first column for the table.  This column holds the\nastropy\/io\/fits\/hdu\/compressed.py:        # First, setup the values to be used for the compression parameters\nastropy\/io\/fits\/hdu\/compressed.py:        # First we will get the table data (the compressed\nastropy\/io\/fits\/hdu\/compressed.py:        # First delete the ._coldefs attributes under it to break a possible\nastropy\/io\/fits\/hdu\/compressed.py:            # First delete the original compressed data, if it exists\nastropy\/io\/fits\/hdu\/compressed.py:                \"clock, or -1 for autogeneration from a checksum of the first \"\nastropy\/io\/fits\/hdu\/compressed.py:            # Get the first tile by using the tile dimensions as the end\nastropy\/io\/fits\/hdu\/compressed.py:            first_tile = self.data[tuple(slice(d) for d in tile_dims)]\nastropy\/io\/fits\/hdu\/compressed.py:            csum = first_tile.view(dtype=\"uint8\").sum()\nastropy\/io\/votable\/tests\/vo_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/vo_test.py:    with np.errstate(over=\"ignore\"):\nastropy\/io\/votable\/tests\/vo_test.py:    with np.errstate(over=\"ignore\"):\nastropy\/io\/votable\/tests\/vo_test.py:    table = votable.get_first_table()\nastropy\/io\/votable\/tests\/vo_test.py:        votable.get_first_table().format = \"binary\"\nastropy\/io\/votable\/tests\/vo_test.py:        votable.get_first_table()._config[\"version_1_3_or_later\"] = True\nastropy\/io\/votable\/tests\/vo_test.py:        votable.get_first_table().format = \"binary2\"\nastropy\/io\/votable\/tests\/vo_test.py:    votable2.get_first_table().format = \"tabledata\"\nastropy\/io\/votable\/tests\/vo_test.py:    output = [x.decode(\"utf-8\").rstrip() for x in output]\nastropy\/io\/votable\/tests\/vo_test.py:    truth = [x.rstrip() for x in truth]\nastropy\/io\/votable\/tests\/vo_test.py:        with np.errstate(over=\"ignore\"):\nastropy\/io\/votable\/tests\/vo_test.py:            ).get_first_table()\nastropy\/io\/votable\/tests\/vo_test.py:        with np.errstate(over=\"ignore\"):\nastropy\/io\/votable\/tests\/vo_test.py:        self.table = self.votable.get_first_table()\nastropy\/io\/votable\/tests\/vo_test.py:    ).get_first_table()\nastropy\/io\/votable\/tests\/vo_test.py:    ).get_first_table()\nastropy\/io\/votable\/tests\/vo_test.py:        with np.errstate(over=\"ignore\"):\nastropy\/io\/votable\/tests\/vo_test.py:        self.table = self.votable.get_first_table()\nastropy\/io\/votable\/tests\/vo_test.py:        with np.errstate(over=\"ignore\"):\nastropy\/io\/votable\/tests\/vo_test.py:        self.table = self.votable.get_first_table()\nastropy\/io\/votable\/tests\/vo_test.py:        with np.errstate(over=\"ignore\"):\nastropy\/io\/votable\/tests\/vo_test.py:        votable.get_first_table().format = \"binary\"\nastropy\/io\/votable\/tests\/vo_test.py:        self.table = self.votable.get_first_table()\nastropy\/io\/votable\/tests\/vo_test.py:        with np.errstate(over=\"ignore\"):\nastropy\/io\/votable\/tests\/vo_test.py:        votable.get_first_table()._config[\"version_1_3_or_later\"] = True\nastropy\/io\/votable\/tests\/vo_test.py:        votable.get_first_table().format = \"binary2\"\nastropy\/io\/votable\/tests\/vo_test.py:        self.table = self.votable.get_first_table()\nastropy\/io\/votable\/tests\/vo_test.py:@np.errstate(over=\"ignore\")\nastropy\/io\/votable\/tests\/vo_test.py:    table = votable.get_first_table()\nastropy\/io\/votable\/tests\/vo_test.py:    with np.errstate(over=\"ignore\"):\nastropy\/io\/votable\/tests\/vo_test.py:    assert isinstance(votable.get_first_table().fields[0].unit, u.UnrecognizedUnit)\nastropy\/io\/votable\/tests\/vo_test.py:    assert not isinstance(votable.get_first_table().fields[0].unit, u.UnrecognizedUnit)\nastropy\/io\/votable\/tests\/vo_test.py:    table = votable.get_first_table()\nastropy\/io\/votable\/tests\/resource_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/hdu\/nonstandard.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/nonstandard.py:            xtension = xtension.rstrip()\nastropy\/io\/registry\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/hdu\/__init__.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/diff.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/diff.py:    When instantiating a FITS diff object, the first two arguments are always\nastropy\/io\/fits\/diff.py:        # The first 3 arguments of any Diff initializer are self, a, and b.\nastropy\/io\/fits\/diff.py:            compare to the first file.\nastropy\/io\/fits\/diff.py:            An HDU object to compare to the first HDU object.\nastropy\/io\/fits\/diff.py:            A header to compare to the first header.\nastropy\/io\/fits\/diff.py:                    value = value.rstrip()\nastropy\/io\/fits\/diff.py:            An HDU object to compare to the first HDU object.\nastropy\/io\/fits\/diff.py:            An HDU object to compare to the first HDU object.\nastropy\/io\/fits\/diff.py:      either in name or format, this contains a 2-tuple of lists. The first\nastropy\/io\/fits\/diff.py:      is a list of 2-tuples: The first a tuple of the column name and the\nastropy\/io\/fits\/diff.py:            An HDU object to compare to the first HDU object.\nastropy\/io\/fits\/diff.py:        # TODO: It might be nice to optionally compare the first n rows where n\nastropy\/io\/fits\/diff.py:        # accessed in FITS tables, a case-sensitive is tried first, and failing\nastropy\/io\/votable\/validator\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/registry\/interface.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/registry\/tests\/test_registries.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/converter_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/util.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/util.py:def first(iterable):\nastropy\/io\/fits\/util.py:    Returns the first item returned by iterating over an iterable object.\nastropy\/io\/fits\/util.py:    >>> first(a)\nastropy\/io\/fits\/util.py:    Generator over all subclasses of a given class, in depth first order.\nastropy\/io\/fits\/util.py:# import time, we defer the setting of this global variable until the first\nastropy\/io\/fits\/util.py:def _rstrip_inplace(array):\nastropy\/io\/fits\/util.py:    Performs an in-place rstrip operation on string arrays. This is necessary\nastropy\/io\/fits\/util.py:    since the built-in `np.char.rstrip` in Numpy does not perform an in-place\nastropy\/io\/fits\/util.py:    # unlikely case that a string array has small first dimension and cannot\nastropy\/io\/registry\/compat.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/scripts\/fitsinfo.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/file.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/file.py:        # We just wrote the contents of the first file in the archive to a new\nastropy\/io\/votable\/util.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/exceptions.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/exceptions.py:        dimensions separated by the ``x`` character, with the first\nastropy\/io\/fits\/tests\/test_division.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_checksum.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_checksum.py:        # Now do like in the first writeto but use checksum immediately\nastropy\/io\/fits\/tests\/test_compression_failures.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/votable\/ucd.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_fitsheader.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tree.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tree.py:        Given a string *ref*, finds the first element in the iterator\nastropy\/io\/votable\/tree.py:        Given an key *ref*, finds the first element in the iterator\nastropy\/io\/votable\/tree.py:        # First, parse the unit in the default way, so that we can\nastropy\/io\/votable\/tree.py:        # First, parse the unit in the default way, so that we can\nastropy\/io\/votable\/tree.py:    def get_first_table(self):\nastropy\/io\/votable\/tree.py:        that's all you need.  This method returns that first table.\nastropy\/io\/fits\/hdu\/groups.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/groups.py:            of the arguments are used only for the first case.\nastropy\/io\/fits\/hdu\/groups.py:        # Now create columns from collected parameters, but first add the DATA\nastropy\/io\/fits\/hdu\/groups.py:        # Drop the first axis from the shape\nastropy\/io\/fits\/tests\/test_image.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_image.py:        hdulist['PRIMARY'] will still refer to the first HDU even if it has an\nastropy\/io\/fits\/tests\/test_image.py:        # make a defect HDUList first\nastropy\/io\/fits\/tests\/test_image.py:        # Test all ways to slice the last dimension but keeping the first two.\nastropy\/io\/fits\/tests\/test_image.py:        # Test without having accessed the full data first\nastropy\/io\/fits\/tests\/test_image.py:        # First make a test image with lossy compression and make sure it\nastropy\/io\/fits\/tests\/test_image.py:            # First try inserting a restricted keyword\nastropy\/io\/fits\/tests\/test_image.py:            # First try keyword-relative insert\nastropy\/io\/fits\/tests\/test_image.py:        # The first row (which will be the first compressed tile) has a very\nastropy\/io\/fits\/tests\/test_image.py:    # first HDU.\nastropy\/io\/fits\/tests\/test_fitsinfo.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/volint.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_fitsdiff.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_diff.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_diff.py:        # First test some arrays that should be equivalent....\nastropy\/io\/fits\/column.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/column.py:# TODO: Table column formats need to be verified upon first reading the file;\nastropy\/io\/fits\/column.py:            try:  # try to convert to a ndarray first\nastropy\/io\/fits\/column.py:        # Ideally the .array attribute never would have existed in the first\nastropy\/io\/fits\/column.py:        Returns a 2-tuple of dicts.  The first maps valid keywords to their\nastropy\/io\/fits\/column.py:        # Convert the format to a type we understand\nastropy\/io\/fits\/column.py:                        # The 'last' dimension (first in the order given\nastropy\/io\/fits\/column.py:           method), it will try to match the exact name first, so in\nastropy\/io\/fits\/column.py:           the example in (a), field('abc') will get the first field,\nastropy\/io\/fits\/column.py:        # try to find exact match first\nastropy\/io\/fits\/column.py:            indx = names.index(key.rstrip())\nastropy\/io\/fits\/column.py:            _key = key.lower().rstrip()\nastropy\/io\/fits\/column.py:            names = [n.lower().rstrip() for n in names]\nastropy\/io\/fits\/column.py:        int64 (for Q format arrays)--must be nrows long in its first dimension\nastropy\/io\/fits\/column.py:    # First, if value is a string, try to convert to the appropriate scalar\nastropy\/io\/fits\/column.py:        fmt_str = format_string.lstrip(\"{:\").rstrip(\"}\")\nastropy\/io\/fits\/tests\/test_convenience.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_convenience.py:        # meta dict (note that the first and last card are legitimate keys)\nastropy\/io\/fits\/tests\/test_convenience.py:        # Primary HDU or first extension HDU\nastropy\/io\/fits\/tests\/test_convenience.py:            IndexError, match=\"No data in either Primary or first extension HDUs.\"\nastropy\/io\/fits\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_tilde_path.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/fitsrec.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/fitsrec.py:from .util import _rstrip_inplace, decode_ascii, encode_ascii\nastropy\/io\/fits\/fitsrec.py:                # picked, it needs to be deepcopied first\nastropy\/io\/fits\/fitsrec.py:                    # The normal case where the first dimension is the rows\nastropy\/io\/fits\/fitsrec.py:        # First, see if ndarray has this attr, and return it if so. Note that\nastropy\/io\/fits\/fitsrec.py:        array in the format that it was first read from a file before it was\nastropy\/io\/fits\/fitsrec.py:        _rstrip_inplace(output_field)\nastropy\/io\/fits\/tests\/test_structured.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_uint.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_uint.py:        if data is sliced first, make sure the data is still converted as uint\nastropy\/io\/fits\/tests\/test_fsspec.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_util.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_util.py:from astropy.io.fits.util import _rstrip_inplace, ignore_sigint\nastropy\/io\/fits\/tests\/test_util.py:def test_rstrip_inplace():\nastropy\/io\/fits\/tests\/test_util.py:        _rstrip_inplace(s)\nastropy\/io\/fits\/tests\/test_util.py:    _rstrip_inplace(s)\nastropy\/io\/fits\/tests\/test_util.py:    _rstrip_inplace(s)\nastropy\/io\/fits\/tests\/test_util.py:    _rstrip_inplace(s)\nastropy\/io\/fits\/tests\/test_util.py:    _rstrip_inplace(s)\nastropy\/io\/fits\/tests\/test_util.py:    _rstrip_inplace(s)\nastropy\/io\/fits\/tests\/test_connect.py:        t1.meta[\"HISTORY\"] = [\"first\", \"second\", \"third\"]\nastropy\/io\/fits\/tests\/test_connect.py:        hdu1 = BinTableHDU(self.data1, name=\"first\")\nastropy\/io\/fits\/tests\/test_connect.py:            r\"are present, reading in first available \"\nastropy\/io\/fits\/tests\/test_connect.py:            r\"are present, reading in first available \"\nastropy\/io\/fits\/tests\/test_connect.py:    @pytest.mark.parametrize(\"hdu\", [1, \"first\"])\nastropy\/io\/fits\/tests\/test_connect.py:            r\"reading in first available table \\(hdu=1\\)\",\nastropy\/io\/fits\/tests\/test_connect.py:            r\"reading in first available table \\(hdu=1\\)\",\nastropy\/io\/fits\/tests\/test_connect.py:            r\"reading in first available table \\(hdu=2\\)\",\nastropy\/io\/fits\/tests\/test_connect.py:            r\"are present, reading in first available \"\nastropy\/io\/fits\/tests\/test_connect.py:            r\"are present, reading in first available \"\nastropy\/io\/fits\/tests\/test_connect.py:    @pytest.mark.parametrize(\"hdu\", [1, \"first\", None])\nastropy\/io\/fits\/tests\/test_connect.py:    @pytest.mark.parametrize(\"hdu\", [1, \"first\"])\nastropy\/io\/fits\/tests\/test_connect.py:            r\"reading in first available table \\(hdu=1\\)\",\nastropy\/io\/fits\/tests\/test_connect.py:            r\"reading in first available table \\(hdu=1\\)\",\nastropy\/io\/fits\/tests\/test_connect.py:            r\"reading in first available table \\(hdu=2\\)\",\nastropy\/io\/fits\/tests\/test_connect.py:    @pytest.mark.parametrize(\"hdu\", [None, 1, \"first\"])\nastropy\/io\/fits\/tests\/test_connect.py:    was not defined to have their first element masked.\nastropy\/io\/fits\/tests\/test_connect.py:    t = Table([a, b, c], names=(\"a\", \"b\", \"c\"), meta={\"name\": \"first table\"})\nastropy\/io\/fits\/tests\/test_connect.py:    t.meta[\"history\"] = [\"first\", \"second\", \"third\"]\nastropy\/io\/fits\/tests\/test_connect.py:    assert t2.meta[\"HISTORY\"] == [\"first\", \"second\", \"third\"]\nastropy\/io\/fits\/tests\/test_fitscheck.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_nonstandard.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_groups.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_groups.py:        # make a copy of it first (so that the file doesn't actually get\nastropy\/io\/fits\/tests\/conftest.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_fitstime.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_core.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_core.py:            # bytes.  The first 100 bytes should match the original data we\nastropy\/io\/fits\/tests\/test_hdulist.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_table.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_table.py:        # first, create individual column definitions\nastropy\/io\/fits\/tests\/test_table.py:        # Get the number of rows in the table from the first file\nastropy\/io\/fits\/tests\/test_table.py:        # Create a new table that consists of the data from the first table\nastropy\/io\/fits\/tests\/test_table.py:            # First test some default assumptions\nastropy\/io\/fits\/tests\/test_table.py:            # First test some default assumptions\nastropy\/io\/fits\/tests\/test_table.py:        data = [[b\"abcd\", b\"efgh\"], [b\"ijkl\", b\"mnop\"], [b\"qrst\", b\"uvwx\"]]\nastropy\/io\/fits\/tests\/test_table.py:        to take the first 4 elements as implied by the TDIM and ignore the\nastropy\/io\/fits\/tests\/test_table.py:        # The first column has the mismatched repeat count\nastropy\/io\/fits\/tests\/test_table.py:        directly from one FITS file to a new file without first reading the\nastropy\/io\/fits\/tests\/test_table.py:    # First, check that special keywords such as TUNIT are ignored in the header\nastropy\/io\/fits\/setup_package.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/votable\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/tests\/test_configs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/tests\/test_configs.py:    # Check that we start in an understood state.\nastropy\/io\/registry\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/registry\/core.py:    # Conservatively attempt to apply `os.path.expanduser` to the first\nastropy\/io\/registry\/core.py:    First let's start by creating a read-only registry.\nastropy\/convolution\/tests\/test_convolve.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_header.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_header.py:    list1 = [(i, j) for j, i in enumerate(\"abcdefghijklmnopqrstuvwxyz\")]\nastropy\/io\/fits\/tests\/test_header.py:        # to be a string and everything after the first slash will be comment\nastropy\/io\/fits\/tests\/test_header.py:        assert \" \".join(header[\"\"]) == value.rstrip()\nastropy\/io\/fits\/tests\/test_header.py:        first = header.pop(0)\nastropy\/io\/fits\/tests\/test_header.py:        assert first == \"B\"\nastropy\/io\/fits\/tests\/test_header.py:        first = header.pop(\"A\")\nastropy\/io\/fits\/tests\/test_header.py:        assert first == \"B\"\nastropy\/io\/fits\/tests\/test_header.py:        # New card should fill the first blank by default\nastropy\/io\/fits\/tests\/test_header.py:        # Same tests, but copy the values first; as it turns out this is\nastropy\/io\/fits\/tests\/test_header.py:        # different from just directly doing an __eq__ as in the first set of\nastropy\/io\/fits\/tests\/test_header.py:        assert str(header.cards[4]).rstrip() == \"HISTORY \" + longval[72:]\nastropy\/io\/fits\/tests\/test_header.py:        assert str(header.cards[2]).rstrip() == \"HISTORY \" + longval[72:]\nastropy\/io\/fits\/tests\/test_header.py:        assert str(header.cards[4]).rstrip() == \"HISTORY \" + longval[72:]\nastropy\/io\/fits\/tests\/test_header.py:        assert str(header.cards[2]).rstrip() == \"HISTORY \" + longval[72:]\nastropy\/io\/fits\/tests\/test_header.py:            hdu.header.fromtextfile(header_filename), update=True, update_first=True\nastropy\/io\/fits\/tests\/test_header.py:            update_first=True,\nastropy\/io\/fits\/tests\/test_header.py:            hdu.header.fromfile(header_filename), update=True, update_first=True\nastropy\/io\/fits\/tests\/test_header.py:            update_first=True,\nastropy\/io\/fits\/tests\/test_header.py:        # First the case that *does* work prior to fixing this issue\nastropy\/io\/fits\/tests\/test_header.py:        # The first two warnings are just the headers to the actual warning\nastropy\/io\/fits\/tests\/test_header.py:        First regression test for\nastropy\/io\/fits\/tests\/test_header.py:        assert h.cards[\"FOO\"].image.rstrip() == \"FOO     = 'Bar      '\"\nastropy\/io\/fits\/tests\/test_header.py:        assert h.cards[\"QUX\"].image.rstrip() == \"QUX     = 'Bar        '\"\nastropy\/io\/fits\/tests\/test_header.py:            assert h.cards[\"FOO\"].image.rstrip() == \"FOO     = 'Bar      '\"\nastropy\/io\/fits\/tests\/test_header.py:            assert h.cards[\"QUX\"].image.rstrip() == \"QUX     = 'Bar        '\"\nastropy\/io\/fits\/tests\/test_header.py:        assert h.cards[\"FOO\"].image.rstrip() == \"FOO     = 'Bar      '\"\nastropy\/io\/fits\/tests\/test_header.py:        assert h.cards[\"QUX\"].image.rstrip() == \"QUX     = 'Bar        '\"\nastropy\/io\/fits\/tests\/test_header.py:        # First ensure that we can't assign new keyword values with newlines in\nastropy\/io\/fits\/tests\/test_header.py:    which this feature was first introduced.\nastropy\/io\/fits\/tests\/test_header.py:        assert str(c).rstrip() == \"DP1     = 'NAXIS1: 2' \/ A comment\"\nastropy\/io\/fits\/tests\/test_header.py:        string of the first card with that keyword.\nastropy\/io\/fits\/tests\/test_header.py:            (\"a\", 1.0, \"first\"),\nastropy\/io\/fits\/tests\/test_header.py:    assert my_header.comments[\"a\"] == \"first\"\nastropy\/io\/fits\/convenience.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/convenience.py:    The above example will try to set the NAXIS value on the first extension\nastropy\/io\/fits\/convenience.py:    specify the first extension HDU use::\nastropy\/io\/fits\/convenience.py:            to retrieve data from first extension HDU.\nastropy\/io\/fits\/convenience.py:            # fallback to the first extension HDU\nastropy\/io\/fits\/convenience.py:                raise IndexError(\"No data in either Primary or first extension HDUs.\")\nastropy\/io\/fits\/convenience.py:            # The first arg is an extension name; it could still be valid\nastropy\/io\/fits\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/connect.py:from .util import first\nastropy\/io\/fits\/connect.py:                    \" are present, reading in first available\"\nastropy\/io\/fits\/connect.py:                    f\" table (hdu={first(tables)})\",\nastropy\/io\/fits\/connect.py:                hdu = first(tables)\nastropy\/io\/fits\/connect.py:            # hdu might not be an integer, so we first need to convert it\nastropy\/io\/fits\/connect.py:                        f\"{msg}, reading in first available table \"\nastropy\/io\/fits\/connect.py:                        f\"(hdu={first(tables)}) instead. This will\"\nastropy\/io\/fits\/connect.py:            table = tables[first(tables)]\nastropy\/io\/fits\/verify.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/verify.py:            # Don't print out fixable issues; the first element of each verify\nastropy\/io\/fits\/verify.py:        # go through the list twice, first time print out all top level\nastropy\/io\/fits\/verify.py:                    first_line = next(next_lines)\nastropy\/io\/fits\/verify.py:                    first_line = None\nastropy\/io\/fits\/verify.py:                if first_line is not None:\nastropy\/io\/fits\/verify.py:                    yield first_line\nastropy\/wcs\/wcsapi\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/wcsapi\/utils.py:    return \"\\n\".join([l.rstrip() for l in s.splitlines()])\nastropy\/config\/configuration.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/configuration.py:        of those values, and the first in the list will be taken as the default\nastropy\/config\/configuration.py:        The full module name that this item is associated with. The first\nastropy\/config\/configuration.py:                \" Using the first.\",\nastropy\/config\/configuration.py:                    # If this is the first item of the module, we print the\nastropy\/wcs\/wcsapi\/fitswcs.py:#   Bennett et al. (2003), First-Year Wilkinson Microwave\nastropy\/wcs\/wcsapi\/fitswcs.py:    \"HGLN\": \"custom:pos.heliographic.stonyhurst.lon\",\nastropy\/wcs\/wcsapi\/fitswcs.py:    \"HGLT\": \"custom:pos.heliographic.stonyhurst.lat\",\nastropy\/io\/votable\/xmlutil.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/core.py:    There are two methods that are intended to be overridden, first\nastropy\/io\/ascii\/core.py:        If splitting on whitespace then replace unquoted tabs with space first\"\"\"\nastropy\/io\/ascii\/core.py:        out = self.csv_writer.writerow(vals).rstrip(\"\\r\\n\")\nastropy\/io\/ascii\/core.py:            # Get the data values from the first line of table data to determine n_data_cols\nastropy\/io\/ascii\/core.py:                first_data_vals = next(self.data.get_str_vals())\nastropy\/io\/ascii\/core.py:            n_data_cols = len(first_data_vals)\nastropy\/io\/ascii\/core.py:        In the first step it is evaluated with value from ``fill_values`` applies to\nastropy\/io\/ascii\/core.py:            # iterate over reversed order, so last condition is set first and\nastropy\/io\/ascii\/core.py:        # Try a smaller subset first for a long array\nastropy\/io\/ascii\/core.py:            # and the first col.converters[0] access raises IndexError.\nastropy\/wcs\/wcsapi\/low_level_api.py:        assumed to be 0 at the center of the first pixel in each dimension. If a\nastropy\/wcs\/wcsapi\/low_level_api.py:        coordinates are assumed to be 0 at the center of the first pixel in each\nastropy\/wcs\/wcsapi\/low_level_api.py:        * The first is a name for the world object this world array\nastropy\/wcs\/wcsapi\/low_level_api.py:        * The first element of the tuple must be a class or a string specifying\nastropy\/wcs\/wcsapi\/low_level_api.py:          return an object of the type of the first element in the tuple.\nastropy\/wcs\/wcsapi\/low_level_api.py:        passing an instance as the first argument to the same class with\nastropy\/convolution\/tests\/test_pickle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_convolve_speeds.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/connect.py:        first argument is typically the input filename.\nastropy\/table\/connect.py:        first argument is the output filename.\nastropy\/wcs\/wcsapi\/tests\/test_fitswcs.py:CRVAL3  = 2375.341 \/ Relative time of first frame\nastropy\/wcs\/wcsapi\/tests\/test_fitswcs.py:CRVAL3A = 2440.525 \/ Relative time of first frame\nastropy\/wcs\/wcsapi\/tests\/test_fitswcs.py:    # first make sure the WCS works when using a low accuracy\nastropy\/wcs\/wcsapi\/tests\/test_fitswcs.py:    # First ensure that transformations round-trip\nastropy\/convolution\/tests\/test_discretize.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/tests\/mixin_columns.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_tab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_tab.py:    reason=\"Only in WCSLIB 7.6 a 1D -TAB axis roundtrips unless first axis\",\nastropy\/wcs\/tests\/test_tab.py:    # this axis is not the first axis. This tests a bug fixed in WCSLIB 7.6.\nastropy\/io\/tests\/safeio.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/wcsapi\/wrappers\/tests\/test_sliced_wcs.py:    # FIXME: do we still need the first two since the third assert\nastropy\/wcs\/tests\/test_pickle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_auxprm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_auxprm.py:HGLN_OBS=             8.431123 \/ [deg] Stonyhurst heliographic lng of observer\nastropy\/wcs\/tests\/test_utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_utils.py:    # First try with scalars\nastropy\/wcs\/tests\/test_utils.py:    # First try with scalars\nastropy\/wcs\/tests\/test_utils.py:    # First try with a scalar\nastropy\/wcs\/tests\/conftest.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_wcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_wcs.py:    first_wmsg = str(w[0].message)\nastropy\/wcs\/tests\/test_wcs.py:    assert \"unitfix\" in first_wmsg and \"Hz\" in first_wmsg and \"M\/S\" in first_wmsg\nastropy\/wcs\/tests\/test_wcs.py:    hdrstr = (\nastropy\/wcs\/tests\/test_wcs.py:        hdrstr += (\nastropy\/wcs\/tests\/test_wcs.py:        hdrstr += (\nastropy\/wcs\/tests\/test_wcs.py:    hdrstr += (\"END\",)\nastropy\/wcs\/tests\/test_wcs.py:    header_string = \"\".join(hdrstr)\nastropy\/wcs\/tests\/test_wcs.py:NAXIS1  =                 2136 \/ length of first array dimension\nastropy\/wcs\/tests\/test_wcs.py:    # Equality checking of two different cunit object having the same first unit\nastropy\/wcs\/tests\/test_wcs.py:    # Before fixing this, wx used to return np.nan for the first element\nastropy\/wcs\/tests\/test_celprm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/wcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/wcs.py:                header_string = header.tostring().rstrip()\nastropy\/wcs\/wcs.py:                tmp_header_bytes = tmp_header.tostring().rstrip()\nastropy\/wcs\/wcs.py:        # (it is the norm of the very first correction).\nastropy\/wcs\/wcs.py:        >>> # First, turn detect_divergence on:\nastropy\/wcs\/wcs.py:    def reorient_celestial_first(self):\nastropy\/wcs\/wcs.py:        Reorient the WCS such that the celestial axes are first, followed by\nastropy\/wcs\/wcs.py:            meaning the first slice will be applied to the *last* numpy index\nastropy\/wcs\/wcs.py:            but the *first* WCS axis.\nastropy\/wcs\/wcs.py:        # Python first checks whether __iter__ is present, so we can raise an\nastropy\/wcs\/wcs.py:        The result is returned as nested lists.  The first level\nastropy\/wcs\/tests\/test_wtbarr.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_prjprm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_tabprm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_profiling.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_wcsprm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/helper.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/utils.py:    # The first is the approximate sum (with some floating point error)\nastropy\/time\/utils.py:    The first is the approximate sum (with some floating point error)\nastropy\/time\/utils.py:    The first is the approximate product (with some floating point error)\nastropy\/time\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/core.py:# scale offsets as second = first + first * scale_offset[(first,second)]\nastropy\/time\/core.py:        First of the two doubles that internally store time value(s) in JD.\nastropy\/time\/core.py:            values should be given.  The default of '*' picks the first\nastropy\/time\/core.py:        # First get the minimum at normal precision.\nastropy\/time\/core.py:                # first we need to convert to GCRS coordinates with the correct\nastropy\/time\/core.py:        on the first instance ut1 is needed.\nastropy\/time\/core.py:            # First go from the current input time (which is either\nastropy\/time\/core.py:        If positional argument(s) are provided then the first one is checked\nastropy\/time\/core.py:        default picks the first available for a given format, i.e., 'float').\nastropy\/time\/core.py:            set by ``out_subfmt`` (which by default picks the first available\nastropy\/time\/core.py:        # With positional arguments, we try parsing the first one as a unit,\nastropy\/time\/core.py:                    \"first argument is not one of the known \"\nastropy\/time\/core.py:        Fill the given MaskedArray ``val`` from the first non-masked\nastropy\/time\/core.py:            # First unmasked element.  If all elements are masked then\nastropy\/time\/core.py:            # 1. First call (NOT_STARTED).\nastropy\/time\/core.py:            # 3. Another thread which raced with the first call\nastropy\/time\/core.py:            #    (RUNNING). The first thread has relinquished the\nastropy\/units\/astrophys.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/funcs.py:        The first Cartesian coordinate.\nastropy\/coordinates\/funcs.py:        The first cartesian coordinate.\nastropy\/coordinates\/funcs.py:    # First, validate that the representations are the same, and\nastropy\/modeling\/statistic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/formats.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/formats.py:            # Convert any quantity-likes to days first, attempting to be\nastropy\/time\/formats.py:    of the first day of each year.  For example 2000.5 corresponds to the\nastropy\/time\/formats.py:    format is the same as the first time instance.\nastropy\/time\/formats.py:        is the same as the class of the first Time object in the list.\nastropy\/time\/formats.py:        # Get the str_fmt element of the first allowed output subformat\nastropy\/time\/formats.py:        # Select the first available subformat based on current\nastropy\/units\/tests\/test_quantity_annotations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/core.py:        or array--elements of this array are taken along the first axis (or\nastropy\/modeling\/core.py:        first axis of each input parameter array (properly the 0th axis) is\nastropy\/modeling\/core.py:        Given a shape tuple as the first input, construct a new one by  removing\nastropy\/modeling\/core.py:                # Just raise an error on the first unrecognized argument\nastropy\/modeling\/core.py:        # by the size of that axis on the first parameter--if the other\nastropy\/modeling\/core.py:                    # Use the dimensions of the first parameter to determine\nastropy\/modeling\/core.py:                    'First argument to \"fix_inputs\" must be an instance of '\nastropy\/modeling\/core.py:            # Append keyword specified args first\nastropy\/modeling\/core.py:            # Do this check first in order to raise a more helpful Exception,\nastropy\/modeling\/powerlaws.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_photometric.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/earth_orientation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/errors.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/projections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/required_by_vounit.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_aliases.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_icrs_observed_transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/utils.py:        First iterates over keys from the parent dict (if the aliased keys are\nastropy\/units\/tests\/test_logarithmic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/polynomial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/polynomial.py:    where ``T_n(x)`` and ``T_m(y)`` are Chebyshev polynomials of the first kind.\nastropy\/modeling\/polynomial.py:        SIP polynomial order for first axis\nastropy\/modeling\/polynomial.py:        SIP coefficients for first axis\nastropy\/units\/misc.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angles.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angles.py:    `~astropy.coordinates.Angle` object. First some imports::\nastropy\/coordinates\/angles.py:        the unit will be taken from the first given value.\nastropy\/coordinates\/angles.py:        any string that `~astropy.units.Unit` understands, but it is\nastropy\/coordinates\/angles.py:        with np.errstate(invalid=\"ignore\"):\nastropy\/coordinates\/angles.py:        the unit will be taken from the first given value.\nastropy\/coordinates\/angles.py:        any string that `~astropy.units.Unit` understands, but it is\nastropy\/coordinates\/angles.py:        # first check bounds\nastropy\/coordinates\/angles.py:        the unit will be taken from the first given value.\nastropy\/coordinates\/angles.py:        any string that `~astropy.units.Unit` understands, but it is\nastropy\/units\/tests\/test_units.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_units.py:def test_compose_best_unit_first():\nastropy\/units\/tests\/test_physical.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/convolution.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_structured.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_structured.py:        # Ensure same conversion is done, by placing q1 first.\nastropy\/units\/tests\/test_equivalencies.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/matching.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/matching.py:        The first set of coordinates, which will be searched for matches from\nastropy\/coordinates\/matching.py:        The first set of coordinates, which will be searched for matches from\nastropy\/coordinates\/orbital_elements.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_quantity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_quantity.py:    # UnitConversionError first in ilshift, then in the unit's rlshift.\nastropy\/units\/tests\/test_quantity.py:    # first check directly that we can use a Column to assign to a slice.\nastropy\/units\/tests\/test_quantity.py:    Regression test for the issue first reported in\nastropy\/coordinates\/earth.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/earth.py:    Initialization is first attempted assuming geocentric (x, y, z) coordinates\nastropy\/coordinates\/earth.py:            ``address='springfield'``), this function will use the **first**\nastropy\/coordinates\/earth.py:            When this function is called, it will first attempt to\nastropy\/coordinates\/earth.py:        Gets the site registry.  The first time this either downloads or loads\nastropy\/coordinates\/earth.py:        # \"earth\" first, which gives m\/s as unit.\nastropy\/coordinates\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_quantity_non_ufuncs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_quantity_non_ufuncs.py:        # and the bin edges.  First, check the actual histogram.\nastropy\/units\/tests\/test_quantity_non_ufuncs.py:        # First replicates of the histogram2d tests, but using the\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_distance.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_distance.py:    # first make sure distances are immutable\nastropy\/units\/tests\/test_structured_erfa_ufuncs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_regression.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_regression.py:    # better than the claimed accuracy of <1 mas for this first-order in\nastropy\/units\/tests\/test_quantity_typing.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angle_parsetab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_geodetic_representations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_arrays.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_arrays.py:    Test transformation on coordinates with array content (first length-2 1D, then a 3D array)\nastropy\/coordinates\/tests\/test_name_resolve.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_name_resolve.py:    # First check that sesame is up\nastropy\/coordinates\/tests\/test_name_resolve.py:    # First check that at least some sesame mirror is up\nastropy\/coordinates\/tests\/test_funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_funcs.py:    # The first four cross the boundary at 06h14m30 == 6.2416666666666... hours\nastropy\/coordinates\/baseframe.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/baseframe.py:        Keys are like for normal differentials, i.e., 's' for a first\nastropy\/coordinates\/baseframe.py:        # We first check for explicitly set values for these:\nastropy\/coordinates\/baseframe.py:        # Set the frame attributes. We first construct the attributes from\nastropy\/coordinates\/baseframe.py:                    # first gather up positional args\nastropy\/coordinates\/baseframe.py:                    # first gather up positional args\nastropy\/coordinates\/baseframe.py:            represent the coordinates; 's' the first derivative to time, i.e.,\nastropy\/coordinates\/baseframe.py:                # allow this transformation in the first place?\nastropy\/coordinates\/baseframe.py:                \"explicitly instantiate the target frame, or first convert the source \"\nastropy\/coordinates\/baseframe.py:        which first checks whether they themselves are in equivalent frames\nastropy\/coordinates\/baseframe.py:                attrstr = attr._astropy_repr_in_frame()\nastropy\/coordinates\/baseframe.py:                attrstr = str(attr)\nastropy\/coordinates\/baseframe.py:            attr_strs.append(f\"{attribute_name}={attrstr}\")\nastropy\/coordinates\/baseframe.py:            first transformed to the frame of this object. This can lead to\nastropy\/coordinates\/baseframe.py:        # do this first just in case the conversion somehow creates a distance\nastropy\/coordinates\/tests\/test_sky_coord_velocities.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_iau_fullstack.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_matching.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_shape_manipulation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:def representation_equal(first, second):\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        getattr(first, comp) == getattr(second, comp) for comp in first.components\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        # simple check by hand for first element.\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        # simple check by hand for first element\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        # simple check by hand for first element.\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        # simple check by hand for first element.\nastropy\/coordinates\/tests\/test_api_ape5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_api_ape5.py:    # elements are converted to match the first element's units.\nastropy\/coordinates\/tests\/test_api_ape5.py:    # first element doesn't have the right unit\nastropy\/coordinates\/tests\/test_api_ape5.py:    # first dimension must be length-3 if a lone `Quantity` is passed in.\nastropy\/coordinates\/tests\/test_api_ape5.py:    # They can always accept a representation as a first argument\nastropy\/coordinates\/tests\/test_api_ape5.py:    # identically to the first ICRS example further up.\nastropy\/coordinates\/tests\/test_celestial_transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_earth.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_earth.py:        \"\"\"Test that different ellipsoids are understood, and differ\"\"\"\nastropy\/units\/cds.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_spectral_coordinate.py:# We first run through a series of cases to test different ways of initializing\nastropy\/coordinates\/tests\/test_spectral_coordinate.py:    with np.errstate(all=\"ignore\"):\nastropy\/coordinates\/tests\/test_spectral_coordinate.py:    with np.errstate(all=\"ignore\"):\nastropy\/coordinates\/tests\/test_spectral_coordinate.py:    # First check case where observer and\/or target aren't specified\nastropy\/coordinates\/tests\/test_spectral_coordinate.py:    # note this probably will not work on the first try, but it's ok if this is\nastropy\/units\/tests\/test_deprecated.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_atc_replacements.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/imperial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_angular_separation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_matrix_utilities.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_quantity_decorator.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/solar_system.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/solar_system.py:                    # spk.generate first yields the position and then the\nastropy\/coordinates\/tests\/test_angles.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/__init__.py:# this also makes it easier to understand where most time is spent\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    # first do a round-tripping test\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    # first do a round-tripping test\nastropy\/coordinates\/tests\/test_sky_coord.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_sky_coord.py:    assert \"Cannot parse first argument data\" in str(err.value)\nastropy\/coordinates\/tests\/test_sky_coord.py:    assert \"Cannot parse first argument data\" in str(err.value)\nastropy\/coordinates\/tests\/test_sky_coord.py:    assert \"Cannot parse first argument data\" in str(err.value)\nastropy\/coordinates\/tests\/test_sky_coord.py:    something coordinates understands.\nastropy\/coordinates\/tests\/test_sky_coord.py:    # Check a very simple case first:\nastropy\/coordinates\/tests\/test_sky_coord.py:NAXIS1  =                 2136 \/ length of first array dimension\nastropy\/coordinates\/tests\/test_sky_coord.py:    class MockHeliographicStonyhurst(BaseCoordinateFrame):\nastropy\/coordinates\/tests\/test_sky_coord.py:    fr = MockHeliographicStonyhurst(lon=1 * u.deg, lat=2 * u.deg, radius=10 * u.au)\nastropy\/coordinates\/name_resolve.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/name_resolve.py:for a named object by querying SESAME and getting the first returned result.\nastropy\/coordinates\/name_resolve.py:    # if requested, first try extract coordinates embedded in the object name.\nastropy\/coordinates\/name_resolve.py:    # Do this first since it may be much faster than doing the sesame query\nastropy\/coordinates\/name_resolve.py:    # The web API just takes the first letter of the database name\nastropy\/units\/equivalencies.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/equivalencies.py:            \"Frequency is now the first input, and angular area \"\nastropy\/coordinates\/tests\/test_transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_transformations.py:@pytest.mark.parametrize(\"first, second, check\",\nastropy\/coordinates\/tests\/test_transformations.py:def test_combine_affine_params(first, second, check):\nastropy\/coordinates\/tests\/test_transformations.py:    result = t._combine_affine_params(first, second)\nastropy\/modeling\/rotations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/matrix_utilities.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_frames.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/si.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_representation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_representation.py:        # test that they are close on the first value\nastropy\/coordinates\/tests\/test_representation.py:        # so only test on the first value\nastropy\/coordinates\/tests\/test_representation.py:    # see doc\/coordinates\/representations.rst\nastropy\/coordinates\/erfa_astrom.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/attributes.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_spectral_quantity.py:        # First, operations that should return SpectralQuantity\nastropy\/coordinates\/tests\/test_spectral_quantity.py:        # First, operations that should return SpectralQuantity\nastropy\/coordinates\/tests\/test_spectral_quantity.py:        # First, operations that should return SpectralQuantity\nastropy\/coordinates\/tests\/test_spectral_quantity.py:        # First, operations that should return SpectralQuantity\nastropy\/coordinates\/tests\/accuracy\/test_galactic_fk4.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_format.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/accuracy\/test_icrs_fk5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/bounding_box.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/accuracy\/test_fk4_no_e_fk4.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_representation_methods.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_representation_methods.py:        # properly if it is not the first component that fails.\nastropy\/units\/tests\/test_quantity_array_methods.py:        endindices = [(qf.index, qf.coords) for x in qf][-2]  # next() oversteps\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:    (from the first row of the Results table at the bottom of that page)\nastropy\/units\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/utils.py:def _get_first_sentence(s):\nastropy\/units\/utils.py:    Get the first sentence from a string and remove any carriage\nastropy\/units\/utils.py:        doc = _get_first_sentence(unit.__doc__).strip()\nastropy\/units\/utils.py:    # Normally, start with 0,1 and 1,0; here we have applied first iteration.\nastropy\/units\/tests\/test_utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/cgs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/lombscargle\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/skyoffset.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:# # first define helper functions\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:    # c2tcio expects a GCRS->CIRS matrix as it's first argument.\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:    # first get us to TETE at the target obstime, and location (no-op if same)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:    # first get the pmatrix\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:    # first get us to CIRS at the target obstime, and location (no-op if same)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:    # first get us to GCRS with the right attributes (might be a no-op)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:    # first un-precess\nastropy\/coordinates\/builtin_frames\/fk4_fk5_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/histogram.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/histogram.py:    # if bins is a string, first compute bin edges with the desired heuristic\nastropy\/stats\/histogram.py:        optimal bin width. Bins are measured starting at the first data point.\nastropy\/coordinates\/builtin_frames\/itrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:    # first get us to a 0 pos\/vel GCRS at the target equinox\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:    # first un-precess from ecliptic to ICRS orientation\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:    # first get us to a 0 pos\/vel GCRS at the target equinox\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:    # first un-precess from ecliptic to ICRS orientation\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:    # first un-precess from ecliptic to ICRS orientation\nastropy\/coordinates\/distances.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/fk4.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/fk4.py:    # first precess, if necessary\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:    # first set up the astrometry context for CIRS<->observed\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:    # first set up the astrometry context for ICRS<->CIRS at the observed_coo time\nastropy\/coordinates\/builtin_frames\/equatorial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/hadec.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/icrs_observed_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/icrs_observed_transforms.py:    # first set up the astrometry context for ICRS<->observed\nastropy\/coordinates\/builtin_frames\/icrs_observed_transforms.py:    # first set up the astrometry context for ICRS<->CIRS at the observed_coo time\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:# First the ICRS\/CIRS related transforms\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:    # first set up the astrometry context for ICRS<->CIRS\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:        # When there is a distance,  we first offset for parallax to get the\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:    # first set up the astrometry context for ICRS<->GCRS.\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:        # When there is a distance,  we first offset for parallax to get the\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:        # if they GCRS obstime and HCRS obstime are not the same, we first\nastropy\/coordinates\/builtin_frames\/fk5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/ecliptic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angle_utilities.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/galactic_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/galactic_transforms.py:    # need precess to J2000 first\nastropy\/coordinates\/builtin_frames\/supergalactic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/icrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/icrs_fk5_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/accuracy\/test_ecliptic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/galactic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/altaz.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/utils.py:        First part of two part Julian date (TDB)\nastropy\/coordinates\/builtin_frames\/utils.py:    few arcseconds in the worst case (e.g a Venus transit).\nastropy\/coordinates\/builtin_frames\/utils.py:    few arcseconds in the worst case (e.g a Venus transit).\nastropy\/coordinates\/builtin_frames\/hcrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/supergalactic_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/accuracy\/test_fk4_no_e_fk5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/jackknife.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/jackknife.py:        If ``statistic`` is single-valued, the first and second elements are\nastropy\/stats\/jackknife.py:        each component of ``statistic``. The first and second rows contain the\nastropy\/coordinates\/builtin_frames\/gcrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/galactocentric.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_quantity_ufuncs.py:        # can also replace input with first output when scaling\nastropy\/units\/tests\/test_quantity_ufuncs.py:        First two tests that check that float32 is kept close #3976.\nastropy\/units\/tests\/test_quantity_ufuncs.py:        \"\"\"Check that scipy gets loaded upon first use.\"\"\"\nastropy\/units\/function\/units.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/mixin.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/lsr.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/spatial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/optimizers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/fitting.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/fitting.py:        return ret_str.rstrip()\nastropy\/modeling\/fitting.py:        return ret_str.rstrip()\nastropy\/modeling\/fitting.py:                # first convert any parameters to the units that correspond to the\nastropy\/modeling\/fitting.py:        model set fitting, this must understand masked input data (as\nastropy\/modeling\/fitting.py:        # works even for fitters that don't understand masked arrays. For model\nastropy\/modeling\/fitting.py:            # be last, so that its first dimension is the same length as the x\nastropy\/modeling\/fitting.py:    # the model first, for use in evaluating the \"tied\" expression--it might be\nastropy\/units\/function\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/core.py:            # first convert physical units to other's physical units\nastropy\/units\/function\/core.py:                # if iterable, see if first item has a unit\nastropy\/units\/physical.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/__init__.py:    \"\"\"Get the first line of a docstring.\nastropy\/coordinates\/builtin_frames\/__init__.py:    Skips possible empty first lines, and then combine following text until\nastropy\/coordinates\/builtin_frames\/__init__.py:    the first period or a fully empty line.\nastropy\/units\/function\/logarithmic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/logarithmic.py:        # First, insist on compatible logarithmic type. Here, plain u.mag,\nastropy\/units\/function\/logarithmic.py:        # We check if this power is OK by applying it first to the unit.\nastropy\/units\/function\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/cirs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/bayesian_blocks.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/bayesian_blocks.py:        raise ValueError(\"fitness parameter not understood\")\nastropy\/stats\/bayesian_blocks.py:        # Start with first data cell; add one cell at each iteration\nastropy\/timeseries\/binned.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/binned.py:        # manually, time is added first and is of the right type.\nastropy\/timeseries\/binned.py:        # First if time_bin_start and time_bin_end have been given in the table data, we\nastropy\/timeseries\/binned.py:            # first bin and that the bins are contiguous. In this case,\nastropy\/timeseries\/binned.py:            # Now shift the array so that the first entry is 0\nastropy\/timeseries\/binned.py:            # First we try the readers defined for the BinnedTimeSeries class\nastropy\/units\/_typing.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/calculation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tabular.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/spline.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/biweight.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/biweight.py:    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\nastropy\/stats\/biweight.py:    with np.errstate(invalid=\"ignore\"):\nastropy\/stats\/biweight.py:    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\nastropy\/stats\/biweight.py:    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\nastropy\/stats\/biweight.py:    with np.errstate(invalid=\"ignore\"):\nastropy\/stats\/biweight.py:    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\nastropy\/stats\/biweight.py:    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\nastropy\/stats\/biweight.py:    with np.errstate(invalid=\"ignore\"):\nastropy\/stats\/biweight.py:    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\nastropy\/units\/photometric.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/sigma_clipping.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/sigma_clipping.py:def _move_tuple_axes_first(array, axis):\nastropy\/stats\/sigma_clipping.py:    first dimension of the array so that we can then use axis=0.\nastropy\/stats\/sigma_clipping.py:        array = _move_tuple_axes_first(array, axis=axis)\nastropy\/stats\/sigma_clipping.py:        array = _move_tuple_axes_first(array, axis=axis)\nastropy\/stats\/sigma_clipping.py:        array = _move_tuple_axes_first(array, axis=axis)\nastropy\/stats\/sigma_clipping.py:        with np.errstate(invalid=\"ignore\"):\nastropy\/stats\/sigma_clipping.py:            with np.errstate(invalid=\"ignore\"):\nastropy\/stats\/sigma_clipping.py:            with np.errstate(invalid=\"ignore\"):\nastropy\/stats\/sigma_clipping.py:                with np.errstate(invalid=\"ignore\"):\nastropy\/modeling\/tests\/test_model_sets.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_model_sets.py:    # Parameters for the first model are all NaNs\nastropy\/stats\/circstats.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/circstats.py:        The first and second elements correspond to the direction and length of\nastropy\/stats\/circstats.py:    .. [3] M. Chirstman., C. Miller. \"Testing a Sample of Directions for\nastropy\/stats\/circstats.py:    .. [3] M. Chirstman., C. Miller. \"Testing a Sample of Directions for\nastropy\/modeling\/tests\/test_parameters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/mappings.py:    Mapper that operates on the units of the input, first converting to\nastropy\/modeling\/mappings.py:        inputs by position.  The first element of the each pair is the unit that\nastropy\/modeling\/tests\/test_quantities_rotations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_input.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_input.py:    With n_models=2 all outputs should have a first dimension of size 2 (unless\nastropy\/modeling\/tests\/test_input.py:        # model rather than evaluating the first model with 100 and the second\nastropy\/modeling\/tests\/test_statistics.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/info_theory.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_polynomial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_quantities_evaluation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_quantities_evaluation.py:    # We first check that calling the Gaussian with quantities returns the\nastropy\/modeling\/tests\/test_quantities_evaluation.py:    Test units to first model in chain.\nastropy\/modeling\/tests\/test_quantities_evaluation.py:    Test units to first model in chain.\nastropy\/modeling\/tests\/test_quantities_evaluation.py:    Test units to first model in chain.\nastropy\/modeling\/tests\/test_quantities_evaluation.py:    Test incompatible units to first model in chain.\nastropy\/modeling\/tests\/test_quantities_evaluation.py:    Test that return_units on the first model in the chain is respected for the\nastropy\/modeling\/tests\/test_quantities_fitting.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_rotations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/baseradec.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_convolution.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_units_mapping.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/example_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/parameters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/parameters.py:    which are just aliases for the first and second elements of the 'bounds'\nastropy\/modeling\/tests\/test_core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_core.py:    array is passed as first input, but output is broadcast to larger\nastropy\/modeling\/tests\/test_compound.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_compound.py:    S1 = Shift(2) | Scale(3)  # First shift then scale\nastropy\/modeling\/tests\/test_compound.py:    S2 = Scale(2) | Shift(3)  # First scale then shift\nastropy\/modeling\/tests\/test_compound.py:    Test a case where an Identity (or Mapping) model is the first in a chain\nastropy\/modeling\/tests\/test_compound.py:    S1 = Shift(2, name=\"shift2\") | Scale(3, name=\"scale3\")  # First shift then scale\nastropy\/modeling\/tests\/test_compound.py:    S2 = Scale(2, name=\"scale2\") | Shift(3, name=\"shift3\")  # First scale then shift\nastropy\/modeling\/tests\/test_separable.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_mappings.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_models_quantities.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst:\nastropy\/modeling\/tests\/test_physical_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_physical_models.py:        with np.errstate(all=\"ignore\"):\nastropy\/modeling\/tests\/test_physical_models.py:    # First element is NaN, last element is very small, others normal\nastropy\/modeling\/tests\/test_physical_models.py:    with np.errstate(all=\"ignore\"):\nastropy\/modeling\/tests\/test_physical_models.py:    with np.errstate(all=\"ignore\"):\nastropy\/modeling\/tests\/irafutil.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/irafutil.py:        # take only the first 3 columns\nastropy\/modeling\/tests\/irafutil.py:        self.records = [IdentifyRecord(rstr) for rstr in self.aslist(dtbstr)]\nastropy\/modeling\/tests\/irafutil.py:        # if the first one is a comment remove it from the list\nastropy\/modeling\/tests\/test_utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_math_func.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_constraints.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_fitters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_fitters.py:        # first compute the ordinary least squares covariance matrix\nastropy\/modeling\/tests\/test_fitters.py:    # Refit just the first row without any rejection iterations, to ensure\nastropy\/modeling\/tests\/test_fitters.py:        # the cov matrix of first model in the set\nastropy\/modeling\/tests\/test_fitters.py:        # the cov matrix of first model in the set\nastropy\/modeling\/tests\/test_functional_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_functional_models.py:    # first make sure the valid ones are OK\nastropy\/modeling\/tests\/data\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/representation.py:                        f\" {component!r} (or first argument should be an instance of\"\nastropy\/coordinates\/representation.py:        arrstr = _array2string(self._values, prefix=prefixstr)\nastropy\/coordinates\/representation.py:            f\" {unitstr:s}\\n{prefixstr}{arrstr}{diffstr}>\"\nastropy\/coordinates\/representation.py:        # first time a duplicate is added\nastropy\/coordinates\/representation.py:        # remove first entry and add both using their qualnames\nastropy\/coordinates\/representation.py:        first, second = (self, other_c) if not reverse else (other_c, self)\nastropy\/coordinates\/representation.py:                op(getattr(first, component), getattr(second, component))\nastropy\/coordinates\/representation.py:                for component in first.components\nastropy\/coordinates\/representation.py:            first, second = (self, other) if not reverse else (other, self)\nastropy\/coordinates\/representation.py:                *[op(getattr(first, c), getattr(second, c)) for c in self.components]\nastropy\/coordinates\/representation.py:            first, second = (self, other) if not reverse else (other, self)\nastropy\/coordinates\/representation.py:                c: op(getattr(first, c, 0.0), getattr(second, c, 0.0))\nastropy\/coordinates\/representation.py:            first, second = (self, other) if not reverse else (other, self)\nastropy\/coordinates\/representation.py:                c: op(getattr(first, c, 0.0), getattr(second, c, 0.0))\nastropy\/coordinates\/representation.py:                first, second = other.distance, self.d_distance\nastropy\/coordinates\/representation.py:                first, second = self.d_distance, other.distance\nastropy\/coordinates\/representation.py:            return other.__class__(op(first, second), copy=False)\nastropy\/coordinates\/representation.py:            first, second = (self, other) if not reverse else (other, self)\nastropy\/coordinates\/representation.py:                c: op(getattr(first, c, 0.0), getattr(second, c, 0.0))\nastropy\/stats\/tests\/test_jackknife.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_jackknife.py:    # Test from the first example of Ref.[3]\nastropy\/units\/format\/ogip_parsetab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_sigma_clipping.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_sigma_clipping.py:    # First check with regular std, which shouldn't remove any values\nastropy\/timeseries\/sampled.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/sampled.py:        The time of the first sample in the time series. This is an alternative\nastropy\/timeseries\/sampled.py:        # manually, time is added first and is of the right type.\nastropy\/timeseries\/sampled.py:        # First if time has been given in the table data, we should extract it\nastropy\/timeseries\/sampled.py:            # We interpret this as meaning that time is that of the first\nastropy\/timeseries\/sampled.py:            offset \/ phase will be ``epoch_phase``. Defaults to the first time\nastropy\/timeseries\/sampled.py:            # First we try the readers defined for the BinnedTimeSeries class\nastropy\/stats\/tests\/test_biweight.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/physical_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/physical_models.py:            Use `numpy.errstate` to suppress Numpy warnings, if desired.\nastropy\/units\/format\/fits.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/latex.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_quantities_parameters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/generic_parsetab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_projections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/cds.py:# Licensed under a 3-clause BSD style license - see LICNSE.rst\nastropy\/units\/format\/unicode_format.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/bls\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/ogip_lextab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/base.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_histogram.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/vounit.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/ogip.py:# Licensed under a 3-clause BSD style license - see LICNSE.rst\nastropy\/units\/format\/ogip.py:                    f\"The function '{p[1]}' is valid in OGIP, but not understood \"\nastropy\/timeseries\/io\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/cds_lextab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/io\/kepler.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_bayesian_blocks.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/generic_lextab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/generic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/cds_parsetab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_spline.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_bounding_box.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angle_formats.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angle_formats.py:            last_value = last_value.rstrip(\"0\").rstrip(\".\")\nastropy\/units\/format\/console.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/functional_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/functional_models.py:        The radius of the Airy disk (radius of the first zero).\nastropy\/modeling\/functional_models.py:    Where :math:`J_1` is the first order Bessel function of the first\nastropy\/modeling\/functional_models.py:    For an optical system, the radius of the first zero represents the\nastropy\/modeling\/functional_models.py:        description=\"The radius of the Airy disk (radius of first zero crossing)\",\nastropy\/units\/structured.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/structured.py:                # For list, the first item is the name of our level,\nastropy\/units\/structured.py:        The routine does presume that the type of the first tuple is\nastropy\/units\/structured.py:            specified unit.  If a sequence, the first element must have\nastropy\/coordinates\/transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/transformations.py:        # first make the list of nodes\nastropy\/coordinates\/transformations.py:        for p in path[1:]:  # first element is fromsys so we skip it\nastropy\/coordinates\/transformations.py:        # first make the nodes\nastropy\/coordinates\/transformations.py:        This decorator assumes the first argument of the ``transcls``\nastropy\/coordinates\/transformations.py:    calculation has two components. The first part is simple the existing\nastropy\/coordinates\/transformations.py:            # first we use the existing differential to compute an offset due to\nastropy\/coordinates\/transformations.py:                # We have to first represent as the Unit types we converted to,\nastropy\/coordinates\/transformations.py:        # Transform the first displacement vector by the second transformation matrix\nastropy\/timeseries\/io\/tests\/test_kepler.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/deprecated.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/io\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/math_functions.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/separable.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/tests\/test_common.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/tests\/test_binned.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/tests\/test_binned.py:    # Make sure things crash when the first column added is not a time column\nastropy\/timeseries\/tests\/test_binned.py:            r\" first column but found 'flux'\"\nastropy\/timeseries\/tests\/test_downsample.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/tests\/test_downsample.py:    # to an array with its first element set to the start of the timeseries and rest populated using\nastropy\/timeseries\/tests\/test_downsample.py:        )  # single-valued time series falls in *first* bin\nastropy\/timeseries\/periodograms\/bls\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/periodograms\/bls\/methods.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/periodograms\/bls\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/periodograms\/lombscargle\/_statistics.py:def vectorize_first_argument(func):\nastropy\/timeseries\/periodograms\/lombscargle\/_statistics.py:    with np.errstate(divide=\"ignore\"):\nastropy\/timeseries\/periodograms\/lombscargle\/_statistics.py:    with np.errstate(divide=\"ignore\"):\nastropy\/timeseries\/periodograms\/lombscargle\/_statistics.py:    with np.errstate(divide=\"ignore\"):\nastropy\/timeseries\/periodograms\/lombscargle\/_statistics.py:@vectorize_first_argument\nastropy\/timeseries\/periodograms\/lombscargle\/_statistics.py:@vectorize_first_argument\nastropy\/timeseries\/periodograms\/lombscargle\/core.py:        Conference on Intelligent Data Understanding (2012)\nastropy\/timeseries\/periodograms\/lombscargle\/implementations\/fastchi2_impl.py:    .. [1] M. Zechmeister and M. Kurster, A&A 496, 577-584 (2009)\nastropy\/timeseries\/periodograms\/lombscargle\/implementations\/fast_impl.py:    .. [2] M. Zechmeister and M. Kurster, A&A 496, 577-584 (2009)\nastropy\/timeseries\/periodograms\/lombscargle\/implementations\/fast_impl.py:    # 2. Compute the periodogram, following Zechmeister & Kurster\nastropy\/coordinates\/sky_coordinate_parsers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/sky_coordinate_parsers.py:    determines the frame class either using the kwargs, or using the first\nastropy\/coordinates\/sky_coordinate_parsers.py:    # The first place to check: the frame could be specified explicitly\nastropy\/coordinates\/sky_coordinate_parsers.py:        # to allow the first argument to set the class.  That's OK because\nastropy\/coordinates\/sky_coordinate_parsers.py:        # the first and all the others\nastropy\/coordinates\/sky_coordinate_parsers.py:        # First validate the component data\nastropy\/coordinates\/sky_coordinate_parsers.py:            # Now use the first to determine if they are all UnitSpherical\nastropy\/coordinates\/sky_coordinate_parsers.py:            # get the frame attributes from the first coord in the list, because\nastropy\/coordinates\/sky_coordinate_parsers.py:            # from the above we know it matches all the others.  First copy over\nastropy\/coordinates\/sky_coordinate_parsers.py:        raise ValueError(\"Cannot parse coordinates from first argument\")\nastropy\/coordinates\/sky_coordinate_parsers.py:            f'Cannot parse first argument data \"{value}\" for attribute'\nastropy\/timeseries\/periodograms\/lombscargle\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/periodograms\/lombscargle\/implementations\/chi2_impl.py:    .. [1] M. Zechmeister and M. Kurster, A&A 496, 577-584 (2009)\nastropy\/timeseries\/periodograms\/bls\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/tests\/test_sampled.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/tests\/test_sampled.py:    # Make sure things crash when the first column added is not a time column\nastropy\/timeseries\/tests\/test_sampled.py:            r\"TimeSeries object is invalid - expected 'time' as the first column but\"\nastropy\/timeseries\/tests\/test_sampled.py:    # Try without epoch time, as it should default to the first time and\nastropy\/timeseries\/tests\/test_sampled.py:    # Try without epoch time, as it should default to the first time and\nastropy\/timeseries\/tests\/test_sampled.py:        r\"TimeSeries object is invalid - expected 'time' as the first column but found\"\nastropy\/timeseries\/tests\/test_sampled.py:        r\"TimeSeries object is invalid - expected \\['time', 'a'\\] as the first columns\"\nastropy\/timeseries\/periodograms\/lombscargle\/implementations\/utils.py:    # first take care of the easy cases where x is an integer\nastropy\/stats\/funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/funcs.py:    Bootstrap resampling is used to understand confidence intervals of sample\nastropy\/stats\/funcs.py:        N-D array. The bootstrap resampling will be performed on the first\nastropy\/stats\/funcs.py:        index, so the first index should access the relevant information\nastropy\/stats\/funcs.py:    Obtain a statistic with two outputs on the array, keeping only the first\nastropy\/stats\/funcs.py:        The first set of data values.\nastropy\/stats\/funcs.py:    should be converted to units of the orbital period first).\nastropy\/timeseries\/periodograms\/bls\/tests\/test_bls.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/periodograms\/bls\/tests\/test_bls.py:    # absolute instead of relative in the first case.\nastropy\/units\/quantity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/quantity.py:        'representation for IPython gets \"summarized\" (meaning only the first '\nastropy\/units\/quantity.py:            If tuple, then the first element is the unit specification\nastropy\/units\/quantity.py:            # convert unit first, to avoid multiple string->unit conversions\nastropy\/units\/quantity.py:                # The first part of the regex string matches any integer\/float;\nastropy\/units\/quantity.py:        arrstr = np.array2string(\nastropy\/units\/quantity.py:        return f\"{prefixstr}{arrstr}{self._unitstr:s}>\"\nastropy\/units\/quantity.py:            # First remove two special cases (with a fast test):\nastropy\/units\/quantity.py:            Any positional arguments to the function beyond the first argument\nastropy\/timeseries\/downsample.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/downsample.py:        Defaults to the first time in the sampled time series.\nastropy\/timeseries\/periodograms\/lombscargle\/implementations\/scipy_impl.py:    .. [1] M. Zechmeister and M. Kurster, A&A 496, 577-584 (2009)\nastropy\/coordinates\/sites.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angle_lextab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/sky_coordinate.py:    full coordinates documentation.  First some imports::\nastropy\/coordinates\/sky_coordinate.py:            first transformed to the frame of this object. This can lead to\nastropy\/coordinates\/sky_coordinate.py:        To determine which constellation a point on the sky is in, this first\nastropy\/coordinates\/sky_coordinate.py:        For example, the first rule means columns with names like\nastropy\/timeseries\/periodograms\/lombscargle\/tests\/test_lombscargle.py:    # make sure the first time is also the smallest so that internally the\nastropy\/units\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/core.py:            # Loop through all of the names first, to ensure all of them\nastropy\/units\/core.py:        # First see if it is just a scaling.\nastropy\/units\/core.py:            # We assume the equivalencies have the unit itself as first item.\nastropy\/units\/core.py:            # Sort the results so the simplest ones appear first.\nastropy\/units\/core.py:            units of that system will appear first.\nastropy\/units\/core.py:        The name of the unit.  If a list of strings, the first element\nastropy\/units\/core.py:        are aliases.  If a tuple of lists, the first element is a list\nastropy\/units\/core.py:        names; all but the first short name are considered \"aliases\".\nastropy\/units\/core.py:        # Loop through all of the names first, to ensure all of them\nastropy\/units\/core.py:        # understands how to recreate the Unit on the other side.\nastropy\/units\/core.py:        The name of the unit.  If a list, the first element is the\nastropy\/units\/core.py:        The name of the unit.  If a list, the first element is the\nastropy\/time\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/core.py:                    f\" '{required_columns[0]}' as the first column{plural} but time\"\nastropy\/timeseries\/core.py:                    f\" {as_scalar_or_list_str(required_columns)} as the first\"\nastropy\/timeseries\/periodograms\/lombscargle\/implementations\/slow_impl.py:    .. [3] M. Zechmeister and M. Kurster, A&A 496, 577-584 (2009)\nastropy\/units\/quantity_helper\/erfa.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/spectral_coordinate.py:        with np.errstate(all=\"ignore\"):\nastropy\/coordinates\/spectral_coordinate.py:        arrstr = np.array2string(self.view(np.ndarray), separator=\", \", prefix=\"  \")\nastropy\/coordinates\/spectral_coordinate.py:            repr_items[0] += f\"{arrstr}{self._unitstr:s}\"\nastropy\/coordinates\/spectral_coordinate.py:            repr_items.append(f\"  {arrstr}{self._unitstr:s}\")\nastropy\/units\/quantity_helper\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/timeseries\/periodograms\/bls\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/connect.py:        first argument is typically the input filename.\nastropy\/cosmology\/connect.py:        first argument is the output filename.\nastropy\/cosmology\/connect.py:        first argument is the output filename.\nastropy\/units\/quantity_helper\/converters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_corrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/uncertainty\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_custom_formats.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_functions.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/parameter.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_quantity_interaction.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/standard_profile.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/lockfile_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/hub_proxy.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_basic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_basic.py:        # and that scale and format are same as first element.\nastropy\/time\/tests\/test_basic.py:        # These first three are TimeFromEpoch and have an intrinsic time scale\nastropy\/samp\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/hub_script.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_methods.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/client.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_fast_parser.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/tests\/conftest.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/tests\/test_cosmology.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/tests\/test_cosmology.py:    with pytest.warns(AstropyUserWarning, match=\"less than first redshift\"):\nastropy\/cosmology\/tests\/test_cosmology.py:    #  First try 3 massive neutrinos, all 100 eV -- note this is a universe\nastropy\/cosmology\/tests\/test_parameters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/tests\/test_utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/yaml.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/mapping.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/mapping.py:    ``from_mapping``, we will first make a mapping using\nastropy\/cosmology\/tests\/test_realizations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/hub.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/constants.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/funcs\/optimize.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/funcs\/optimize.py:       Make sure you understand the behavior of the function that you are\nastropy\/cosmology\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/utils.py:        :func:`functools.wraps` of ``func`` where the first ``nin``\nastropy\/cosmology\/utils.py:        :func:`functools.wraps` of ``func`` where the first ``nin``\nastropy\/cosmology\/io\/table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/table.py:    ``from_table``, we will first make a |QTable| using\nastropy\/cosmology\/io\/table.py:        default) or as the first column (if `False`).\nastropy\/cosmology\/tests\/test_connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/tests\/test_parameter.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/tests\/test_core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/tests\/test_core.py:        c._name = cosmo.name  # first change name back\nastropy\/cosmology\/tests\/test_core.py:        assert r.index(cosmo_cls.__qualname__) == 0  # it's the first thing\nastropy\/cosmology\/io\/tests\/test_cosmology.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/tests\/test_row.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/model.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/model.py:            The first ``n_inputs`` of ``*args`` are for evaluating the method\nastropy\/cosmology\/io\/tests\/test_ecsv.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/tests\/test_json.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/row.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/row.py:    ``from_row``, we will first make a `~astropy.table.Row` using\nastropy\/cosmology\/io\/row.py:        as the first column (if `False`, default).\nastropy\/cosmology\/io\/tests\/test_yaml.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/tests\/test_mapping.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/tests\/test_model.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/tests\/base.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/ecsv.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/ecsv.py:        default) or as the first column (if `False`).\nastropy\/cosmology\/funcs\/comparison.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/tests\/test_.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/tests\/test_.py:This file is weirdly named so that it's the first test of I\/O.\nastropy\/cosmology\/io\/tests\/test_html.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/tests\/test_html.py:        # For now, Cosmology class and name are stored in first 2 slots\nastropy\/cosmology\/io\/tests\/test_html.py:        # cosmology name is still stored in first slot\nastropy\/cosmology\/io\/tests\/test_html.py:            # for now, Cosmology as metadata and name is stored in first 2 slots\nastropy\/cosmology\/io\/tests\/test_html.py:            # for now now, metadata is still stored in first slot\nastropy\/cosmology\/io\/tests\/test_table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_mask.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_mask.py:# The first form is expanded to r\"can't set attribute '{0}'\" in Python 3.10, and replaced\nastropy\/cosmology\/io\/cosmology.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/funcs\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/tests\/helper.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/tests\/helper.py:        ):  # First non-self arg is z.\nastropy\/time\/tests\/test_comparisons.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/parameters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_guess.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_delta.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_delta.py:        first time.  The one exception is UTC, which returns TAI.\nastropy\/time\/tests\/test_delta.py:        # check that if we put TCG first, we get a TCG scale back\nastropy\/samp\/errors.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/realizations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/integrated_client.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/funcs\/tests\/test_funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/io\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/uncertainty\/distributions.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/funcs\/tests\/test_comparison.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_sidereal.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_precision.py:    that it can work towards a failure and present the worst failure ever seen\nastropy\/cosmology\/units.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/flrw\/w0wzcdm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/flrw\/w0wacdm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_update_leap_seconds.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/flrw\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_ut1.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_pickle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/flrw\/w0cdm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/flrw\/lambdacdm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/web_profile.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/flrw\/wpwazpcdm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/quantity_helper\/scipy_special.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/quantity_helper\/function_helpers.py:# Licensed under a 3-clause BSD style license. See LICENSE.rst except\nastropy\/units\/quantity_helper\/function_helpers.py:# implementations; for those, see licenses\/NUMPY_LICENSE.rst.\nastropy\/units\/quantity_helper\/function_helpers.py:# zeros_like does work by default for regular quantities, because numpy first\nastropy\/units\/quantity_helper\/function_helpers.py:def _quantities2arrays(*args, unit_from_first=False):\nastropy\/units\/quantity_helper\/function_helpers.py:    \"\"\"Convert to arrays in units of the first argument that has a unit.\nastropy\/units\/quantity_helper\/function_helpers.py:    If unit_from_first, take the unit of the first argument regardless\nastropy\/units\/quantity_helper\/function_helpers.py:    # Turn first argument into a quantity.\nastropy\/units\/quantity_helper\/function_helpers.py:    if not unit_from_first and (\nastropy\/units\/quantity_helper\/function_helpers.py:    arrays, unit = _quantities2arrays(arr, values, unit_from_first=True)\nastropy\/units\/quantity_helper\/function_helpers.py:    (arr, values), unit = _quantities2arrays(arr, values, unit_from_first=True)\nastropy\/units\/quantity_helper\/function_helpers.py:    (a, b), unit = _quantities2arrays(a, b, unit_from_first=True)\nastropy\/units\/quantity_helper\/function_helpers.py:    arrays, unit = _quantities2arrays(x, bins, unit_from_first=True)\nastropy\/cosmology\/flrw\/tests\/test_base.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/flrw\/tests\/test_base.py:        # decouple first.\nastropy\/cosmology\/flrw\/tests\/test_lambdacdm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/flrw\/tests\/test_w0cdm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/flrw\/tests\/test_init.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/quantity_helper\/helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/quantity_helper\/helpers.py:    # if first arg is not a quantity, just return plain array\nastropy\/nddata\/bitmask.py:        # in the first position:\nastropy\/nddata\/nddata_withmixins.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/flrw\/tests\/test_wpwazpcdm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/compat.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/compat.py:            # internal representation should be one numpy understands\nastropy\/uncertainty\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/uncertainty\/core.py:            firstspace = reprarr.find(\" \")\nastropy\/uncertainty\/core.py:            reprarr = reprarr[firstspace + 1 : -1]  # :-1] removes the ending '>'\nastropy\/uncertainty\/core.py:            firstparen = reprarr.find(\"(\")\nastropy\/uncertainty\/core.py:            reprarr = reprarr[firstparen:]\nastropy\/uncertainty\/core.py:        distrstr = str(self.distribution)\nastropy\/uncertainty\/core.py:        return distrstr + toadd\nastropy\/cosmology\/flrw\/tests\/conftest.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/tests\/test_helpers.py:        # Here we need to make sure that we first reply, *then* write out the\nastropy\/tests\/test_logger.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/uncertainty\/tests\/test_distribution.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/ccddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/ccddata.py:            If this option is `True`, the first item of the returned\nastropy\/nddata\/ccddata.py:        no data in the primary HDU, it will search for the first\nastropy\/nddata\/ccddata.py:        # search for the first instance with data if\nastropy\/nddata\/ccddata.py:                    log.info(f\"first HDU with data is extension {hdu}.\")\nastropy\/nddata\/ccddata.py:        If this option is `True`, the first item of the returned\nastropy\/nddata\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/utils.py:    If instead we use a subsampling of 2, we see that for the two first values\nastropy\/nddata\/tests\/test_utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_utils.py:    The first few lines test the most error-prone part: Extraction of an\nastropy\/nddata\/_testing.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_nddata_base.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_flag_collection.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_bitmask.py:Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nddata.py:                # it first.\nastropy\/nddata\/mixins\/ndslicing.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_compat.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/flrw\/base.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/flrw\/base.py:        # But check for common cases first\nastropy\/cosmology\/flrw\/base.py:                f\"Second redshift(s) z2 ({z2}) is less than first \"\nastropy\/nddata\/tests\/test_blocks.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_decorators.py:def test_incorrect_first_argument():\nastropy\/nddata\/tests\/test_decorators.py:        == \"Can only wrap functions whose first positional argument is `data`\"\nastropy\/nddata\/tests\/test_decorators.py:        == \"Can only wrap functions whose first positional argument is `data`\"\nastropy\/nddata\/tests\/test_decorators.py:        == \"Can only wrap functions whose first positional argument is `data`\"\nastropy\/nddata\/tests\/test_decorators.py:    # First argument is not data\nastropy\/nddata\/tests\/test_nddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_nddata.py:    # First one is sliceable but has no shape, so should fail.\nastropy\/nddata\/tests\/test_nddata.py:    # First make sure that NDData isn't converting its data to a numpy array.\nastropy\/nddata\/mixins\/ndio.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/ndio.py:        first argument is the input filename.\nastropy\/nddata\/mixins\/ndio.py:        first argument is the output filename.\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/ndarithmetic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/ndarithmetic.py:        result will have a copied version of the first operand that has an\nastropy\/nddata\/mixins\/ndarithmetic.py:    handle_mask : callable, ``'first_found'`` or ``None``, optional\nastropy\/nddata\/mixins\/ndarithmetic.py:        If ``None`` the result will have no mask. If ``'first_found'`` the\nastropy\/nddata\/mixins\/ndarithmetic.py:        result will have a copied version of the first operand that has a\nastropy\/nddata\/mixins\/ndarithmetic.py:    handle_meta : callable, ``'first_found'`` or ``None``, optional\nastropy\/nddata\/mixins\/ndarithmetic.py:        If ``None`` the result will have no meta. If ``'first_found'`` the\nastropy\/nddata\/mixins\/ndarithmetic.py:        result will have a copied version of the first operand that has a\nastropy\/nddata\/mixins\/ndarithmetic.py:    compare_wcs : callable, ``'first_found'`` or ``None``, optional\nastropy\/nddata\/mixins\/ndarithmetic.py:        the wcs of the operands is made. If ``'first_found'`` the\nastropy\/nddata\/mixins\/ndarithmetic.py:        result will have a copied version of the first operand that has a\nastropy\/nddata\/mixins\/ndarithmetic.py:        not successful. Default is ``'first_found'``.\nastropy\/nddata\/mixins\/ndarithmetic.py:    callable must accept the corresponding attributes as first two\nastropy\/nddata\/mixins\/ndarithmetic.py:    ``\"first_found\"`` can also be abbreviated with ``\"ff\"``.\nastropy\/nddata\/mixins\/ndarithmetic.py:    uncertainty, ``False`` means it takes the uncertainty of the first operand\nastropy\/nddata\/mixins\/ndarithmetic.py:        compare_wcs=\"first_found\",\nastropy\/nddata\/mixins\/ndarithmetic.py:        handle_mask : callable, ``'first_found'`` or ``None``, optional\nastropy\/nddata\/mixins\/ndarithmetic.py:        handle_meta : callable, ``'first_found'`` or ``None``, optional\nastropy\/nddata\/mixins\/ndarithmetic.py:        compare_wcs : callable, ``'first_found'`` or ``None``, optional\nastropy\/nddata\/mixins\/ndarithmetic.py:        # First check that the WCS allows the arithmetic operation\nastropy\/nddata\/mixins\/ndarithmetic.py:        elif compare_wcs in [\"ff\", \"first_found\"]:\nastropy\/nddata\/mixins\/ndarithmetic.py:        elif handle_mask in [\"ff\", \"first_found\"]:\nastropy\/nddata\/mixins\/ndarithmetic.py:        elif handle_meta in [\"ff\", \"first_found\"]:\nastropy\/nddata\/mixins\/ndarithmetic.py:            The ``wcs`` of the first operand is returned.\nastropy\/nddata\/mixins\/ndarithmetic.py:                # Convert the first operand to the class of this method.\nastropy\/samp\/tests\/test_errors.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/command.py:            \"is necessary.  If a relative  path to a .rst file, it is relative to \"\nastropy\/tests\/command.py:            \"The path to the documentation .rst files.  If not provided, and \"\nastropy\/tests\/command.py:        (\"skip-docs\", None, \"Don't test the documentation .rst files.\"),\nastropy\/nddata\/blocks.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nduncertainty.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nduncertainty.py:        First this method checks if a correlation is given and the subclass\nastropy\/nddata\/nduncertainty.py:    \"\"\"Standard deviation uncertainty assuming first order gaussian error\nastropy\/nddata\/nduncertainty.py:    Variance uncertainty assuming first order Gaussian error\nastropy\/nddata\/nduncertainty.py:    Inverse variance uncertainty assuming first order Gaussian error\nastropy\/samp\/tests\/test_client.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/flag_collection.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/decorators.py:        The function to decorate or ``None`` if used as factory. The first\nastropy\/nddata\/decorators.py:        it assumes the function takes a ``data`` argument as first argument,\nastropy\/nddata\/decorators.py:        but if the first argument is called ``input`` one should pass\nastropy\/nddata\/decorators.py:        # First argument should be data\nastropy\/nddata\/decorators.py:                \"Can only wrap functions whose first positional \"\nastropy\/cosmology\/flrw\/tests\/test_w0wacdm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_nduncertainty.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/figures\/helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/tests\/test_run_tests.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# Test abbreviation and long name for taking the first found meta, mask, wcs\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:@pytest.mark.parametrize(\"use_abbreviation\", [\"ff\", \"first_found\"])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Only first has attributes and False is chosen\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    def meta_fun_func(meta1, meta2, take=\"first\"):\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        if take == \"first\":\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:def test_two_argument_useage_non_nddata_first_arg(meth):\nastropy\/tests\/figures\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/flrw\/tests\/test_w0wzcdm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/helper.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/helper.py:    # First, totally reset the warning state. The modules may change during\nastropy\/nddata\/nddata_base.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/runner.py:    # Increase priority so this warning is displayed first.\nastropy\/tests\/runner.py:            if ext in (\".rst\", \"\"):\nastropy\/tests\/runner.py:                        \"Can not test .rst files without a docs_path specified.\"\nastropy\/tests\/runner.py:                    # Turn on the doctest_rst plugin\nastropy\/tests\/runner.py:                    all_args.append(\"--doctest-rst\")\nastropy\/tests\/runner.py:                os.path.isdir(test_path) or (\".py\" in test_path or \".rst\" in test_path)\nastropy\/tests\/runner.py:                    \"Test path must be a directory or a path to a .py or .rst file\"\nastropy\/tests\/runner.py:            The path to the documentation .rst files.\nastropy\/tests\/runner.py:                    \"Can not test .rst docs for {name}, since \"\nastropy\/tests\/runner.py:                paths.append(\"--doctest-rst\")\nastropy\/tests\/runner.py:            When `True`, skips running the doctests in the .rst files.\nastropy\/tests\/tests\/test_imports.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nconftest.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_ccddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_ccddata.py:    hdu1 = fits.ImageHDU(fake_img1, name=\"first\", ver=1)\nastropy\/nddata\/tests\/test_ccddata.py:    # by default, we reading from the first extension\nastropy\/samp\/tests\/test_hub.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/_strptime.py:# See licenses\/PYTHON.rst\nastropy\/extern\/_strptime.py:            # 2005-01-03 occurs before the first Monday of the year.  Otherwise\nastropy\/extern\/_strptime.py:# first!\nastropy\/extern\/_strptime.py:    first_weekday = datetime_date(year, 1, 1).weekday()\nastropy\/extern\/_strptime.py:    # easier to just shift the view to Sunday being the first day of the\nastropy\/extern\/_strptime.py:        first_weekday = (first_weekday + 1) % 7\nastropy\/extern\/_strptime.py:    # Need to watch out for a week 0 (when the first day of the year is not\nastropy\/extern\/_strptime.py:    week_0_length = (7 - first_weekday) % 7\nastropy\/extern\/_strptime.py:        return 1 + day_of_week - first_weekday\nastropy\/extern\/_strptime.py:        year = 1904  # 1904 is first leap year of 20th century\nastropy\/extern\/_strptime.py:        # Need to add 1 to result since first day of the year is 1, not 0.\nastropy\/constants\/codata2014.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/argparse.py:            \"be created first)\"\nastropy\/constants\/astropyconst40.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/cgs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/ply\/lex.py:        # Pull off the first character to see if s looks like a string\nastropy\/extern\/ply\/lex.py:                            func.__code__.co_filename, func.__code__.co_firstlineno,\nastropy\/extern\/ply\/lex.py:                    line = t.__code__.co_firstlineno\nastropy\/extern\/ply\/lex.py:            f.sort(key=lambda x: x[1].__code__.co_firstlineno)\nastropy\/extern\/ply\/lex.py:                line = f.__code__.co_firstlineno\nastropy\/extern\/ply\/lex.py:                line = f.__code__.co_firstlineno\nastropy\/extern\/ply\/lex.py:        # Add rules defined by functions first\nastropy\/utils\/tests\/test_decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_decorators.py:    # A first test that replaces an empty docstring\nastropy\/utils\/tests\/test_decorators.py:    # A first test that replaces an empty docstring\nastropy\/utils\/console.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/console.py:    is invalid, fall back first on utf-8, then on latin-1 if the message cannot\nastropy\/utils\/console.py:                raise TypeError(\"First argument must be int or sequence\")\nastropy\/utils\/console.py:    line = line.rstrip(\"\\n\")\nastropy\/utils\/tests\/test_shapes.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_misc.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_misc.py:        # break after the first level since the data dir contains some other\nastropy\/utils\/tests\/test_misc.py:    # First, test if the required locales are available\nastropy\/utils\/tests\/test_xml.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/exceptions.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/parsing.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/parsing.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\ndocs\/conf.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\ndocs\/conf.py:    rst_epilog,\ndocs\/conf.py:exclude_patterns.append(\"_pkgtemplate.rst\")  # noqa: F405\ndocs\/conf.py:    \"**\/*.inc.rst\"\ndocs\/conf.py:)  # .inc.rst mean *include* files, don't have sphinx process them\ndocs\/conf.py:    rst_epilog += cl.read().format(\ndocs\/conf.py:    exclude_patterns.append(\"testhelpers.rst\")  # noqa: F405\ndocs\/conf.py:    \"https:\/\/pyfits.readthedocs.io\/en\/v3.2.1\/\",  # defunct page in CHANGES.rst\ndocs\/conf.py:def rstjinja(app, docname, source):\ndocs\/conf.py:    app.connect(\"source-read\", rstjinja)\nastropy\/utils\/iers\/tests\/test_iers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/iers\/tests\/test_iers.py:    # there in the first place.  Better take that into account.\nastropy\/utils\/iers\/iers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/iers\/iers.py:offline?  If you understand what you are doing then this error can be\nastropy\/utils\/iers\/iers.py:        On the first call in a session, the table will be memoized (in the\nastropy\/utils\/iers\/iers.py:        If the location is a network location it is first downloaded via\nastropy\/utils\/iers\/iers.py:            first part of two-part JD, or Time object\nastropy\/utils\/iers\/iers.py:            first part of two-part JD, or Time object\nastropy\/utils\/iers\/iers.py:            first part of two-part JD, or Time object\nastropy\/utils\/iers\/iers.py:            first part of two-part JD, or Time object\nastropy\/utils\/iers\/iers.py:        # Get the table index for the first row that has predictive values\nastropy\/utils\/iers\/iers.py:        # finding the first index where the flag equals 'P'.\nastropy\/utils\/iers\/iers.py:        On the first call in a session, the table will be memoized (in the\nastropy\/utils\/iers\/iers.py:        - The first predictive values are at least ``conf.auto_max_age days`` old.\nastropy\/utils\/iers\/iers.py:                # Replace *replace* current values from the first predictive index through\nastropy\/utils\/iers\/iers.py:        URLs in `~astropy.utils.iers.Conf` are tried, returning the first\nastropy\/utils\/iers\/iers.py:        first before attempting to retrieve it again.\nastropy\/utils\/iers\/iers.py:        # Go through all entries, and return the first one that\nastropy\/utils\/iers\/tests\/test_leap_second.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/iers\/tests\/test_leap_second.py:        # Since it is checked first, it should thus be found.\nastropy\/utils\/misc.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/misc.py:        # need to first read\/remove the first four lines, which have info before\nastropy\/utils\/misc.py:    # The heuristic here is to first try \"singularizing\" the word.  If\nastropy\/utils\/misc.py:                    # Make sure to put obj first for sorting purposes\nastropy\/utils\/tests\/test_collections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_codegen.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/compat\/numpycompat.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/compat\/misc.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/compat\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/masked\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/masked\/function_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/masked\/function_helpers.py:# same helper, because the first arguments have different names.\nastropy\/utils\/masked\/function_helpers.py:        # Single element: first just typeset it normally, replace with masked\nastropy\/utils\/tests\/test_data_info.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_diff.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/compat\/optional_deps.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/compat\/optional_deps.py:# First, the top-level packages:\nastropy\/utils\/masked\/tests\/test_containers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/masked\/tests\/test_masked.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/metadata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/metadata.py:    The first class attribute is ``types``.  This is defined as a list of\nastropy\/utils\/xml\/unescaper.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/writer.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_data.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_data.py:    # First test the expected exception when download fails due to a\nastropy\/utils\/tests\/test_data.py:                # assert f.read().rstrip() == b'CONTENT'\nastropy\/utils\/tests\/test_data.py:            assert f.read().rstrip() == b\"CONTENT\"\nastropy\/utils\/tests\/test_data.py:            assert f.read().rstrip().endswith(b\"invalid\")\nastropy\/utils\/tests\/test_data.py:    # test should be uncommented and the README.rst should be replaced with\nastropy\/utils\/tests\/test_data.py:    # fnout2 = get_pkg_data_filename('..\/..\/data\/README.rst')\nastropy\/utils\/tests\/test_data.py:    # assert os.path.isfile(fnout2) and fnout2.endswith('README.rst')\nastropy\/utils\/tests\/test_data.py:        get_pkg_data_filename(\"..\/..\/..\/data\/README.rst\")\nastropy\/utils\/tests\/test_data.py:    rands = b\"1234567890abcdefghijklmnopqrstuvwxyz\"\nastropy\/utils\/tests\/test_data.py:        assert f.read().rstrip() == b\"CONTENT\"\nastropy\/utils\/tests\/test_data.py:            f.read().rstrip()\nastropy\/utils\/masked\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/masked\/core.py:        # which expects the shape as its first argument, not an array.\nastropy\/utils\/masked\/core.py:            For an array with fields defined, the fields to compare first,\nastropy\/utils\/masked\/core.py:        # First get result from array itself; this will error if not a scalar.\nastropy\/utils\/tests\/test_state.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/masked\/tests\/test_functions.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_console.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_console.py:    # First test without a specified encoding; we should be able to write\nastropy\/utils\/xml\/tests\/test_iterparse.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/tests\/test_iterparse.py:# Firstly, assemble a minimal VOTABLE header, table contents and footer.\nastropy\/utils\/masked\/tests\/test_table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/decorators.py:        If True, caches the value returned by the first call to the getter\nastropy\/utils\/decorators.py:    first access off ``complicated_property`` is returned.\nastropy\/utils\/decorators.py:    automatically passed as the first ``self`` argument of the method)::\nastropy\/utils\/decorators.py:    on an object to first parse the new docstring and then to parse the\nastropy\/utils\/tests\/test_parsing.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/diff.py:            fixed_width_indent(\"  {}\\n\".format(line.rstrip(\"\\n\")), indent_width)\nastropy\/utils\/xml\/validate.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/iterparser.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/masked\/tests\/test_function_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_introspection.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/check.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/si.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/iau2012.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/collections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/ply\/ygen.py:    lines = [line.rstrip()+'\\n' for line in lines]\nastropy\/constants\/codata2010.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/data_info.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/data_info.py:    This will allow downstream code to understand the context in which a column\nastropy\/utils\/data_info.py:    # code to understand the context in which a column is being serialized.\nastropy\/constants\/codata2018.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/introspection.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/introspection.py:        first module that is *different* from those in the provided list.\nastropy\/utils\/introspection.py:    # Check to see if we're importing from a bundle file. First ensure that\nastropy\/utils\/shapes.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/shapes.py:                # The first dimension of size greater than 1\nastropy\/utils\/shapes.py:    first_not_unity = next(\nastropy\/utils\/shapes.py:    return array.reshape(array.shape[first_not_unity:])\nastropy\/constants\/config.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/data.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/data.py:    the first argument providing the warning message. If args[1] is present, it\nastropy\/utils\/data.py:    # BufferedReader to avoid reading loading the whole file first,\nastropy\/utils\/data.py:              will first be searched for locally, and if not found,\nastropy\/utils\/data.py:              will first be searched for locally, and if not found,\nastropy\/utils\/data.py:        # first try looking for a local version if a hash is specified\nastropy\/utils\/data.py:              will first be searched for locally, and if not found,\nastropy\/utils\/data.py:    # Always try first with a secure connection\nastropy\/utils\/data.py:                    \"understand the implications; the original error \"\nastropy\/constants\/iau2015.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/constant.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/__init__.py:See the README.rst in this directory of the Astropy source repository for more\nastropy\/extern\/ply\/cpp.py:        lines = [x.rstrip() for x in input.splitlines()]\nastropy\/extern\/ply\/cpp.py:            # Normal expansion.  Argument is macro expanded first\nastropy\/utils\/codegen.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/astropyconst20.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/astropyconst13.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/ply\/yacc.py:                # first syntax error.  This function is only called if\nastropy\/extern\/ply\/yacc.py:                    # Create the error symbol for the first time and make it the new lookahead symbol\nastropy\/extern\/ply\/yacc.py:                # first syntax error.  This function is only called if\nastropy\/extern\/ply\/yacc.py:                    # Create the error symbol for the first time and make it the new lookahead symbol\nastropy\/extern\/ply\/yacc.py:                # first syntax error.  This function is only called if\nastropy\/extern\/ply\/yacc.py:                    # Create the error symbol for the first time and make it the new lookahead symbol\nastropy\/extern\/ply\/yacc.py:# with various computed properties such as first sets, follow sets, LR items, etc.\nastropy\/extern\/ply\/yacc.py:        self.Productions  = [None]  # A list of all of the productions.  The first\nastropy\/extern\/ply\/yacc.py:        self.First        = {}      # A dictionary of precomputed FIRST(x) symbols\nastropy\/extern\/ply\/yacc.py:    # _first()\nastropy\/extern\/ply\/yacc.py:    # During execution of compute_first1, the result may be incomplete.\nastropy\/extern\/ply\/yacc.py:    def _first(self, beta):\nastropy\/extern\/ply\/yacc.py:        # We are computing First(x1,x2,x3,...,xn)\nastropy\/extern\/ply\/yacc.py:            # Add all the non-<empty> symbols of First[x] to the result.\nastropy\/extern\/ply\/yacc.py:            for f in self.First[x]:\nastropy\/extern\/ply\/yacc.py:    # compute_first()\nastropy\/extern\/ply\/yacc.py:    def compute_first(self):\nastropy\/extern\/ply\/yacc.py:        if self.First:\nastropy\/extern\/ply\/yacc.py:            return self.First\nastropy\/extern\/ply\/yacc.py:            self.First[t] = [t]\nastropy\/extern\/ply\/yacc.py:        self.First['$end'] = ['$end']\nastropy\/extern\/ply\/yacc.py:            self.First[n] = []\nastropy\/extern\/ply\/yacc.py:                    for f in self._first(p.prod):\nastropy\/extern\/ply\/yacc.py:                        if f not in self.First[n]:\nastropy\/extern\/ply\/yacc.py:                            self.First[n].append(f)\nastropy\/extern\/ply\/yacc.py:        return self.First\nastropy\/extern\/ply\/yacc.py:        # If first sets not computed yet, do that first.\nastropy\/extern\/ply\/yacc.py:        if not self.First:\nastropy\/extern\/ply\/yacc.py:            self.compute_first()\nastropy\/extern\/ply\/yacc.py:                        fst = self._first(p.prod[i+1:])\nastropy\/extern\/ply\/yacc.py:    # LR items.  The LR items are stored in two ways:  First, they are uniquely\nastropy\/extern\/ply\/yacc.py:        self.grammar.compute_first()\nastropy\/extern\/ply\/yacc.py:        # First we look for a previously cached entry\nastropy\/extern\/ply\/yacc.py:                                        # that was defined first in the grammar file\nastropy\/extern\/ply\/yacc.py:            eline = self.error_func.__code__.co_firstlineno\nastropy\/extern\/ply\/yacc.py:                line = getattr(item, 'co_firstlineno', item.__code__.co_firstlineno)\nastropy\/extern\/ply\/yacc.py:                                             v.__code__.co_filename, v.__code__.co_firstlineno, n)\ndocs\/conftest.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\ndocs\/conftest.py:        # Don't apply this fixture to io.rst.  It reads files and doesn't write.\ndocs\/conftest.py:        if \"io.rst\" not in request.node.name:\nexamples\/io\/plot_fits-image.py:# data from this first extension using the keyword argument ``ext=0``:\nastropy\/constants\/tests\/test_constant.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:# The first step is to create a new class, which we'll call\nastropy\/extern\/configobj\/configobj.py:            This is similar to a depth-first-search algorithm.\nastropy\/extern\/configobj\/configobj.py:            # try the current section first\nastropy\/extern\/configobj\/configobj.py:    Interpolation is tried first from this object, then from the 'DEFAULT'\nastropy\/extern\/configobj\/configobj.py:            # not yet: first time running _interpolate(), so pick the engine\nastropy\/extern\/configobj\/configobj.py:            # First create the new depth level,\nastropy\/extern\/configobj\/configobj.py:        \"\"\"Pops the first (key,val)\"\"\"\nastropy\/extern\/configobj\/configobj.py:        subsection, *first* the function is called for the *whole* subsection,\nastropy\/extern\/configobj\/configobj.py:        # scalars first\nastropy\/extern\/configobj\/configobj.py:            # Set the newlines attribute (first line ending it finds)\nastropy\/extern\/configobj\/configobj.py:        content = [line.rstrip('\\r\\n') for line in content]\nastropy\/extern\/configobj\/configobj.py:                msg = \"Parsing failed with several errors.\\nFirst error %s\" % info\nastropy\/extern\/configobj\/configobj.py:            # first we check if it's a section marker\nastropy\/extern\/configobj\/configobj.py:        # first time called\nastropy\/extern\/configobj\/configobj.py:    section the first member will be an empty tuple. For values in the 'foo'\nastropy\/extern\/configobj\/configobj.py:    section the first member will be ``('foo',)``. For members in the 'bar'\nastropy\/extern\/configobj\/configobj.py:    subsection of the 'foo' section the first member will be ``('foo', 'bar')``.\nexamples\/io\/skip_create-large-fits.py:# First, it is helpful to anticipate about how large (as in, how many keywords)\nexamples\/io\/skip_create-large-fits.py:# Since the first thing we write to a FITS file is the header, we want to write\nexamples\/coordinates\/plot_galactocentric-frame.py:Cartesian 3-velocity of the sun in the Galactocentric frame. We'll first\nexamples\/coordinates\/plot_galactocentric-frame.py:# Let's first define a barycentric coordinate and velocity in the ICRS frame.\nexamples\/coordinates\/plot_galactocentric-frame.py:# First, let's visualize the geometry in Galactocentric coordinates. Here are\nastropy\/constants\/tests\/test_prior_version.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/configobj\/validate.py:    but the first argument should always be 'value'.\nastropy\/extern\/configobj\/validate.py:    The first program to utilise Validator() was Michael Foord's\nastropy\/constants\/tests\/test_pickle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nexamples\/io\/create-mef.py:# Alternatively, the HDU instances can be created first (or read from an","role":"tool","tool_calls":null},{"content":"astropy\/io\/ascii\/fixedwidth.py:        header_rows = getattr(self, \"header_rows\", [\"name\"])\nastropy\/io\/ascii\/fixedwidth.py:            line = self.get_line(lines, start_line + header_rows.index(\"name\"))\nastropy\/io\/ascii\/fixedwidth.py:        for ii, attr in enumerate(header_rows):\nastropy\/io\/ascii\/fixedwidth.py:        default_header_rows = [] if self.header.start_line is None else [\"name\"]\nastropy\/io\/ascii\/fixedwidth.py:        header_rows = getattr(self, \"header_rows\", default_header_rows)\nastropy\/io\/ascii\/fixedwidth.py:        for col_attr in header_rows:\nastropy\/io\/ascii\/fixedwidth.py:        header_rows=None,\nastropy\/io\/ascii\/fixedwidth.py:        if header_rows is None:\nastropy\/io\/ascii\/fixedwidth.py:            header_rows = [\"name\"]\nastropy\/io\/ascii\/fixedwidth.py:        self.header.header_rows = header_rows\nastropy\/io\/ascii\/fixedwidth.py:        self.data.header_rows = header_rows\nastropy\/io\/ascii\/fixedwidth.py:            self.data.start_line = len(header_rows)\nastropy\/io\/ascii\/fixedwidth.py:            header_rows=[],\nastropy\/io\/ascii\/fixedwidth.py:        header_rows=None,\nastropy\/io\/ascii\/fixedwidth.py:            delimiter_pad=delimiter_pad, bookend=bookend, header_rows=header_rows\nastropy\/io\/ascii\/fixedwidth.py:            position_line = len(self.header.header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:def test_fixed_width_header_rows():\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    header_rows = [\"dtype\", \"name\", \"unit\", \"format\", \"description\"]\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    dat = ascii.read(tbl, format=\"fixed_width\", delimiter=\"|\", header_rows=header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    ascii.write(dat, out, format=\"fixed_width\", delimiter=\"|\", header_rows=header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:def test_fixed_width_two_line_header_rows():\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    header_rows = [\"dtype\", \"unit\", \"format\", \"description\", \"name\"]\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    dat = ascii.read(tbl, format=\"fixed_width_two_line\", header_rows=header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    ascii.write(dat, out, format=\"fixed_width_two_line\", header_rows=header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:def test_fixed_width_no_header_header_rows():\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    with pytest.raises(TypeError, match=r\"unexpected keyword argument 'header_rows'\"):\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:        ascii.read(tbl, format=\"fixed_width_no_header\", header_rows=[\"unit\"])","role":"tool","tool_calls":null},{"content":".\/astropy\/io\/ascii\/core.py\n.\/astropy\/io\/ascii\/connect.py\n.\/astropy\/io\/ascii\/setup_package.py\n.\/astropy\/io\/ascii\/ui.py\n.\/astropy\/io\/ascii\/tests\/test_cds_header_from_readme.py\n.\/astropy\/io\/ascii\/tests\/test_ecsv.py\n.\/astropy\/io\/ascii\/tests\/test_c_reader.py\n.\/astropy\/io\/ascii\/tests\/test_cds.py\n.\/astropy\/io\/ascii\/tests\/common.py\n.\/astropy\/io\/ascii\/tests\/test_ipac_definitions.py\n.\/astropy\/io\/ascii\/tests\/test_fixedwidth.py\n.\/astropy\/io\/ascii\/tests\/test_compressed.py\n.\/astropy\/io\/ascii\/tests\/test_read.py\n.\/astropy\/io\/ascii\/tests\/test_write.py\n.\/astropy\/io\/ascii\/tests\/test_types.py\n.\/astropy\/io\/ascii\/tests\/test_html.py\n.\/astropy\/io\/ascii\/tests\/test_qdp.py\n.\/astropy\/io\/ascii\/tests\/test_rst.py\n.\/astropy\/io\/ascii\/tests\/test_connect.py\n.\/astropy\/io\/ascii\/tests\/__init__.py\n.\/astropy\/io\/ascii\/qdp.py\n.\/astropy\/io\/ascii\/ecsv.py\n.\/astropy\/io\/ascii\/ipac.py\n.\/astropy\/io\/ascii\/daophot.py\n.\/astropy\/io\/ascii\/docs.py\n.\/astropy\/io\/ascii\/sextractor.py\n.\/astropy\/io\/ascii\/html.py\n.\/astropy\/io\/ascii\/latex.py\n.\/astropy\/io\/ascii\/basic.py\n.\/astropy\/io\/ascii\/fixedwidth.py\n.\/astropy\/io\/ascii\/fastbasic.py\n.\/astropy\/io\/ascii\/mrt.py\n.\/astropy\/io\/ascii\/rst.py\n.\/astropy\/io\/ascii\/misc.py\n.\/astropy\/io\/ascii\/__init__.py\n.\/astropy\/io\/ascii\/cds.py","role":"tool","tool_calls":null}],"task":"default","reward":0.0,"generation_ms":0.0,"scoring_ms":0.3123283386,"total_ms":0.3123283386,"info":{"instance_id":"astropy__astropy-14182","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/io\/ascii\/rst.py\": {\"old_start\": 27, \"old_count\": 40, \"new_start\": 27, \"new_count\": 61, \"hunks\": [{\"old_start\": 27, \"old_count\": 7, \"new_start\": 27, \"new_count\": 6}, {\"old_start\": 39, \"old_count\": 12, \"new_start\": 38, \"new_count\": 29}, {\"old_start\": 57, \"old_count\": 10, \"new_start\": 73, \"new_count\": 15}]}}","file_localization_reward":0.0}
{"example_id":2,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"ascii.qdp Table format assumes QDP commands are upper case\n### Description\n\nascii.qdp assumes that commands in a QDP file are upper case, for example, for errors they must be \"READ SERR 1 2\" whereas QDP itself is not case sensitive and case use \"read serr 1 2\". \r\n\r\nAs many QDP files are created by hand, the expectation that all commands be all-caps should be removed.\n\n### Expected behavior\n\nThe following qdp file should read into a `Table` with errors, rather than crashing.\r\n```\r\nread serr 1 2 \r\n1 0.5 1 0.5\r\n```\n\n### How to Reproduce\n\nCreate a QDP file:\r\n```\r\n> cat > test.qdp\r\nread serr 1 2 \r\n1 0.5 1 0.5\r\n<EOF>\r\n\r\n > python\r\nPython 3.10.9 (main, Dec  7 2022, 02:03:23) [Clang 13.0.0 (clang-1300.0.29.30)] on darwin\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> from astropy.table import Table\r\n>>> Table.read('test.qdp',format='ascii.qdp')\r\nWARNING: table_id not specified. Reading the first available table [astropy.io.ascii.qdp]\r\nTraceback (most recent call last):\r\n...\r\n    raise ValueError(f'Unrecognized QDP line: {line}')\r\nValueError: Unrecognized QDP line: read serr 1 2\r\n```\r\n\r\nRunning \"qdp test.qdp\" works just fine.\r\n\n\n### Versions\n\nPython 3.10.9 (main, Dec  7 2022, 02:03:23) [Clang 13.0.0 (clang-1300.0.29.30)]\r\nastropy 5.1\r\nNumpy 1.24.1\r\npyerfa 2.0.0.1\r\nScipy 1.10.0\r\nMatplotlib 3.6.3\r\n\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-cc822269118a4ed29bb582bfd2315c5d\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg \\\\\\\"ascii.qdp\\\\\\\" -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"astropy\/io\/ascii\/qdp.py:        t = Table.read(example_qdp, format='ascii.qdp', table_id=1, names=['a', 'b', 'c', 'd'])\nastropy\/io\/ascii\/tests\/test_qdp.py:from astropy.io.ascii.qdp import _get_lines_from_file, _read_table_qdp, _write_table_qdp\nastropy\/io\/ascii\/tests\/test_qdp.py:        example_qdp, format=\"ascii.qdp\", table_id=1, names=[\"a\", \"b\", \"c\", \"d\"]\nastropy\/io\/ascii\/tests\/test_qdp.py:        example_qdp, format=\"ascii.qdp\", table_id=1, names=[\"a\", \"b\", \"c\", \"d\"]\nastropy\/io\/ascii\/tests\/test_qdp.py:        example_qdp, format=\"ascii.qdp\", table_id=1, names=[\"a\", \"b\", \"c\", \"d\"], sep=\",\"\nastropy\/io\/ascii\/tests\/test_qdp.py:    t1.write(test_file, format=\"ascii.qdp\")\nastropy\/io\/ascii\/tests\/test_qdp.py:        t2 = Table.read(test_file, format=\"ascii.qdp\")\nastropy\/io\/ascii\/tests\/test_qdp.py:    t1.write(test_file, format=\"ascii.qdp\")\nastropy\/io\/ascii\/tests\/test_qdp.py:    t2 = Table.read(test_file, table_id=0, format=\"ascii.qdp\", names=[\"a\"])","role":"tool","tool_calls":null},{"content":"\n\n<files>\nastropy\/io\/ascii\/qdp.py\nastropy\/io\/ascii\/tests\/test_qdp.py\n<\/files>","role":"assistant","tool_calls":null}],"task":"default","reward":0.6666666667,"generation_ms":37936.5303516388,"scoring_ms":0.1564025879,"total_ms":37936.6867542267,"info":{"instance_id":"astropy__astropy-14365","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/io\/ascii\/qdp.py\": {\"old_start\": 68, \"old_count\": 245, \"new_start\": 68, \"new_count\": 245, \"hunks\": [{\"old_start\": 68, \"old_count\": 7, \"new_start\": 68, \"new_count\": 7}, {\"old_start\": 306, \"old_count\": 7, \"new_start\": 306, \"new_count\": 7}]}}","file_localization_reward":0.6666666667}
{"example_id":3,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"In v5.3, NDDataRef mask propagation fails when one of the operand does not have a mask\n### Description\n\nThis applies to v5.3. \r\n\r\nIt looks like when one of the operand does not have a mask, the mask propagation when doing arithmetic, in particular with `handle_mask=np.bitwise_or` fails.  This is not a problem in v5.2.\r\n\r\nI don't know enough about how all that works, but it seems from the error that the operand without a mask is set as a mask of None's and then the bitwise_or tries to operate on an integer and a None and fails.\n\n### Expected behavior\n\nWhen one of the operand does not have mask, the mask that exists should just be copied over to the output.  Or whatever was done in that situation in v5.2 where there's no problem.\n\n### How to Reproduce\n\nThis is with v5.3.   With v5.2, there are no errors.\r\n\r\n```\r\n>>> import numpy as np\r\n>>> from astropy.nddata import NDDataRef\r\n\r\n>>> array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\r\n>>> mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\r\n\r\n>>> nref_nomask = NDDataRef(array)\r\n>>> nref_mask = NDDataRef(array, mask=mask)\r\n\r\n# multiply no mask by constant (no mask * no mask)\r\n>>> nref_nomask.multiply(1., handle_mask=np.bitwise_or).mask   # returns nothing, no mask,  OK\r\n\r\n# multiply no mask by itself (no mask * no mask)\r\n>>> nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask # return nothing, no mask, OK\r\n\r\n# multiply mask by constant (mask * no mask)\r\n>>> nref_mask.multiply(1., handle_mask=np.bitwise_or).mask\r\n...\r\nTypeError: unsupported operand type(s) for |: 'int' and 'NoneType'\r\n\r\n# multiply mask by itself (mask * mask)\r\n>>> nref_mask.multiply(nref_mask, handle_mask=np.bitwise_or).mask\r\narray([[ 0,  1, 64],\r\n       [ 8,  0,  1],\r\n       [ 2,  1,  0]])\r\n\r\n# multiply mask by no mask (mask * no mask)\r\n>>> nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask\r\n...\r\nTypeError: unsupported operand type(s) for |: 'int' and 'NoneType'\r\n```\r\n\n\n### Versions\n\n>>> import sys; print(\"Python\", sys.version)\r\nPython 3.10.11 | packaged by conda-forge | (main, May 10 2023, 19:07:22) [Clang 14.0.6 ]\r\n>>> import astropy; print(\"astropy\", astropy.__version__)\r\nastropy 5.3\r\n>>> import numpy; print(\"Numpy\", numpy.__version__)\r\nNumpy 1.24.3\r\n>>> import erfa; print(\"pyerfa\", erfa.__version__)\r\npyerfa 2.0.0.3\r\n>>> import scipy; print(\"Scipy\", scipy.__version__)\r\nScipy 1.10.1\r\n>>> import matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\nMatplotlib 3.7.1\r\n\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-fe14ae966ded451a93d4f5e4384d800f\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'NDDataRef' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"astropy\/nddata\/nddata.py:    NDDataRef\nastropy\/nddata\/mixins\/ndslicing.py:    NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:from astropy.nddata import NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:NDDataArithmetic = NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndio.py:from astropy.nddata import NDData, NDDataRef, NDIOMixin  # noqa: F401\nastropy\/nddata\/mixins\/tests\/test_ndio.py:NDDataIO = NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:# TODO: Make this use NDDataRef instead!\nastropy\/nddata\/nddata_withmixins.py:__all__ = [\"NDDataRef\"]\nastropy\/nddata\/nddata_withmixins.py:class NDDataRef(NDArithmeticMixin, NDIOMixin, NDSlicingMixin, NDData):\nastropy\/nddata\/nddata_withmixins.py:        >>> from astropy.nddata import NDDataRef, StdDevUncertainty\nastropy\/nddata\/nddata_withmixins.py:        >>> ndd1 = NDDataRef(data, uncertainty=StdDevUncertainty(data))\nastropy\/nddata\/nddata_withmixins.py:        >>> ndd2 = NDDataRef(data, uncertainty=StdDevUncertainty(data))","role":"tool","tool_calls":null},{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-1efc790d5961424d810f03c113f42ade\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'handle_mask' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"astropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        handle_mask=None,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        handle_mask=use_abbreviation,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        handle_mask=use_abbreviation,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd1.add(nd2, handle_mask=mask_sad_func)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd4 = nd1.add(nd2, handle_mask=mask_sad_func, mask_fun=1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        nd1.add(nd2, handle_mask=mask_sad_func, fun=1)\nastropy\/nddata\/mixins\/ndarithmetic.py:    handle_mask : callable, ``'first_found'`` or ``None``, optional\nastropy\/nddata\/mixins\/ndarithmetic.py:        handle_mask=np.logical_or,\nastropy\/nddata\/mixins\/ndarithmetic.py:        handle_mask : callable, ``'first_found'`` or ``None``, optional\nastropy\/nddata\/mixins\/ndarithmetic.py:        if handle_mask is None:\nastropy\/nddata\/mixins\/ndarithmetic.py:        elif handle_mask in [\"ff\", \"first_found\"]:\nastropy\/nddata\/mixins\/ndarithmetic.py:                operation, operand, handle_mask, axis=axis, **kwds2[\"mask\"]\nastropy\/nddata\/mixins\/ndarithmetic.py:    def _arithmetic_mask(self, operation, operand, handle_mask, axis=None, **kwds):\nastropy\/nddata\/mixins\/ndarithmetic.py:        handle_mask : callable\nastropy\/nddata\/mixins\/ndarithmetic.py:            Additional parameters given to ``handle_mask``.\nastropy\/nddata\/mixins\/ndarithmetic.py:            ``handle_mask`` must create (and copy) the returned mask.\nastropy\/nddata\/mixins\/ndarithmetic.py:        ) or handle_mask is None:\nastropy\/nddata\/mixins\/ndarithmetic.py:            return handle_mask(self.mask, operand.mask, **kwds)\nastropy\/nddata\/mixins\/ndarithmetic.py:            # for collapse operations, use astropy.utils.masked rather than handle_mask","role":"tool","tool_calls":null},{"content":"\n\n<files>\nastropy\/nddata\/nddata.py\nastropy\/nddata\/mixins\/ndarithmetic.py\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py\n<\/files>","role":"assistant","tool_calls":null}],"task":"default","reward":0.5,"generation_ms":63580.872297287,"scoring_ms":0.2224445343,"total_ms":63581.0947418213,"info":{"instance_id":"astropy__astropy-14995","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/nddata\/mixins\/ndarithmetic.py\": {\"old_start\": 520, \"old_count\": 10, \"new_start\": 520, \"new_count\": 10, \"hunks\": [{\"old_start\": 520, \"old_count\": 10, \"new_start\": 520, \"new_count\": 10}]}}","file_localization_reward":0.5}
{"example_id":4,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"Possible bug in io.fits related to D exponents\nI came across the following code in ``fitsrec.py``:\r\n\r\n```python\r\n        # Replace exponent separator in floating point numbers\r\n        if 'D' in format:\r\n            output_field.replace(encode_ascii('E'), encode_ascii('D'))\r\n```\r\n\r\nI think this may be incorrect because as far as I can tell ``replace`` is not an in-place operation for ``chararray`` (it returns a copy). Commenting out this code doesn't cause any tests to fail so I think this code isn't being tested anyway.\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-fd1804b2d67749aab289bc5d40ac6872\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'chararray' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-96c0173e034a45e8b5515ad3f09d604b\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"find . -path '*\/io\/fits\/*' -type f -name '*.py'\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-dd9cb397738b4373bb3e5fa6034f7611\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'D' -t py | grep -v 'fitsrec.py'\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"astropy\/io\/fits\/fitsrec.py:from numpy import char as chararray\nastropy\/io\/fits\/fitsrec.py:                    # Normally the column array is a chararray of 1 character\nastropy\/io\/fits\/fitsrec.py:                elif isinstance(raw_field, chararray.chararray):\nastropy\/io\/fits\/fitsrec.py:    Numeric-style chararray objects.\nastropy\/io\/fits\/fitsrec.py:    # Numpy >= 1.10.dev recarray no longer returns chararrays for strings\nastropy\/io\/fits\/fitsrec.py:            not isinstance(field, chararray.chararray)):\nastropy\/io\/fits\/fitsrec.py:        field = field.view(chararray.chararray)\nastropy\/io\/fits\/column.py:from numpy import char as chararray\nastropy\/io\/fits\/column.py:                          (np.ndarray, chararray.chararray, Delayed)):\nastropy\/io\/fits\/column.py:                    array = chararray.array(array, itemsize=itemsize)\nastropy\/io\/fits\/column.py:                    return chararray.array(array, itemsize=fsize, copy=False)\nastropy\/io\/fits\/column.py:                input = [chararray.array(x, itemsize=1) for x in input]\nastropy\/io\/fits\/column.py:        elif isinstance(value, chararray.chararray) and value.itemsize == 1:\nastropy\/io\/fits\/column.py:            value = chararray.array(value, itemsize=1)\nastropy\/io\/fits\/column.py:            data_output[idx] = chararray.array(encode_ascii(rowval),\nastropy\/io\/fits\/hdu\/table.py:from numpy import char as chararray\nastropy\/io\/fits\/hdu\/table.py:        if isinstance(field, chararray.chararray):\nastropy\/io\/fits\/hdu\/table.py:                if (not isinstance(c, chararray.chararray) and\nastropy\/io\/fits\/tests\/test_table.py:from numpy import char as chararray\nastropy\/io\/fits\/tests\/test_table.py:        a1 = chararray.array(['abc', 'def', 'xx'])\nastropy\/io\/fits\/tests\/test_table.py:        a1 = chararray.array(['abcd', 'def'])\nastropy\/io\/fits\/tests\/test_table.py:                           array=chararray.array(a))\nastropy\/io\/fits\/tests\/test_table.py:            # the single row.  However, this is broken for chararray because\nastropy\/io\/fits\/tests\/test_table.py:            # is a bug in chararray though and not a bug in any FITS-specific","role":"tool","tool_calls":null},{"content":".\/astropy\/io\/fits\/connect.py\n.\/astropy\/io\/fits\/convenience.py\n.\/astropy\/io\/fits\/setup_package.py\n.\/astropy\/io\/fits\/verify.py\n.\/astropy\/io\/fits\/file.py\n.\/astropy\/io\/fits\/tests\/test_groups.py\n.\/astropy\/io\/fits\/tests\/test_compression_failures.py\n.\/astropy\/io\/fits\/tests\/test_division.py\n.\/astropy\/io\/fits\/tests\/test_fitscheck.py\n.\/astropy\/io\/fits\/tests\/test_checksum.py\n.\/astropy\/io\/fits\/tests\/test_nonstandard.py\n.\/astropy\/io\/fits\/tests\/test_util.py\n.\/astropy\/io\/fits\/tests\/test_fitsheader.py\n.\/astropy\/io\/fits\/tests\/test_image.py\n.\/astropy\/io\/fits\/tests\/test_hdulist.py\n.\/astropy\/io\/fits\/tests\/test_table.py\n.\/astropy\/io\/fits\/tests\/test_fitsinfo.py\n.\/astropy\/io\/fits\/tests\/test_header.py\n.\/astropy\/io\/fits\/tests\/test_diff.py\n.\/astropy\/io\/fits\/tests\/test_structured.py\n.\/astropy\/io\/fits\/tests\/test_core.py\n.\/astropy\/io\/fits\/tests\/test_uint.py\n.\/astropy\/io\/fits\/tests\/test_fitsdiff.py\n.\/astropy\/io\/fits\/tests\/test_fitstime.py\n.\/astropy\/io\/fits\/tests\/test_connect.py\n.\/astropy\/io\/fits\/tests\/__init__.py\n.\/astropy\/io\/fits\/tests\/test_convenience.py\n.\/astropy\/io\/fits\/_numpy_hacks.py\n.\/astropy\/io\/fits\/hdu\/compressed.py\n.\/astropy\/io\/fits\/hdu\/image.py\n.\/astropy\/io\/fits\/hdu\/table.py\n.\/astropy\/io\/fits\/hdu\/nonstandard.py\n.\/astropy\/io\/fits\/hdu\/streaming.py\n.\/astropy\/io\/fits\/hdu\/base.py\n.\/astropy\/io\/fits\/hdu\/__init__.py\n.\/astropy\/io\/fits\/hdu\/groups.py\n.\/astropy\/io\/fits\/hdu\/hdulist.py\n.\/astropy\/io\/fits\/diff.py\n.\/astropy\/io\/fits\/column.py\n.\/astropy\/io\/fits\/fitsrec.py\n.\/astropy\/io\/fits\/fitstime.py\n.\/astropy\/io\/fits\/util.py\n.\/astropy\/io\/fits\/card.py\n.\/astropy\/io\/fits\/scripts\/fitsheader.py\n.\/astropy\/io\/fits\/scripts\/fitsdiff.py\n.\/astropy\/io\/fits\/scripts\/fitscheck.py\n.\/astropy\/io\/fits\/scripts\/fitsinfo.py\n.\/astropy\/io\/fits\/scripts\/__init__.py\n.\/astropy\/io\/fits\/header.py\n.\/astropy\/io\/fits\/__init__.py","role":"tool","tool_calls":null},{"content":"setup.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nsetup.py:# Register ASDF extensions\nsetup.py:      author='The Astropy Developers',\nsetup.py:      license='BSD',\nsetup.py:          'License :: OSI Approved :: BSD License',\nah_bootstrap.py:    # This may raise a DistributionNotFound in which case no version of\nah_bootstrap.py:        # this results in DistributionNotFound we want to give up\nah_bootstrap.py:# later cause the TemporaryDirectory class defined in it to stop working when\nah_bootstrap.py:from setuptools import Distribution\nah_bootstrap.py:from distutils.debug import DEBUG\nah_bootstrap.py:# TODO: Maybe enable checking for a specific version of astropy_helpers?\nah_bootstrap.py:DIST_NAME = 'astropy-helpers'\nah_bootstrap.py:# Defaults for other options\nah_bootstrap.py:DOWNLOAD_IF_NEEDED = True\nah_bootstrap.py:INDEX_URL = 'https:\/\/pypi.python.org\/simple'\nah_bootstrap.py:AUTO_UPGRADE = True\nah_bootstrap.py:        self.index_url = index_url if index_url is not None else INDEX_URL\nah_bootstrap.py:                         else DOWNLOAD_IF_NEEDED)\nah_bootstrap.py:                             if auto_upgrade is not None else AUTO_UPGRADE)\nah_bootstrap.py:        # Declared as False by default--later we check if astropy-helpers can be\nah_bootstrap.py:            if DEBUG:\nah_bootstrap.py:        # custom command or even custom Distribution class defines an argument\nah_bootstrap.py:        # directory\/submodule its Distribution object gets a \"precedence\" of\nah_bootstrap.py:        # \"DEVELOP_DIST\".  However, in other cases it gets a precedence of\nah_bootstrap.py:        # \"EGG_DIST\".  However, when activing the distribution it will only be\nah_bootstrap.py:        # placed early on sys.path if it is treated as an EGG_DIST, so always\nah_bootstrap.py:        dist = dist.clone(precedence=pkg_resources.EGG_DIST)\nah_bootstrap.py:            if DEBUG:\nah_bootstrap.py:            log.warn('Downloading {0!r} disabled.'.format(DIST_NAME))\nah_bootstrap.py:            \"Downloading {0!r}; run setup.py with the --offline option to \"\nah_bootstrap.py:            \"force offline installation.\".format(DIST_NAME))\nah_bootstrap.py:            if DEBUG:\nah_bootstrap.py:                '{2}'.format(DIST_NAME, self.index_url, str(e)))\nah_bootstrap.py:        dist = ws.by_key.get(DIST_NAME)\nah_bootstrap.py:        # Distribution (such as options) before handling setup_requires, so it\nah_bootstrap.py:        class _Distribution(Distribution):\nah_bootstrap.py:                opts = Distribution.get_option_dict(self, command_name)\nah_bootstrap.py:            req = '{0}=={1}'.format(DIST_NAME, version)\nah_bootstrap.py:            req = DIST_NAME\nah_bootstrap.py:            if DEBUG:\nah_bootstrap.py:                _Distribution(attrs=attrs)\nah_bootstrap.py:                    _Distribution(attrs=attrs)\nah_bootstrap.py:            return pkg_resources.working_set.by_key.get(DIST_NAME)\nah_bootstrap.py:            if DEBUG:\nah_bootstrap.py:            elif index_url != INDEX_URL:\nah_bootstrap.py:            raise Exception(msg.format(DIST_NAME, source, repr(e)))\nah_bootstrap.py:            '{0}>{1},<{2}'.format(DIST_NAME, dist.version, next_version))\nah_bootstrap.py:        if DEBUG:\nah_bootstrap.py:        # Due to an OSX oddity locale.getdefaultlocale() can also crash\nah_bootstrap.py:class _DummyFile(object):\nah_bootstrap.py:    sys.stdout = _DummyFile()\nah_bootstrap.py:    sys.stderr = _DummyFile()\nah_bootstrap.py:        updates to any git submodule.  Defaults to `True`.\ndocs\/conf.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\ndocs\/conf.py:ON_RTD = os.environ.get('READTHEDOCS') == 'True'\ndocs\/conf.py:# Don't use the default - which includes a numpy and matplotlib import\ndocs\/conf.py:author = u'The Astropy Developers'\ndocs\/conf.py:latex_documents = [('index', project + '.tex', project + u' Documentation',\ndocs\/conf.py:man_pages = [('index', project.lower(), project + u' Documentation',\ndocs\/conf.py:# Don't import the module as \"version\" or it will override the\ndocs\/wcs\/examples\/programmatic.py:w.wcs.ctype = [\"RA---AIR\", \"DEC--AIR\"]\ndocs\/wcs\/examples\/programmatic.py:# PrimaryHDU and write it to a file.\ndocs\/wcs\/examples\/programmatic.py:hdu = fits.PrimaryHDU(header=header)\ndocs\/wcs\/examples\/from_file.py:    # Parse the WCS keywords in the primary HDU\nez_setup.py:This method is DEPRECATED. Check https:\/\/github.com\/pypa\/setuptools\/issues\/581 for more details.\nez_setup.py:DEFAULT_VERSION = \"33.1.1\"\nez_setup.py:DEFAULT_URL = \"https:\/\/pypi.io\/packages\/source\/s\/setuptools\/\"\nez_setup.py:DEFAULT_SAVE_DIR = os.curdir\nez_setup.py:DEFAULT_DEPRECATION_MESSAGE = \"ez_setup.py is deprecated and when using it setuptools will be pinned to {0} since it's the last version that supports setuptools self upgrade\/installation, check https:\/\/github.com\/pypa\/setuptools\/issues\/581 for more info; use pip to install setuptools\"\nez_setup.py:MEANINGFUL_INVALID_ZIP_ERR_MSG = 'Maybe {0} is corrupted, delete it and try again.'\nez_setup.py:log.warn(DEFAULT_DEPRECATION_MESSAGE.format(DEFAULT_VERSION))\nez_setup.py:                MEANINGFUL_INVALID_ZIP_ERR_MSG.format(filename),\nez_setup.py:    \"\"\"Download Setuptools.\"\"\"\nez_setup.py:        version=DEFAULT_VERSION, download_base=DEFAULT_URL,\nez_setup.py:        to_dir=DEFAULT_SAVE_DIR, download_delay=15):\nez_setup.py:    except pkg_resources.DistributionNotFound:\nez_setup.py:    Download the file at url to target using Powershell.\nez_setup.py:        \"[System.Net.WebRequest]::DefaultWebProxy.Credentials = \"\nez_setup.py:        \"[System.Net.CredentialCache]::DefaultCredentials; \"\nez_setup.py:        '(new-object System.Net.WebClient).DownloadFile(\"%(url)s\", \"%(target)s\")'\nez_setup.py:    \"\"\"Determine if Powershell is available.\"\"\"\nez_setup.py:        version=DEFAULT_VERSION, download_base=DEFAULT_URL,\nez_setup.py:        to_dir=DEFAULT_SAVE_DIR, delay=15,\nez_setup.py:    Download setuptools from a specified location and return its filename.\nez_setup.py:        log.warn(\"Downloading %s\", url)\nez_setup.py:        default=DEFAULT_URL,\nez_setup.py:        default=DEFAULT_VERSION,\nez_setup.py:        help=\"Directory to save (and re-use) package\",\nez_setup.py:        default=DEFAULT_SAVE_DIR,\nconftest.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/conftest.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/conftest.py:from astropy.tests.plugins.display import PYTEST_HEADER_MODULES\nastropy\/conftest.py:PYTEST_HEADER_MODULES['Cython'] = 'cython'\nastropy\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/astropyconst13.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/timer.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/timer.py:# STDLIB\nastropy\/utils\/timer.py:from collections import Iterable, OrderedDict\nastropy\/utils\/timer.py:# THIRD-PARTY\nastropy\/utils\/timer.py:    \"\"\"Decorator to time a function or method.\nastropy\/utils\/timer.py:        self._cache_good = OrderedDict()\nastropy\/utils\/timer.py:        self._cache_est = OrderedDict()\nastropy\/utils\/timer.py:        self._cache_out = OrderedDict()\nastropy\/utils\/timer.py:            If `None`, will use `~astropy.modeling.polynomial.Polynomial1D`\nastropy\/utils\/timer.py:        self._cache_est = OrderedDict()\nastropy\/utils\/timer.py:            model = modeling.models.Polynomial1D(1)\nastropy\/utils\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/iau2012.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/iau2012.py:# DISTANCE\nastropy\/constants\/iau2012.py:              \"Derived from au\", system='si')\nastropy\/constants\/iau2012.py:               \"Derived from au\", system='si')\nastropy\/constants\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/__init__.py:    '   Name        Value            Unit       Description',\nastropy\/constants\/si.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nexamples\/io\/plot_fits-image.py:*License: BSD*\nexamples\/io\/plot_fits-image.py:# Download the example FITS files used by this example:\nexamples\/io\/plot_fits-image.py:# Generally the image information is located in the Primary HDU, also known\nexamples\/io\/plot_fits-image.py:# The data is now stored as a 2D numpy array. Print the dimensions using the\nexamples\/io\/plot_fits-image.py:# Display the image data:\nexamples\/io\/create-mef.py:*License: BSD*\nexamples\/io\/create-mef.py:# HDUList objects are used to hold all the HDUs in a FITS file. This\nexamples\/io\/create-mef.py:# ``HDUList`` class is a subclass of Python's builtin `list`. and can be\nexamples\/io\/create-mef.py:new_hdul = fits.HDUList()\nexamples\/io\/create-mef.py:new_hdul.append(fits.ImageHDU())\nexamples\/io\/create-mef.py:new_hdul.append(fits.ImageHDU())\nexamples\/io\/create-mef.py:# Alternatively, the HDU instances can be created first (or read from an\nexamples\/io\/create-mef.py:# default PRIMARY HDU is prepended automatically if one is not specified;\nexamples\/io\/create-mef.py:hdu1 = fits.PrimaryHDU()\nexamples\/io\/create-mef.py:hdu2 = fits.ImageHDU()\nexamples\/io\/create-mef.py:new_hdul = fits.HDUList([hdu1, hdu2])\nexamples\/io\/modify-fits-header.py:*License: BSD*\nexamples\/io\/modify-fits-header.py:# Download a FITS file:\nastropy\/utils\/tests\/test_decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_decorators.py:from ..exceptions import AstropyDeprecationWarning, AstropyUserWarning\nastropy\/utils\/tests\/test_decorators.py:    class DummyClass:\nastropy\/utils\/tests\/test_decorators.py:    dummy = DummyClass()\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    # Creating an instance should work but raise a DeprecationWarning\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    # Creating an instance should work but raise a DeprecationWarning\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:        \"\"\"Docstring\"\"\"\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:        with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyUserWarning, AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyUserWarning, AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyUserWarning, AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/modeling\/parameters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/parameters.py:from ..utils import isiterable, OrderedDescriptor\nastropy\/modeling\/parameters.py:class ParameterDefinitionError(ParameterError):\nastropy\/modeling\/parameters.py:            \"Don't know how to convert parameter of {0} to \"\nastropy\/modeling\/parameters.py:                # Because OrderedDescriptor uses __lt__ to work, we need to\nastropy\/modeling\/parameters.py:class Parameter(OrderedDescriptor):\nastropy\/modeling\/parameters.py:    # Settings for OrderedDescriptor\nastropy\/modeling\/parameters.py:                raise ParameterDefinitionError(\nastropy\/modeling\/parameters.py:        # and ordering ID\nastropy\/modeling\/parameters.py:        # TODO: Rather than using self.value this could be determined from the\nastropy\/modeling\/parameters.py:            >>> from astropy.modeling import Fittable1DModel\nastropy\/modeling\/parameters.py:            >>> class TestModel(Fittable1DModel):\nastropy\/modeling\/parameters.py:            >>> m = TestModel(a=1, b=2)  # doctest: +IGNORE_EXCEPTION_DETAIL\nastropy\/modeling\/parameters.py:            >>> m.a = 0  # doctest: +IGNORE_EXCEPTION_DETAIL\nastropy\/modeling\/parameters.py:            >>> m.a.validator(-42)  # doctest: +IGNORE_EXCEPTION_DETAIL\nastropy\/modeling\/parameters.py:    # TODO: These methods should probably be moved to the Model class, since it\nastropy\/modeling\/parameters.py:            # TODO: Maybe handle exception on invalid input shape\nastropy\/modeling\/parameters.py:                    # Don't make a partial function unless we're tied to a\nastropy\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/__init__.py:    # TODO: Issue a warning using the logging framework\nastropy\/__init__.py:    # TODO: Issue a warning using the logging framework\nastropy\/__init__.py:    except config.configuration.ConfigurationDefaultMissingError as e:\nastropy\/__init__.py:        warn(config.configuration.ConfigurationDefaultMissingWarning(wmsg))\nastropy\/coordinates\/funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/funcs.py:    Converts 3D rectangular cartesian coordinates to spherical polar\nastropy\/coordinates\/funcs.py:    Determines the location of the sun at a given time (or times, if the input\nastropy\/coordinates\/funcs.py:    Determines the constellation(s) a given coordinate object contains.\nastropy\/coordinates\/funcs.py:    to B1875, and then uses the Delporte boundaries of the 88 modern\nastropy\/visualization\/stretch.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/stretch.py:from ..utils.misc import InheritDocstrings\nastropy\/visualization\/stretch.py:           \"PowerDistStretch\", \"SquaredStretch\", \"LogStretch\", \"AsinhStretch\",\nastropy\/visualization\/stretch.py:class BaseStretch(BaseTransform, metaclass=InheritDocstrings):\nastropy\/visualization\/stretch.py:class PowerDistStretch(BaseStretch):\nastropy\/visualization\/stretch.py:        The ``a`` parameter used in the above formula.  Default is 1000.\nastropy\/visualization\/stretch.py:        return InvertedPowerDistStretch(a=self.exp)\nastropy\/visualization\/stretch.py:class InvertedPowerDistStretch(BaseStretch):\nastropy\/visualization\/stretch.py:    `~astropy.image.scaling.PowerDistStretch`.\nastropy\/visualization\/stretch.py:        The ``a`` parameter used in the above formula.  Default is 1000.\nastropy\/visualization\/stretch.py:        return PowerDistStretch(a=self.exp)\nastropy\/visualization\/stretch.py:        The ``a`` parameter used in the above formula.  Default is 1000.\nastropy\/visualization\/stretch.py:        The ``a`` parameter used in the above formula.  Default is 1000.\nastropy\/visualization\/stretch.py:        Default is 0.1\nastropy\/visualization\/stretch.py:        The ``a`` parameter used in the above formula.  Default is 1\/3.\nastropy\/time\/formats.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/formats.py:from collections import OrderedDict\nastropy\/time\/formats.py:__all__ = ['TimeFormat', 'TimeJD', 'TimeMJD', 'TimeFromEpoch', 'TimeUnix',\nastropy\/time\/formats.py:           'TimeCxcSec', 'TimeGPS', 'TimeDecimalYear',\nastropy\/time\/formats.py:           'TimePlotDate', 'TimeUnique', 'TimeDatetime', 'TimeString',\nastropy\/time\/formats.py:           'TimeISO', 'TimeISOT', 'TimeFITS', 'TimeYearDayTime',\nastropy\/time\/formats.py:           'TimeEpochDate', 'TimeBesselianEpoch', 'TimeJulianEpoch',\nastropy\/time\/formats.py:           'TimeDeltaFormat', 'TimeDeltaSec', 'TimeDeltaJD',\nastropy\/time\/formats.py:           'TimeEpochDateString', 'TimeBesselianEpochString',\nastropy\/time\/formats.py:           'TimeJulianEpochString', 'TIME_FORMATS', 'TIME_DELTA_FORMATS',\nastropy\/time\/formats.py:__doctest_skip__ = ['TimePlotDate']\nastropy\/time\/formats.py:# Use an OrderedDict to fix the order in which formats are tried.\nastropy\/time\/formats.py:TIME_FORMATS = OrderedDict()\nastropy\/time\/formats.py:TIME_DELTA_FORMATS = OrderedDict()\nastropy\/time\/formats.py:FITS_DEPRECATED_SCALES = {'TDT': 'tt', 'ET': 'tt',\nastropy\/time\/formats.py:    Metaclass that adds `TimeFormat` and `TimeDeltaFormat` to the\nastropy\/time\/formats.py:    `TIME_FORMATS` and `TIME_DELTA_FORMATS` registries, respectively.\nastropy\/time\/formats.py:            scale = 'utc'  # Default scale as of astropy 0.4\nastropy\/time\/formats.py:class TimeJD(TimeFormat):\nastropy\/time\/formats.py:    Julian Date time format.\nastropy\/time\/formats.py:    For example, 2451544.5 in JD is midnight on January 1, 2000.\nastropy\/time\/formats.py:class TimeMJD(TimeFormat):\nastropy\/time\/formats.py:    Modified Julian Date time format.\nastropy\/time\/formats.py:    For example, 51544.0 in MJD is midnight on January 1, 2000.\nastropy\/time\/formats.py:        # TODO - this routine and vals should be Cythonized to follow the ERFA\nastropy\/time\/formats.py:        jd1 += erfa.DJM0  # erfa.DJM0=2400000.5 (from erfam.h)\nastropy\/time\/formats.py:        return (self.jd1 - erfa.DJM0) + self.jd2\nastropy\/time\/formats.py:class TimeDecimalYear(TimeFormat):\nastropy\/time\/formats.py:        # Form new JDs based on epoch time + time from epoch (converted to JD).\nastropy\/time\/formats.py:    unit = 1.0 \/ erfa.DAYSEC  # in days (1 day == 86400 seconds)\nastropy\/time\/formats.py:    unit = 1.0 \/ erfa.DAYSEC  # in days (1 day == 86400 seconds)\nastropy\/time\/formats.py:    unit = 1.0 \/ erfa.DAYSEC  # in days (1 day == 86400 seconds)\nastropy\/time\/formats.py:class TimePlotDate(TimeFromEpoch):\nastropy\/time\/formats.py:class TimeDatetime(TimeUnique):\nastropy\/time\/formats.py:            Offset from UTC in days. Defaults to zero.\nastropy\/time\/formats.py:            Daylight Savings Time offset in days. Defaults to zero\nastropy\/time\/formats.py:        >>> utc = TimezoneInfo()    # Defaults to UTC\nastropy\/time\/formats.py:        # Datetime components required for conversion to JD by ERFA, along\nastropy\/time\/formats.py:        calendar date and time for the internal JD values.\nastropy\/time\/formats.py:        # TODO: fix this ugly hack\nastropy\/time\/formats.py:    ISO 8601 compliant date-time format \"YYYY-MM-DD HH:MM:SS.sss...\".\nastropy\/time\/formats.py:                # XXX To Do - use strftime for output ??\nastropy\/time\/formats.py:    ISO 8601 compliant date-time format \"YYYY-MM-DDTHH:MM:SS.sss...\".\nastropy\/time\/formats.py:class TimeYearDayTime(TimeISO):\nastropy\/time\/formats.py:    Year, day-of-year and time as \"YYYY:DOY:HH:MM:SS.sss...\".\nastropy\/time\/formats.py:    The day-of-year (DOY) goes from 001 to 365 (366 in leap years).\nastropy\/time\/formats.py:    FITS format: \"[\u00b1Y]YYYY-MM-DD[THH:MM:SS[.sss]][(SCALE[(REALIZATION)])]\".\nastropy\/time\/formats.py:            scale = FITS_DEPRECATED_SCALES.get(fits_scale, fits_scale.lower())\nastropy\/time\/formats.py:class TimeEpochDate(TimeFormat):\nastropy\/time\/formats.py:class TimeBesselianEpoch(TimeEpochDate):\nastropy\/time\/formats.py:class TimeJulianEpoch(TimeEpochDate):\nastropy\/time\/formats.py:    unit = erfa.DJY  # 365.25, the Julian year, for conversion to quantities\nastropy\/time\/formats.py:class TimeEpochDateString(TimeString):\nastropy\/time\/formats.py:class TimeBesselianEpochString(TimeEpochDateString):\nastropy\/time\/formats.py:class TimeJulianEpochString(TimeEpochDateString):\nastropy\/time\/formats.py:class TimeDeltaFormatMeta(TimeFormatMeta):\nastropy\/time\/formats.py:    _registry = TIME_DELTA_FORMATS\nastropy\/time\/formats.py:class TimeDeltaFormat(TimeFormat, metaclass=TimeDeltaFormatMeta):\nastropy\/time\/formats.py:        if scale is not None and scale not in TIME_DELTA_SCALES:\nastropy\/time\/formats.py:                                  .format(scale, TIME_DELTA_SCALES))\nastropy\/time\/formats.py:class TimeDeltaSec(TimeDeltaFormat):\nastropy\/time\/formats.py:    unit = 1. \/ erfa.DAYSEC  # for quantity input\nastropy\/time\/formats.py:class TimeDeltaJD(TimeDeltaFormat):\nastropy\/time\/formats.py:from .core import Time, TIME_SCALES, TIME_DELTA_SCALES, ScaleValueError\nastropy\/samp\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/utils.py:        SAMP client instance. Decorator initialization, accepting the instance\nastropy\/coordinates\/distances.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/distances.py:__all__ = ['Distance']\nastropy\/coordinates\/distances.py:class Distance(u.SpecificTypeQuantity):\nastropy\/coordinates\/distances.py:        cosmologies).  Default: ``False``.\nastropy\/coordinates\/distances.py:    >>> d1 = Distance(10, u.Mpc)\nastropy\/coordinates\/distances.py:    >>> d2 = Distance(40, unit=u.au)\nastropy\/coordinates\/distances.py:    >>> d3 = Distance(value=5, unit=u.kpc)\nastropy\/coordinates\/distances.py:    >>> d4 = Distance(z=0.23)\nastropy\/coordinates\/distances.py:    >>> d5 = Distance(z=0.23, cosmology=WMAP5)\nastropy\/coordinates\/distances.py:    >>> d6 = Distance(distmod=24.47)\nastropy\/coordinates\/distances.py:    >>> d7 = Distance(Distance(10 * u.Mpc))\nastropy\/coordinates\/distances.py:    >>> d8 = Distance(parallax=21.34*u.mas)\nastropy\/coordinates\/distances.py:                                 'or `distmod` in Distance constructor.')\nastropy\/coordinates\/distances.py:                                 'provided in Distance constructor')\nastropy\/coordinates\/distances.py:                         '`parallax` in Distance constructor.')\nastropy\/coordinates\/distances.py:                                 '`parallax` were given to Distance '\nastropy\/coordinates\/distances.py:            raise ValueError(\"Distance must be >= 0.  Use the argument \"\nastropy\/coordinates\/orbital_elements.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/orbital_elements.py:#   D   M   M'  F   l    r\nastropy\/coordinates\/orbital_elements.py:#   D   M   M'  F   b\nastropy\/coordinates\/orbital_elements.py:D : Mean elongation of the Moon\nastropy\/coordinates\/orbital_elements.py:_coD = (2.97850192e+02, 4.45267111e+05, -1.88190000e-03,\nastropy\/coordinates\/orbital_elements.py:    # This should strictly speaking be in Ephemeris Time, but TDB or TT\nastropy\/coordinates\/orbital_elements.py:    D = u.Quantity(polyval(T, _coD), u.deg)\nastropy\/coordinates\/orbital_elements.py:    for DNum, MNum, McNum, FNum, LFac, RFac in _MOON_L_R:\nastropy\/coordinates\/orbital_elements.py:        suml += LFac*corr*np.sin(D*DNum+M*MNum+Mc*McNum+F*FNum)\nastropy\/coordinates\/orbital_elements.py:        sumr += RFac*corr*np.cos(D*DNum+M*MNum+Mc*McNum+F*FNum)\nastropy\/coordinates\/orbital_elements.py:    for DNum, MNum, McNum, FNum, BFac in _MOON_B:\nastropy\/coordinates\/orbital_elements.py:        sumb += BFac*corr*np.sin(D*DNum+M*MNum+Mc*McNum+F*FNum)\nastropy\/samp\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:from ..transformations import FunctionTransformWithFiniteDifference\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, GCRS, CIRS)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, CIRS, GCRS)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, CIRS, ITRS)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, CIRS)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, ITRS)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:# TODO: implement GCRS<->CIRS if there's call for it.  The thing that's awkward\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, GCRS, PrecessedGeocentric)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, PrecessedGeocentric, GCRS)\nastropy\/coordinates\/representation.py:from collections import OrderedDict\nastropy\/coordinates\/representation.py:from .distances import Distance\nastropy\/coordinates\/representation.py:from ..utils import ShapedLikeNDArray, classproperty\nastropy\/coordinates\/representation.py:from ..utils.misc import InheritDocstrings\nastropy\/coordinates\/representation.py:__all__ = [\"BaseRepresentationOrDifferential\", \"BaseRepresentation\",\nastropy\/coordinates\/representation.py:           \"BaseDifferential\", \"CartesianDifferential\",\nastropy\/coordinates\/representation.py:           \"BaseSphericalDifferential\", \"BaseSphericalCosLatDifferential\",\nastropy\/coordinates\/representation.py:           \"SphericalDifferential\", \"SphericalCosLatDifferential\",\nastropy\/coordinates\/representation.py:           \"UnitSphericalDifferential\", \"UnitSphericalCosLatDifferential\",\nastropy\/coordinates\/representation.py:           \"RadialDifferential\", \"CylindricalDifferential\",\nastropy\/coordinates\/representation.py:           \"PhysicsSphericalDifferential\"]\nastropy\/coordinates\/representation.py:DIFFERENTIAL_CLASSES = {}\nastropy\/coordinates\/representation.py:class BaseRepresentationOrDifferential(ShapedLikeNDArray):\nastropy\/coordinates\/representation.py:    \"\"\"3D coordinate representations and differentials.\nastropy\/coordinates\/representation.py:        The components of the 3D point or differential.  The names are the\nastropy\/coordinates\/representation.py:        `~astropy.coordinates.SphericalDifferential`.)\nastropy\/coordinates\/representation.py:        are all defined in `~astropy.utils.misc.ShapedLikeNDArray`. It will be\nastropy\/coordinates\/representation.py:# be combined with a ShapedLikeNDArray subclass (which is an ABC).  Without it:\nastropy\/coordinates\/representation.py:class MetaBaseRepresentation(InheritDocstrings, abc.ABCMeta):\nastropy\/coordinates\/representation.py:class BaseRepresentation(BaseRepresentationOrDifferential,\nastropy\/coordinates\/representation.py:    \"\"\"Base for representing a point in a 3D coordinate system.\nastropy\/coordinates\/representation.py:        The components of the 3D points.  The names are the keys and the\nastropy\/coordinates\/representation.py:    differentials : dict, `BaseDifferential`, optional\nastropy\/coordinates\/representation.py:        representation. The input must either be a single `BaseDifferential`\nastropy\/coordinates\/representation.py:    and define an ``attr_classes`` attribute, an `~collections.OrderedDict`\nastropy\/coordinates\/representation.py:        elif isinstance(differentials, BaseDifferential):\nastropy\/coordinates\/representation.py:            if (isinstance(differentials, RadialDifferential) and\nastropy\/coordinates\/representation.py:                raise ValueError(\"To attach a RadialDifferential to a \"\nastropy\/coordinates\/representation.py:            if (isinstance(diff, RadialDifferential) and\nastropy\/coordinates\/representation.py:                # We trust the passing of a key for a RadialDifferential\nastropy\/coordinates\/representation.py:                # TODO: message of IncompatibleShapeError is not customizable,\nastropy\/coordinates\/representation.py:        return [DIFFERENTIAL_CLASSES[self.get_name()]]\nastropy\/coordinates\/representation.py:    # they are only necessary if one also defines an associated Differential.\nastropy\/coordinates\/representation.py:                issubclass(differential_class, BaseDifferential)):\nastropy\/coordinates\/representation.py:            # TODO: is there a better way to do this?\nastropy\/coordinates\/representation.py:            ValueError(\"Desired differential classes must be passed in \"\nastropy\/coordinates\/representation.py:                    raise TypeError(\"Desired differential class {0} is not \"\nastropy\/coordinates\/representation.py:        differential_class : dict of `~astropy.coordinates.BaseDifferential`, optional\nastropy\/coordinates\/representation.py:        Differential keys that already exist in this object's differential dict\nastropy\/coordinates\/representation.py:        differentials : Sequence of `~astropy.coordinates.BaseDifferential`\nastropy\/coordinates\/representation.py:        This is not a simple inherit from ``BaseRepresentationOrDifferential``\nastropy\/coordinates\/representation.py:        See docstring for `BaseRepresentationOrDifferential._apply`.\nastropy\/coordinates\/representation.py:    @BaseRepresentationOrDifferential.shape.setter\nastropy\/coordinates\/representation.py:        BaseRepresentationOrDifferential.shape.fset(self, shape)\nastropy\/coordinates\/representation.py:            BaseRepresentationOrDifferential.shape.fset(self, orig_shape)\nastropy\/coordinates\/representation.py:        \"\"\"Dot product of two representations.\nastropy\/coordinates\/representation.py:    Representation of points in 3D cartesian coordinates.\nastropy\/coordinates\/representation.py:    differentials : dict, `CartesianDifferential`, optional\nastropy\/coordinates\/representation.py:        `CartesianDifferential` instance, or a dictionary of\nastropy\/coordinates\/representation.py:        `CartesianDifferential` s with keys set to a string representation of\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('x', u.Quantity),\nastropy\/coordinates\/representation.py:        return OrderedDict(\nastropy\/coordinates\/representation.py:        return OrderedDict((('x', l), ('y', l), ('z', l)))\nastropy\/coordinates\/representation.py:        # TODO: since this is likely to be a widely used function in coordinate\nastropy\/coordinates\/representation.py:            # TODO: speed this up going via d.d_xyz.\nastropy\/coordinates\/representation.py:        \"\"\"Dot product of two representations.\nastropy\/coordinates\/representation.py:    differentials : dict, `BaseDifferential`, optional\nastropy\/coordinates\/representation.py:        representation. The input must either be a single `BaseDifferential`\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('lon', Longitude),\nastropy\/coordinates\/representation.py:        return [UnitSphericalDifferential, UnitSphericalCosLatDifferential,\nastropy\/coordinates\/representation.py:                SphericalDifferential, SphericalCosLatDifferential,\nastropy\/coordinates\/representation.py:                RadialDifferential]\nastropy\/coordinates\/representation.py:        return OrderedDict(\nastropy\/coordinates\/representation.py:        return OrderedDict((('lon', sf_lon),\nastropy\/coordinates\/representation.py:        Converts spherical polar coordinates to 3D rectangular cartesian\nastropy\/coordinates\/representation.py:        Converts 3D rectangular cartesian coordinates to spherical polar\nastropy\/coordinates\/representation.py:        # TODO: this could be optimized to shortcut even if a differential_class\nastropy\/coordinates\/representation.py:            Dimensionless ones, with the same shape as the representation.\nastropy\/coordinates\/representation.py:    differentials : dict, `BaseDifferential`, optional\nastropy\/coordinates\/representation.py:        representation. The input must either be a single `BaseDifferential`\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('distance', u.Quantity)])\nastropy\/coordinates\/representation.py:        return OrderedDict((('distance', l),))\nastropy\/coordinates\/representation.py:        Converts 3D rectangular cartesian coordinates to radial coordinate.\nastropy\/coordinates\/representation.py:            Dimensionless ones, with the same shape as the representation.\nastropy\/coordinates\/representation.py:    Representation of points in 3D spherical coordinates.\nastropy\/coordinates\/representation.py:        passed to the :class:`~astropy.coordinates.Distance` class, otherwise\nastropy\/coordinates\/representation.py:    differentials : dict, `BaseDifferential`, optional\nastropy\/coordinates\/representation.py:        representation. The input must either be a single `BaseDifferential`\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('lon', Longitude),\nastropy\/coordinates\/representation.py:            self._distance = self._distance.view(Distance)\nastropy\/coordinates\/representation.py:        return [UnitSphericalDifferential, UnitSphericalCosLatDifferential,\nastropy\/coordinates\/representation.py:                SphericalDifferential, SphericalCosLatDifferential,\nastropy\/coordinates\/representation.py:                RadialDifferential]\nastropy\/coordinates\/representation.py:        return OrderedDict(\nastropy\/coordinates\/representation.py:        return OrderedDict((('lon', sf_lon),\nastropy\/coordinates\/representation.py:        # TODO: this could be optimized to shortcut even if a differential_class\nastropy\/coordinates\/representation.py:        Converts spherical polar coordinates to 3D rectangular cartesian\nastropy\/coordinates\/representation.py:        # We need to convert Distance to Quantity to allow negative values.\nastropy\/coordinates\/representation.py:        if isinstance(self.distance, Distance):\nastropy\/coordinates\/representation.py:        Converts 3D rectangular cartesian coordinates to spherical polar\nastropy\/coordinates\/representation.py:    Representation of points in 3D spherical coordinates (using the physics\nastropy\/coordinates\/representation.py:        passed to the :class:`~astropy.coordinates.Distance` class, otherwise\nastropy\/coordinates\/representation.py:    differentials : dict, `PhysicsSphericalDifferential`, optional\nastropy\/coordinates\/representation.py:        `PhysicsSphericalDifferential` instance, or a dictionary of of\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('phi', Angle),\nastropy\/coordinates\/representation.py:            self._r = self._r.view(Distance)\nastropy\/coordinates\/representation.py:        return OrderedDict(\nastropy\/coordinates\/representation.py:        return OrderedDict((('phi', r * sintheta),\nastropy\/coordinates\/representation.py:        # TODO: this could be optimized to shortcut even if a differential_class\nastropy\/coordinates\/representation.py:        Converts spherical polar coordinates to 3D rectangular cartesian\nastropy\/coordinates\/representation.py:        # We need to convert Distance to Quantity to allow negative values.\nastropy\/coordinates\/representation.py:        if isinstance(self.r, Distance):\nastropy\/coordinates\/representation.py:        Converts 3D rectangular cartesian coordinates to spherical polar\nastropy\/coordinates\/representation.py:    Representation of points in 3D cylindrical coordinates.\nastropy\/coordinates\/representation.py:    differentials : dict, `CylindricalDifferential`, optional\nastropy\/coordinates\/representation.py:        `CylindricalDifferential` instance, or a dictionary of of differential\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('rho', u.Quantity),\nastropy\/coordinates\/representation.py:        return OrderedDict(\nastropy\/coordinates\/representation.py:        return OrderedDict((('rho', l),\nastropy\/coordinates\/representation.py:        Converts 3D rectangular cartesian coordinates to cylindrical polar\nastropy\/coordinates\/representation.py:        Converts cylindrical polar coordinates to 3D rectangular cartesian\nastropy\/coordinates\/representation.py:class MetaBaseDifferential(InheritDocstrings, abc.ABCMeta):\nastropy\/coordinates\/representation.py:    \"\"\"Set default ``attr_classes`` and component getters on a Differential.\nastropy\/coordinates\/representation.py:        # Don't do anything for base helper classes.\nastropy\/coordinates\/representation.py:        if cls.__name__ in ('BaseDifferential', 'BaseSphericalDifferential',\nastropy\/coordinates\/representation.py:                            'BaseSphericalCosLatDifferential'):\nastropy\/coordinates\/representation.py:            raise NotImplementedError('Differential representations must have a'\nastropy\/coordinates\/representation.py:            cls.attr_classes = OrderedDict([('d_' + c, u.Quantity)\nastropy\/coordinates\/representation.py:        if repr_name in DIFFERENTIAL_CLASSES:\nastropy\/coordinates\/representation.py:            raise ValueError(\"Differential class {0} already defined\"\nastropy\/coordinates\/representation.py:        DIFFERENTIAL_CLASSES[repr_name] = cls\nastropy\/coordinates\/representation.py:                                 doc=(\"Component '{0}' of the Differential.\"\nastropy\/coordinates\/representation.py:class BaseDifferential(BaseRepresentationOrDifferential,\nastropy\/coordinates\/representation.py:                       metaclass=MetaBaseDifferential):\nastropy\/coordinates\/representation.py:        The components of the 3D differentials.  The names are the keys and the\nastropy\/coordinates\/representation.py:            raise TypeError(\"Differential class {0} is not compatible with the \"\nastropy\/coordinates\/representation.py:        \"\"\"Convert the differential to 3D rectangular cartesian coordinates.\nastropy\/coordinates\/representation.py:        This object as a `CartesianDifferential`\nastropy\/coordinates\/representation.py:        \"\"\"Convert the differential from 3D rectangular cartesian coordinates to\nastropy\/coordinates\/representation.py:        if issubclass(other_class, BaseDifferential):\nastropy\/coordinates\/representation.py:        if isinstance(representation, BaseDifferential):\nastropy\/coordinates\/representation.py:class CartesianDifferential(BaseDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differentials in of points in 3D cartesian coordinates.\nastropy\/coordinates\/representation.py:class BaseSphericalDifferential(BaseDifferential):\nastropy\/coordinates\/representation.py:        a `~astropy.coordinates.SphericalDifferential` (e.g., a\nastropy\/coordinates\/representation.py:        `~astropy.coordinates.UnitSphericalDifferential` and a\nastropy\/coordinates\/representation.py:        `~astropy.coordinates.RadialDifferential`), they will combined\nastropy\/coordinates\/representation.py:        if (isinstance(other, BaseSphericalDifferential) and\nastropy\/coordinates\/representation.py:                isinstance(other, RadialDifferential)):\nastropy\/coordinates\/representation.py:            return SphericalDifferential(**result_args)\nastropy\/coordinates\/representation.py:class UnitSphericalDifferential(BaseSphericalDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differential(s) of points on a unit sphere.\nastropy\/coordinates\/representation.py:        return SphericalDifferential\nastropy\/coordinates\/representation.py:        if issubclass(other_class, UnitSphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        if isinstance(representation, SphericalDifferential):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, (SphericalCosLatDifferential,\nastropy\/coordinates\/representation.py:                                         UnitSphericalCosLatDifferential)):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, PhysicsSphericalDifferential):\nastropy\/coordinates\/representation.py:class SphericalDifferential(BaseSphericalDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differential(s) of points in 3D spherical coordinates.\nastropy\/coordinates\/representation.py:    _unit_differential = UnitSphericalDifferential\nastropy\/coordinates\/representation.py:        if issubclass(other_class, UnitSphericalDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, RadialDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, SphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, UnitSphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, PhysicsSphericalDifferential):\nastropy\/coordinates\/representation.py:        if isinstance(representation, SphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, PhysicsSphericalDifferential):\nastropy\/coordinates\/representation.py:class BaseSphericalCosLatDifferential(BaseDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differtials from points on a spherical base representation.\nastropy\/coordinates\/representation.py:        a `~astropy.coordinates.SphericalDifferential` (e.g., a\nastropy\/coordinates\/representation.py:        `~astropy.coordinates.UnitSphericalDifferential` and a\nastropy\/coordinates\/representation.py:        `~astropy.coordinates.RadialDifferential`), they will combined\nastropy\/coordinates\/representation.py:        if (isinstance(other, BaseSphericalCosLatDifferential) and\nastropy\/coordinates\/representation.py:                isinstance(other, RadialDifferential)):\nastropy\/coordinates\/representation.py:            return SphericalCosLatDifferential(**result_args)\nastropy\/coordinates\/representation.py:class UnitSphericalCosLatDifferential(BaseSphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differential(s) of points on a unit sphere.\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('d_lon_coslat', u.Quantity),\nastropy\/coordinates\/representation.py:        return SphericalCosLatDifferential\nastropy\/coordinates\/representation.py:        if issubclass(other_class, UnitSphericalDifferential):\nastropy\/coordinates\/representation.py:        if isinstance(representation, SphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, (SphericalDifferential,\nastropy\/coordinates\/representation.py:                                         UnitSphericalDifferential)):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, PhysicsSphericalDifferential):\nastropy\/coordinates\/representation.py:class SphericalCosLatDifferential(BaseSphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differential(s) of points in 3D spherical coordinates.\nastropy\/coordinates\/representation.py:    _unit_differential = UnitSphericalCosLatDifferential\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('d_lon_coslat', u.Quantity),\nastropy\/coordinates\/representation.py:        if issubclass(other_class, UnitSphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, RadialDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, SphericalDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, UnitSphericalDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, PhysicsSphericalDifferential):\nastropy\/coordinates\/representation.py:        if isinstance(representation, SphericalDifferential):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, PhysicsSphericalDifferential):\nastropy\/coordinates\/representation.py:class RadialDifferential(BaseDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differential(s) of radial distances.\nastropy\/coordinates\/representation.py:        if isinstance(representation, (SphericalDifferential,\nastropy\/coordinates\/representation.py:                                       SphericalCosLatDifferential)):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, PhysicsSphericalDifferential):\nastropy\/coordinates\/representation.py:        elif isinstance(other, (BaseSphericalDifferential,\nastropy\/coordinates\/representation.py:                                BaseSphericalCosLatDifferential)):\nastropy\/coordinates\/representation.py:            return SphericalDifferential(**result_args)\nastropy\/coordinates\/representation.py:class PhysicsSphericalDifferential(BaseDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differential(s) of 3D spherical coordinates using physics convention.\nastropy\/coordinates\/representation.py:        # do the equivalent of self._d_lon_coslat in SphericalDifferential.\nastropy\/coordinates\/representation.py:        if issubclass(other_class, SphericalDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, UnitSphericalDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, SphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, UnitSphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, RadialDifferential):\nastropy\/coordinates\/representation.py:        # do the equivalent of cls._d_lon in SphericalDifferential.\nastropy\/coordinates\/representation.py:        if isinstance(representation, SphericalDifferential):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, SphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:class CylindricalDifferential(BaseDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differential(s) of points in cylindrical coordinates.\nastropy\/coordinates\/builtin_frames\/hcrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/hcrs.py:from .utils import DEFAULT_OBSTIME\nastropy\/coordinates\/builtin_frames\/hcrs.py:from .baseradec import _base_radec_docstring, BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/hcrs.py:class HCRS(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/hcrs.py:    obstime = TimeAttribute(default=DEFAULT_OBSTIME)\nastropy\/samp\/hub.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/hub.py:__all__ = ['SAMPHubServer', 'WebProfileDialog']\nastropy\/samp\/hub.py:        Defines the Hub running mode. If ``mode`` is ``'single'`` then the Hub\nastropy\/samp\/hub.py:        ``.samp-1`` directory, of the form ``samp-hub-<UUID>``, where\nastropy\/samp\/hub.py:        ``<UUID>`` is a unique UUID assigned to the hub.\nastropy\/samp\/hub.py:        # Generate random ID for the hub\nastropy\/samp\/hub.py:        The unique hub ID.\nastropy\/samp\/hub.py:            # TODO: Some sort of duck-typing on the web_profile_dialog object\nastropy\/samp\/hub.py:        # TODO: What happens if not all threads are stopped after timeout?\nastropy\/samp\/hub.py:            # Dictionary stored with the public id\nastropy\/samp\/hub.py:                raise SAMPProxyError(6, \"Invalid client ID\")\nastropy\/samp\/hub.py:                raise SAMPProxyError(6, \"Invalid client ID\")\nastropy\/samp\/hub.py:            raise SAMPHubError(\"Invalid client ID\")\nastropy\/samp\/hub.py:class WebProfileDialog:\nastropy\/coordinates\/builtin_frames\/baseradec.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/baseradec.py:__all__ = ['BaseRADecFrame']\nastropy\/coordinates\/builtin_frames\/baseradec.py:        The Declination for this object (``ra`` must also be given and\nastropy\/coordinates\/builtin_frames\/baseradec.py:        The Distance for this object along the line-of-sight.\nastropy\/coordinates\/builtin_frames\/baseradec.py:        The proper motion in Declination for this object (``pm_ra_cosdec`` must\nastropy\/coordinates\/builtin_frames\/baseradec.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/builtin_frames\/baseradec.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/builtin_frames\/baseradec.py:class BaseRADecFrame(BaseCoordinateFrame):\nastropy\/coordinates\/builtin_frames\/baseradec.py:    represent longitude and latitude as Right Ascension and Declination\nastropy\/coordinates\/builtin_frames\/baseradec.py:        r.SphericalCosLatDifferential: [\nastropy\/coordinates\/builtin_frames\/baseradec.py:        r.SphericalDifferential: [\nastropy\/coordinates\/builtin_frames\/baseradec.py:        r.CartesianDifferential: [\nastropy\/coordinates\/builtin_frames\/baseradec.py:    frame_specific_representation_info[r.UnitSphericalCosLatDifferential] = \\\nastropy\/coordinates\/builtin_frames\/baseradec.py:        frame_specific_representation_info[r.SphericalCosLatDifferential]\nastropy\/coordinates\/builtin_frames\/baseradec.py:    frame_specific_representation_info[r.UnitSphericalDifferential] = \\\nastropy\/coordinates\/builtin_frames\/baseradec.py:        frame_specific_representation_info[r.SphericalDifferential]\nastropy\/coordinates\/builtin_frames\/baseradec.py:    default_differential = r.SphericalCosLatDifferential\nastropy\/coordinates\/builtin_frames\/baseradec.py:BaseRADecFrame.__doc__ = BaseRADecFrame.__doc__.format(\nastropy\/coordinates\/baseframe.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/baseframe.py:from collections import namedtuple, OrderedDict, defaultdict\nastropy\/coordinates\/baseframe.py:# Dependencies\nastropy\/coordinates\/baseframe.py:from ..utils import (OrderedDescriptorContainer, ShapedLikeNDArray,\nastropy\/coordinates\/baseframe.py:    **differentials : dict of str or `~astropy.coordinates.BaseDifferentials`\nastropy\/coordinates\/baseframe.py:            differential_cls = r.DIFFERENTIAL_CLASSES.get(base.get_name(), None)\nastropy\/coordinates\/baseframe.py:        elif differential_cls in r.DIFFERENTIAL_CLASSES:\nastropy\/coordinates\/baseframe.py:            differential_cls = r.DIFFERENTIAL_CLASSES[differential_cls]\nastropy\/coordinates\/baseframe.py:               not issubclass(differential_cls, r.BaseDifferential))):\nastropy\/coordinates\/baseframe.py:                'Differential is {0!r} but must be a BaseDifferential class '\nastropy\/coordinates\/baseframe.py:                    differential_cls, list(r.DIFFERENTIAL_CLASSES)))\nastropy\/coordinates\/baseframe.py:# with ShapedLikeNDArray below (which is an ABC); without it, one gets\nastropy\/coordinates\/baseframe.py:class FrameMeta(OrderedDescriptorContainer, abc.ABCMeta):\nastropy\/coordinates\/baseframe.py:        # https:\/\/mail.python.org\/pipermail\/python-list\/2002-December\/167861.html\nastropy\/coordinates\/baseframe.py:class BaseCoordinateFrame(ShapedLikeNDArray, metaclass=FrameMeta):\nastropy\/coordinates\/baseframe.py:        A subclass of `~astropy.coordinates.BaseDifferential` that will be\nastropy\/coordinates\/baseframe.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/baseframe.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/baseframe.py:    frame_attributes = OrderedDict()\nastropy\/coordinates\/baseframe.py:    # Default empty frame_attributes dict\nastropy\/coordinates\/baseframe.py:        # TODO: we should be able to deal with an instance, not just a\nastropy\/coordinates\/baseframe.py:                    issubclass(differential_cls, r.BaseDifferential)):\nastropy\/coordinates\/baseframe.py:                # TODO: assumes the differential class is for the velocity\nastropy\/coordinates\/baseframe.py:            # TODO: possibly generalize this somehow?\nastropy\/coordinates\/baseframe.py:            # Now we handle the Differential data:\nastropy\/coordinates\/baseframe.py:                    differential_cls = r.RadialDifferential\nastropy\/coordinates\/baseframe.py:                # TODO: assumes a velocity unit differential\nastropy\/coordinates\/baseframe.py:    # We have to override the ShapedLikeNDArray definitions, since our shape\nastropy\/coordinates\/baseframe.py:        return OrderedDict((name, getattr(cls, name))\nastropy\/coordinates\/baseframe.py:        representation : `~astropy.coordinates.BaseRepresentation` or `~astropy.coordinates.BaseDifferential`.\nastropy\/coordinates\/baseframe.py:        s : `~astropy.coordinates.BaseDifferential` subclass, optional\nastropy\/coordinates\/baseframe.py:                              list(r.DIFFERENTIAL_CLASSES.values())):\nastropy\/coordinates\/baseframe.py:                # TODO: this provides a layer of backwards compatibility in\nastropy\/coordinates\/baseframe.py:        out = OrderedDict()\nastropy\/coordinates\/baseframe.py:        out = OrderedDict()\nastropy\/coordinates\/baseframe.py:        # TODO: should we expose this, so one has a choice?\nastropy\/coordinates\/baseframe.py:        s : subclass of `~astropy.coordinates.BaseDifferential`, str, optional\nastropy\/coordinates\/baseframe.py:                # TODO NOTE: only supports a single differential\nastropy\/coordinates\/baseframe.py:                diff = data.differentials['s']  # TODO: assumes velocity\nastropy\/coordinates\/baseframe.py:                        # input data has a UnitSphericalDifferential or a\nastropy\/coordinates\/baseframe.py:                        # RadialDifferential. It is re-represented to the\nastropy\/coordinates\/baseframe.py:                        # dimensional Differential), so we don't want to try to\nastropy\/coordinates\/baseframe.py:                                       (r.UnitSphericalDifferential,\nastropy\/coordinates\/baseframe.py:                                        r.UnitSphericalCosLatDifferential)) and\nastropy\/coordinates\/baseframe.py:                        elif (isinstance(data_diff, r.RadialDifferential) and\nastropy\/coordinates\/baseframe.py:                    # the input differential is a RadialDifferential, it usually\nastropy\/coordinates\/baseframe.py:                    # gets turned into a SphericalCosLatDifferential (or\nastropy\/coordinates\/baseframe.py:        Determines if this coordinate frame can be transformed to another\nastropy\/coordinates\/baseframe.py:        Determine whether or not a frame attribute has its value because it's\nastropy\/coordinates\/baseframe.py:                if isinstance(dif_data, (r.UnitSphericalDifferential,\nastropy\/coordinates\/baseframe.py:                                         r.UnitSphericalCosLatDifferential,\nastropy\/coordinates\/baseframe.py:                                         r.RadialDifferential)):\nastropy\/coordinates\/baseframe.py:            data_repr = 'Data:\\n' + data_repr\nastropy\/coordinates\/baseframe.py:        are all defined in `~astropy.utils.misc.ShapedLikeNDArray`. It will be\nastropy\/coordinates\/baseframe.py:        # TODO: expose this trickery in docstring?\nastropy\/coordinates\/baseframe.py:            if isinstance(value, ShapedLikeNDArray):\nastropy\/coordinates\/baseframe.py:        # TODO: change to representation_cls in __init__ - gh-6219.\nastropy\/coordinates\/baseframe.py:        TODO: dynamic representation transforms (i.e. include cylindrical et al.).\nastropy\/coordinates\/baseframe.py:        TODO: We should handle dynamic representation transforms here (e.g.,\nastropy\/coordinates\/baseframe.py:            # TODO: this doesn't work for the case when there is only\nastropy\/coordinates\/baseframe.py:        sep : `~astropy.coordinates.Distance`\nastropy\/coordinates\/baseframe.py:        from .distances import Distance\nastropy\/coordinates\/baseframe.py:        return Distance((self_car - other_car).norm())\nastropy\/coordinates\/baseframe.py:        # TODO: if representations are updated to use a full transform graph,\nastropy\/coordinates\/baseframe.py:        # TODO: if representations are updated to use a full transform graph,\nastropy\/coordinates\/baseframe.py:        `SphericalCosLatDifferential` for the velocity data in this object.\nastropy\/coordinates\/baseframe.py:        # TODO: if representations are updated to use a full transform graph,\nastropy\/coordinates\/baseframe.py:        `CartesianDifferential` object. This is equivalent to calling\nastropy\/coordinates\/baseframe.py:            raise ValueError('Frame has no associated velocity (Differential) '\nastropy\/coordinates\/baseframe.py:            raise ValueError('Frame has no associated velocity (Differential) '\nastropy\/coordinates\/baseframe.py:            raise ValueError('Frame has no associated velocity (Differential) '\nastropy\/coordinates\/baseframe.py:        self.frame_attributes = OrderedDict()\nastropy\/coordinates\/matching.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/matching.py:        If a string, will store the KD-Tree used for the computation\nastropy\/coordinates\/matching.py:        same catalog. If False, the KD-Tree is discarded after use.\nastropy\/coordinates\/matching.py:        The 3D distance between the closest match for each ``matchcoord`` and\nastropy\/coordinates\/matching.py:    if nthneighbor > 1:  # query gives 1D arrays if k=1, 2D arrays otherwise\nastropy\/coordinates\/matching.py:        If a string, will store the KD-Tree used for the computation\nastropy\/coordinates\/matching.py:        same catalog. If False, the KD-Tree is discarded after use.\nastropy\/coordinates\/matching.py:        The 3D distance between the closest match for each ``matchcoord`` and\nastropy\/coordinates\/matching.py:        ``matchcoord`` or ``catalogcoord`` don't have a distance, this is the 3D\nastropy\/coordinates\/matching.py:    # Check for a stored KD-tree on the passed-in coordinate. Normally it will\nastropy\/coordinates\/matching.py:    # have a distinct name from the \"3D\" one, so it's safe to use even though\nastropy\/coordinates\/matching.py:    distance in 3D space.\nastropy\/coordinates\/matching.py:        If a string, will store the KD-Tree used in the search with the name\nastropy\/coordinates\/matching.py:        to this function. If False, the KD-Trees are not saved.\nastropy\/coordinates\/matching.py:        The 3D distance between the coordinates. Shape matches ``idx1`` and\nastropy\/coordinates\/matching.py:    # so that if the conversion does happen, the KD tree of coord2 at least gets\nastropy\/coordinates\/matching.py:    # this is the *cartesian* 3D distance that corresponds to the given angle\nastropy\/coordinates\/matching.py:        If a string, will store the KD-Tree used in the search with the name\nastropy\/coordinates\/matching.py:        to this function. If False, the KD-Trees are not saved.\nastropy\/coordinates\/matching.py:        The 3D distance between the coordinates. Shape matches ``idx1``\nastropy\/coordinates\/matching.py:        this is the 3D distance on the unit sphere, rather than a\nastropy\/coordinates\/matching.py:    # so that if the conversion does happen, the KD tree of coord2 at least gets\nastropy\/coordinates\/matching.py:        # just use the stored KD-Tree\nastropy\/coordinates\/matching.py:            # save the KD-Tree in coords2, *not* ucoords2\nastropy\/coordinates\/matching.py:    # this is the *cartesian* 3D distance that corresponds to the given angle\nastropy\/coordinates\/matching.py:    a 3D cartesian KD-Tree from various sorts of astropy coordinate objects.\nastropy\/coordinates\/matching.py:        The coordinates to build the KD-Tree for.\nastropy\/coordinates\/matching.py:    attrname_or_kdt : bool or str or KDTree\nastropy\/coordinates\/matching.py:        If a string, will store the KD-Tree used for the computation in the\nastropy\/coordinates\/matching.py:        KD-Tree, it will just be used directly.\nastropy\/coordinates\/matching.py:        being put in the KD-Tree.  If None, whatever unit it's already in\nastropy\/coordinates\/matching.py:    kdt : `~scipy.spatial.cKDTree` or `~scipy.spatial.KDTree`\nastropy\/coordinates\/matching.py:        The KD-Tree representing the 3D cartesian representation of the input\nastropy\/coordinates\/matching.py:        KDTree = spatial.cKDTree\nastropy\/coordinates\/matching.py:        warn('C-based KD tree not found, falling back on (much slower) '\nastropy\/coordinates\/matching.py:        KDTree = spatial.KDTree\nastropy\/coordinates\/matching.py:    # figure out where any cached KDTree might be\nastropy\/coordinates\/matching.py:        if kdt is not None and not isinstance(kdt, KDTree):\nastropy\/coordinates\/matching.py:            raise TypeError('The `attrname_or_kdt` \"{0}\" is not a scipy KD tree!'.format(attrname_or_kdt))\nastropy\/coordinates\/matching.py:    elif isinstance(attrname_or_kdt, KDTree):\nastropy\/coordinates\/matching.py:        raise TypeError('Invalid `attrname_or_kdt` argument for KD-Tree:' +\nastropy\/coordinates\/matching.py:        # need to build the cartesian KD-tree for the catalog\nastropy\/coordinates\/matching.py:        kdt = KDTree(flatxyz.value.T)\nastropy\/coordinates\/builtin_frames\/fk5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/fk5.py:from ..transformations import DynamicMatrixTransform\nastropy\/coordinates\/builtin_frames\/fk5.py:from .baseradec import _base_radec_docstring, BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/fk5.py:class FK5(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/fk5.py:# This is the \"self-transform\".  Defined at module level because the decorator\nastropy\/coordinates\/builtin_frames\/fk5.py:@frame_transform_graph.transform(DynamicMatrixTransform, FK5, FK5)\nastropy\/coordinates\/builtin_frames\/galactic_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/galactic_transforms.py:from ..transformations import DynamicMatrixTransform\nastropy\/coordinates\/builtin_frames\/galactic_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, FK5, Galactic)\nastropy\/coordinates\/builtin_frames\/galactic_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, Galactic, FK5)\nastropy\/coordinates\/builtin_frames\/galactic_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, FK4NoETerms, Galactic)\nastropy\/coordinates\/builtin_frames\/galactic_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, Galactic, FK4NoETerms)\nastropy\/coordinates\/builtin_frames\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/__init__.py:from .baseradec import BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/__init__.py:           'BaseEclipticFrame', 'BaseRADecFrame']\nastropy\/coordinates\/builtin_frames\/fk4_fk5_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/fk4_fk5_transforms.py:from ..transformations import DynamicMatrixTransform\nastropy\/coordinates\/builtin_frames\/fk4_fk5_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, FK4NoETerms, FK5)\nastropy\/coordinates\/builtin_frames\/fk4_fk5_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, FK5, FK4NoETerms)\nastropy\/coordinates\/builtin_frames\/supergalactic_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/lsr.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/lsr.py:from ..attributes import DifferentialAttribute\nastropy\/coordinates\/builtin_frames\/lsr.py:from .baseradec import _base_radec_docstring, BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/lsr.py:v_bary_Schoenrich2010 = r.CartesianDifferential([11.1, 12.24, 7.25]*u.km\/u.s)\nastropy\/coordinates\/builtin_frames\/lsr.py:class LSR(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_bary : `~astropy.coordinates.representation.CartesianDifferential`\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_bary = DifferentialAttribute(default=v_bary_Schoenrich2010,\nastropy\/coordinates\/builtin_frames\/lsr.py:                                   allowed_classes=[r.CartesianDifferential])\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_offset = v_bary_icrs.data.represent_as(r.CartesianDifferential)\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_offset = v_bary_icrs.data.represent_as(r.CartesianDifferential)\nastropy\/coordinates\/builtin_frames\/lsr.py:        The Distance for this object along the line-of-sight.\nastropy\/coordinates\/builtin_frames\/lsr.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/builtin_frames\/lsr.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_bary : `~astropy.coordinates.representation.CartesianDifferential`\nastropy\/coordinates\/builtin_frames\/lsr.py:        r.SphericalCosLatDifferential: [\nastropy\/coordinates\/builtin_frames\/lsr.py:        r.SphericalDifferential: [\nastropy\/coordinates\/builtin_frames\/lsr.py:        r.CartesianDifferential: [\nastropy\/coordinates\/builtin_frames\/lsr.py:    frame_specific_representation_info[r.UnitSphericalCosLatDifferential] = \\\nastropy\/coordinates\/builtin_frames\/lsr.py:        frame_specific_representation_info[r.SphericalCosLatDifferential]\nastropy\/coordinates\/builtin_frames\/lsr.py:    frame_specific_representation_info[r.UnitSphericalDifferential] = \\\nastropy\/coordinates\/builtin_frames\/lsr.py:        frame_specific_representation_info[r.SphericalDifferential]\nastropy\/coordinates\/builtin_frames\/lsr.py:    default_differential = r.SphericalCosLatDifferential\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_bary = DifferentialAttribute(default=v_bary_Schoenrich2010)\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_offset = v_bary_gal.data.represent_as(r.CartesianDifferential)\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_offset = v_bary_gal.data.represent_as(r.CartesianDifferential)\nastropy\/coordinates\/builtin_frames\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/utils.py:DEFAULT_OBSTIME = Time('J2000', scale='utc')\nastropy\/coordinates\/builtin_frames\/utils.py:_DEFAULT_PM = (0.035, 0.29)*u.arcsec\nastropy\/coordinates\/builtin_frames\/utils.py:                'valid. Defaulting to polar motion from the 50-yr mean for those. '\nastropy\/coordinates\/builtin_frames\/utils.py:        xp.ravel()[status.ravel() == iers.TIME_BEFORE_IERS_RANGE] = _DEFAULT_PM[0]\nastropy\/coordinates\/builtin_frames\/utils.py:        yp.ravel()[status.ravel() == iers.TIME_BEFORE_IERS_RANGE] = _DEFAULT_PM[1]\nastropy\/coordinates\/builtin_frames\/utils.py:    if np.any(status == iers.TIME_BEYOND_IERS_RANGE):\nastropy\/coordinates\/builtin_frames\/utils.py:                'valid. Defaulting to polar motion from the 50-yr mean for those. '\nastropy\/coordinates\/builtin_frames\/utils.py:        xp.ravel()[status.ravel() == iers.TIME_BEYOND_IERS_RANGE] = _DEFAULT_PM[0]\nastropy\/coordinates\/builtin_frames\/utils.py:        yp.ravel()[status.ravel() == iers.TIME_BEYOND_IERS_RANGE] = _DEFAULT_PM[1]\nastropy\/coordinates\/builtin_frames\/utils.py:        First part of two part Julian date (TDB)\nastropy\/coordinates\/builtin_frames\/utils.py:        Second part of two part Julian date (TDB)\nastropy\/coordinates\/builtin_frames\/utils.py:    # RA, Dec to cartesian unit vectors\nastropy\/coordinates\/builtin_frames\/utils.py:    # ICRS astrometric RA, Dec\nastropy\/coordinates\/builtin_frames\/utils.py:    # CIRS (GCRS) RA, Dec\nastropy\/coordinates\/builtin_frames\/icrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/icrs.py:from .baseradec import _base_radec_docstring, BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/icrs.py:class ICRS(BaseRADecFrame):\nastropy\/coordinates\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/galactic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/galactic.py:    *origin* of this frame in 3D space is the solar system barycenter, not\nastropy\/coordinates\/builtin_frames\/galactic.py:        The Distance for this object along the line-of-sight.\nastropy\/coordinates\/builtin_frames\/galactic.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/builtin_frames\/galactic.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/builtin_frames\/galactic.py:        r.CartesianDifferential: [\nastropy\/coordinates\/builtin_frames\/galactic.py:        r.SphericalCosLatDifferential: [\nastropy\/coordinates\/builtin_frames\/galactic.py:        r.SphericalDifferential: [\nastropy\/coordinates\/builtin_frames\/galactic.py:    frame_specific_representation_info[r.UnitSphericalCosLatDifferential] = \\\nastropy\/coordinates\/builtin_frames\/galactic.py:        frame_specific_representation_info[r.SphericalCosLatDifferential]\nastropy\/coordinates\/builtin_frames\/galactic.py:    frame_specific_representation_info[r.UnitSphericalDifferential] = \\\nastropy\/coordinates\/builtin_frames\/galactic.py:        frame_specific_representation_info[r.SphericalDifferential]\nastropy\/coordinates\/builtin_frames\/galactic.py:    default_differential = r.SphericalCosLatDifferential\nastropy\/coordinates\/builtin_frames\/itrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/itrs.py:from ..representation import CartesianRepresentation, CartesianDifferential\nastropy\/coordinates\/builtin_frames\/itrs.py:from .utils import DEFAULT_OBSTIME\nastropy\/coordinates\/builtin_frames\/itrs.py:    default_differential = CartesianDifferential\nastropy\/coordinates\/builtin_frames\/itrs.py:    obstime = TimeAttribute(default=DEFAULT_OBSTIME)\nastropy\/coordinates\/builtin_frames\/supergalactic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        The Distance for this object along the line-of-sight.\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        The proper motion in Declination for this object (``pm_sgl_cossgb`` must\nastropy\/coordinates\/builtin_frames\/supergalactic.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        r.SphericalCosLatDifferential: [\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        r.SphericalDifferential: [\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        r.CartesianDifferential: [\nastropy\/coordinates\/builtin_frames\/supergalactic.py:    frame_specific_representation_info[r.UnitSphericalCosLatDifferential] = \\\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        frame_specific_representation_info[r.SphericalCosLatDifferential]\nastropy\/coordinates\/builtin_frames\/supergalactic.py:    frame_specific_representation_info[r.UnitSphericalDifferential] = \\\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        frame_specific_representation_info[r.SphericalDifferential]\nastropy\/coordinates\/builtin_frames\/supergalactic.py:    default_differential = r.SphericalCosLatDifferential\nastropy\/coordinates\/builtin_frames\/cirs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/cirs.py:from .baseradec import _base_radec_docstring, BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/cirs.py:from .utils import DEFAULT_OBSTIME\nastropy\/coordinates\/builtin_frames\/cirs.py:class CIRS(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/cirs.py:    obstime = TimeAttribute(default=DEFAULT_OBSTIME)\nastropy\/coordinates\/builtin_frames\/gcrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/gcrs.py:from .utils import DEFAULT_OBSTIME, EQUINOX_J2000\nastropy\/coordinates\/builtin_frames\/gcrs.py:from .baseradec import _base_radec_docstring, BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/gcrs.py:class GCRS(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/gcrs.py:        Defaults to [0, 0, 0], meaning \"true\" GCRS.\nastropy\/coordinates\/builtin_frames\/gcrs.py:        units.  Defaults to [0, 0, 0], meaning \"true\" GCRS.\nastropy\/coordinates\/builtin_frames\/gcrs.py:    obstime = TimeAttribute(default=DEFAULT_OBSTIME)\nastropy\/coordinates\/builtin_frames\/gcrs.py:class PrecessedGeocentric(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/gcrs.py:        Defaults to [0, 0, 0], meaning \"true\" Geocentric.\nastropy\/coordinates\/builtin_frames\/gcrs.py:        Defaults to [0, 0, 0], meaning \"true\" Geocentric.\nastropy\/coordinates\/builtin_frames\/gcrs.py:    obstime = TimeAttribute(default=DEFAULT_OBSTIME)\nastropy\/coordinates\/builtin_frames\/fk4.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/fk4.py:from ..transformations import (FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/builtin_frames\/fk4.py:                               FunctionTransform, DynamicMatrixTransform)\nastropy\/coordinates\/builtin_frames\/fk4.py:from .baseradec import _base_radec_docstring, BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/fk4.py:class FK4(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/fk4.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, FK4, FK4)\nastropy\/coordinates\/builtin_frames\/fk4.py:class FK4NoETerms(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/fk4.py:@frame_transform_graph.transform(DynamicMatrixTransform, FK4NoETerms, FK4NoETerms)\nastropy\/coordinates\/builtin_frames\/fk4.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, FK4, FK4NoETerms)\nastropy\/coordinates\/builtin_frames\/fk4.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, FK4NoETerms, FK4)\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:from ..transformations import FunctionTransformWithFiniteDifference, AffineTransform\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ICRS, CIRS)\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, CIRS, ICRS)\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, CIRS, CIRS)\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ICRS, GCRS)\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, GCRS, GCRS)\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, GCRS, HCRS)\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:_NEED_ORIGIN_HINT = (\"The input {0} coordinates do not have length units. This \"\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:        raise u.UnitsError(_NEED_ORIGIN_HINT.format(hcrs_coo.__class__.__name__))\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:        raise u.UnitsError(_NEED_ORIGIN_HINT.format(icrs_coo.__class__.__name__))\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, HCRS, HCRS)\nastropy\/coordinates\/builtin_frames\/galactocentric.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/galactocentric.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                          DifferentialAttribute)\nastropy\/coordinates\/builtin_frames\/galactocentric.py:        {\\rm Dec} = -28:56:10.23~{\\rm deg}\nastropy\/coordinates\/builtin_frames\/galactocentric.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/builtin_frames\/galactocentric.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/builtin_frames\/galactocentric.py:    galcen_v_sun : `~astropy.coordinates.representation.CartesianDifferential`, optional, must be keyword\nastropy\/coordinates\/builtin_frames\/galactocentric.py:        r.CartesianDifferential: [\nastropy\/coordinates\/builtin_frames\/galactocentric.py:    default_differential = r.CartesianDifferential\nastropy\/coordinates\/builtin_frames\/galactocentric.py:    galcen_v_sun = DifferentialAttribute(\nastropy\/coordinates\/builtin_frames\/galactocentric.py:        default=r.CartesianDifferential([11.1, 220+12.24, 7.25] * u.km\/u.s),\nastropy\/coordinates\/builtin_frames\/galactocentric.py:        allowed_classes=[r.CartesianDifferential])\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                          \"argument\", AstropyDeprecationWarning)\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                      \"'.galcen_coord.ra' instead.\", AstropyDeprecationWarning)\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                      \"'.galcen_coord.dec' instead.\", AstropyDeprecationWarning)\nastropy\/coordinates\/builtin_frames\/galactocentric.py:        offset_v = r.CartesianDifferential.from_cartesian(\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                           \"requires a 3D coordinate, e.g. (angle, angle, \"\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                       (r.UnitSphericalDifferential,\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                        r.UnitSphericalCosLatDifferential,\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                        r.RadialDifferential))):\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                           \"requires a 3D velocity, e.g., proper motion \"\nastropy\/coordinates\/name_resolve.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/name_resolve.py:        # TODO: Implement me\nastropy\/coordinates\/name_resolve.py:    subpackage. Default is to search all databases, but this can be\nastropy\/coordinates\/name_resolve.py:        The string Declination parsed from the HTTP response.\nastropy\/coordinates\/name_resolve.py:            # Retrieve ascii name resolve data from CDS\nastropy\/coordinates\/builtin_frames\/ecliptic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/ecliptic.py:from .utils import EQUINOX_J2000, DEFAULT_OBSTIME\nastropy\/coordinates\/builtin_frames\/ecliptic.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        r.SphericalCosLatDifferential: [\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        r.SphericalDifferential: [\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        r.CartesianDifferential: [\nastropy\/coordinates\/builtin_frames\/ecliptic.py:    frame_specific_representation_info[r.UnitSphericalCosLatDifferential] = \\\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        frame_specific_representation_info[r.SphericalCosLatDifferential]\nastropy\/coordinates\/builtin_frames\/ecliptic.py:    frame_specific_representation_info[r.UnitSphericalDifferential] = \\\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        frame_specific_representation_info[r.SphericalDifferential]\nastropy\/coordinates\/builtin_frames\/ecliptic.py:    default_differential = r.SphericalCosLatDifferential\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        The date to assume for this frame.  Determines the location of the\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        The date to assume for this frame.  Determines the location of the\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        The date to assume for this frame.  Determines the location of the\nastropy\/coordinates\/builtin_frames\/ecliptic.py:    obstime = TimeAttribute(default=DEFAULT_OBSTIME)\nastropy\/samp\/constants.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/constants.py:Defines constants used in `astropy.samp`.\nastropy\/coordinates\/solar_system.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/solar_system.py:from collections import OrderedDict\nastropy\/coordinates\/solar_system.py:DEFAULT_JPL_EPHEMERIS = 'de430'\nastropy\/coordinates\/solar_system.py:BODY_NAME_TO_KERNEL_SPEC = OrderedDict(\nastropy\/coordinates\/solar_system.py:PLAN94_BODY_NAME_TO_PLANET_INDEX = OrderedDict(\nastropy\/coordinates\/solar_system.py:    \"\"\"Default ephemerides for calculating positions of Solar-System bodies.\nastropy\/coordinates\/solar_system.py:                    tuple(PLAN94_BODY_NAME_TO_PLANET_INDEX.keys()))\nastropy\/coordinates\/solar_system.py:            return tuple(BODY_NAME_TO_KERNEL_SPEC.keys())\nastropy\/coordinates\/solar_system.py:        value = DEFAULT_JPL_EPHEMERIS\nastropy\/coordinates\/solar_system.py:                    body_index = PLAN94_BODY_NAME_TO_PLANET_INDEX[body]\nastropy\/coordinates\/solar_system.py:                kernel_spec = BODY_NAME_TO_KERNEL_SPEC[body.lower()]\nastropy\/coordinates\/solar_system.py:        # jplephem cannot handle multi-D arrays, so convert to 1D here.\nastropy\/coordinates\/solar_system.py:        # Note that we use the new jd1.shape here to create a 1D result array.\nastropy\/coordinates\/solar_system.py:    Convert Skycoord in GCRS frame into one in which RA and Dec\nastropy\/coordinates\/builtin_frames\/icrs_fk5_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/icrs_fk5_transforms.py:from ..transformations import DynamicMatrixTransform\nastropy\/coordinates\/builtin_frames\/icrs_fk5_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, ICRS, FK5)\nastropy\/coordinates\/builtin_frames\/icrs_fk5_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, FK5, ICRS)\nastropy\/utils\/tests\/test_xml.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_xml.py:             'DSACAT=IDR&amp;amp;DSATAB=Emitters&amp;amp;'\nastropy\/utils\/tests\/test_xml.py:              'DSACAT=IDR&DSATAB=Emitters&'\nastropy\/utils\/tests\/test_xml.py:             b'DSACAT=IDR&amp;amp;DSATAB=Emitters&amp;amp;'\nastropy\/utils\/tests\/test_xml.py:              b'DSACAT=IDR&DSATAB=Emitters&'\nastropy\/utils\/tests\/test_xml.py:    # Default is True (all XML tags escaped)\nastropy\/samp\/hub_script.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/hub_script.py:    parser.add_argument(\"-k\", \"--secret\", dest=\"secret\", metavar=\"CODE\",\nastropy\/samp\/hub_script.py:    parser.add_argument(\"-d\", \"--addr\", dest=\"addr\", metavar=\"ADDR\",\nastropy\/samp\/hub_script.py:    timeout_group.add_argument(\"-t\", \"--timeout\", dest=\"timeout\", metavar=\"SECONDS\",\nastropy\/samp\/hub_script.py:                               help=\"set the Hub inactivity timeout in SECONDS. By default it \"\nastropy\/samp\/hub_script.py:    timeout_group.add_argument(\"-c\", \"--client-timeout\", dest=\"client_timeout\", metavar=\"SECONDS\",\nastropy\/samp\/hub_script.py:                               help=\"set the client inactivity timeout in SECONDS. By default it \"\nastropy\/samp\/hub_script.py:                           help=\"set the Hub instance log level (OFF, ERROR, WARNING, INFO, DEBUG).\",\nastropy\/samp\/hub_script.py:                           type=str, choices=[\"OFF\", \"ERROR\", \"WARNING\", \"INFO\", \"DEBUG\"], default='INFO')\nastropy\/samp\/hub_script.py:                                          \"samp-hub-<PID>-<ID>, where PID is the Hub process ID while ID is an \"\nastropy\/samp\/hub_script.py:                                          \"internal ID (integer).\")\nastropy\/samp\/hub_script.py:        if options.loglevel in (\"OFF\", \"ERROR\", \"WARNING\", \"DEBUG\", \"INFO\"):\nastropy\/coordinates\/angles.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angles.py:        # TODO: Numpy array of tuples?\nastropy\/coordinates\/angles.py:        # Do the wrapping, but only if any angles need to be wrapped\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:from ..transformations import FunctionTransformWithFiniteDifference, DynamicMatrixTransform\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, GeocentricTrueEcliptic, GCRS)\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, ICRS, BarycentricTrueEcliptic)\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, BarycentricTrueEcliptic, ICRS)\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:_NEED_ORIGIN_HINT = (\"The input {0} coordinates do not have length units. This \"\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:        raise UnitsError(_NEED_ORIGIN_HINT.format(from_coo.__class__.__name__))\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:        raise UnitsError(_NEED_ORIGIN_HINT.format(from_coo.__class__.__name__))\nastropy\/visualization\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/attributes.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/attributes.py:# Dependencies\nastropy\/coordinates\/attributes.py:from ..utils.exceptions import AstropyDeprecationWarning\nastropy\/coordinates\/attributes.py:from ..utils import OrderedDescriptor, ShapedLikeNDArray\nastropy\/coordinates\/attributes.py:           'DifferentialAttribute']\nastropy\/coordinates\/attributes.py:class Attribute(OrderedDescriptor):\nastropy\/coordinates\/attributes.py:        Default value for the attribute if not provided\nastropy\/coordinates\/attributes.py:                    if isinstance(out, ShapedLikeNDArray):\nastropy\/coordinates\/attributes.py:        Default value for the attribute if not provided\nastropy\/coordinates\/attributes.py:        Default value for the attribute if not provided\nastropy\/coordinates\/attributes.py:        Default value for the attribute if not provided\nastropy\/coordinates\/attributes.py:        Default value for the attribute if not provided\nastropy\/coordinates\/attributes.py:        Default value for the attribute if not provided\nastropy\/coordinates\/attributes.py:class DifferentialAttribute(Attribute):\nastropy\/coordinates\/attributes.py:    any `~astropy.coordinates.BaseDifferential` subclass instance is valid.\nastropy\/coordinates\/attributes.py:        Default value for the attribute if not provided\nastropy\/coordinates\/attributes.py:            self.allowed_classes = BaseDifferential\nastropy\/coordinates\/attributes.py:            raise TypeError('Tried to set a DifferentialAttribute with '\nastropy\/coordinates\/attributes.py:                            'an unsupported Differential type {0}. Allowed '\nastropy\/coordinates\/attributes.py:                      AstropyDeprecationWarning)\nastropy\/coordinates\/attributes.py:                      AstropyDeprecationWarning)\nastropy\/coordinates\/attributes.py:                      \"QuantityAttribute.\", AstropyDeprecationWarning)\nastropy\/coordinates\/attributes.py:                      AstropyDeprecationWarning)\nastropy\/coordinates\/attributes.py:from .representation import CartesianRepresentation, BaseDifferential\nastropy\/utils\/tests\/test_collections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:from ..transformations import FunctionTransformWithFiniteDifference\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, CIRS, AltAz)\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, AltAz, CIRS)\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:        # treat the output of atoiq as an \"astrometric\" RA\/DEC, so to get the\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:        # actual RA\/Dec from the observers vantage point, we have to reverse\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, AltAz, AltAz)\nastropy\/coordinates\/angle_parsetab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angle_parsetab.py:# This file is automatically generated. Do not edit.\nastropy\/coordinates\/angle_parsetab.py:_lr_signature = 'DA395940D76FFEB6A68EA2DB16FC015D'\nastropy\/coordinates\/angle_parsetab.py:_lr_action_items = {'UINT':([0,2,10,12,19,20,22,23,35,36,38,],[-7,12,-6,19,25,27,29,32,25,25,25,]),'MINUTE':([4,6,8,12,13,19,21,24,25,26,27,28,29,31,32,34,40,],[16,-14,-15,-17,-16,-9,-12,-8,-9,-13,-9,-10,36,37,38,39,-11,]),'COLON':([12,27,],[20,35,]),'$end':([1,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,30,31,32,33,34,36,37,38,39,40,41,42,43,44,],[-4,-1,-32,-5,-14,-2,-15,-3,0,-17,-16,-33,-31,-35,-24,-34,-9,-12,-25,-18,-8,-9,-13,-9,-10,-9,-26,-8,-9,-19,-8,-27,-28,-20,-21,-11,-29,-22,-30,-23,]),'SIMPLE_UNIT':([4,6,8,12,13,19,21,24,25,26,27,28,40,],[14,-14,-15,-17,-16,-9,-12,-8,-9,-13,-9,-10,-11,]),'DEGREE':([4,6,8,12,13,19,21,24,25,26,27,28,40,],[15,-14,-15,22,-16,-9,-12,-8,-9,-13,-9,-10,-11,]),'UFLOAT':([0,2,10,12,19,20,22,23,35,36,38,],[-7,13,-6,24,24,24,31,34,24,24,24,]),'HOUR':([4,6,8,12,13,19,21,24,25,26,27,28,40,],[17,-14,-15,23,-16,-9,-12,-8,-9,-13,-9,-10,-11,]),'SECOND':([4,6,8,12,13,19,21,24,25,26,27,28,40,41,42,],[18,-14,-15,-17,-16,-9,-12,-8,-9,-13,-9,-10,-11,43,44,]),'SIGN':([0,],[10,]),}\nastropy\/coordinates\/angle_parsetab.py:  ('hms -> sign UINT HOUR UINT MINUTE ufloat SECOND','hms',7,'p_hms','angle_utilities.py',198),\nastropy\/coordinates\/angle_parsetab.py:  ('dms -> sign UINT DEGREE','dms',3,'p_dms','angle_utilities.py',212),\nastropy\/coordinates\/angle_parsetab.py:  ('dms -> sign UINT DEGREE ufloat','dms',4,'p_dms','angle_utilities.py',213),\nastropy\/coordinates\/angle_parsetab.py:  ('dms -> sign UINT DEGREE UINT MINUTE','dms',5,'p_dms','angle_utilities.py',214),\nastropy\/coordinates\/angle_parsetab.py:  ('dms -> sign UINT DEGREE UFLOAT MINUTE','dms',5,'p_dms','angle_utilities.py',215),\nastropy\/coordinates\/angle_parsetab.py:  ('dms -> sign UINT DEGREE UINT MINUTE ufloat','dms',6,'p_dms','angle_utilities.py',216),\nastropy\/coordinates\/angle_parsetab.py:  ('dms -> sign UINT DEGREE UINT MINUTE ufloat SECOND','dms',7,'p_dms','angle_utilities.py',217),\nastropy\/coordinates\/angle_parsetab.py:  ('dms -> generic DEGREE','dms',2,'p_dms','angle_utilities.py',218),\nastropy\/coordinates\/angle_parsetab.py:  ('arcsecond -> generic SECOND','arcsecond',2,'p_arcsecond','angle_utilities.py',241),\nastropy\/coordinates\/matrix_utilities.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/frame.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/frame.py:from collections import OrderedDict\nastropy\/visualization\/wcsaxes\/frame.py:from matplotlib.lines import Line2D, Path\nastropy\/visualization\/wcsaxes\/frame.py:            self._pixel = self.parent_axes.transData.transform(self._data)\nastropy\/visualization\/wcsaxes\/frame.py:            self._data = self.parent_axes.transData.inverted().transform(self._data)\nastropy\/visualization\/wcsaxes\/frame.py:            self._pixel = self.parent_axes.transData.transform(self._data)\nastropy\/visualization\/wcsaxes\/frame.py:class BaseFrame(OrderedDict, metaclass=abc.ABCMeta):\nastropy\/visualization\/wcsaxes\/frame.py:        return PathPatch(self._path, transform=self.parent_axes.transData,\nastropy\/visualization\/wcsaxes\/frame.py:            line = Line2D(x, y, linewidth=self._linewidth, color=self._color, zorder=1000)\nastropy\/visualization\/wcsaxes\/frame.py:        spines = OrderedDict()\nastropy\/visualization\/wcsaxes\/frame.py:        line = Line2D(x, y, linewidth=self._linewidth, color=self._color, zorder=1000)\nastropy\/coordinates\/builtin_frames\/altaz.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/altaz.py:_90DEG = 90*u.deg\nastropy\/coordinates\/builtin_frames\/altaz.py:        The Distance for this object along the line-of-sight.\nastropy\/coordinates\/builtin_frames\/altaz.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/builtin_frames\/altaz.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/builtin_frames\/altaz.py:        r.SphericalCosLatDifferential: [\nastropy\/coordinates\/builtin_frames\/altaz.py:        r.SphericalDifferential: [\nastropy\/coordinates\/builtin_frames\/altaz.py:        r.CartesianDifferential: [\nastropy\/coordinates\/builtin_frames\/altaz.py:    frame_specific_representation_info[r.UnitSphericalCosLatDifferential] = \\\nastropy\/coordinates\/builtin_frames\/altaz.py:        frame_specific_representation_info[r.SphericalCosLatDifferential]\nastropy\/coordinates\/builtin_frames\/altaz.py:    frame_specific_representation_info[r.UnitSphericalDifferential] = \\\nastropy\/coordinates\/builtin_frames\/altaz.py:        frame_specific_representation_info[r.SphericalDifferential]\nastropy\/coordinates\/builtin_frames\/altaz.py:    default_differential = r.SphericalCosLatDifferential\nastropy\/coordinates\/builtin_frames\/altaz.py:        return _90DEG.to(self.alt.unit) - self.alt\nastropy\/visualization\/wcsaxes\/ticklabels.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/ticklabels.py:                # TODO: the problem here is that we might get rid of a label\nastropy\/coordinates\/earth.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/earth.py:from .representation import CartesianRepresentation, CartesianDifferential\nastropy\/coordinates\/earth.py:ELLIPSOIDS = ('WGS84', 'GRS80', 'WGS72')\nastropy\/coordinates\/earth.py:    if ellipsoid not in ELLIPSOIDS:\nastropy\/coordinates\/earth.py:                         .format(ellipsoid, ELLIPSOIDS))\nastropy\/coordinates\/earth.py:        # TODO: needs copy argument and better dealing with inputs.\nastropy\/coordinates\/earth.py:            NY) or a city name (e.g., Danbury, CT), or etc.\nastropy\/coordinates\/earth.py:            Reference ellipsoid to use.  Default is the one the coordinates\nastropy\/coordinates\/earth.py:        itrs.data.differentials['s'] = CartesianDifferential(zeros)\nastropy\/visualization\/wcsaxes\/ticks.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/ticks.py:from matplotlib.lines import Path, Line2D\nastropy\/visualization\/wcsaxes\/ticks.py:from matplotlib.transforms import Affine2D\nastropy\/visualization\/wcsaxes\/ticks.py:class Ticks(Line2D):\nastropy\/visualization\/wcsaxes\/ticks.py:    Ticks are derived from Line2D, and note that ticks themselves\nastropy\/visualization\/wcsaxes\/ticks.py:        Line2D.__init__(self, [0.], [0.], **line2d_kwargs)\nastropy\/visualization\/wcsaxes\/ticks.py:        Draw the ticks.\nastropy\/visualization\/wcsaxes\/ticks.py:        Draw the minor ticks.\nastropy\/visualization\/wcsaxes\/ticks.py:        marker_scale = Affine2D().scale(offset, offset)\nastropy\/visualization\/wcsaxes\/ticks.py:        marker_rotation = Affine2D()\nastropy\/visualization\/wcsaxes\/ticks.py:                # Draw the markers\nastropy\/samp\/hub_proxy.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/hub_proxy.py:        Disconnect from the current SAMP Hub.\nastropy\/coordinates\/builtin_frames\/skyoffset.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/skyoffset.py:from ..transformations import DynamicMatrixTransform, FunctionTransform\nastropy\/coordinates\/builtin_frames\/skyoffset.py:                    # TODO: we could support proper motions \/ velocities in sky\nastropy\/coordinates\/builtin_frames\/skyoffset.py:    @frame_transform_graph.transform(DynamicMatrixTransform, framecls, _SkyOffsetFramecls)\nastropy\/coordinates\/builtin_frames\/skyoffset.py:        # Define rotation matrices along the position angle vector, and\nastropy\/coordinates\/builtin_frames\/skyoffset.py:    @frame_transform_graph.transform(DynamicMatrixTransform, _SkyOffsetFramecls, framecls)\nastropy\/coordinates\/builtin_frames\/skyoffset.py:    object's ``lat`` will be pointed in the direction of Dec, while ``lon``\nastropy\/visualization\/wcsaxes\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/axislabels.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/utils.py:    Determine whether a particular WCS ctype corresponds to an angle or scalar\nastropy\/visualization\/wcsaxes\/utils.py:    elif ctype[:4] in ['DEC-', 'HPLT'] or ctype[1:4] == 'LAT':\nastropy\/visualization\/wcsaxes\/grid_paths.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/grid_paths.py:ROUND_TRIP_TOL = 1e-1\nastropy\/visualization\/wcsaxes\/grid_paths.py:DISCONT_FACTOR = 10.\nastropy\/visualization\/wcsaxes\/grid_paths.py:    Draw a curve, taking into account discontinuities.\nastropy\/visualization\/wcsaxes\/grid_paths.py:        mask = np.abs(sep > ROUND_TRIP_TOL)\nastropy\/visualization\/wcsaxes\/grid_paths.py:    # discontinuous = step > DISCONT_FACTOR * np.median(step)\nastropy\/visualization\/wcsaxes\/grid_paths.py:    discontinuous = step[1:] > DISCONT_FACTOR * step[:-1]\nastropy\/visualization\/wcsaxes\/grid_paths.py:    if step[0] > DISCONT_FACTOR * step[1]:\nastropy\/visualization\/wcsaxes\/grid_paths.py:    Draw a grid line\nastropy\/visualization\/scripts\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/patches.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/patches.py:    # Determine rotation matrix to make it so that the circle is centered\nastropy\/visualization\/wcsaxes\/patches.py:    # Apply 3D rotation\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:from matplotlib.transforms import Affine2D, ScaledTranslation\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        self.dpi_transform = Affine2D()\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        self.ticks = Ticks(transform=parent_axes.transData + self.offset_transform)\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        # Matplotlib's gridlines use Line2D, but ours use PathPatch.\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:                                  'transform': self.parent_axes.transData}\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        # TODO: this method should be optimized for speed\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        transData = self.parent_axes.transData\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        invertedTransLimits = transData.inverted()\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:            # Determine tick rotation in display coordinates and compare to\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:            axes0 = transData.transform(pixel0)\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        Display minor ticks for this coordinate.\nastropy\/utils\/tests\/test_codegen.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_codegen.py:        assert exc_cls is ZeroDivisionError\nastropy\/visualization\/wcsaxes\/coordinates_map.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/coordinates_map.py:        choose which dimensions are being shown in the 2D image. The slice\nastropy\/visualization\/units.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angle_utilities.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angle_utilities.py:        # TODO: in principle, the parser should be invalidated if we change unit\nastropy\/coordinates\/angle_utilities.py:        # system (from CDS to FITS, say).  Might want to keep a link to the\nastropy\/coordinates\/angle_utilities.py:            'DEGREE',\nastropy\/coordinates\/angle_utilities.py:            'SECOND',\nastropy\/coordinates\/angle_utilities.py:        # NOTE THE ORDERING OF THESE RULES IS IMPORTANT!!\nastropy\/coordinates\/angle_utilities.py:        t_DEGREE = r'd(eg(ree(s)?)?)?|\u00b0'\nastropy\/coordinates\/angle_utilities.py:        t_SECOND = r's(ec(ond(s)?)?)?|\u2033|\\\"|\u02e2'\nastropy\/coordinates\/angle_utilities.py:                | sign UINT HOUR UINT MINUTE ufloat SECOND\nastropy\/coordinates\/angle_utilities.py:            dms : sign UINT DEGREE\nastropy\/coordinates\/angle_utilities.py:                | sign UINT DEGREE ufloat\nastropy\/coordinates\/angle_utilities.py:                | sign UINT DEGREE UINT MINUTE\nastropy\/coordinates\/angle_utilities.py:                | sign UINT DEGREE UFLOAT MINUTE\nastropy\/coordinates\/angle_utilities.py:                | sign UINT DEGREE UINT MINUTE ufloat\nastropy\/coordinates\/angle_utilities.py:                | sign UINT DEGREE UINT MINUTE ufloat SECOND\nastropy\/coordinates\/angle_utilities.py:                | generic DEGREE\nastropy\/coordinates\/angle_utilities.py:            arcsecond : generic SECOND\nastropy\/coordinates\/angle_utilities.py:    Convert an angle in Radians to Degrees.\nastropy\/samp\/client.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/client.py:    # TODO: define what is meant by callable\nastropy\/samp\/client.py:            Sender public ID.\nastropy\/samp\/client.py:            Sender public ID.\nastropy\/samp\/client.py:            Message ID received.\nastropy\/samp\/client.py:            Responder public ID.\nastropy\/samp\/client.py:        notification sender ID, ``msg_id`` is the Hub message-id (calls only,\nastropy\/samp\/client.py:            Dictionary containing additional metadata to declare associated\nastropy\/samp\/client.py:        notification sender ID, ``mtype`` is the message MType, ``params`` is\nastropy\/samp\/client.py:            Dictionary containing additional metadata to declare associated\nastropy\/samp\/client.py:        notification sender ID, ``msg_id`` is the Hub message-id, ``mtype`` is\nastropy\/samp\/client.py:            Dictionary containing additional metadata to declare associated\nastropy\/samp\/client.py:        the message responder ID, ``msg_tag`` is the message-tag provided at\nastropy\/samp\/client.py:        Declares the MTypes the client wishes to subscribe to, implicitly\nastropy\/samp\/client.py:            Dictionary containing the list of MTypes to subscribe to, with the\nastropy\/samp\/client.py:        Declare the client application metadata supported.\nastropy\/samp\/client.py:            Dictionary containing the client application metadata as defined in\nastropy\/samp\/client.py:        Return public client ID obtained at registration time\nastropy\/samp\/client.py:            Client public ID.\nastropy\/visualization\/wcsaxes\/tests\/test_coordinate_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_frame.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_frame.py:from ....tests.image_tests import IMAGE_REFERENCE_DIR\nastropy\/visualization\/wcsaxes\/tests\/test_frame.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_frame.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_frame.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_frame.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_utils.py:    assert coord_type_from_ctype('DEC-') == ('latitude', None)\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:from ....tests.image_tests import IMAGE_REFERENCE_DIR\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:class DistanceToLonLat(CurvedTransform):\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:        return LonLatToDistance(R=self.R)\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:class LonLatToDistance(CurvedTransform):\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:        return DistanceToLonLat(R=self.R)\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR, filename='coords_overlay.png', tolerance=1.5)\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:        s = DistanceToLonLat(R=6378.273)\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR, filename='coords_overlay_auto_coord_meta.png', tolerance=1.5)\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR, filename='direct_init.png', tolerance=1.5)\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:        s = DistanceToLonLat(R=6378.273)\nastropy\/visualization\/wcsaxes\/coordinate_range.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:from matplotlib.transforms import Affine2D\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS2D = WCS(naxis=2)\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS2D.wcs.ctype = ['x', 'y']\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS2D.wcs.cunit = ['km', 'km']\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS2D.wcs.crpix = [614.5, 856.5]\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS2D.wcs.cdelt = [6.25, 6.25]\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS2D.wcs.crval = [0., 0.]\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS3D = WCS(naxis=3)\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS3D.wcs.ctype = ['x', 'y', 'z']\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS3D.wcs.cunit = ['km', 'km', 'km']\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS3D.wcs.crpix = [614.5, 856.5, 333]\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS3D.wcs.cdelt = [6.25, 6.25, 23]\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS3D.wcs.crval = [0., 0., 1.]\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:# We add Affine2D to catch the fact that in Matplotlib, having a Composite\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:    w1 = WCSWorld2PixelTransform(WCS2D) + Affine2D()\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:    w1 = WCSWorld2PixelTransform(WCS3D, slice=('y', 0, 'x')) + Affine2D()\nastropy\/visualization\/wcsaxes\/formatter_locator.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/formatter_locator.py:DMS_RE = re.compile('^dd(:mm(:ss(.(s)+)?)?)?$')\nastropy\/visualization\/wcsaxes\/formatter_locator.py:DDEC_RE = re.compile('^d(.(d)+)?$')\nastropy\/visualization\/wcsaxes\/formatter_locator.py:DMIN_RE = re.compile('^m(.(m)+)?$')\nastropy\/visualization\/wcsaxes\/formatter_locator.py:DSEC_RE = re.compile('^s(.(s)+)?$')\nastropy\/visualization\/wcsaxes\/formatter_locator.py:        if DMS_RE.match(value) is not None:\nastropy\/visualization\/wcsaxes\/formatter_locator.py:        elif DDEC_RE.match(value) is not None:\nastropy\/visualization\/wcsaxes\/formatter_locator.py:        elif DMIN_RE.match(value) is not None:\nastropy\/visualization\/wcsaxes\/formatter_locator.py:        elif DSEC_RE.match(value) is not None:\nastropy\/visualization\/wcsaxes\/tests\/datasets.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/datasets.py:\"\"\"Downloads the FITS files that are used in image testing and for building documentation.\nastropy\/visualization\/wcsaxes\/tests\/datasets.py:    Download a FITS file to the cache and open HDU 0.\nastropy\/visualization\/wcsaxes\/tests\/datasets.py:    \"\"\"Fetch the MSX example dataset HDU.\nastropy\/visualization\/wcsaxes\/tests\/datasets.py:    hdu : `~astropy.io.fits.ImageHDU`\nastropy\/visualization\/wcsaxes\/tests\/datasets.py:        Image HDU\nastropy\/visualization\/wcsaxes\/tests\/test_display_world_coordinates.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_display_world_coordinates.py:class TestDisplayWorldCoordinate(BaseImageTests):\nastropy\/visualization\/scripts\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:from ....tests.image_tests import IMAGE_REFERENCE_DIR\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR, tolerance=1.5)\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR, tolerance=1.5)\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:        w.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:        w.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:        # TODO: the formatted string should show units\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/core.py:from matplotlib.transforms import Affine2D, Bbox, Transform\nastropy\/visualization\/wcsaxes\/core.py:IDENTITY = WCS(naxis=2)\nastropy\/visualization\/wcsaxes\/core.py:IDENTITY.wcs.ctype = [\"X\", \"Y\"]\nastropy\/visualization\/wcsaxes\/core.py:IDENTITY.wcs.crval = [0., 0.]\nastropy\/visualization\/wcsaxes\/core.py:IDENTITY.wcs.crpix = [1., 1.]\nastropy\/visualization\/wcsaxes\/core.py:IDENTITY.wcs.cdelt = [1., 1.]\nastropy\/visualization\/wcsaxes\/core.py:    transData : `~matplotlib.transforms.Transform`, optional\nastropy\/visualization\/wcsaxes\/core.py:        choose which dimensions are being shown in the 2D image. The slice\nastropy\/visualization\/wcsaxes\/core.py:                 transData=None, slices=None, frame_class=RectangularFrame,\nastropy\/visualization\/wcsaxes\/core.py:        if not (transData is None):\nastropy\/visualization\/wcsaxes\/core.py:            self.transData = transData\nastropy\/visualization\/wcsaxes\/core.py:            self.wcs = IDENTITY\nastropy\/visualization\/wcsaxes\/core.py:        This does not include the transData transformation\nastropy\/visualization\/wcsaxes\/core.py:        return self._get_transform_no_transdata(frame).inverted() + self.transData\nastropy\/visualization\/wcsaxes\/core.py:            return Affine2D()\nastropy\/utils\/tests\/test_data_info.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_data_info.py:DTYPE_TESTS = ((np.array(b'abcd').dtype, STRING_TYPE_NAMES[(True, 'S')] + '4'),\nastropy\/utils\/tests\/test_data_info.py:@pytest.mark.parametrize('input,output', DTYPE_TESTS)\nastropy\/utils\/tests\/test_data.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_data.py:         'https:\/\/astropy.stsci.edu\/data\/intersphinx\/README'])\nastropy\/utils\/tests\/test_data.py:    # Download the test URL and make sure it exists, then clear just that\nastropy\/utils\/tests\/test_data.py:    # TODO: if in the future, the root data\/ directory is added in, the below\nastropy\/utils\/tests\/test_data.py:    # test should be uncommented and the README.rst should be replaced with\nastropy\/utils\/tests\/test_data.py:    # fnout2 = get_pkg_data_filename('..\/..\/data\/README.rst')\nastropy\/utils\/tests\/test_data.py:    # assert os.path.isfile(fnout2) and fnout2.endswith('README.rst')\nastropy\/utils\/tests\/test_data.py:    get_pkg_data_filename('..\/..\/..\/data\/README.rst')\nastropy\/utils\/tests\/test_data.py:    monkeypatch.setenv(str('XDG_CONFIG_HOME'), 'foo')\nastropy\/utils\/tests\/test_data.py:    monkeypatch.delenv(str('XDG_CONFIG_HOME'))\nastropy\/utils\/tests\/test_data.py:    monkeypatch.setenv(str('XDG_CACHE_HOME'), 'bar')\nastropy\/utils\/tests\/test_data.py:    monkeypatch.delenv(str('XDG_CACHE_HOME'))\nastropy\/coordinates\/errors.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/errors.py:# TODO: consider if this should be used to `units`?\nastropy\/coordinates\/errors.py:            message += \" Did you mean one of: '{0}'?'\".format(\"', '\".join(close_names))\nastropy\/visualization\/wcsaxes\/tests\/test_formatter_locator.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:        hdu1 = fits.PrimaryHDU()\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:        hdu2 = fits.ImageHDU(data)\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:        hdulist = fits.HDUList([hdu1, hdu2])\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:        hdu1 = fits.PrimaryHDU()\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:        hdu2 = fits.ImageHDU(data)\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:        hdulist = fits.HDUList([hdu1, hdu2])\nastropy\/coordinates\/calculation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/calculation.py:_VALID_SIGNS = [\"capricorn\", \"aquarius\", \"pisces\", \"aries\", \"taurus\", \"gemini\",\nastropy\/coordinates\/calculation.py:        if zodiac_sign not in _VALID_SIGNS:\nastropy\/visualization\/lupton_rgb.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/lupton_rgb.py:        The asinh softening parameter. Default is 8.\nastropy\/visualization\/scripts\/fits2bitmap.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/scripts\/fits2bitmap.py:        The pixel value of the minimum cut level.  Data values less than\nastropy\/visualization\/scripts\/fits2bitmap.py:        The pixel value of the maximum cut level.  Data values greater\nastropy\/visualization\/scripts\/fits2bitmap.py:        log.critical('data in FITS extension {0} is not a 2D array'\nastropy\/visualization\/scripts\/fits2bitmap.py:                        help='Specify the HDU extension number or name '\nastropy\/visualization\/scripts\/fits2bitmap.py:                             '(Default is 0).')\nastropy\/visualization\/scripts\/fits2bitmap.py:                        help='Filename for the output image (Default is a '\nastropy\/visualization\/scripts\/fits2bitmap.py:                        '\"power\", \"log\", or \"asinh\") (Default is \"linear\").')\nastropy\/visualization\/scripts\/fits2bitmap.py:                        help='Power index for \"power\" stretching (Default is '\nastropy\/visualization\/scripts\/fits2bitmap.py:                             '(Default is 0.1).')\nastropy\/visualization\/scripts\/fits2bitmap.py:                             '(Default is the image minimum).')\nastropy\/visualization\/scripts\/fits2bitmap.py:                             '(Default is the image maximum).')\nastropy\/visualization\/scripts\/fits2bitmap.py:                             'minimum cut level (Default is 0).')\nastropy\/visualization\/scripts\/fits2bitmap.py:                             'maximum cut level (Default is 100).')\nastropy\/visualization\/scripts\/fits2bitmap.py:                             'maximum cut levels (Default is 100).')\nastropy\/visualization\/scripts\/fits2bitmap.py:                                                '(Default is \"Greys_r\").')\nastropy\/utils\/tests\/test_metadata.py:from collections import OrderedDict\nastropy\/utils\/tests\/test_metadata.py:from ..metadata import MetaData, MergeConflictError, merge, enable_merge_strategies\nastropy\/utils\/tests\/test_metadata.py:class OrderedDictSubclass(OrderedDict):\nastropy\/utils\/tests\/test_metadata.py:        assert isinstance(d.meta, OrderedDict)\nastropy\/utils\/tests\/test_metadata.py:                                         OrderedDict([('a', 1)]),\nastropy\/utils\/tests\/test_metadata.py:                                         OrderedDictSubclass([('a', 1)])]))\nastropy\/utils\/tests\/test_metadata.py:                                         OrderedDict([('a', 1)]),\nastropy\/utils\/tests\/test_metadata.py:                                         OrderedDictSubclass([('a', 1)])]))\nastropy\/utils\/tests\/test_metadata.py:class ExampleData:\nastropy\/utils\/tests\/test_metadata.py:    meta = MetaData()\nastropy\/utils\/tests\/test_metadata.py:class TestMetaExampleData(MetaBaseTest):\nastropy\/utils\/tests\/test_metadata.py:    test_class = ExampleData\nastropy\/utils\/tests\/test_metadata.py:    data1 = ExampleData()\nastropy\/utils\/tests\/test_metadata.py:    data2 = ExampleData()\nastropy\/visualization\/hist.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/mpl_normalize.py:        The pixel value of the minimum cut level.  Data values less than\nastropy\/visualization\/mpl_normalize.py:        The pixel value of the maximum cut level.  Data values greater\nastropy\/visualization\/mpl_style.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/mpl_style.py:    'patch.facecolor': '#348ABD',\nastropy\/visualization\/mpl_style.py:color_cycle = ['#348ABD',   # blue\nastropy\/time\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_norm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_norm.py:DATA = np.linspace(0., 15., 6)\nastropy\/visualization\/tests\/test_norm.py:DATA2 = np.arange(3)\nastropy\/visualization\/tests\/test_norm.py:DATA2SCL = 0.5 * DATA2\nastropy\/visualization\/tests\/test_norm.py:        norm2 = ImageNormalize(DATA, interval=ManualInterval(2, 10),\nastropy\/visualization\/tests\/test_norm.py:        output = norm(DATA)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(output, norm2(DATA))\nastropy\/visualization\/tests\/test_norm.py:        norm2 = ImageNormalize(DATA, interval=ManualInterval(2, 10),\nastropy\/visualization\/tests\/test_norm.py:        output = norm(DATA)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm.inverse(norm(DATA))[1:], DATA[1:])\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(output, norm2(DATA))\nastropy\/visualization\/tests\/test_norm.py:        norm2 = ImageNormalize(DATA, interval=ManualInterval(None, 10),\nastropy\/visualization\/tests\/test_norm.py:        output = norm(DATA)\nastropy\/visualization\/tests\/test_norm.py:        assert norm.vmin == np.min(DATA)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(output, norm2(DATA))\nastropy\/visualization\/tests\/test_norm.py:        norm2 = ImageNormalize(DATA, interval=ManualInterval(2, None),\nastropy\/visualization\/tests\/test_norm.py:        output = norm(DATA)\nastropy\/visualization\/tests\/test_norm.py:        assert norm.vmax == np.max(DATA)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(output, norm2(DATA))\nastropy\/visualization\/tests\/test_norm.py:        mdata = ma.array(DATA, mask=[0, 0, 1, 0, 0, 0])\nastropy\/visualization\/tests\/test_norm.py:        mdata = ma.array(DATA, mask=[0, 0, 1, 0, 0, 0])\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm.inverse(norm(DATA))[1:], DATA[1:])\nastropy\/visualization\/tests\/test_norm.py:        norm = simple_norm(DATA2, stretch='linear')\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), DATA2SCL, atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:        norm = simple_norm(DATA2, stretch='sqrt')\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), np.sqrt(DATA2SCL), atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:        norm = simple_norm(DATA2, stretch='power', power=power)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), DATA2SCL ** power, atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:        norm = simple_norm(DATA2, stretch='log')\nastropy\/visualization\/tests\/test_norm.py:        ref = np.log10(1000 * DATA2SCL + 1.0) \/ np.log10(1001.0)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), ref, atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:        norm = simple_norm(DATA2, stretch='asinh', asinh_a=a)\nastropy\/visualization\/tests\/test_norm.py:        ref = np.arcsinh(DATA2SCL \/ a) \/ np.arcsinh(1. \/ a)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), ref, atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:        norm = simple_norm(DATA2, stretch='linear', min_cut=1.)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), [0., 0., 1.], atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:        norm = simple_norm(DATA2, stretch='linear', percent=99.)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), DATA2SCL, atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:        norm2 = simple_norm(DATA2, stretch='linear', min_percent=0.5,\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), norm2(DATA2), atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:            simple_norm(DATA2, stretch='invalid')\nastropy\/visualization\/tests\/test_stretch.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_stretch.py:                       PowerDistStretch, SquaredStretch, LogStretch,\nastropy\/visualization\/tests\/test_stretch.py:DATA = np.array([0.00, 0.25, 0.50, 0.75, 1.00])\nastropy\/visualization\/tests\/test_stretch.py:RESULTS[PowerDistStretch()] = np.array([0., 0.004628, 0.030653, 0.177005, 1.])\nastropy\/visualization\/tests\/test_stretch.py:RESULTS[HistEqStretch(DATA)] = DATA\nastropy\/visualization\/tests\/test_stretch.py:RESULTS[HistEqStretch(DATA[::-1])] = DATA\nastropy\/visualization\/tests\/test_stretch.py:RESULTS[HistEqStretch(DATA ** 0.5)] = np.array([0., 0.125, 0.25, 0.5674767,\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch(DATA, clip=False),\nastropy\/visualization\/tests\/test_stretch.py:        new_shape = DATA.shape + (1,) * ndim\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch(DATA.reshape(new_shape),\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch(DATA, clip=True),\nastropy\/visualization\/tests\/test_stretch.py:        data_in = DATA.copy()\nastropy\/visualization\/tests\/test_stretch.py:        result = np.zeros(DATA.shape)\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(data_in, DATA)\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch.inverse(stretch(DATA, clip=False),\nastropy\/visualization\/tests\/test_stretch.py:                                                   clip=False), DATA)\nastropy\/visualization\/tests\/test_stretch.py:        result = np.zeros(DATA.shape)\nastropy\/visualization\/tests\/test_stretch.py:        stretch(DATA, out=result, clip=False)\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(result, DATA)\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch.inverse.inverse(DATA),\nastropy\/visualization\/tests\/test_stretch.py:                                   stretch(DATA), atol=1.e-6)\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch_1(DATA),\nastropy\/visualization\/tests\/test_stretch.py:                                   stretch_2(DATA))\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch_1(DATA),\nastropy\/visualization\/tests\/test_stretch.py:                                   stretch_2(DATA))\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch_1.inverse(DATA),\nastropy\/visualization\/tests\/test_stretch.py:                                   stretch_3(DATA))\nastropy\/visualization\/interval.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/interval.py:from ..utils.misc import InheritDocstrings\nastropy\/visualization\/interval.py:class BaseInterval(BaseTransform, metaclass=InheritDocstrings):\nastropy\/visualization\/interval.py:        The minimum value in the scaling.  Defaults to the image\nastropy\/visualization\/interval.py:        The maximum value in the scaling.  Defaults to the image\nastropy\/visualization\/interval.py:        # Determine values at percentiles\nastropy\/visualization\/interval.py:    Licensed under a 3-clause BSD style license (see AURA_LICENSE.rst).\nastropy\/visualization\/interval.py:        scaling factors.  Defaults to 1000.\nastropy\/visualization\/interval.py:        Defaults to 0.25.\nastropy\/visualization\/interval.py:        Defaults to 0.5.\nastropy\/visualization\/interval.py:        Defaults to 5.\nastropy\/visualization\/interval.py:        The number of sigma used for the rejection. Defaults to 2.5.\nastropy\/visualization\/interval.py:        The maximum number of iterations for the rejection. Defaults to\nastropy\/visualization\/interval.py:            # Detect and reject pixels further than k*sigma from the\nastropy\/visualization\/wcsaxes\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_lupton_rgb.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_lupton_rgb.py:from ...convolution import convolve, Gaussian2DKernel\nastropy\/visualization\/tests\/test_lupton_rgb.py:    \"\"\"Display an rgb image using matplotlib (useful for debugging)\"\"\"\nastropy\/visualization\/tests\/test_lupton_rgb.py:        psf = Gaussian2DKernel(2.5)\nastropy\/visualization\/tests\/test_lupton_rgb.py:        # TODO: Cannot test with these options yet, as that part of the code is not implemented.\nastropy\/visualization\/tests\/test_interval.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_interval.py:class TestInterval2D(TestInterval):\nastropy\/visualization\/tests\/test_interval.py:    # Don't accept integer array in output\nastropy\/visualization\/transform.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_histogram.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_representation_methods.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_representation_methods.py:                SphericalDifferential)\nastropy\/coordinates\/tests\/test_representation_methods.py:        self.diff = SphericalDifferential(\nastropy\/coordinates\/tests\/test_representation_methods.py:        # Doing it on the CartesianRepresentation just for variety's sake.\nastropy\/coordinates\/tests\/test_representation_methods.py:        # Do this on a copy, to keep self.s0 unchanged.\nastropy\/samp\/lockfile_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/lockfile_helpers.py:# TODO: this file should be refactored to use a more thread-safe and\nastropy\/samp\/lockfile_helpers.py:    os.chmod(lockfilename, stat.S_IREAD + stat.S_IWRITE)\nastropy\/samp\/lockfile_helpers.py:                             stat.S_IREAD + stat.S_IWRITE + stat.S_IEXEC)\nastropy\/samp\/lockfile_helpers.py:    # HUB SINGLE INSTANCE MODE\nastropy\/samp\/lockfile_helpers.py:    # HUB MULTIPLE INSTANCE MODE\nastropy\/samp\/lockfile_helpers.py:    # HUB SINGLE INSTANCE MODE\nastropy\/samp\/lockfile_helpers.py:    # HUB MULTIPLE INSTANCE MODE\nastropy\/coordinates\/tests\/test_regression.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_regression.py:from .test_matching import HAS_SCIPY, OLDER_SCIPY\nastropy\/coordinates\/tests\/test_regression.py:    # de = SkyCoord.from_name('Deneb')\nastropy\/coordinates\/tests\/test_regression.py:@pytest.mark.skipif(OLDER_SCIPY, reason='Scipy too old')\nastropy\/coordinates\/tests\/test_regression.py:    Dc = -0.065838*u.arcsec\nastropy\/coordinates\/tests\/test_regression.py:    Dd = +0.335299*u.arcsec\nastropy\/coordinates\/tests\/test_regression.py:    # Dc * tan(obliquity), as given on p.170\nastropy\/coordinates\/tests\/test_regression.py:    Dctano = -0.028553*u.arcsec\nastropy\/coordinates\/tests\/test_regression.py:    fk4noe_dec = (fk4.dec - (Dd*np.cos(fk4.ra) -\nastropy\/coordinates\/tests\/test_regression.py:                             Dc*np.sin(fk4.ra))*np.sin(fk4.dec) -\nastropy\/coordinates\/tests\/test_regression.py:                  Dctano*np.cos(fk4.dec))\nastropy\/coordinates\/tests\/test_regression.py:    fk4noe_ra = fk4.ra - (Dc*np.cos(fk4.ra) +\nastropy\/coordinates\/tests\/test_regression.py:                          Dd*np.sin(fk4.ra)) \/ np.cos(fk4.dec)\nastropy\/coordinates\/tests\/test_regression.py:    # ensure we can represent all Representations and transform to ND frames\nastropy\/coordinates\/tests\/test_regression.py:@pytest.mark.skipif(OLDER_SCIPY, reason='Scipy too old')\nastropy\/coordinates\/tests\/test_regression.py:@pytest.mark.skipif(OLDER_SCIPY, reason='Scipy too old')\nastropy\/coordinates\/tests\/test_regression.py:    from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/coordinates\/tests\/test_regression.py:            if issubclass(w.category, AstropyDeprecationWarning):\nastropy\/coordinates\/tests\/test_regression.py:            assert False, \"Deprecation warning not raised\"\nastropy\/coordinates\/tests\/test_regression.py:            if issubclass(w.category, AstropyDeprecationWarning):\nastropy\/coordinates\/tests\/test_regression.py:            assert False, \"Deprecation warning not raised\"\nastropy\/coordinates\/tests\/test_regression.py:            if issubclass(w.category, AstropyDeprecationWarning):\nastropy\/coordinates\/tests\/test_regression.py:            assert False, \"Deprecation warning not raised\"\nastropy\/coordinates\/tests\/test_distance.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_distance.py:This includes tests for the Distance class and related calculations\nastropy\/coordinates\/tests\/test_distance.py:from .. import Longitude, Latitude, Distance, CartesianRepresentation\nastropy\/coordinates\/tests\/test_distance.py:    Distances can also be specified, and allow for a full 3D definition of a\nastropy\/coordinates\/tests\/test_distance.py:    # try all the different ways to initialize a Distance\nastropy\/coordinates\/tests\/test_distance.py:    distance = Distance(12, u.parsec)\nastropy\/coordinates\/tests\/test_distance.py:    Distance(40, unit=u.au)\nastropy\/coordinates\/tests\/test_distance.py:    Distance(value=5, unit=u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:        Distance(12)\nastropy\/coordinates\/tests\/test_distance.py:    # 3D position\nastropy\/coordinates\/tests\/test_distance.py:                 distance=Distance(12, u.parsec))\nastropy\/coordinates\/tests\/test_distance.py:    # c.distance = Distance(z=0.2)  # uses current cosmology\nastropy\/coordinates\/tests\/test_distance.py:    # c.distance = Distance(z=0.2, cosmology=WMAP5)\nastropy\/coordinates\/tests\/test_distance.py:    assert isinstance(sep12, Distance)\nastropy\/coordinates\/tests\/test_distance.py:    # TODO: choose between these when CartesianRepresentation gets a definite\nastropy\/coordinates\/tests\/test_distance.py:    # try different ways to initialize a Distance\nastropy\/coordinates\/tests\/test_distance.py:    d4 = Distance(z=0.23)  # uses default cosmology - as of writing, WMAP7\nastropy\/coordinates\/tests\/test_distance.py:    d5 = Distance(z=0.23, cosmology=WMAP5)\nastropy\/coordinates\/tests\/test_distance.py:    d6 = Distance(z=0.23, cosmology=WMAP5, unit=u.km)\nastropy\/coordinates\/tests\/test_distance.py:    c1 = ICRS(ra, dec, Distance(1, unit=u.kpc))\nastropy\/coordinates\/tests\/test_distance.py:        c1.distance = Distance(2, unit=u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:    c2 = ICRS(ra, dec, Distance(2, unit=u.kpc))\nastropy\/coordinates\/tests\/test_distance.py:    Distance(2 * u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance([2, 3.1], u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance([2 * u.kpc, 250. * u.pc])\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance(10, u.pc)\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance(distmod=20)\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance(distmod=-1., unit=u.au)\nastropy\/coordinates\/tests\/test_distance.py:        d = Distance(value=d, distmod=20)\nastropy\/coordinates\/tests\/test_distance.py:        d = Distance(z=.23, distmod=20)\nastropy\/coordinates\/tests\/test_distance.py:    assert Distance(distmod=1).unit == u.pc\nastropy\/coordinates\/tests\/test_distance.py:    assert Distance(distmod=11).unit == u.kpc\nastropy\/coordinates\/tests\/test_distance.py:    assert Distance(distmod=26).unit == u.Mpc\nastropy\/coordinates\/tests\/test_distance.py:    assert Distance(distmod=-21).unit == u.AU\nastropy\/coordinates\/tests\/test_distance.py:    assert Distance(distmod=[1, 11, 26]).unit == u.kpc\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance(parallax=1*u.arcsecond)\nastropy\/coordinates\/tests\/test_distance.py:        d = Distance(15*u.pc, parallax=20*u.milliarcsecond)\nastropy\/coordinates\/tests\/test_distance.py:        d = Distance(parallax=20*u.milliarcsecond, distmod=20)\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance(parallax=plx)\nastropy\/coordinates\/tests\/test_distance.py:        Distance([-2, 3.1], u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:        Distance([-2, -3.1], u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:        Distance(-2, u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance(-2, u.kpc, allow_negative=True)\nastropy\/coordinates\/tests\/test_distance.py:    a = Distance(15*u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:    b = Distance(15*u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:    c = Distance(1.*u.Mpc)\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance(15*u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:    assert isinstance(twice, Distance)\nastropy\/coordinates\/tests\/test_distance.py:    assert not isinstance(area, Distance)\nastropy\/coordinates\/transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/transformations.py:from collections import defaultdict, OrderedDict\nastropy\/coordinates\/transformations.py:           'StaticMatrixTransform', 'DynamicMatrixTransform',\nastropy\/coordinates\/transformations.py:           'FunctionTransformWithFiniteDifference', 'CompositeTransform']\nastropy\/coordinates\/transformations.py:        # use Dijkstra's algorithm to find shortest path in all other cases\nastropy\/coordinates\/transformations.py:        # (used as edge weights in Dijkstra's algorithm)\nastropy\/coordinates\/transformations.py:        Converts this transform graph to the graphviz_ DOT format.\nastropy\/coordinates\/transformations.py:            graphviz_ for details) or 'plain' to just save the DOT graph\nastropy\/coordinates\/transformations.py:            blue, ``DynamicMatrixTransform``: green.\nastropy\/coordinates\/transformations.py:            A string with the DOT format graph.\nastropy\/coordinates\/transformations.py:# <-------------------Define the builtin transform classes-------------------->\nastropy\/coordinates\/transformations.py:        Does the actual coordinate transformation from the ``fromsys`` class to\nastropy\/coordinates\/transformations.py:class FunctionTransformWithFiniteDifference(FunctionTransform):\nastropy\/coordinates\/transformations.py:        :math:`\\frac{x(t + \\Delta t \/ 2) - x(t + \\Delta t \/ 2)}{\\Delta t}`, or\nastropy\/coordinates\/transformations.py:        if False, :math:`\\frac{x(t + \\Delta t) - x(t)}{\\Delta t}`.  The latter\nastropy\/coordinates\/transformations.py:                                     CartesianDifferential)\nastropy\/coordinates\/transformations.py:            newdiff = CartesianDifferential(diffxyz)\nastropy\/coordinates\/transformations.py:                                     CartesianDifferential,\nastropy\/coordinates\/transformations.py:                                     SphericalDifferential,\nastropy\/coordinates\/transformations.py:                                     SphericalCosLatDifferential,\nastropy\/coordinates\/transformations.py:                                     RadialDifferential)\nastropy\/coordinates\/transformations.py:        _unit_diffs = (SphericalDifferential._unit_differential,\nastropy\/coordinates\/transformations.py:                       SphericalCosLatDifferential._unit_differential)\nastropy\/coordinates\/transformations.py:                        isinstance(data.differentials['s'], RadialDifferential))\nastropy\/coordinates\/transformations.py:        # If it's a RadialDifferential, we flat-out ignore the differentials\nastropy\/coordinates\/transformations.py:        diffs = dict([(k, diff.represent_as(CartesianDifferential, data))\nastropy\/coordinates\/transformations.py:        # TODO: if we decide to allow arithmetic between representations that\nastropy\/coordinates\/transformations.py:        # having a RadialDifferential\nastropy\/coordinates\/transformations.py:        (optionally) an attached velocity ``CartesianDifferential`` to represent\nastropy\/coordinates\/transformations.py:    This is distinct from DynamicMatrixTransform in that this kind of matrix is\nastropy\/coordinates\/transformations.py:class DynamicMatrixTransform(BaseAffineTransform):\nastropy\/coordinates\/transformations.py:            # TODO: caching this information when creating the transform may\nastropy\/coordinates\/transformations.py:trans_to_color = OrderedDict()\nastropy\/coordinates\/transformations.py:trans_to_color[FunctionTransformWithFiniteDifference] = '#d95f02'  # red-ish\nastropy\/coordinates\/transformations.py:trans_to_color[DynamicMatrixTransform] = '#1b9e77'  # green-ish\nastropy\/coordinates\/tests\/test_sites.py:    assert exc.value.args[0] == \"Site 'kec' not in database. Use the 'names' attribute to see available sites. Did you mean one of: 'keck'?'\"\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:MOONDIST = 385000*u.km  # approximate moon semi-major orbit axis of moon\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:MOONDIST_CART = CartesianRepresentation(3**-0.5*MOONDIST, 3**-0.5*MOONDIST, 3**-0.5*MOONDIST)\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    moon = GCRS(MOONDIST_CART, obstime=testframe.obstime)\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    moon = GCRS(MOONDIST_CART, obstime=testframe.obstime)\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    moon = CIRS(MOONDIST_CART, obstime=testframe.obstime)\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    moonish = CIRS(MOONDIST_CART, obstime=testframe.obstime)\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    moonish = GCRS(MOONDIST_CART, obstime=testframe.obstime)\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    moonoffset = [0, 0, MOONDIST.value]*MOONDIST.unit\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    assert 1000*u.km < np.abs(moonaa.distance - MOONDIST).to(u.au) < 7000*u.km\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    Moon positions were originally created using JPL DE432s ephemeris.\nastropy\/coordinates\/tests\/test_shape_manipulation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_angular_separation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_angular_separation.py:from .. import Angle, Distance\nastropy\/coordinates\/tests\/test_angular_separation.py:    Test 3D separation functionality\nastropy\/coordinates\/tests\/test_angular_separation.py:    assert isinstance(sep3d, Distance)\nastropy\/visualization\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_units.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_matching.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_matching.py:    OLDER_SCIPY = False\nastropy\/coordinates\/tests\/test_matching.py:    OLDER_SCIPY = True\nastropy\/coordinates\/tests\/test_matching.py:    assert 'KD' in e.value.args[0]\nastropy\/coordinates\/tests\/test_matching.py:@pytest.mark.skipif(str('OLDER_SCIPY'))\nastropy\/coordinates\/tests\/test_matching.py:@pytest.mark.skipif(str('OLDER_SCIPY'))\nastropy\/coordinates\/tests\/test_matching.py:@pytest.mark.skipif(str('OLDER_SCIPY'))\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:TARGET_HEADER = fits.Header.fromstring(\"\"\"\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:CDELT1  =                 -0.4\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:CTYPE2  = 'DEC--MOL'\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:CDELT2  =                  0.4\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:COORDSYS= 'icrs    '\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:    ax = plt.subplot(1, 1, 1, projection=WCS(TARGET_HEADER))\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:    ax = plt.subplot(1, 1, 1, projection=WCS(TARGET_HEADER))\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:    ax = plt.subplot(1, 1, 1, projection=WCS(TARGET_HEADER))\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:GAL_HEADER = fits.Header.fromstring(\"\"\"\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:EXTEND  =                    T\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:CTYPE1  = 'DISTMOD '\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:CDELT1  =                  0.5\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:CDELT2  =               -0.125\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:CDELT3  =                0.125\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:    wcs3d = WCS(GAL_HEADER)\nastropy\/coordinates\/tests\/test_earth.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_earth.py:from ..earth import EarthLocation, ELLIPSOIDS\nastropy\/coordinates\/tests\/test_earth.py:    @pytest.mark.parametrize('ellipsoid', ELLIPSOIDS)\nastropy\/coordinates\/tests\/test_celestial_transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_celestial_transformations.py:from ..distances import Distance\nastropy\/coordinates\/tests\/test_celestial_transformations.py:m31_dist = Distance(770, u.kpc)\nastropy\/coordinates\/tests\/test_celestial_transformations.py:    catalog location of M31 from NED.\nastropy\/coordinates\/tests\/test_celestial_transformations.py:    # check that ND arrays work\nastropy\/coordinates\/tests\/test_api_ape5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_api_ape5.py:    from ... coordinates import Angle, Longitude, Latitude, Distance\nastropy\/coordinates\/tests\/test_api_ape5.py:    # Distance is optional.\nastropy\/coordinates\/tests\/test_api_ape5.py:    SphericalRepresentation(Longitude(8, u.hour), Latitude(5, u.deg), Distance(10, u.kpc))\nastropy\/coordinates\/tests\/test_api_ape5.py:    # Default is to copy arrays, but optionally, it can be a reference\nastropy\/coordinates\/tests\/test_api_ape5.py:    # converted to Angle\/Distance\nastropy\/coordinates\/tests\/test_api_ape5.py:    assert isinstance(c1.distance, Distance)\nastropy\/coordinates\/tests\/test_api_ape5.py:    c2.lat[:] = [0] * u.deg  # possible, but NOT SUPPORTED\nastropy\/coordinates\/tests\/test_api_ape5.py:    # Dec. This works simply as a shorthand for the longer form above\nastropy\/coordinates\/tests\/test_api_ape5.py:    # while `separation_3d` includes the 3D distance information\nastropy\/coordinates\/tests\/test_api_ape5.py:    from ..transformations import DynamicMatrixTransform\nastropy\/coordinates\/tests\/test_api_ape5.py:    # it's a *different* RA and Dec\nastropy\/coordinates\/tests\/test_api_ape5.py:    @frame_transform_graph.transform(DynamicMatrixTransform, SomeNewSystem, FK5)\nastropy\/coordinates\/tests\/test_api_ape5.py:    # sc = coords.SkyCoord('SDSS J123456.89-012345.6', frame='icrs')\nastropy\/coordinates\/tests\/test_api_ape5.py:    # assert str(m31icrs) == '<SkyCoord (ICRS) RA=10.68471 deg, Dec=41.26875 deg>'\nastropy\/coordinates\/tests\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_iau_fullstack.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_iau_fullstack.py:    assert np.all(addecs < tol), 'largest Dec change is {0} mas, > {1}'.format(np.max(addecs.arcsec*1000), tol)\nastropy\/coordinates\/earth_orientation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/earth_orientation.py:    Eccentricity of the Earth's orbit at the requested Julian Date.\nastropy\/coordinates\/earth_orientation.py:    requested Julian Date.\nastropy\/coordinates\/earth_orientation.py:    Computes the obliquity of the Earth at the requested Julian Date.\nastropy\/coordinates\/earth_orientation.py:    * Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351. 2000\nastropy\/coordinates\/earth_orientation.py:# TODO: replace this with SOFA equivalent\nastropy\/coordinates\/earth_orientation.py:                  ('nD', int),\nastropy\/coordinates\/earth_orientation.py:                  ('nD', int),\nastropy\/coordinates\/earth_orientation.py:#l lprime F D Omega longitude_sin longitude_sin*t longitude_cos obliquity_cos obliquity_cos*t,obliquity_sin\nastropy\/coordinates\/earth_orientation.py:# TODO: replace w\/SOFA equivalent\nastropy\/coordinates\/earth_orientation.py:        epoch at which to compute the nutation components as a JD\nastropy\/coordinates\/earth_orientation.py:    # Fundamental (Delaunay) arguments from Simon et al. (1994) via SOFA\nastropy\/coordinates\/earth_orientation.py:    D = ((1072260.70369 + 1602961601.2090 * t) % 1296000) \/ _asecperrad\nastropy\/coordinates\/earth_orientation.py:    arg = dat.nl * el + dat.nlp * elp + dat.nF * F + dat.nD * D + dat.nOm * Om\nastropy\/coordinates\/earth_orientation.py:    # TODO: implement higher precision 2006\/2000A model if requested\/needed\nastropy\/coordinates\/tests\/test_matrix_utilities.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_atc_replacements.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_frames.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_frames.py:from ...utils import OrderedDescriptorContainer\nastropy\/coordinates\/tests\/test_frames.py:    class TestAttributes(metaclass=OrderedDescriptorContainer):\nastropy\/coordinates\/tests\/test_frames.py:    # Defaults\nastropy\/coordinates\/tests\/test_frames.py:    assert isinstance(rep2.differentials['s'], r.CylindricalDifferential)\nastropy\/coordinates\/tests\/test_frames.py:    # TODO: this should probably fail in the future once we figure out a better\nastropy\/coordinates\/tests\/test_frames.py:    # RadialDifferential's\nastropy\/coordinates\/tests\/test_frames.py:    #                          r.SphericalCosLatDifferential)\nastropy\/coordinates\/tests\/test_frames.py:    # assert isinstance(rep2.differentials['s'], r.SphericalCosLatDifferential)\nastropy\/coordinates\/tests\/test_frames.py:    dif = r.CartesianDifferential([1, 2, 3]*u.km\/u.s)\nastropy\/coordinates\/tests\/test_frames.py:    assert isinstance(sph.differentials['s'], r.SphericalDifferential)\nastropy\/coordinates\/tests\/test_frames.py:    assert isinstance(sph.differentials['s'], r.SphericalCosLatDifferential)\nastropy\/coordinates\/tests\/test_frames.py:    dif1 = r.CartesianDifferential([1, 2, 3]*u.km\/u.s)\nastropy\/coordinates\/tests\/test_frames.py:    dif2 = r.CartesianDifferential([1, 2, 3]*u.km\/u.s**2)\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:                FunctionTransformWithFiniteDifference, get_sun,\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:                CartesianDifferential, SphericalDifferential,\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:                DynamicMatrixTransform)\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:    @frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:    @frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:    @frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:        trans = DynamicMatrixTransform(fk5_to_gal, FK5, Galactic2)\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:    @frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:        trans = DynamicMatrixTransform(_gal_to_fk5, Galactic2, FK5)\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:    cdiff = acoo.data.differentials['s'].represent_as(CartesianDifferential,\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:                                      # TODO:  make these not fail when the\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:    sd = frame.data.differentials['s'].represent_as(SphericalDifferential, frame.data)\nastropy\/coordinates\/tests\/test_arrays.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_arrays.py:    Test transformation on coordinates with array content (first length-2 1D, then a 3D array)\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:from ..distances import Distance\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:    # Dec rotations\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:    # Done in xyz space because dec must be [-90,90]\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:m31_dist = Distance(770, u.kpc)\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:    catalog location of M31 from NED, via SkyOffsetFrames\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:    # TODO: remove this when the SkyOffsetFrame's support velocities\nastropy\/coordinates\/tests\/test_name_resolve.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_name_resolve.py:%V z 1593 0.005327 [0.000060] D 2002LEDA.........0P\nastropy\/coordinates\/tests\/test_name_resolve.py:%D 1.673 1.657 75 (32767) (I) C 2006AJ....131.1163S\nastropy\/coordinates\/tests\/test_name_resolve.py:%T 5 =32800000 D 2011A&A...532A..74B\nastropy\/coordinates\/tests\/test_name_resolve.py:#====Done (2013-Feb-12,16:37:11z)====\"\"\"\nastropy\/coordinates\/tests\/test_name_resolve.py:#====Done (2013-Feb-12,16:37:42z)====\"\"\"\nastropy\/coordinates\/tests\/test_name_resolve.py:%V z 1593 0.005327 [0.000060] D 2002LEDA.........0P\nastropy\/coordinates\/tests\/test_name_resolve.py:%D 1.673 1.657 75 (32767) (I) C 2006AJ....131.1163S\nastropy\/coordinates\/tests\/test_name_resolve.py:%T 5 =32800000 D 2011A&A...532A..74B\nastropy\/coordinates\/tests\/test_name_resolve.py:#!N=NED : *** Could not access the server ***\nastropy\/coordinates\/tests\/test_name_resolve.py:#====Done (2013-Feb-12,16:39:48z)====\"\"\"\nastropy\/coordinates\/tests\/test_name_resolve.py:%S A1V+A2Vm =0.0000D200.0030.0110000000100000 C 2001AJ....122.3466M\nastropy\/coordinates\/tests\/test_name_resolve.py:#!N=NED: ****object name not recognized by NED name interpreter\nastropy\/coordinates\/tests\/test_name_resolve.py:#!N=NED: ***Not recognized by NED: castor\nastropy\/coordinates\/tests\/test_name_resolve.py:#====Done (2013-Feb-12,16:52:02z)====\"\"\"\nastropy\/coordinates\/tests\/test_name_resolve.py:%S A1V+A2Vm =0.0000D200.0030.0110000000100000 C 2001AJ....122.3466M\nastropy\/coordinates\/tests\/test_name_resolve.py:#====Done (2013-Feb-12,17:00:39z)====\"\"\"\nastropy\/coordinates\/tests\/test_pickle.py:          coord.Distance,\nastropy\/coordinates\/tests\/test_pickle.py:          coord.DynamicMatrixTransform,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                UnitSphericalRepresentation, SphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                CartesianDifferential, UnitSphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                SphericalCosLatDifferential, UnitSphericalCosLatDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                PhysicsSphericalDifferential, CylindricalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                RadialRepresentation, RadialDifferential, Longitude, Latitude)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:from ..representation import DIFFERENTIAL_CLASSES\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        # work on multi-D representations.\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:class TestSphericalDifferential():\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    # these test cases are subclassed for SphericalCosLatDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls = SphericalCosLatDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls = SphericalDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.SD_cls is SphericalCosLatDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.SD_cls.get_name() == 'sphericalcoslat'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.SD_cls is SphericalDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.SD_cls.get_name() == 'spherical'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert self.SD_cls.get_name() in DIFFERENTIAL_CLASSES\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon = self.SD_cls(1.*u.arcsec, 0.*u.arcsec, 0.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon2 = self.SD_cls.from_cartesian(o_lonc, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lat = self.SD_cls(0.*u.arcsec, 1.*u.arcsec, 0.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_distance = self.SD_cls(0.*u.arcsec, 0.*u.arcsec, 1.*u.mpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon = self.SD_cls(1.*u.arcsec, 0.*u.arcsec, 0.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon2 = self.SD_cls(1*u.mas\/u.yr, 0*u.mas\/u.yr, 0*u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon3 = self.SD_cls.from_cartesian(o_lon3c, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        expected0 = self.SD_cls(1.*u.mas\/u.yr, 0.*u.mas\/u.yr, 0.*u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls(1.*u.arcsec, 0., 0.)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls(1.*u.arcsec, 0.*u.arcsec, 0.*u.kpc,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls(1.*u.arcsec, 0.*u.arcsec, 0.*u.kpc,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls(1.*u.arcsec, 0.*u.arcsec, 0.*u.kpc,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls(np.ones(2)*u.arcsec,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls(1.*u.arcsec, 1.*u.s, 0.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls(1.*u.kpc, 1.*u.arcsec, 0.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o = self.SD_cls(1.*u.arcsec, 1.*u.arcsec, 0.*u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o = self.SD_cls(1.*u.arcsec, 1.*u.arcsec, 0.*u.km)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls.to_cartesian(c)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls.from_cartesian(c)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls.from_cartesian(c, SphericalRepresentation)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls.from_cartesian(c, c)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:class TestUnitSphericalDifferential():\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.USD_cls = UnitSphericalCosLatDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.USD_cls = UnitSphericalDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.USD_cls is UnitSphericalCosLatDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.USD_cls.get_name() == 'unitsphericalcoslat'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.USD_cls is UnitSphericalDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.USD_cls.get_name() == 'unitspherical'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert self.USD_cls.get_name() in DIFFERENTIAL_CLASSES\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon = self.USD_cls(1.*u.arcsec, 0.*u.arcsec)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon2 = self.USD_cls.from_cartesian(o_lonc, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lat = self.USD_cls(0.*u.arcsec, 1.*u.arcsec)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon = self.USD_cls(1.*u.arcsec, 0.*u.arcsec)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert type(o_lon_by_2) is self.USD_cls\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert type(o_lon_rec) is self.USD_cls\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert type(o_lon_0) is self.USD_cls\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon2 = self.USD_cls(1.*u.mas\/u.yr, 0.*u.mas\/u.yr)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon3 = self.USD_cls.from_cartesian(o_lon3c, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        expected0 = self.USD_cls(1.*u.mas\/u.yr, 0.*u.mas\/u.yr)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.USD_cls(0.*u.deg, 10.*u.deg\/u.yr)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:class TestRadialDifferential():\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert RadialDifferential.get_name() == 'radial'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert RadialDifferential.get_name() in DIFFERENTIAL_CLASSES\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_distance = RadialDifferential(1.*u.mpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_recover = RadialDifferential.from_cartesian(o_distancec, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:class TestPhysicsSphericalDifferential():\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    \"\"\"Test copied from SphericalDifferential, so less extensive.\"\"\"\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert PhysicsSphericalDifferential.get_name() == 'physicsspherical'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert PhysicsSphericalDifferential.get_name() in DIFFERENTIAL_CLASSES\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_phi = PhysicsSphericalDifferential(1*u.arcsec, 0*u.arcsec, 0*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_phi2 = PhysicsSphericalDifferential.from_cartesian(o_phic, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_theta = PhysicsSphericalDifferential(0*u.arcsec, 1*u.arcsec, 0*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_r = PhysicsSphericalDifferential(0*u.arcsec, 0*u.arcsec, 1*u.mpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            PhysicsSphericalDifferential(1.*u.arcsec, 0., 0.)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:class TestCylindricalDifferential():\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    \"\"\"Test copied from SphericalDifferential, so less extensive.\"\"\"\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert CylindricalDifferential.get_name() == 'cylindrical'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert CylindricalDifferential.get_name() in DIFFERENTIAL_CLASSES\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_rho = CylindricalDifferential(1.*u.mpc, 0.*u.arcsec, 0.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_phi = CylindricalDifferential(0.*u.kpc, 1.*u.arcsec, 0.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_phi2 = CylindricalDifferential.from_cartesian(o_phic, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_z = CylindricalDifferential(0.*u.kpc, 0.*u.arcsec, 1.*u.mpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            CylindricalDifferential(1.*u.pc, 1.*u.arcsec, 3.*u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:class TestCartesianDifferential():\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    \"\"\"Test copied from SphericalDifferential, so less extensive.\"\"\"\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert CartesianDifferential.get_name() == 'cartesian'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert CartesianDifferential.get_name() in DIFFERENTIAL_CLASSES\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                ('x', CartesianDifferential(1.*u.pc, 0.*u.pc, 0.*u.pc)),\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                ('y', CartesianDifferential([0., 1., 0.], unit=u.pc)),\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                ('z', CartesianDifferential(np.array([[0., 0., 1.]]) * u.pc,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            differential2 = CartesianDifferential.from_cartesian(o_c)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            differential3 = CartesianDifferential.from_cartesian(o_c, base=o_c)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            CartesianDifferential(1.*u.kpc\/u.s, 2.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            CartesianDifferential(1.*u.kpc\/u.s, 2.*u.kpc, 3.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            CartesianDifferential(1.*u.kpc, 2.*u.kpc, 3.*u.kpc, xyz_axis=1)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:class TestDifferentialConversion():\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    @pytest.mark.parametrize('sd_cls', [SphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                                        SphericalCosLatDifferential])\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        so = SphericalDifferential(1.*u.deg, 2.*u.deg, 0.1*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        so_coslat = so.represent_as(SphericalCosLatDifferential, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        so2 = so_coslat.represent_as(SphericalDifferential, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        so3 = SphericalDifferential.from_representation(so_coslat, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        so_coslat2 = SphericalCosLatDifferential.from_representation(so, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        uo = so.represent_as(UnitSphericalDifferential)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        uo_coslat = so.represent_as(UnitSphericalCosLatDifferential, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        uo2 = uo_coslat.represent_as(UnitSphericalDifferential, base=us)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        uo3 = UnitSphericalDifferential.from_representation(uo_coslat, base=us)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        uo_coslat2 = UnitSphericalCosLatDifferential.from_representation(\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        uo_coslat3 = uo.represent_as(UnitSphericalCosLatDifferential, base=us)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    @pytest.mark.parametrize('sd_cls', [SphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                                        SphericalCosLatDifferential])\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    @pytest.mark.parametrize('sd_cls', [SphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                                        SphericalCosLatDifferential])\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        # Conversion needs no base for SphericalDifferential, but does\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        # need one (to get the latitude) for SphericalCosLatDifferential.\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        if sd_cls is SphericalDifferential:\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            usd_cls = UnitSphericalDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            usd_cls = UnitSphericalCosLatDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        po = so.represent_as(PhysicsSphericalDifferential, base=base_s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        po2 = PhysicsSphericalDifferential.from_representation(so, base=base_p)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        po2 = so.represent_as(PhysicsSphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        sro = RadialDifferential.from_representation(so)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        pro = RadialDifferential.from_representation(po)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        sro2 = so.represent_as(RadialDifferential)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        pro2 = po.represent_as(RadialDifferential)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        [(SphericalDifferential, UnitSphericalDifferential),\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:         (SphericalCosLatDifferential, UnitSphericalCosLatDifferential)])\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        ro_r = so1.represent_as(RadialDifferential)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert np.all(representation_equal(ro_r, RadialDifferential(5.*u.pc)))\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    @pytest.mark.parametrize('sd_cls', [SphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                                        SphericalCosLatDifferential])\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        cyo = so.represent_as(CylindricalDifferential, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        cyo2 = CylindricalDifferential.from_representation(so, base=cy)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    @pytest.mark.parametrize('sd_cls', [SphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                                        SphericalCosLatDifferential])\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        if sd_cls is SphericalDifferential:\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            uo = UnitSphericalDifferential(2.*u.deg, 1.*u.deg)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            uo = UnitSphericalCosLatDifferential(2.*u.deg, 1.*u.deg)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        ro = RadialDifferential(1.*u.mpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:     CartesianDifferential([.1, .2, .3]*u.km\/u.s)],\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:     SphericalDifferential(1.*u.deg, 2.*u.deg, 0.1*u.kpc)]\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:       R            D            pmRA     pmDE                               Di      pmGLon   pmGLat   RV      U      V      W\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:                differential_cls=r.UnitSphericalDifferential)\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:                differential_cls={'s': r.UnitSphericalDifferential})\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:    icrs.set_representation_cls(s=r.UnitSphericalDifferential)\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:             differential_cls=r.CartesianDifferential)\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:                differential_cls=r.CartesianDifferential)\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:                 differential_cls=r.CartesianDifferential)\nastropy\/modeling\/rotations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/rotations.py:__all__ = ['RotateCelestial2Native', 'RotateNative2Celestial', 'Rotation2D',\nastropy\/modeling\/rotations.py:        where each character denotes an axis in 3D space.\nastropy\/modeling\/rotations.py:class Rotation2D(Model):\nastropy\/modeling\/rotations.py:    Perform a 2D rotation given an angle.\nastropy\/modeling\/rotations.py:        # 1-element 1-D array on output for consistency with most other models\nastropy\/coordinates\/tests\/test_representation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_representation.py:from collections import OrderedDict\nastropy\/coordinates\/tests\/test_representation.py:from ..distances import Distance\nastropy\/coordinates\/tests\/test_representation.py:                              DIFFERENTIAL_CLASSES,\nastropy\/coordinates\/tests\/test_representation.py:                              SphericalCosLatDifferential,\nastropy\/coordinates\/tests\/test_representation.py:                              CartesianDifferential,\nastropy\/coordinates\/tests\/test_representation.py:                              SphericalDifferential,\nastropy\/coordinates\/tests\/test_representation.py:#   the test file doesn't add a persistent test subclass (LogDRepresentation)\nastropy\/coordinates\/tests\/test_representation.py:        assert isinstance(s3.distance, Distance)\nastropy\/coordinates\/tests\/test_representation.py:                                     Distance(10, u.kpc))\nastropy\/coordinates\/tests\/test_representation.py:        assert isinstance(s2.distance, Distance)\nastropy\/coordinates\/tests\/test_representation.py:                                     Distance(1., u.Rsun))\nastropy\/coordinates\/tests\/test_representation.py:        assert isinstance(s1.distance, Distance)\nastropy\/coordinates\/tests\/test_representation.py:        distance = Distance([1, 2] * u.kpc)\nastropy\/coordinates\/tests\/test_representation.py:        assert isinstance(s3.r, Distance)\nastropy\/coordinates\/tests\/test_representation.py:                                            Distance(10, u.kpc))\nastropy\/coordinates\/tests\/test_representation.py:        assert isinstance(s2.r, Distance)\nastropy\/coordinates\/tests\/test_representation.py:        assert isinstance(s1.r, Distance)\nastropy\/coordinates\/tests\/test_representation.py:        r = Distance([1, 2] * u.kpc)\nastropy\/coordinates\/tests\/test_representation.py:        attr_classes = OrderedDict([('lon', Longitude180),\nastropy\/coordinates\/tests\/test_representation.py:    class LogDRepresentation(BaseRepresentation):\nastropy\/coordinates\/tests\/test_representation.py:        attr_classes = OrderedDict([('lon', Longitude),\nastropy\/coordinates\/tests\/test_representation.py:                                    ('logd', u.Dex)])\nastropy\/coordinates\/tests\/test_representation.py:            return cls(lon=lon, lat=lat, logd=u.Dex(r), copy=False)\nastropy\/coordinates\/tests\/test_representation.py:    ld1 = LogDRepresentation(90.*u.deg, 0.*u.deg, 1.*u.dex(u.kpc))\nastropy\/coordinates\/tests\/test_representation.py:    ld2 = LogDRepresentation(lon=90.*u.deg, lat=0.*u.deg, logd=1.*u.dex(u.kpc))\nastropy\/coordinates\/tests\/test_representation.py:    ld3 = LogDRepresentation.from_cartesian(c)\nastropy\/coordinates\/tests\/test_representation.py:        LogDRepresentation(0.*u.deg, 1.*u.deg)\nastropy\/coordinates\/tests\/test_representation.py:        LogDRepresentation(0.*u.deg, 1.*u.deg, 1.*u.dex(u.kpc), lon=1.*u.deg)\nastropy\/coordinates\/tests\/test_representation.py:        LogDRepresentation(0.*u.deg, 1.*u.deg, 1.*u.dex(u.kpc), True, False)\nastropy\/coordinates\/tests\/test_representation.py:        LogDRepresentation(0.*u.deg, 1.*u.deg, 1.*u.dex(u.kpc), foo='bar')\nastropy\/coordinates\/tests\/test_representation.py:        class LogDRepresentation(BaseRepresentation):\nastropy\/coordinates\/tests\/test_representation.py:            attr_classes = OrderedDict([('lon', Longitude),\nastropy\/coordinates\/tests\/test_representation.py:                                        ('logr', u.Dex)])\nastropy\/coordinates\/tests\/test_representation.py:class TestCartesianRepresentationWithDifferential:\nastropy\/coordinates\/tests\/test_representation.py:        diff = CartesianDifferential(d_x=1 * u.km\/u.s,\nastropy\/coordinates\/tests\/test_representation.py:            CartesianDifferential(d_x=1 * u.km\/u.s, d_y=2 * u.km\/u.s,\nastropy\/coordinates\/tests\/test_representation.py:        # TODO: more extensive checking of this\nastropy\/coordinates\/tests\/test_representation.py:        diff = SphericalDifferential(d_lon=1 * u.mas\/u.yr,\nastropy\/coordinates\/tests\/test_representation.py:        diff = SphericalCosLatDifferential(d_lon_coslat=1 * u.mas\/u.yr,\nastropy\/coordinates\/tests\/test_representation.py:        d1 = CartesianDifferential(*[1, 2, 3] * u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation.py:        d2 = CartesianDifferential(*[4, 5, 6] * u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation.py:        diff = CartesianDifferential(d_x=arr1, d_y=arr1, d_z=arr1)\nastropy\/coordinates\/tests\/test_representation.py:        diff = SphericalCosLatDifferential(d_lon_coslat=1 * u.mas\/u.yr,\nastropy\/coordinates\/tests\/test_representation.py:        diff = CartesianDifferential(d_x=1 * u.km\/u.s,\nastropy\/coordinates\/tests\/test_representation.py:                                    SphericalCosLatDifferential)\nastropy\/coordinates\/tests\/test_representation.py:                                    {'s': SphericalCosLatDifferential})\nastropy\/coordinates\/tests\/test_representation.py:                # TODO: Converting a CartesianDifferential to a\nastropy\/coordinates\/tests\/test_representation.py:                #       RadialDifferential fails, even on `master`\nastropy\/coordinates\/tests\/test_representation.py:                                        DIFFERENTIAL_CLASSES[name])\nastropy\/coordinates\/tests\/test_representation.py:        d = CartesianDifferential(d_x=np.arange(10) * u.m\/u.s,\nastropy\/coordinates\/tests\/test_representation.py:        d1 = CartesianDifferential(d_x=[1, 2] * u.km\/u.s,\nastropy\/coordinates\/tests\/test_representation.py:        diff = CartesianDifferential([.1, .2, .3]*u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation.py:        diff2 = CartesianDifferential([.1, .2, .3]*u.m\/u.s)\nastropy\/coordinates\/tests\/test_representation.py:        d1 = CartesianDifferential(*np.random.random((3, 5)), unit=u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation.py:        d2 = CartesianDifferential(*np.random.random((3, 5)), unit=u.km\/u.s**2)\nastropy\/coordinates\/tests\/test_representation.py:    diff = CartesianDifferential([.1, .2, .3]*u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation.py:    sd = SphericalDifferential(d_lat=1*u.deg, d_lon=2*u.deg, d_distance=10*u.m)\nastropy\/modeling\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/__init__.py:performing model evaluation and fitting. It supports 1D and 2D models\nastropy\/coordinates\/tests\/test_transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_transformations.py:    trans2 = t.DynamicMatrixTransform(matfunc, TCoo1, TCoo2)\nastropy\/coordinates\/tests\/test_transformations.py:    dif = r.CartesianDifferential(*np.arange(3, 6)*u.pc\/u.Myr)\nastropy\/coordinates\/tests\/test_transformations.py:                              differentials=r.CartesianDifferential(8, 9, 10,\nastropy\/coordinates\/tests\/test_transformations.py:                              differentials=r.CartesianDifferential(8, 9, 10,\nastropy\/coordinates\/tests\/test_transformations.py:     .represent_as(r.CylindricalRepresentation, r.CylindricalDifferential)\nastropy\/coordinates\/tests\/test_transformations.py:    diffs = dict([(k, diff.represent_as(r.CartesianDifferential, rep))\nastropy\/coordinates\/tests\/test_transformations.py:    diff = r.CartesianDifferential(8, 9, 10, unit=u.pc\/u.Myr)\nastropy\/coordinates\/tests\/test_transformations.py:    dif1 = r.CartesianDifferential(*np.arange(3, 6)*u.pc\/u.Myr)\nastropy\/coordinates\/tests\/test_transformations.py:    dif2 = r.CartesianDifferential(*np.arange(3, 6)*u.pc\/u.Myr**2)\nastropy\/coordinates\/tests\/test_transformations.py:        differentials=r.SphericalDifferential(d_lon=15*u.mas\/u.yr,\nastropy\/coordinates\/tests\/test_transformations.py:        differentials={'s': r.RadialDifferential(d_distance=-110*u.km\/u.s)}),\nastropy\/coordinates\/tests\/test_transformations.py:        differentials={'s': r.RadialDifferential(d_distance=-110*u.km\/u.s)})\nastropy\/coordinates\/tests\/test_transformations.py:    if isinstance(rep.differentials['s'], r.RadialDifferential):\nastropy\/coordinates\/tests\/test_transformations.py:    # TODO: replace after a final decision on PR #6280\nastropy\/coordinates\/tests\/test_transformations.py:    diff = r.CartesianDifferential([.1, .2, .3]*u.km\/u.s)\nastropy\/modeling\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/utils.py:__all__ = ['ExpressionTree', 'AliasDict', 'check_broadcast',\nastropy\/modeling\/utils.py:        TODO: Document this better.\nastropy\/modeling\/utils.py:                    # TODO: Explain and\/or refactor this better\nastropy\/modeling\/utils.py:class AliasDict(MutableMapping):\nastropy\/modeling\/utils.py:    >>> alias_dict = AliasDict(parent, aliases)\nastropy\/modeling\/utils.py:    In particular, updates on the `AliasDict` to a key that is equal to\nastropy\/modeling\/utils.py:    assigning to a key ``'a'`` on the `AliasDict` does not impact the\nastropy\/modeling\/utils.py:    storage, for example an `OrderedDict`.  However, even in this case\nastropy\/modeling\/utils.py:        # TODO:\nastropy\/modeling\/utils.py:    for example `~astropy.modeling.models.Gaussian1D.bounding_box`).\nastropy\/modeling\/utils.py:        of lower and upper bounds for 1-D models, or an N-tuple of 2-tuples\nastropy\/modeling\/utils.py:        for N-D models.\nastropy\/modeling\/utils.py:        ensure it is always an N-tuple (even for the 1-D case).\nastropy\/modeling\/utils.py:    Calculates the extent of a box encapsulating a rotated 2D ellipse.\nastropy\/modeling\/utils.py:        from astropy.modeling.models import Ellipse2D\nastropy\/modeling\/utils.py:        model = Ellipse2D(amplitude, x0, y0, a, b, theta)\nastropy\/modeling\/utils.py:        if param.kind in (param.VAR_POSITIONAL, param.VAR_KEYWORD):\nastropy\/coordinates\/tests\/accuracy\/test_galactic_fk4.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/accuracy\/test_fk4_no_e_fk4.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/accuracy\/test_fk4_no_e_fk5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/accuracy\/test_ecliptic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/accuracy\/test_ecliptic.py:    # this is 1D so we allow it to be somewhat smaller\nastropy\/coordinates\/tests\/test_funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_velocity_corrs.py:    ##   HJD          VOBS   VHELIO     VLSR   VDIURNAL   VLUNAR  VANNUAL   VSOLAR\nastropy\/modeling\/projections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/projections.py:    'COD', 'COO', 'BON', 'PCO', 'TSC', 'CSC', 'QSC', 'HPX', 'XPH'\nastropy\/modeling\/projections.py:           'AffineTransformation2D',\nastropy\/modeling\/projections.py:           'Pix2Sky_COD', 'Sky2Pix_COD',\nastropy\/modeling\/projections.py:        Distance from point of projection to center of sphere\nastropy\/modeling\/projections.py:        in spherical radii, \u03bc.  Default is 0.\nastropy\/modeling\/projections.py:        Look angle \u03b3 in degrees.  Default is 0\u00b0.\nastropy\/modeling\/projections.py:        # TODO: Support quantity objects here and in similar contexts\nastropy\/modeling\/projections.py:        Distance from point of projection to center of sphere\nastropy\/modeling\/projections.py:        in spherical radii, \u03bc. Default is 0.\nastropy\/modeling\/projections.py:        Look angle \u03b3 in degrees. Default is 0\u00b0.\nastropy\/modeling\/projections.py:        Distance from point of projection to center of sphere\nastropy\/modeling\/projections.py:        in spherical radii, \u03bc.  Default is 0.\nastropy\/modeling\/projections.py:        The longitude \u03c6\u2080 of the reference point, in degrees.  Default\nastropy\/modeling\/projections.py:        The latitude \u03b8\u2080 of the reference point, in degrees.  Default\nastropy\/modeling\/projections.py:        in spherical radii, \u03bc.  Default is 0.\nastropy\/modeling\/projections.py:        The longitude \u03c6\u2080 of the reference point, in degrees.  Default\nastropy\/modeling\/projections.py:        The latitude \u03b8\u2080 of the reference point, in degrees.  Default\nastropy\/modeling\/projections.py:        Obliqueness parameter, \u03be.  Default is 0.0.\nastropy\/modeling\/projections.py:        Obliqueness parameter, \u03b7.  Default is 0.0.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90\u00b0.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90\u00b0.\nastropy\/modeling\/projections.py:        Distance from center of sphere in the direction opposite the\nastropy\/modeling\/projections.py:        projected surface, in spherical radii, \u03bc. Default is 1.\nastropy\/modeling\/projections.py:        Radius of the cylinder in spherical radii, \u03bb. Default is 1.\nastropy\/modeling\/projections.py:        Distance from center of sphere in the direction opposite the\nastropy\/modeling\/projections.py:        projected surface, in spherical radii, \u03bc.  Default is 0.\nastropy\/modeling\/projections.py:        Radius of the cylinder in spherical radii, \u03bb.  Default is 0.\nastropy\/modeling\/projections.py:        Radius of the cylinder in spherical radii, \u03bb.  Default is 0.\nastropy\/modeling\/projections.py:        Radius of the cylinder in spherical radii, \u03bb.  Default is 0.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:    Corresponds to the ``COD`` projection in FITS WCS.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:Pix2Sky_COD = Pix2Sky_ConicEquidistant\nastropy\/modeling\/projections.py:    Corresponds to the ``COD`` projection in FITS WCS.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:Sky2Pix_COD = Sky2Pix_ConicEquidistant\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:class AffineTransformation2D(Model):\nastropy\/modeling\/projections.py:        A 2D vector (given as either a 2x1 or 1x2 array) specifying a\nastropy\/modeling\/projections.py:        \"\"\"Validates that the input matrix is a 2x2 2D array.\"\"\"\nastropy\/modeling\/projections.py:        Validates that the translation vector is a 2D vector.  This allows\nastropy\/modeling\/projections.py:        Apply the transformation to a set of 2D Cartesian coordinates given as\nastropy\/modeling\/fitting.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/fitting.py:from .optimizers import (DEFAULT_MAXITER, DEFAULT_EPS, DEFAULT_ACC)\nastropy\/modeling\/fitting.py:# TODO: I have ongoing branch elsewhere that's refactoring this module so that\nastropy\/modeling\/fitting.py:            case x, y and\/or z have units. Default is None.\nastropy\/modeling\/fitting.py:                    # TODO: See above comment\nastropy\/modeling\/fitting.py:                # Don't modify in-place in case rhs was the original dependent\nastropy\/modeling\/fitting.py:        # TODO: Only Polynomial models currently have an _order attribute;\nastropy\/modeling\/fitting.py:            Data measurements (1D case) or input coordinates (2D case).\nastropy\/modeling\/fitting.py:            Data measurements (2D case).\nastropy\/modeling\/fitting.py:            Data used to perform the fitting after outlier removal.\nastropy\/modeling\/fitting.py:    covariance matrix of the parameters as a 2D numpy array.  The order of the\nastropy\/modeling\/fitting.py:                 maxiter=DEFAULT_MAXITER, acc=DEFAULT_ACC,\nastropy\/modeling\/fitting.py:                 epsilon=DEFAULT_EPS, estimate_jacobian=False):\nastropy\/modeling\/fitting.py:            case x, y and\/or z have units. Default is None.\nastropy\/modeling\/fitting.py:            self.objective_function, init_values, args=farg, Dfun=dfunc,\nastropy\/modeling\/fitting.py:            case x, y and\/or z have units. Default is None.\nastropy\/modeling\/fitting.py:            case x, y and\/or z have units. Default is None.\nastropy\/modeling\/fitting.py:            # For a 1-D model the y coordinate's model-set-axis is expected to\nastropy\/modeling\/fitting.py:            # That is, each model should be represented by a column.  TODO:\nastropy\/modeling\/fitting.py:# TODO: These utility functions are really particular to handling\nastropy\/modeling\/fitting.py:# TODO: Most of this code should be entirely rewritten; it should not be as\nastropy\/modeling\/optimizers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/optimizers.py:DEFAULT_MAXITER = 100\nastropy\/modeling\/optimizers.py:DEFAULT_EPS = np.sqrt(np.finfo(float).eps)\nastropy\/modeling\/optimizers.py:# Default requested accuracy\nastropy\/modeling\/optimizers.py:DEFAULT_ACC = 1e-07\nastropy\/modeling\/optimizers.py:DEFAULT_BOUNDS = (-10 ** 12, 10 ** 12)\nastropy\/modeling\/optimizers.py:        self._maxiter = DEFAULT_MAXITER\nastropy\/modeling\/optimizers.py:        self._eps = DEFAULT_EPS\nastropy\/modeling\/optimizers.py:        self._acc = DEFAULT_ACC\nastropy\/modeling\/optimizers.py:                i[0] = DEFAULT_BOUNDS[0]\nastropy\/modeling\/optimizers.py:                i[1] = DEFAULT_BOUNDS[1]\nastropy\/coordinates\/tests\/test_sky_coord.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_sky_coord.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/coordinates\/tests\/test_sky_coord.py:DEC = 2.0 * u.deg\nastropy\/coordinates\/tests\/test_sky_coord.py:C_ICRS = ICRS(RA, DEC)\nastropy\/coordinates\/tests\/test_sky_coord.py:    OLDER_SCIPY = False\nastropy\/coordinates\/tests\/test_sky_coord.py:    OLDER_SCIPY = True\nastropy\/coordinates\/tests\/test_sky_coord.py:                  SkyCoord(RA, DEC, 'fk4', equinox='J1980')):\nastropy\/coordinates\/tests\/test_sky_coord.py:        s_icrs = SkyCoord(RA, DEC, frame='icrs')\nastropy\/coordinates\/tests\/test_sky_coord.py:    sc = SkyCoord(frame0, RA, DEC, **attrs0)\nastropy\/coordinates\/tests\/test_sky_coord.py:FRAME_DEPRECATION_WARNING = (\"Passing a frame as a positional argument is now \"\nastropy\/coordinates\/tests\/test_sky_coord.py:    Different ways of providing the frame.\nastropy\/coordinates\/tests\/test_sky_coord.py:    sc = SkyCoord(RA, DEC, frame='icrs')\nastropy\/coordinates\/tests\/test_sky_coord.py:    sc = SkyCoord(RA, DEC, frame=ICRS)\nastropy\/coordinates\/tests\/test_sky_coord.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/coordinates\/tests\/test_sky_coord.py:        sc = SkyCoord(RA, DEC, 'icrs')\nastropy\/coordinates\/tests\/test_sky_coord.py:    assert str(w[0].message) == FRAME_DEPRECATION_WARNING\nastropy\/coordinates\/tests\/test_sky_coord.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/coordinates\/tests\/test_sky_coord.py:        sc = SkyCoord(RA, DEC, ICRS)\nastropy\/coordinates\/tests\/test_sky_coord.py:    assert str(w[0].message) == FRAME_DEPRECATION_WARNING\nastropy\/coordinates\/tests\/test_sky_coord.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/coordinates\/tests\/test_sky_coord.py:        sc = SkyCoord('icrs', RA, DEC)\nastropy\/coordinates\/tests\/test_sky_coord.py:    assert str(w[0].message) == FRAME_DEPRECATION_WARNING\nastropy\/coordinates\/tests\/test_sky_coord.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/coordinates\/tests\/test_sky_coord.py:        sc = SkyCoord(ICRS, RA, DEC)\nastropy\/coordinates\/tests\/test_sky_coord.py:    assert str(w[0].message) == FRAME_DEPRECATION_WARNING\nastropy\/coordinates\/tests\/test_sky_coord.py:    sc2 = SkyCoord(sc.frame)  # Doesn't have equinox there so we get FK4 defaults\nastropy\/coordinates\/tests\/test_sky_coord.py:    Driven by #3106.\nastropy\/coordinates\/tests\/test_sky_coord.py:@pytest.mark.skipif(str('OLDER_SCIPY'))\nastropy\/coordinates\/tests\/test_sky_coord.py:        tab.add_column(Column(data=np.random.rand(1000), unit='deg', name='DEC[J2000]'))\nastropy\/coordinates\/tests\/test_sky_coord.py:    npt.assert_array_equal(sc.dec.deg, tab['DEC[J2000]'])\nastropy\/coordinates\/tests\/test_sky_coord.py:    tab['DEC[J2000]'].unit = None\nastropy\/coordinates\/tests\/test_sky_coord.py:    npt.assert_array_equal(sc.dec.deg, tab['DEC[J2000]'])\nastropy\/coordinates\/tests\/test_sky_coord.py:    npt.assert_array_equal(sc3.dec.deg, tab['DEC[J2000]'])\nastropy\/samp\/integrated_client.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/integrated_client.py:            Recipient ID\nastropy\/samp\/integrated_client.py:            Recipient ID\nastropy\/samp\/integrated_client.py:            Recipient ID\nastropy\/samp\/integrated_client.py:            Message ID to which reply.\nastropy\/utils\/exceptions.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/exceptions.py:class AstropyDeprecationWarning(AstropyWarning):\nastropy\/utils\/exceptions.py:class AstropyPendingDeprecationWarning(PendingDeprecationWarning, AstropyWarning):\nastropy\/coordinates\/tests\/test_solar_system.py:from ..solar_system import (get_body, get_moon, BODY_NAME_TO_KERNEL_SPEC,\nastropy\/coordinates\/tests\/test_solar_system.py:    HAS_SKYFIELD = False\nastropy\/coordinates\/tests\/test_solar_system.py:    HAS_SKYFIELD = True\nastropy\/coordinates\/tests\/test_solar_system.py:@pytest.mark.skipif(str('not HAS_SKYFIELD'))\nastropy\/coordinates\/tests\/test_solar_system.py:        kspec = BODY_NAME_TO_KERNEL_SPEC[bodyname]\nastropy\/coordinates\/tests\/test_unit_representation.py:from collections import OrderedDict\nastropy\/coordinates\/tests\/test_unit_representation.py:        attr_classes = OrderedDict([('lon', Longitude180),\nastropy\/coordinates\/tests\/test_unit_representation.py:        attr_classes = OrderedDict([('lon', Longitude180),\nastropy\/coordinates\/tests\/test_angles.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_angles.py:    def string(self, unit=DEGREE, decimal=False, sep=\" \", precision=5,\nastropy\/coordinates\/tests\/test_angles.py:    res = 'Angle as DMS: 3d36m29.7888s'\nastropy\/coordinates\/tests\/test_angles.py:    assert \"Angle as DMS: {0}\".format(angle.to_string(unit=u.degree)) == res\nastropy\/coordinates\/tests\/test_angles.py:    res = 'Angle as DMS: 3:36:29.7888'\nastropy\/coordinates\/tests\/test_angles.py:    assert \"Angle as DMS: {0}\".format(angle.to_string(unit=u.degree, sep=\":\")) == res\nastropy\/coordinates\/tests\/test_angles.py:    res = 'Angle as DMS: 3:36:29.79'\nastropy\/coordinates\/tests\/test_angles.py:    assert \"Angle as DMS: {0}\".format(angle.to_string(unit=u.degree, sep=\":\",\nastropy\/coordinates\/tests\/test_angles.py:    res = 'Angle as DMS: 3d36m29.7888s'\nastropy\/coordinates\/tests\/test_angles.py:    assert \"Angle as DMS: {0}\".format(angle.to_string(unit=u.degree,\nastropy\/coordinates\/tests\/test_angles.py:    res = 'Angle as DMS: 3-36|29.7888'\nastropy\/coordinates\/tests\/test_angles.py:    assert \"Angle as DMS: {0}\".format(angle.to_string(unit=u.degree, sep=[\"-\", \"|\"],\nastropy\/coordinates\/tests\/test_angles.py:    res = 'Angle as DMS: 3-36-29.7888'\nastropy\/coordinates\/tests\/test_angles.py:    assert \"Angle as DMS: {0}\".format(angle.to_string(unit=u.degree, sep=\"-\",\nastropy\/coordinates\/tests\/test_angles.py:    res = 'Angle as DMS: 03d36m29.7888s'\nastropy\/coordinates\/tests\/test_angles.py:    assert \"Angle as DMS: {0}\".format(angle.to_string(unit=u.degree, precision=4,\nastropy\/coordinates\/tests\/test_angles.py:    # TODO: adjust in 0.3 for whatever behavior is decided on\nastropy\/coordinates\/tests\/test_angles.py:    # TODO: again, fix based on >24 behavior\nastropy\/coordinates\/tests\/test_angles.py:    # TODO: this was the \"smart\" initializer behavior - adjust in 0.3 appropriately\nastropy\/coordinates\/tests\/test_angles.py:    # Test for DMS parser\nastropy\/coordinates\/tests\/test_angles.py:    # Test for DM parser\nastropy\/coordinates\/tests\/test_angles.py:    # Test for DMS parser\nastropy\/coordinates\/tests\/test_angles.py:    # Test for DMS parser\nastropy\/coordinates\/tests\/test_angles.py:    # Test for DMS parser\nastropy\/coordinates\/tests\/test_angles.py:    # Test for DMS parser\nastropy\/coordinates\/tests\/test_angles.py:    # Default wrapping at 360d with an array input\nastropy\/modeling\/blackbody.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/blackbody.py:For blackbody representation as a model, see :class:`BlackBody1D`.\nastropy\/modeling\/blackbody.py:from collections import OrderedDict\nastropy\/modeling\/blackbody.py:from .core import Fittable1DModel\nastropy\/modeling\/blackbody.py:__all__ = ['BlackBody1D', 'blackbody_nu', 'blackbody_lambda']\nastropy\/modeling\/blackbody.py:class BlackBody1D(Fittable1DModel):\nastropy\/modeling\/blackbody.py:    >>> bb = models.BlackBody1D()\nastropy\/modeling\/blackbody.py:        from astropy.modeling.models import BlackBody1D\nastropy\/modeling\/blackbody.py:        bb = BlackBody1D(temperature=5778*u.K)\nastropy\/modeling\/blackbody.py:            Desired integral for the blackbody.\nastropy\/modeling\/blackbody.py:        return OrderedDict([('temperature', u.K),\nastropy\/modeling\/blackbody.py:    ZeroDivisionError\nastropy\/utils\/misc.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/misc.py:from collections import defaultdict, OrderedDict\nastropy\/utils\/misc.py:           'JsonCustomEncoder', 'indent', 'InheritDocstrings',\nastropy\/utils\/misc.py:           'OrderedDescriptor', 'OrderedDescriptorContainer', 'set_locale',\nastropy\/utils\/misc.py:           'ShapedLikeNDArray', 'check_broadcast', 'IncompatibleShapeError',\nastropy\/utils\/misc.py:class _DummyFile:\nastropy\/utils\/misc.py:    sys.stdout = _DummyFile()\nastropy\/utils\/misc.py:    sys.stderr = _DummyFile()\nastropy\/utils\/misc.py:            raise ZeroDivisionError(\nastropy\/utils\/misc.py:    Determines the URL of the API page for the specified object, and\nastropy\/utils\/misc.py:        location that should be the *base* of the documentation. Defaults to\nastropy\/utils\/misc.py:    Determines if a given file or directory is hidden.\nastropy\/utils\/misc.py:        c for c in unicodedata.normalize('NFD', s)\nastropy\/utils\/misc.py:        Returns the string \"Did you mean X, Y, or Z?\", or the empty\nastropy\/utils\/misc.py:        return 'Did you mean {0}?'.format(matches)\nastropy\/utils\/misc.py:class InheritDocstrings(type):\nastropy\/utils\/misc.py:        >>> from astropy.utils.misc import InheritDocstrings\nastropy\/utils\/misc.py:        >>> class A(metaclass=InheritDocstrings):\nastropy\/utils\/misc.py:class OrderedDescriptor(metaclass=abc.ABCMeta):\nastropy\/utils\/misc.py:    `OrderedDescriptorContainer` metaclass.\nastropy\/utils\/misc.py:    Subclasses of `OrderedDescriptor` must define a value for a class attribute\nastropy\/utils\/misc.py:    `~collections.OrderedDict` at class creation time.  This\nastropy\/utils\/misc.py:    `~collections.OrderedDict` will contain a mapping of all class attributes\nastropy\/utils\/misc.py:    that were assigned instances of the `OrderedDescriptor` subclass, to the\nastropy\/utils\/misc.py:    `OrderedDescriptorContainer` for a concrete example.\nastropy\/utils\/misc.py:    Optionally, subclasses of `OrderedDescriptor` may define a value for a\nastropy\/utils\/misc.py:    # This id increments for each OrderedDescriptor instance created, so they\nastropy\/utils\/misc.py:        of all instances of that `OrderedDescriptor` subclass defined in the class\nastropy\/utils\/misc.py:        # different subclasses of OrderedDescriptors can be sorted correctly\nastropy\/utils\/misc.py:        self.__order = OrderedDescriptor._nextid\nastropy\/utils\/misc.py:        OrderedDescriptor._nextid += 1\nastropy\/utils\/misc.py:        Defined for convenient sorting of `OrderedDescriptor` instances, which\nastropy\/utils\/misc.py:        if (isinstance(self, OrderedDescriptor) and\nastropy\/utils\/misc.py:                isinstance(other, OrderedDescriptor)):\nastropy\/utils\/misc.py:class OrderedDescriptorContainer(type):\nastropy\/utils\/misc.py:    Classes should use this metaclass if they wish to use `OrderedDescriptor`\nastropy\/utils\/misc.py:    Every subclass of `OrderedDescriptor` has an attribute called\nastropy\/utils\/misc.py:        class ExampleDecorator(OrderedDescriptor):\nastropy\/utils\/misc.py:    Then when a class with the `OrderedDescriptorContainer` metaclass is\nastropy\/utils\/misc.py:    referencing an `~collections.OrderedDict` containing all instances of\nastropy\/utils\/misc.py:    ``ExampleDecorator`` defined in the class body, mapped to by the names of\nastropy\/utils\/misc.py:    `OrderedDescriptor` classes that *should* be added from base classes.\nastropy\/utils\/misc.py:    >>> from astropy.utils import OrderedDescriptor, OrderedDescriptorContainer\nastropy\/utils\/misc.py:    >>> class TypedAttribute(OrderedDescriptor):\nastropy\/utils\/misc.py:        >>> class Point2D(metaclass=OrderedDescriptorContainer):\nastropy\/utils\/misc.py:        >>> p1 = Point2D(1.0, 2.0)\nastropy\/utils\/misc.py:        >>> p2 = Point2D('a', 'b')  # doctest: +IGNORE_EXCEPTION_DETAIL\nastropy\/utils\/misc.py:        ValueError: Point2D.x must be of type (float, int>)\nastropy\/utils\/misc.py:    `OrderedDescriptorContainer` did for us::\nastropy\/utils\/misc.py:        >>> Point2D.typed_attributes\nastropy\/utils\/misc.py:        OrderedDict([('x', <TypedAttribute(name=x, type=(float, int))>),\nastropy\/utils\/misc.py:        >>> class Point3D(Point2D):\nastropy\/utils\/misc.py:        >>> Point3D.typed_attributes\nastropy\/utils\/misc.py:        OrderedDict([('z', <TypedAttribute(name=z, type=(float, int))>)])\nastropy\/utils\/misc.py:    However, if we specify ``_inherit_descriptors_`` from ``Point2D`` then\nastropy\/utils\/misc.py:        >>> class Point3D(Point2D):\nastropy\/utils\/misc.py:        >>> Point3D.typed_attributes\nastropy\/utils\/misc.py:        OrderedDict([('x', <TypedAttribute(name=x, type=(float, int))>),\nastropy\/utils\/misc.py:        also allows a class of type `OrderedDescriptorContainer` to use\nastropy\/utils\/misc.py:        multiple different `OrderedDescriptor` classes simultaneously.\nastropy\/utils\/misc.py:                if (not isinstance(obj, OrderedDescriptor) or\nastropy\/utils\/misc.py:                # Don't just use the descriptor's class directly; instead go\nastropy\/utils\/misc.py:                # OrderedDescriptor *may* override _class_attribute_ and have\nastropy\/utils\/misc.py:                # some OrderedDescriptor are still grouped together\nastropy\/utils\/misc.py:                # TODO: It might be worth clarifying this in the docs\nastropy\/utils\/misc.py:                # any OrderedDescriptors from any of the base classes, and\nastropy\/utils\/misc.py:            instances = OrderedDict((key, value) for value, key in instances)\nastropy\/utils\/misc.py:            # Don't do anything if locale is already the requested locale\nastropy\/utils\/misc.py:class ShapedLikeNDArray(metaclass=abc.ABCMeta):\nastropy\/utils\/misc.py:        using ``ShapedLikeNDArray``).\nastropy\/utils\/misc.py:    Determines whether two or more Numpy arrays can be broadcast with each\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:TODO: check if these tests pass on 32-bit machines and implement\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:    \"\"\"Check that Astropy gives consistent results with an IDL hor2eq example.\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      IDL> hor2eq, ten(37,54,41), ten(264,55,06), 2451545.0d, ra, dec, \/verb, obs='kpno', pres=781.0, temp=273.0\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Julian Date =  2451545.000000\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Ra, Dec:  07 36 55.6  +15 25 02   (Apparent Coords)\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Ra, Dec:  07 36 55.2  +15 25 08   (J2000.0000)\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Ra, Dec:  07 36 55.2  +15 25 08   (J2000)\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      IDL> print, ra, dec\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      IDL> hor2eq, ten(37,54,41), ten(264,55,06), 2451545.0d, ra, dec, \/verb, obs='kpno', pres=0.0, temp=273.0\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Julian Date =  2451545.000000\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Ra, Dec:  07 36 59.3  +15 25 31   (Apparent Coords)\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Ra, Dec:  07 36 58.9  +15 25 37   (J2000.0000)\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Ra, Dec:  07 36 58.9  +15 25 37   (J2000)\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      IDL> print, ra, dec\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:    # TODO: why is this difference so large?\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:                             height=2093.093 * u.m)  # TODO: height correct?\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:    \"\"\"TODO: Current output is completely incorrect ... xfailing this test for now.\nastropy\/coordinates\/tests\/accuracy\/test_icrs_fk5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/polynomial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/polynomial.py:from collections import OrderedDict\nastropy\/modeling\/polynomial.py:    'Chebyshev1D', 'Chebyshev2D', 'Hermite1D', 'Hermite2D',\nastropy\/modeling\/polynomial.py:    'InverseSIP', 'Legendre1D', 'Legendre2D', 'Polynomial1D',\nastropy\/modeling\/polynomial.py:    'Polynomial2D', 'SIP', 'OrthoPolynomialBase',\nastropy\/modeling\/polynomial.py:    # Default _param_names list; this will be filled in by the implementation's\nastropy\/modeling\/polynomial.py:        # TODO: Support a means of specifying default values for coefficients\nastropy\/modeling\/polynomial.py:        # TODO: I wonder if there might be a way around that though...\nastropy\/modeling\/polynomial.py:        return self._format_str([('Degree', self.degree)])\nastropy\/modeling\/polynomial.py:        \"\"\"Degree of polynomial.\"\"\"\nastropy\/modeling\/polynomial.py:            raise ValueError(\"Degree of polynomial must be positive or null\")\nastropy\/modeling\/polynomial.py:    This is a base class for the 2D Chebyshev and Legendre models.\nastropy\/modeling\/polynomial.py:        # TODO: Perhaps some of these other parameters should be properties?\nastropy\/modeling\/polynomial.py:        # TODO: An awful lot of the functionality in this method is still\nastropy\/modeling\/polynomial.py:            [('X-Degree', self.x_degree),\nastropy\/modeling\/polynomial.py:             ('Y-Degree', self.y_degree)])\nastropy\/modeling\/polynomial.py:        Determine how many coefficients are needed\nastropy\/modeling\/polynomial.py:        # TODO: This is a very slow way to do this; fix it and related methods\nastropy\/modeling\/polynomial.py:        # TODO: Write a docstring explaining the actual purpose of this method\nastropy\/modeling\/polynomial.py:class Chebyshev1D(PolynomialModel):\nastropy\/modeling\/polynomial.py:class Hermite1D(PolynomialModel):\nastropy\/modeling\/polynomial.py:class Hermite2D(OrthoPolynomialBase):\nastropy\/modeling\/polynomial.py:        Derivatives with respect to the coefficients.\nastropy\/modeling\/polynomial.py:        Derivative of 1D Hermite series\nastropy\/modeling\/polynomial.py:class Legendre1D(PolynomialModel):\nastropy\/modeling\/polynomial.py:class Polynomial1D(PolynomialModel):\nastropy\/modeling\/polynomial.py:    1D Polynomial model.\nastropy\/modeling\/polynomial.py:        return OrderedDict(mapping)\nastropy\/modeling\/polynomial.py:class Polynomial2D(PolynomialModel):\nastropy\/modeling\/polynomial.py:    2D Polynomial  model.\nastropy\/modeling\/polynomial.py:        return OrderedDict(mapping)\nastropy\/modeling\/polynomial.py:class Chebyshev2D(OrthoPolynomialBase):\nastropy\/modeling\/polynomial.py:        Derivatives with respect to the coefficients.\nastropy\/modeling\/polynomial.py:        Derivative of 1D Chebyshev series\nastropy\/modeling\/polynomial.py:class Legendre2D(OrthoPolynomialBase):\nastropy\/modeling\/polynomial.py:    Defined as:\nastropy\/modeling\/polynomial.py:        Derivatives with respect to the coefficients.\nastropy\/modeling\/polynomial.py:        \"\"\"Derivative of 1D Legendre polynomial\"\"\"\nastropy\/modeling\/polynomial.py:class _SIP1D(PolynomialBase):\nastropy\/modeling\/polynomial.py:    This implements the Simple Imaging Polynomial Model (SIP) in 1D.\nastropy\/modeling\/polynomial.py:    It's unlikely it will be used in 1D so this class is private\nastropy\/modeling\/polynomial.py:        # TODO: Rewrite this so that it uses a simpler method of determining\nastropy\/modeling\/polynomial.py:            raise ValueError(\"Degree of polynomial must be 2< deg < 9\")\nastropy\/modeling\/polynomial.py:    .. [1] `David Shupe, et al, ADASS, ASP Conference Series, Vol. 347, 2005 <http:\/\/adsabs.harvard.edu\/abs\/2005ASPC..347..491S>`_\nastropy\/modeling\/polynomial.py:        self.sip1d_a = _SIP1D(a_order, coeff_prefix='A', n_models=n_models,\nastropy\/modeling\/polynomial.py:        self.sip1d_b = _SIP1D(b_order, coeff_prefix='B', n_models=n_models,\nastropy\/modeling\/polynomial.py:        # define the 0th term in order to use Polynomial2D\nastropy\/modeling\/polynomial.py:        self.sip1d_ap = Polynomial2D(degree=ap_order,\nastropy\/modeling\/polynomial.py:        self.sip1d_bp = Polynomial2D(degree=bp_order,\nastropy\/utils\/compat\/misc.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/compat\/misc.py:    Determine if the ``filename`` argument is an allowable type for a filename.\nastropy\/utils\/iers\/iers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/iers\/iers.py:           'FROM_IERS_B', 'FROM_IERS_A', 'FROM_IERS_A_PREDICTION',\nastropy\/utils\/iers\/iers.py:           'TIME_BEFORE_IERS_RANGE', 'TIME_BEYOND_IERS_RANGE',\nastropy\/utils\/iers\/iers.py:           'IERS_A_FILE', 'IERS_A_URL', 'IERS_A_README',\nastropy\/utils\/iers\/iers.py:           'IERS_B_FILE', 'IERS_B_URL', 'IERS_B_README',\nastropy\/utils\/iers\/iers.py:IERS_A_README = get_pkg_data_filename('data\/ReadMe.finals2000A')\nastropy\/utils\/iers\/iers.py:IERS_B_README = get_pkg_data_filename('data\/ReadMe.eopc04_IAU2000')\nastropy\/utils\/iers\/iers.py:FROM_IERS_A_PREDICTION = 2\nastropy\/utils\/iers\/iers.py:TIME_BEYOND_IERS_RANGE = -2\nastropy\/utils\/iers\/iers.py:MJD_ZERO = 2400000.5\nastropy\/utils\/iers\/iers.py:        'then the local IERS-B file will be used by default. Default is True.')\nastropy\/utils\/iers\/iers.py:        'Maximum age (days) of predictive data before auto-downloading. Default is 30.')\nastropy\/utils\/iers\/iers.py:    'MJD', 'UT1_UTC', 'dX_2000A'\/'dY_2000A', and 'PM_x'\/'PM_y'.\nastropy\/utils\/iers\/iers.py:            Whether to use cache. Defaults to False, since IERS files\nastropy\/utils\/iers\/iers.py:        \"\"\"Turn a time to MJD, returning integer and fractional parts.\nastropy\/utils\/iers\/iers.py:            first part of two-part JD, or Time object\nastropy\/utils\/iers\/iers.py:            second part of two-part JD.\nastropy\/utils\/iers\/iers.py:            Default is 0., ignored if jd1 is `~astropy.time.Time`.\nastropy\/utils\/iers\/iers.py:            integer part of MJD\nastropy\/utils\/iers\/iers.py:            fractional part of MJD\nastropy\/utils\/iers\/iers.py:        mjd = np.floor(jd1 - MJD_ZERO + jd2)\nastropy\/utils\/iers\/iers.py:        utc = jd1 - (MJD_ZERO+mjd) + jd2\nastropy\/utils\/iers\/iers.py:            first part of two-part JD, or Time object\nastropy\/utils\/iers\/iers.py:            second part of two-part JD.\nastropy\/utils\/iers\/iers.py:            Default is 0., ignored if jd1 is `~astropy.time.Time`.\nastropy\/utils\/iers\/iers.py:            ``iers.FROM_IERS_A_PREDICTION``\nastropy\/utils\/iers\/iers.py:            ``iers.TIME_BEYOND_IERS_RANGE``\nastropy\/utils\/iers\/iers.py:            first part of two-part JD, or Time object\nastropy\/utils\/iers\/iers.py:            second part of two-part JD (default 0., ignored if jd1 is Time)\nastropy\/utils\/iers\/iers.py:        D_x : Quantity with angle units\nastropy\/utils\/iers\/iers.py:        D_y : Quantity with angle units\nastropy\/utils\/iers\/iers.py:            ``iers.FROM_IERS_A_PREDICTION``\nastropy\/utils\/iers\/iers.py:            ``iers.TIME_BEYOND_IERS_RANGE``\nastropy\/utils\/iers\/iers.py:            first part of two-part JD, or Time object\nastropy\/utils\/iers\/iers.py:            second part of two-part JD.\nastropy\/utils\/iers\/iers.py:            Default is 0., ignored if jd1 is `~astropy.time.Time`.\nastropy\/utils\/iers\/iers.py:            ``iers.FROM_IERS_A_PREDICTION``\nastropy\/utils\/iers\/iers.py:            ``iers.TIME_BEYOND_IERS_RANGE``\nastropy\/utils\/iers\/iers.py:        # For typical format, will always find a match (since MJD are integer)\nastropy\/utils\/iers\/iers.py:        # self['MJD'][i-1]<=mjd<self['MJD'][i]\nastropy\/utils\/iers\/iers.py:        i = np.searchsorted(self['MJD'].value, mjd, side='right')\nastropy\/utils\/iers\/iers.py:        # Get index to MJD at or just below given mjd, clipping to ensure we\nastropy\/utils\/iers\/iers.py:        mjd_0, mjd_1 = self['MJD'][i0].value, self['MJD'][i1].value\nastropy\/utils\/iers\/iers.py:            # Do not extrapolate outside range, instead just propagate last values.\nastropy\/utils\/iers\/iers.py:            status[i == len(self)] = TIME_BEYOND_IERS_RANGE\nastropy\/utils\/iers\/iers.py:        # IERS A has some rows at the end that hold nothing but dates & MJD\nastropy\/utils\/iers\/iers.py:        table.meta['predictive_mjd'] = table['MJD'][table.meta['predictive_index']]\nastropy\/utils\/iers\/iers.py:            Defaults to ``iers.IERS_A_FILE``.\nastropy\/utils\/iers\/iers.py:            full path to ascii file holding CDS-style readme.\nastropy\/utils\/iers\/iers.py:            Defaults to package version, ``iers.IERS_A_README``.\nastropy\/utils\/iers\/iers.py:            readme = IERS_A_README\nastropy\/utils\/iers\/iers.py:        source[ut1flag == 'P'] = FROM_IERS_A_PREDICTION\nastropy\/utils\/iers\/iers.py:        source[nutflag == 'P'] = FROM_IERS_A_PREDICTION\nastropy\/utils\/iers\/iers.py:        source[pmflag == 'P'] = FROM_IERS_A_PREDICTION\nastropy\/utils\/iers\/iers.py:            Defaults to package version, ``iers.IERS_B_FILE``.\nastropy\/utils\/iers\/iers.py:            full path to ascii file holding CDS-style readme.\nastropy\/utils\/iers\/iers.py:            Defaults to package version, ``iers.IERS_B_README``.\nastropy\/utils\/iers\/iers.py:            starting row. Default is 14, appropriate for standard IERS files.\nastropy\/utils\/iers\/iers.py:            readme = IERS_B_README\nastropy\/utils\/iers\/iers.py:            if new_table['MJD'][-1] > self['MJD'][-1]:\nastropy\/utils\/iers\/iers.py:                new_fpi = np.searchsorted(new_table['MJD'].value, predictive_mjd, side='right')\nastropy\/utils\/iers\/iers.py:                if new_table['MJD'][new_fpi + n_replace] - self['MJD'][-1] != 1.0 * u.d:\nastropy\/utils\/iers\/iers.py:                    raise ValueError('unexpected gap in MJD when refreshing IERS table')\nastropy\/utils\/iers\/iers.py:        mjd_b = table['MJD'][~table['UT1_UTC_B'].mask]\nastropy\/utils\/iers\/iers.py:        i0 = np.searchsorted(iers_b['MJD'].value, mjd_b[0], side='left')\nastropy\/utils\/iers\/iers.py:        i1 = np.searchsorted(iers_b['MJD'].value, mjd_b[-1], side='right')\nastropy\/utils\/iers\/iers.py:            if not np.allclose(table['MJD'][:n_iers_b], iers_b['MJD'].value):\nastropy\/utils\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/metadata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/metadata.py:from collections import OrderedDict\nastropy\/utils\/metadata.py:           'MergeStrategyMeta', 'enable_merge_strategies', 'merge', 'MetaData']\nastropy\/utils\/metadata.py:class MetaData:\nastropy\/utils\/metadata.py:        Documentation for the attribute of the class.\nastropy\/utils\/metadata.py:        Default is ``\"\"``.\nastropy\/utils\/metadata.py:        Default is ``True``.\nastropy\/utils\/metadata.py:            instance._meta = OrderedDict()\nastropy\/utils\/metadata.py:            instance._meta = OrderedDict()\nastropy\/utils\/iers\/tests\/test_iers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/iers\/tests\/test_iers.py:FILE_NOT_FOUND_ERROR = getattr(__builtins__, 'FileNotFoundError', OSError)\nastropy\/utils\/iers\/tests\/test_iers.py:        assert status4 == iers.TIME_BEYOND_IERS_RANGE\nastropy\/utils\/iers\/tests\/test_iers.py:        with pytest.raises(FILE_NOT_FOUND_ERROR):\nastropy\/utils\/iers\/tests\/test_iers.py:        assert status2 == iers.TIME_BEYOND_IERS_RANGE\nastropy\/utils\/iers\/tests\/test_iers.py:        assert status3 == iers.FROM_IERS_A_PREDICTION\nastropy\/utils\/iers\/tests\/test_iers.py:            assert dat['MJD'][0] == 57359.0 * u.d\nastropy\/utils\/iers\/tests\/test_iers.py:            assert dat['MJD'][-1] == 57539.0 * u.d\nastropy\/utils\/iers\/tests\/test_iers.py:            # the IERS-B value from MJD=57359.  The value in\nastropy\/utils\/iers\/tests\/test_iers.py:        # Now point to a later file with same values but MJD increased by\nastropy\/utils\/iers\/tests\/test_iers.py:            assert dat['MJD'][0] == 57359.0 * u.d\nastropy\/utils\/iers\/tests\/test_iers.py:            assert dat['MJD'][-1] == (57539.0 + 60) * u.d\nastropy\/utils\/xml\/unescaper.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/unescaper.py:# STDLIB\nastropy\/utils\/xml\/unescaper.py:# This is DIY\nastropy\/utils\/xml\/iterparser.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/iterparser.py:# STDLIB\nastropy\/utils\/xml\/iterparser.py:    parser.CharacterDataHandler = text.append\nastropy\/utils\/xml\/iterparser.py:            - *data*: Depends on the value of *event*:\nastropy\/utils\/xml\/iterparser.py:    Determine the encoding of an XML file by reading its header.\nastropy\/utils\/compat\/numpycompat.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/compat\/numpycompat.py:# TODO: It might also be nice to have aliases to these named for specific\nastropy\/utils\/compat\/numpycompat.py:# astropy.table.table._BROKEN_UNICODE_TABLE_SORT)\nastropy\/utils\/compat\/futures\/__init__.py:from ...exceptions import AstropyDeprecationWarning\nastropy\/utils\/compat\/futures\/__init__.py:              \"use concurrent.futures instead\", AstropyDeprecationWarning)\nastropy\/utils\/compat\/funcsigs.py:from ..exceptions import AstropyDeprecationWarning\nastropy\/utils\/compat\/funcsigs.py:              \"use inspect instead\", AstropyDeprecationWarning)\nastropy\/utils\/compat\/numpy\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/compat\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/check.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/check.py:def check_id(ID):\nastropy\/utils\/xml\/check.py:    Returns `True` if *ID* is a valid XML ID.\nastropy\/utils\/xml\/check.py:    return re.match(r\"^[A-Za-z_][A-Za-z0-9_\\.\\-]*$\", ID) is not None\nastropy\/utils\/xml\/check.py:def fix_id(ID):\nastropy\/utils\/xml\/check.py:    if re.match(r\"^[A-Za-z_][A-Za-z0-9_\\.\\-]*$\", ID):\nastropy\/utils\/xml\/check.py:        return ID\nastropy\/utils\/xml\/check.py:    if len(ID):\nastropy\/utils\/xml\/check.py:        corrected = ID\nastropy\/utils\/tests\/test_console.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/writer.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/writer.py:# STDLIB\nastropy\/utils\/xml\/writer.py:        Escapes &, < and > in an XML CDATA string.\nastropy\/time\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/utils.py:doubles, using the procedure of Shewchuk, 1997, Discrete & Computational\nastropy\/time\/utils.py:    Discrete & Computational Geometry 18(3):305-363\nastropy\/time\/utils.py:    Discrete & Computational Geometry 18(3):305-363\nastropy\/time\/utils.py:    Discrete & Computational Geometry 18(3):305-363\nastropy\/utils\/xml\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/setup_package.py:    XML_DIR = 'astropy\/utils\/xml\/src'\nastropy\/utils\/xml\/setup_package.py:    cfg = setup_helpers.DistutilsExtensionArgs({\nastropy\/utils\/xml\/setup_package.py:        'sources': [join(XML_DIR, \"iterparse.c\")]\nastropy\/utils\/xml\/setup_package.py:        EXPAT_DIR = 'cextern\/expat\/lib'\nastropy\/utils\/xml\/setup_package.py:            join(EXPAT_DIR, fn) for fn in\nastropy\/utils\/xml\/setup_package.py:        cfg['include_dirs'].extend([XML_DIR, EXPAT_DIR])\nastropy\/utils\/xml\/setup_package.py:                    join(XML_DIR, 'iterparse.map'))\nastropy\/utils\/xml\/setup_package.py:            cfg['define_macros'].append(('BYTEORDER', '4321'))\nastropy\/utils\/xml\/setup_package.py:            cfg['define_macros'].append(('BYTEORDER', '1234'))\nastropy\/utils\/xml\/setup_package.py:            cfg['define_macros'].append(('HAVE_UNISTD_H', None))\nastropy\/utils\/decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/decorators.py:from .exceptions import (AstropyDeprecationWarning, AstropyUserWarning,\nastropy\/utils\/decorators.py:                         AstropyPendingDeprecationWarning)\nastropy\/utils\/decorators.py:        If True, uses a AstropyPendingDeprecationWarning instead of a\nastropy\/utils\/decorators.py:        AstropyDeprecationWarning.\nastropy\/utils\/decorators.py:        ``AstropyDeprecationWarning`` when it is called.\nastropy\/utils\/decorators.py:                category = AstropyPendingDeprecationWarning\nastropy\/utils\/decorators.py:                category = AstropyDeprecationWarning\nastropy\/utils\/decorators.py:        If True, uses a AstropyPendingDeprecationWarning instead of a\nastropy\/utils\/decorators.py:        AstropyDeprecationWarning.\nastropy\/utils\/decorators.py:    \"\"\"Deprecate a _renamed_ function argument.\nastropy\/utils\/decorators.py:        Default is ``False``.\nastropy\/utils\/decorators.py:        Default is ``False``.\nastropy\/utils\/decorators.py:        Default is ``False``.\nastropy\/utils\/decorators.py:            # Determine the position of the argument.\nastropy\/utils\/decorators.py:                if param.kind == param.POSITIONAL_OR_KEYWORD:\nastropy\/utils\/decorators.py:                elif param.kind == param.KEYWORD_ONLY:\nastropy\/utils\/decorators.py:                    # Display the deprecation warning only when it's only\nastropy\/utils\/decorators.py:                            AstropyDeprecationWarning, stacklevel=2)\nastropy\/utils\/decorators.py:# TODO: This can still be made to work for setters by implementing an\nastropy\/utils\/decorators.py:          updated=functools.WRAPPER_UPDATES, exclude_args=()):\nastropy\/utils\/decorators.py:            # Delete documentation in this case so we don't end up with\nastropy\/modeling\/mappings.py:    >>> from astropy.modeling.models import Polynomial2D, Shift, Mapping\nastropy\/modeling\/mappings.py:    >>> poly1 = Polynomial2D(1, c0_0=1, c1_0=2, c0_1=3)\nastropy\/modeling\/mappings.py:    >>> poly2 = Polynomial2D(1, c0_0=1, c1_0=2.4, c0_1=2.1)\nastropy\/modeling\/mappings.py:        >>> from astropy.modeling.models import (Polynomial1D, Shift, Scale,\nastropy\/utils\/compat\/numpy\/core\/multiarray.py:from ....exceptions import AstropyDeprecationWarning\nastropy\/utils\/compat\/numpy\/core\/multiarray.py:        'numpy.matmul directly.', AstropyDeprecationWarning)\nastropy\/modeling\/powerlaws.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/powerlaws.py:from collections import OrderedDict\nastropy\/modeling\/powerlaws.py:from .core import Fittable1DModel\nastropy\/modeling\/powerlaws.py:__all__ = ['PowerLaw1D', 'BrokenPowerLaw1D', 'SmoothlyBrokenPowerLaw1D',\nastropy\/modeling\/powerlaws.py:           'ExponentialCutoffPowerLaw1D', 'LogParabola1D']\nastropy\/modeling\/powerlaws.py:class PowerLaw1D(Fittable1DModel):\nastropy\/modeling\/powerlaws.py:    BrokenPowerLaw1D, ExponentialCutoffPowerLaw1D, LogParabola1D\nastropy\/modeling\/powerlaws.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/powerlaws.py:class BrokenPowerLaw1D(Fittable1DModel):\nastropy\/modeling\/powerlaws.py:    PowerLaw1D, ExponentialCutoffPowerLaw1D, LogParabola1D\nastropy\/modeling\/powerlaws.py:        return OrderedDict([('x_break', inputs_unit['x']),\nastropy\/modeling\/powerlaws.py:class SmoothlyBrokenPowerLaw1D(Fittable1DModel):\nastropy\/modeling\/powerlaws.py:    BrokenPowerLaw1D\nastropy\/modeling\/powerlaws.py:    :math:`\\\\alpha_2` for ``alpha_2`` and :math:`\\\\Delta` for\nastropy\/modeling\/powerlaws.py:                        1 + \\\\left( \\\\frac{x}{x_b}\\\\right)^{1 \/ \\\\Delta}\nastropy\/modeling\/powerlaws.py:                   \\\\right\\\\}^{(\\\\alpha_1 - \\\\alpha_2) \\\\Delta}\nastropy\/modeling\/powerlaws.py:            \\\\sim \\\\Delta\nastropy\/modeling\/powerlaws.py:    hence the :math:`\\\\Delta` parameter sets the \"smoothness\" of the\nastropy\/modeling\/powerlaws.py:        f = models.SmoothlyBrokenPowerLaw1D(amplitude=1, x_break=20,\nastropy\/modeling\/powerlaws.py:        # SmoothlyBrokenPowerLaw1D.evaluate)\nastropy\/modeling\/powerlaws.py:        threshold = 30  # (see comments in SmoothlyBrokenPowerLaw1D.evaluate)\nastropy\/modeling\/powerlaws.py:        return OrderedDict([('x_break', inputs_unit['x']),\nastropy\/modeling\/powerlaws.py:class ExponentialCutoffPowerLaw1D(Fittable1DModel):\nastropy\/modeling\/powerlaws.py:    PowerLaw1D, BrokenPowerLaw1D, LogParabola1D\nastropy\/modeling\/powerlaws.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/powerlaws.py:class LogParabola1D(Fittable1DModel):\nastropy\/modeling\/powerlaws.py:    PowerLaw1D, BrokenPowerLaw1D, ExponentialCutoffPowerLaw1D\nastropy\/modeling\/powerlaws.py:        return OrderedDict([('x_0', inputs_unit['x']),\nexamples\/io\/fits-tables.py:*License: BSD*\nexamples\/io\/fits-tables.py:# Download a FITS file\nexamples\/io\/fits-tables.py:# Display information about the contents of the FITS file.\nastropy\/utils\/compat\/numpy\/lib\/stride_tricks.py:from ....exceptions import AstropyDeprecationWarning\nastropy\/utils\/compat\/numpy\/lib\/stride_tricks.py:        'numpy.broadcast_arrays directly.', AstropyDeprecationWarning)\nastropy\/utils\/compat\/numpy\/lib\/stride_tricks.py:        'numpy.broadcast_to directly.', AstropyDeprecationWarning)\nastropy\/utils\/xml\/validate.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/validate.py:Functions to do XML schema and DTD validation.  At the moment, this\nastropy\/utils\/xml\/validate.py:    Validates an XML file against a schema or DTD.\nastropy\/utils\/xml\/validate.py:        The path to the XML schema or DTD\nastropy\/utils\/xml\/validate.py:        raise TypeError(\"schema_file must be a path to an XML Schema or DTD\")\nastropy\/samp\/errors.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/errors.py:Defines custom errors and exceptions used in `astropy.samp`.\nastropy\/modeling\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/setup_package.py:MODELING_ROOT = os.path.relpath(os.path.dirname(__file__))\nastropy\/modeling\/setup_package.py:MODELING_SRC = join(MODELING_ROOT, 'src')\nastropy\/modeling\/setup_package.py:SRC_FILES = [join(MODELING_SRC, 'projections.c.templ'),\nastropy\/modeling\/setup_package.py:GEN_FILES = [join(MODELING_SRC, 'projections.c')]\nastropy\/modeling\/setup_package.py:    # TODO: Move this to setup_helpers\nastropy\/modeling\/setup_package.py:        # Determine modification times\nastropy\/modeling\/setup_package.py:    env = Environment(loader=FileSystemLoader(MODELING_SRC))\nastropy\/modeling\/setup_package.py:    with open(join(MODELING_SRC, 'projections.c'), 'w') as fd:\nastropy\/modeling\/setup_package.py:        join(MODELING_SRC, 'wcsconfig.h')\nastropy\/modeling\/setup_package.py:    cfg = setup_helpers.DistutilsExtensionArgs()\nastropy\/modeling\/setup_package.py:    cfg['include_dirs'].append(MODELING_SRC)\nastropy\/modeling\/setup_package.py:    cfg['sources'].extend(join(MODELING_SRC, x) for x in astropy_files)\nastropy\/utils\/xml\/tests\/test_iterparse.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/tests\/test_iterparse.py:HEADER = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\nastropy\/utils\/xml\/tests\/test_iterparse.py:   <FIELD ID=\"foo\" name=\"foo\" datatype=\"int\" arraysize=\"1\"\/>\nastropy\/utils\/xml\/tests\/test_iterparse.py:    <DATA>\nastropy\/utils\/xml\/tests\/test_iterparse.py:     <TABLEDATA>\nastropy\/utils\/xml\/tests\/test_iterparse.py:ROW = \"\"\"<TR><TD>0<\/TD><\/TR>\nastropy\/utils\/xml\/tests\/test_iterparse.py:    <\/TABLEDATA>\nastropy\/utils\/xml\/tests\/test_iterparse.py:   <\/DATA>\nastropy\/utils\/xml\/tests\/test_iterparse.py:VOTABLE_XML = HEADER + 125*ROW + FOOTER\nastropy\/utils\/xml\/tests\/test_iterparse.py:    zlib_GZIP_STYLE_HEADER = 16\nastropy\/utils\/xml\/tests\/test_iterparse.py:                             zlib.DEFLATED,\nastropy\/utils\/xml\/tests\/test_iterparse.py:                             zlib.MAX_WBITS + zlib_GZIP_STYLE_HEADER)\nastropy\/coordinates\/sky_coordinate.py:from ..utils.exceptions import AstropyDeprecationWarning\nastropy\/coordinates\/sky_coordinate.py:from ..utils import ShapedLikeNDArray\nastropy\/coordinates\/sky_coordinate.py:from .distances import Distance\nastropy\/coordinates\/sky_coordinate.py:J_PREFIXED_RA_DEC_RE = re.compile(\nastropy\/coordinates\/sky_coordinate.py:    ([0-9]{6,7}\\.?[0-9]{0,2})          # RA as HHMMSS.ss or DDDMMSS.ss, optional decimal digits\nastropy\/coordinates\/sky_coordinate.py:    ([\\+\\-][0-9]{6}\\.?[0-9]{0,2})\\s*$  # Dec as DDMMSS.ss, optional decimal digits\nastropy\/coordinates\/sky_coordinate.py:        # Don't output distance if it is all unitless 1.0\nastropy\/coordinates\/sky_coordinate.py:class SkyCoord(ShapedLikeNDArray):\nastropy\/coordinates\/sky_coordinate.py:      SkyCoord(COORD, [FRAME], keyword_args ...)\nastropy\/coordinates\/sky_coordinate.py:      SkyCoord(LON, LAT, [DISTANCE], frame=FRAME, unit=UNIT, keyword_args ...)\nastropy\/coordinates\/sky_coordinate.py:        Type of coordinate frame this `SkyCoord` should represent. Defaults to\nastropy\/coordinates\/sky_coordinate.py:            RA and Dec for frames where ``ra`` and ``dec`` are keys in the\nastropy\/coordinates\/sky_coordinate.py:    # Declare that SkyCoord can be used as a Table column by defining the\nastropy\/coordinates\/sky_coordinate.py:        are all defined in `~astropy.utils.misc.ShapedLikeNDArray`. It will be\nastropy\/coordinates\/sky_coordinate.py:            if isinstance(value, ShapedLikeNDArray):\nastropy\/coordinates\/sky_coordinate.py:            # TODO: remove this when velocities are supported in SkyCoord\nastropy\/coordinates\/sky_coordinate.py:        # Do the transformation, returning a coordinate frame of the desired\nastropy\/coordinates\/sky_coordinate.py:        sep : `~astropy.coordinates.Distance`\nastropy\/coordinates\/sky_coordinate.py:        return Distance((self.cartesian - other.cartesian).norm())\nastropy\/coordinates\/sky_coordinate.py:            The angular offset in the latitude direction (i.e., Dec for\nastropy\/coordinates\/sky_coordinate.py:            The 3D distance between the closest match for each element\nastropy\/coordinates\/sky_coordinate.py:            The 3D distance between the closest match for each element\nastropy\/coordinates\/sky_coordinate.py:            The 3D distance between the coordinates. Shape matches\nastropy\/coordinates\/sky_coordinate.py:        points within a given 3D radius.\nastropy\/coordinates\/sky_coordinate.py:            The 3D distance between the coordinates. Shape matches\nastropy\/coordinates\/sky_coordinate.py:        Determines the constellation(s) of the coordinates this `SkyCoord`\nastropy\/coordinates\/sky_coordinate.py:        precesses to B1875, and then uses the Delporte boundaries of the 88\nastropy\/coordinates\/sky_coordinate.py:                             re.IGNORECASE | re.UNICODE)\nastropy\/coordinates\/sky_coordinate.py:        Given a name, query the CDS name resolver to attempt to retrieve\nastropy\/coordinates\/sky_coordinate.py:    Determine the coordinate frame from input SkyCoord args and kwargs.  This\nastropy\/coordinates\/sky_coordinate.py:                              \"instead.\", AstropyDeprecationWarning)\nastropy\/coordinates\/sky_coordinate.py:    is_scalar = False  # Differentiate between scalar and list input\nastropy\/coordinates\/sky_coordinate.py:            # Do some basic validation of the list elements: all have a length and all\nastropy\/coordinates\/sky_coordinate.py:    Parse RA and Dec values from a coordinate string. Currently the\nastropy\/coordinates\/sky_coordinate.py:       separation between RA and Dec\nastropy\/coordinates\/sky_coordinate.py:     * JHHMMSS.ss+DDMMSS.ss format, with up to two optional decimal digits\nastropy\/coordinates\/sky_coordinate.py:     * JDDDMMSS.ss+DDMMSS.ss format, with up to two optional decimal digits\nastropy\/coordinates\/sky_coordinate.py:        match_j = J_PREFIXED_RA_DEC_RE.match(coord_str)\nastropy\/utils\/state.py:            \"This class is a singleton.  Do not instantiate.\")\nastropy\/modeling\/statistic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/statistic.py:        Independent variable \"y\" to evaluate the model on, for 2D models.\nastropy\/modeling\/models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/models.py:from .blackbody import BlackBody1D\nastropy\/modeling\/models.py:CONSTRAINTS_DOC = \"\"\"\nastropy\/modeling\/models.py:MODELS_WITH_CONSTRAINTS = [\nastropy\/modeling\/models.py:    AiryDisk2D, Moffat1D, Moffat2D, Box1D, Box2D,\nastropy\/modeling\/models.py:    Const1D, Const2D, Ellipse2D, Disk2D,\nastropy\/modeling\/models.py:    Gaussian1D, Gaussian2D,\nastropy\/modeling\/models.py:    Linear1D, Lorentz1D, MexicanHat1D, MexicanHat2D,\nastropy\/modeling\/models.py:    PowerLaw1D, Sersic1D, Sersic2D, Sine1D, Trapezoid1D, TrapezoidDisk2D,\nastropy\/modeling\/models.py:    Chebyshev1D, Chebyshev2D, Hermite1D, Hermite2D, Legendre2D, Legendre1D,\nastropy\/modeling\/models.py:    Polynomial1D, Polynomial2D, Voigt1D\nastropy\/modeling\/models.py:for item in MODELS_WITH_CONSTRAINTS:\nastropy\/modeling\/models.py:        item.__doc__ += CONSTRAINTS_DOC\nastropy\/utils\/tests\/test_misc.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_misc.py:    class Base(metaclass=misc.InheritDocstrings):\nastropy\/utils\/tests\/test_misc.py:        # TODO: Maybe if __doc__ is None this test should be skipped instead?\nastropy\/utils\/tests\/test_misc.py:        locale.setlocale(locale.LC_ALL, str('de_DE'))\nastropy\/utils\/tests\/test_misc.py:    with misc.set_locale('de_DE'):\nastropy\/samp\/standard_profile.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/standard_profile.py:            # SimpleXMLRPCDispatcher. To maintain backwards compatibility,\nastropy\/coordinates\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nexamples\/io\/split-jpeg-to-fits.py:*License: BSD*\nexamples\/io\/split-jpeg-to-fits.py:red = fits.PrimaryHDU(data=r_data)\nexamples\/io\/split-jpeg-to-fits.py:green = fits.PrimaryHDU(data=g_data)\nexamples\/io\/split-jpeg-to-fits.py:blue = fits.PrimaryHDU(data=b_data)\nexamples\/io\/split-jpeg-to-fits.py:# Delete the files created\nastropy\/modeling\/tests\/test_projections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_projections.py:PIX_COORDINATES = [-10, 30]\nastropy\/modeling\/tests\/test_projections.py:    wcslibout = w.wcs.p2s([PIX_COORDINATES], 1)\nastropy\/modeling\/tests\/test_projections.py:    wcslibout = w.wcs.p2s([PIX_COORDINATES], 1)\nastropy\/modeling\/tests\/test_projections.py:    phi, theta = tanprj(*PIX_COORDINATES)\nastropy\/modeling\/tests\/test_projections.py:    wcslibout = w.wcs.p2s([PIX_COORDINATES], 1)\nastropy\/modeling\/tests\/test_projections.py:    wcslibout = w.wcs.p2s([PIX_COORDINATES], 1)\nastropy\/modeling\/tests\/test_projections.py:    phi, theta = tanprj(*PIX_COORDINATES * u.deg)\nastropy\/modeling\/tests\/test_projections.py:    phi, theta = tanprj(*(PIX_COORDINATES * u.deg).to(u.rad))\nastropy\/modeling\/tests\/test_projections.py:    phi, theta = tanprj(*(PIX_COORDINATES * u.deg).to(u.arcmin))\nastropy\/modeling\/tests\/test_projections.py:        ID = 'AZP'\nastropy\/modeling\/tests\/test_projections.py:                               \"1904-66_{0}.hdr\".format(ID))\nastropy\/modeling\/tests\/test_projections.py:        ID = \"CYP\"\nastropy\/modeling\/tests\/test_projections.py:                               \"1904-66_{0}.hdr\".format(ID))\nastropy\/modeling\/tests\/test_projections.py:def test_AffineTransformation2D():\nastropy\/modeling\/tests\/test_projections.py:    model = projections.AffineTransformation2D(\nastropy\/modeling\/tests\/test_projections.py:def test_AffineTransformation2D_inverse():\nastropy\/modeling\/tests\/test_projections.py:    model1 = projections.AffineTransformation2D(\nastropy\/modeling\/tests\/test_projections.py:    model2 = projections.AffineTransformation2D(\nastropy\/modeling\/tests\/test_projections.py:    qaff = projections.AffineTransformation2D(matrix=[[1, 2], [2, 1]] * u.deg)\nastropy\/modeling\/tests\/test_projections.py:    qaff = projections.AffineTransformation2D(matrix=[[1, 2], [2, 1]] * u.deg,\nastropy\/modeling\/tests\/test_projections.py:    aff = projections.AffineTransformation2D(matrix=[[1, 2], [2, 1]], translation=[1, 2])\nastropy\/modeling\/tests\/test_projections.py:    # test the case of WCS PC and CDELT transformations\nastropy\/modeling\/tests\/test_projections.py:    qaff = projections.AffineTransformation2D(matrix=matrix * u.deg,\nastropy\/modeling\/tests\/test_projections.py:    inv_qaff = projections.AffineTransformation2D(matrix=inv_matrix * u.pix,\nastropy\/modeling\/tests\/test_quantities_parameters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_quantities_parameters.py:from ..core import Model, Fittable1DModel, InputParameterError\nastropy\/modeling\/tests\/test_quantities_parameters.py:from ..parameters import Parameter, ParameterDefinitionError\nastropy\/modeling\/tests\/test_quantities_parameters.py:from ..models import (Gaussian1D, Pix2Sky_TAN, RotateNative2Celestial,\nastropy\/modeling\/tests\/test_quantities_parameters.py:                      Rotation2D)\nastropy\/modeling\/tests\/test_quantities_parameters.py:class BaseTestModel(Fittable1DModel):\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1 * u.J, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1 * u.J, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1 * u.Jy, 3, 0.1)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1, 3, 0.1)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1 * u.Jy, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    # TODO: determine whether this is the desired behavior?\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1 * u.Jy, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    with pytest.raises(ParameterDefinitionError) as exc:\nastropy\/modeling\/tests\/test_quantities_parameters.py:        class TestC(Fittable1DModel):\nastropy\/modeling\/tests\/test_quantities_parameters.py:    # TODO: decide whether the default property should return a value or\nastropy\/modeling\/tests\/test_quantities_parameters.py:    # TODO: but how do we know what those units are if we don't return a\nastropy\/modeling\/tests\/test_quantities_parameters.py:    # TODO: this illustrates why the default doesn't make sense anymore\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1 * u.J, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1 * u.J, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D([1, 2] * u.J, [1, 2] * u.m, [0.1, 0.2] * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    rot = Rotation2D(23)\nastropy\/modeling\/tests\/test_rotations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_rotations.py:    w.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/modeling\/tests\/test_rotations.py:def test_Rotation2D():\nastropy\/modeling\/tests\/test_rotations.py:    model = models.Rotation2D(angle=90)\nastropy\/modeling\/tests\/test_rotations.py:def test_Rotation2D_inverse():\nastropy\/modeling\/tests\/test_rotations.py:    model = models.Rotation2D(angle=234.23494)\nastropy\/time\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/core.py:UT1) and time representations (e.g. JD, MJD, ISO 8601) that are used in\nastropy\/time\/core.py:from ..utils import ShapedLikeNDArray\nastropy\/time\/core.py:from .formats import (TIME_FORMATS, TIME_DELTA_FORMATS,\nastropy\/time\/core.py:                      TimeJD, TimeUnique, TimeAstropyTime, TimeDatetime)\nastropy\/time\/core.py:__all__ = ['Time', 'TimeDelta', 'TIME_SCALES', 'TIME_DELTA_SCALES',\nastropy\/time\/core.py:TIME_DELTA_TYPES = dict((scale, scales)\nastropy\/time\/core.py:TIME_DELTA_SCALES = TIME_DELTA_TYPES.keys()\nastropy\/time\/core.py:#   \/* L_B = 1 - d(TDB)\/d(TCB), and TDB (s) at TAI 1977\/1\/1.0 *\/\nastropy\/time\/core.py:SIDEREAL_TIME_MODELS = {\nastropy\/time\/core.py:class TimeDeltaInfo(TimeInfo):\nastropy\/time\/core.py:class Time(ShapedLikeNDArray):\nastropy\/time\/core.py:    formats (e.g. JD) where very high precision (better than 64-bit precision)\nastropy\/time\/core.py:        Digits of precision in string representation of time\nastropy\/time\/core.py:    \"\"\"Dict of time formats\"\"\"\nastropy\/time\/core.py:    # Make sure that reverse arithmetic (e.g., TimeDelta.__rmul__)\nastropy\/time\/core.py:    # Declare that Time can be used as a Table column by defining the\nastropy\/time\/core.py:        # Determine the chain of scale transformations to get from the current\nastropy\/time\/core.py:        Decimal precision when outputting seconds as floating point (int\nastropy\/time\/core.py:        First of the two doubles that internally store time value(s) in JD.\nastropy\/time\/core.py:        Second of the two doubles that internally store time value(s) in JD.\nastropy\/time\/core.py:        which is consistent with the JPL DE405 ephemeris to an accuracy of\nastropy\/time\/core.py:        time_offset : `~astropy.time.TimeDelta`\nastropy\/time\/core.py:            in TDB seconds.  Should be added to the original time to get the\nastropy\/time\/core.py:        return TimeDelta(tcor_val, scale='tdb')\nastropy\/time\/core.py:        if kind.lower() not in SIDEREAL_TIME_MODELS.keys():\nastropy\/time\/core.py:                ' or '.join(sorted(SIDEREAL_TIME_MODELS.keys()))))\nastropy\/time\/core.py:        available_models = SIDEREAL_TIME_MODELS[kind.lower()]\nastropy\/time\/core.py:            'apparent', sorted(SIDEREAL_TIME_MODELS['apparent'].keys()),\nastropy\/time\/core.py:            'mean', sorted(SIDEREAL_TIME_MODELS['mean'].keys()))\nastropy\/time\/core.py:        tm._time = TimeJD(jd1, jd2, self.scale, self.precision,\nastropy\/time\/core.py:        the python stdlib to behave like `Time.copy`. Does *not* make a\nastropy\/time\/core.py:        copy of the JD arrays - only copies by reference.\nastropy\/time\/core.py:        in the python stdlib to behave like `Time.copy`. Does make a\nastropy\/time\/core.py:        copy of the JD arrays.\nastropy\/time\/core.py:            which argmin or argmax was used.  Default: ``False``.\nastropy\/time\/core.py:                raise ScaleValueError(\"Cannot convert TimeDelta with \"\nastropy\/time\/core.py:            ``astropy.utils.iers.FROM_IERS_A_PREDICTION``\nastropy\/time\/core.py:            ``astropy.utils.iers.TIME_BEYOND_IERS_RANGE``\nastropy\/time\/core.py:    # Property for ERFA DUT arg = UT1 - UTC\nastropy\/time\/core.py:        Get ERFA DUT arg = UT1 - UTC.  This getter takes optional jd1 and\nastropy\/time\/core.py:        # Sec. 4.3.1: the arg DUT is the quantity delta_UT1 = UT1 - UTC in\nastropy\/time\/core.py:        if hasattr(val, 'to'):  # Matches Quantity but also TimeDelta.\nastropy\/time\/core.py:    # Property for ERFA DTR arg = TDB - TT\nastropy\/time\/core.py:            # attribute access) then require that the time scale is TT or TDB.\nastropy\/time\/core.py:                                     'is only possible for TT or TDB time '\nastropy\/time\/core.py:            # TDB or TT) to an approximate UT1.  Since TT and TDB are\nastropy\/time\/core.py:        if hasattr(val, 'to'):  # Matches Quantity but also TimeDelta.\nastropy\/time\/core.py:    \"\"\"TDB - TT time scale offset\"\"\"\nastropy\/time\/core.py:                other = TimeDelta(other)\nastropy\/time\/core.py:        # Tdelta - something is dealt with in TimeDelta, so we have\nastropy\/time\/core.py:        other_is_delta = isinstance(other, TimeDelta)\nastropy\/time\/core.py:        # TimeDelta, but not for Time (which can be UTC)\nastropy\/time\/core.py:            self_time = (self._time if self.scale in TIME_DELTA_SCALES\nastropy\/time\/core.py:            # set up TimeDelta, subtraction to be done shortly\nastropy\/time\/core.py:            out = TimeDelta(self_time.jd1, self_time.jd2, format='jd',\nastropy\/time\/core.py:                other = TimeDelta(other)\nastropy\/time\/core.py:        # Tdelta + something is dealt with in TimeDelta, so we have\nastropy\/time\/core.py:        if not isinstance(other, TimeDelta):\nastropy\/time\/core.py:        # TimeDelta cannot be converted arbitrarily\nastropy\/time\/core.py:            raise TypeError(\"Cannot compare TimeDelta instances with scales \"\nastropy\/time\/core.py:    to_datetime.__doc__ = TimeDatetime.to_value.__doc__\nastropy\/time\/core.py:class TimeDelta(Time):\nastropy\/time\/core.py:    A TimeDelta object is initialized with one or more times in the ``val``\nastropy\/time\/core.py:    numeric input formats (e.g. JD) where very high precision (better than\nastropy\/time\/core.py:      >>> list(TimeDelta.FORMATS)\nastropy\/time\/core.py:    val : sequence, ndarray, number, or `~astropy.time.TimeDelta` object\nastropy\/time\/core.py:    SCALES = TIME_DELTA_SCALES\nastropy\/time\/core.py:    FORMATS = TIME_DELTA_FORMATS\nastropy\/time\/core.py:    \"\"\"Dict of time delta formats.\"\"\"\nastropy\/time\/core.py:    info = TimeDeltaInfo()\nastropy\/time\/core.py:        if isinstance(val, TimeDelta):\nastropy\/time\/core.py:                self.SCALES = TIME_DELTA_TYPES[scale]\nastropy\/time\/core.py:        # For TimeDelta, there can only be a change in scale factor,\nastropy\/time\/core.py:        # only deal with TimeDelta + TimeDelta\nastropy\/time\/core.py:            if not isinstance(other, TimeDelta):\nastropy\/time\/core.py:                other = TimeDelta(other)\nastropy\/time\/core.py:        # the scales should be compatible (e.g., cannot convert TDB to TAI)\nastropy\/time\/core.py:            raise TypeError(\"Cannot add TimeDelta instances with scales \"\nastropy\/time\/core.py:        # only deal with TimeDelta - TimeDelta\nastropy\/time\/core.py:            if not isinstance(other, TimeDelta):\nastropy\/time\/core.py:                other = TimeDelta(other)\nastropy\/time\/core.py:        # the scales should be compatible (e.g., cannot convert TDB to TAI)\nastropy\/time\/core.py:            raise TypeError(\"Cannot subtract TimeDelta instances with scales \"\nastropy\/time\/core.py:        \"\"\"Negation of a `TimeDelta` object.\"\"\"\nastropy\/time\/core.py:        \"\"\"Absolute value of a `TimeDelta` object.\"\"\"\nastropy\/time\/core.py:        \"\"\"Multiplication of `TimeDelta` objects by numbers\/arrays.\"\"\"\nastropy\/time\/core.py:            out = TimeDelta(jd1, jd2, format='jd', scale=self.scale)\nastropy\/time\/core.py:        \"\"\"Multiplication of numbers\/arrays with `TimeDelta` objects.\"\"\"\nastropy\/time\/core.py:        \"\"\"Division of `TimeDelta` objects by numbers\/arrays.\"\"\"\nastropy\/time\/core.py:        \"\"\"Division by `TimeDelta` objects of numbers\/arrays.\"\"\"\nastropy\/time\/core.py:        \"\"\"Division of `TimeDelta` objects by numbers\/arrays.\"\"\"\nastropy\/time\/core.py:            out = TimeDelta(jd1, jd2, format='jd', scale=self.scale)\nastropy\/time\/core.py:        \"\"\"Division by `TimeDelta` objects of numbers\/arrays.\"\"\"\nastropy\/modeling\/tabular.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tabular.py:For convenience `Tabular1D` and `Tabular2D` are provided.\nastropy\/modeling\/tabular.py:>>> t2 = Tabular2D(points, lookup_table=table, bounds_error=False,\nastropy\/modeling\/tabular.py:__all__ = ['tabular_model', 'Tabular1D', 'Tabular2D']\nastropy\/modeling\/tabular.py:        2-dimensional data. Default is \"linear\".\nastropy\/modeling\/tabular.py:        >>> from astropy.modeling.models import Tabular1D, Tabular2D\nastropy\/modeling\/tabular.py:        >>> t1 = Tabular1D(points=[1, 2, 3], lookup_table=[10, 20, 30])\nastropy\/modeling\/tabular.py:        >>> t2 = Tabular2D(points=[[1, 2, 3], [2, 3, 4]],\nastropy\/modeling\/tabular.py:        Dimensions of the lookup table.\nastropy\/modeling\/tabular.py:    >>> tab = tabular_model(2, name='Tabular2D')\nastropy\/modeling\/tabular.py:    <class 'abc.Tabular2D'>\nastropy\/modeling\/tabular.py:    Name: Tabular2D\nastropy\/modeling\/tabular.py:Tabular1D = tabular_model(1, name='Tabular1D')\nastropy\/modeling\/tabular.py:Tabular2D = tabular_model(2, name='Tabular2D')\nastropy\/modeling\/tabular.py:        2-dimensional data. Default is \"linear\".\nastropy\/modeling\/tabular.py:Tabular1D.__doc__ = \"\"\"\nastropy\/modeling\/tabular.py:    Tabular model in 1D.\nastropy\/modeling\/tabular.py:Tabular2D.__doc__ = \"\"\"\nastropy\/modeling\/tabular.py:    Tabular model in 2D.\nastropy\/modeling\/tests\/test_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_models.py:from .example_models import models_1D, models_2D\nastropy\/modeling\/tests\/test_models.py:    \"\"\"Test bounding box evaluation for a 3D model\"\"\"\nastropy\/modeling\/tests\/test_models.py:    class Ellipsoid3D(models.custom_model(ellipsoid)):\nastropy\/modeling\/tests\/test_models.py:    model = Ellipsoid3D()\nastropy\/modeling\/tests\/test_models.py:class Fittable2DModelTester:\nastropy\/modeling\/tests\/test_models.py:    def test_input2D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:    def test_eval2D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:    def test_bounding_box2D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:    def test_fitter2D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:    def test_deriv_2D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:            pytest.skip(\"Derivative function is not defined for model.\")\nastropy\/modeling\/tests\/test_models.py:class Fittable1DModelTester:\nastropy\/modeling\/tests\/test_models.py:    def test_input1D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:    def test_eval1D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:    def test_bounding_box1D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:        if isinstance(model, models.Lorentz1D):\nastropy\/modeling\/tests\/test_models.py:    def test_fitter1D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:    def test_deriv_1D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:            pytest.skip(\"Derivative function is not defined for model.\")\nastropy\/modeling\/tests\/test_models.py:                         sorted(models_1D.items(), key=lambda x: str(x[0])))\nastropy\/modeling\/tests\/test_models.py:class TestFittable1DModels(Fittable1DModelTester):\nastropy\/modeling\/tests\/test_models.py:                         sorted(models_2D.items(), key=lambda x: str(x[0])))\nastropy\/modeling\/tests\/test_models.py:class TestFittable2DModels(Fittable2DModelTester):\nastropy\/modeling\/tests\/test_models.py:    m = models.Voigt1D(x_0=5, amplitude_L=10, fwhm_L=0.5, fwhm_G=0.9)\nastropy\/modeling\/tests\/test_models.py:    m = models.Gaussian1D(1.5, 2.5, 3.5)\nastropy\/modeling\/tests\/test_models.py:    assert repr(m) == '<Gaussian1D(amplitude=1.5, mean=2.5, stddev=3.5)>'\nastropy\/modeling\/tests\/test_models.py:    Test Tabular1D model.\nastropy\/modeling\/tests\/test_models.py:    # test 2D arrays as input\nastropy\/modeling\/tests\/test_models.py:    t = models.Tabular2D(lookup_table=a)\nastropy\/modeling\/tests\/test_models.py:    p = models.Polynomial2D(2) & models.Polynomial2D(2)\nastropy\/modeling\/tests\/test_models.py:    # test the order of bbox is not reversed for 1D models\nastropy\/modeling\/tests\/test_models.py:    p = models.Polynomial1D(1, c0=12, c1=2.3)\nastropy\/modeling\/tests\/test_constraints.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_constraints.py:from ..core import Fittable1DModel\nastropy\/modeling\/tests\/test_constraints.py:        self.g1 = models.Gaussian1D(10, 14.9, stddev=.3)\nastropy\/modeling\/tests\/test_constraints.py:        self.g2 = models.Gaussian1D(10, 13, stddev=.4)\nastropy\/modeling\/tests\/test_constraints.py:        g1 = models.Gaussian1D(10, mean=14.9, stddev=.3,\nastropy\/modeling\/tests\/test_constraints.py:        g1 = models.Gaussian1D(10, mean=14.9, stddev=.3, tied={'mean': tied})\nastropy\/modeling\/tests\/test_constraints.py:        g1 = models.Gaussian1D(10, 14.9, stddev=.3)\nastropy\/modeling\/tests\/test_constraints.py:        g2 = models.Gaussian1D(10, 13, stddev=.4)\nastropy\/modeling\/tests\/test_constraints.py:        g1 = models.Gaussian1D(9.9, 14.5, stddev=.3)\nastropy\/modeling\/tests\/test_constraints.py:        line_model = models.Linear1D(guess_slope, guess_intercept,\nastropy\/modeling\/tests\/test_constraints.py:        line_model = models.Linear1D(guess_slope, guess_intercept,\nastropy\/modeling\/tests\/test_constraints.py:        gauss = models.Gaussian2D(amplitude=10., x_mean=5., y_mean=5.,\nastropy\/modeling\/tests\/test_constraints.py:        gauss = models.Gaussian2D(amplitude=10., x_mean=5., y_mean=5.,\nastropy\/modeling\/tests\/test_constraints.py:        self.p1 = models.Polynomial1D(4)\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1)\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1,\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1)\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1,\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1,\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1,\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1,\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1)\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1,\nastropy\/modeling\/tests\/test_constraints.py:    class MyModel(Fittable1DModel):\nastropy\/modeling\/tests\/test_constraints.py:    m = models.Gaussian1D(amplitude=3, mean=4, stddev=1,\nastropy\/modeling\/tests\/test_constraints.py:    class MyModel(Fittable1DModel):\nastropy\/modeling\/tests\/test_constraints.py:    # This is 2D Gaussian with noise to be fitted, as provided by @ysBach\nastropy\/modeling\/tests\/test_constraints.py:    g_init = models.Gaussian2D(x_mean=8, y_mean=8)\nastropy\/time\/tests\/test_basic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_basic.py:        # (internal JD1 and JD1 are now with respect to TT scale)\"\"\"\nastropy\/time\/tests\/test_basic.py:        TDB, TT, UT1, UTC).  This requires auxiliary information (latitude and\nastropy\/time\/tests\/test_basic.py:        \"\"\"Test that all transforms work.  Does not test correctness,\nastropy\/time\/tests\/test_basic.py:        Time('2000-01-01T12:23:34.0(TDB)', format='fits')\nastropy\/time\/tests\/test_basic.py:            # Delta time gives 2 seconds here as expected\nastropy\/time\/tests\/test_basic.py:        \"\"\"Year:Day_of_year format\"\"\"\nastropy\/time\/tests\/test_basic.py:        # Value take from Chandra.Time.DateTime('2010:001:00:00:00').secs\nastropy\/time\/tests\/test_basic.py:        assert 'bad day    (JD computed)' in str(w[0].message)\nastropy\/modeling\/tests\/test_functional_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_functional_models.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/modeling\/tests\/test_functional_models.py:def test_Trapezoid1D():\nastropy\/modeling\/tests\/test_functional_models.py:    model = models.Trapezoid1D(amplitude=4.2, x_0=2.0, width=1.0, slope=3)\nastropy\/modeling\/tests\/test_functional_models.py:def test_Gaussian2D():\nastropy\/modeling\/tests\/test_functional_models.py:    Test rotated elliptical Gaussian2D model.\nastropy\/modeling\/tests\/test_functional_models.py:    model = models.Gaussian2D(4.2, 1.7, 3.1, x_stddev=5.1, y_stddev=3.3,\nastropy\/modeling\/tests\/test_functional_models.py:def test_Gaussian2DCovariance():\nastropy\/modeling\/tests\/test_functional_models.py:    Test rotated elliptical Gaussian2D model when cov_matrix is input.\nastropy\/modeling\/tests\/test_functional_models.py:    model = models.Gaussian2D(17., 2.0, 2.5, cov_matrix=cov_matrix)\nastropy\/modeling\/tests\/test_functional_models.py:def test_Gaussian2DRotation():\nastropy\/modeling\/tests\/test_functional_models.py:    rotation = models.Rotation2D(angle=theta.degree)\nastropy\/modeling\/tests\/test_functional_models.py:    g1 = models.Gaussian2D(theta=0, **pars)\nastropy\/modeling\/tests\/test_functional_models.py:    g2 = models.Gaussian2D(theta=theta.radian, **pars)\nastropy\/modeling\/tests\/test_functional_models.py:def test_Gaussian2D_invalid_inputs():\nastropy\/modeling\/tests\/test_functional_models.py:    models.Gaussian2D()\nastropy\/modeling\/tests\/test_functional_models.py:    models.Gaussian2D(x_stddev=x_stddev, y_stddev=y_stddev, theta=theta)\nastropy\/modeling\/tests\/test_functional_models.py:    models.Gaussian2D(x_stddev=None, y_stddev=y_stddev, theta=theta)\nastropy\/modeling\/tests\/test_functional_models.py:    models.Gaussian2D(x_stddev=x_stddev, y_stddev=None, theta=theta)\nastropy\/modeling\/tests\/test_functional_models.py:    models.Gaussian2D(x_stddev=x_stddev, y_stddev=y_stddev, theta=None)\nastropy\/modeling\/tests\/test_functional_models.py:    models.Gaussian2D(cov_matrix=cov_matrix)\nastropy\/modeling\/tests\/test_functional_models.py:        models.Gaussian2D(x_stddev=0, cov_matrix=cov_matrix)\nastropy\/modeling\/tests\/test_functional_models.py:        models.Gaussian2D(y_stddev=0, cov_matrix=cov_matrix)\nastropy\/modeling\/tests\/test_functional_models.py:        models.Gaussian2D(theta=0, cov_matrix=cov_matrix)\nastropy\/modeling\/tests\/test_functional_models.py:    m1 = models.Moffat1D(**kwargs)\nastropy\/modeling\/tests\/test_functional_models.py:    m2 = models.Moffat2D(**kwargs)\nastropy\/modeling\/tests\/test_functional_models.py:def test_Ellipse2D():\nastropy\/modeling\/tests\/test_functional_models.py:    \"\"\"Test Ellipse2D model.\"\"\"\nastropy\/modeling\/tests\/test_functional_models.py:    em = models.Ellipse2D(amplitude, x0, y0, 7, 3, theta.radian)\nastropy\/modeling\/tests\/test_functional_models.py:    rotation = models.Rotation2D(angle=theta.degree)\nastropy\/modeling\/tests\/test_functional_models.py:    point1 = [2, 0]      # Rotation2D center is (0, 0)\nastropy\/modeling\/tests\/test_functional_models.py:    e1 = models.Ellipse2D(amplitude, x0, y0, 7, 3, theta=0.)\nastropy\/modeling\/tests\/test_functional_models.py:    e2 = models.Ellipse2D(amplitude, x0, y0, 7, 3, theta=theta.radian)\nastropy\/modeling\/tests\/test_functional_models.py:def test_Ellipse2D_circular():\nastropy\/modeling\/tests\/test_functional_models.py:    \"\"\"Test that circular Ellipse2D agrees with Disk2D [3736].\"\"\"\nastropy\/modeling\/tests\/test_functional_models.py:    ellipse = models.Ellipse2D(amplitude, radius, radius, radius, radius,\nastropy\/modeling\/tests\/test_functional_models.py:    disk = models.Disk2D(amplitude, radius, radius, radius)(x, y)\nastropy\/modeling\/tests\/test_functional_models.py:def test_Ring2D_rout():\nastropy\/modeling\/tests\/test_functional_models.py:    m = models.Ring2D(amplitude=1, x_0=1, y_0=1, r_in=2, r_out=5)\nastropy\/modeling\/tests\/test_functional_models.py:def test_Voigt1D():\nastropy\/modeling\/tests\/test_functional_models.py:    voi = models.Voigt1D(amplitude_L=-0.5, x_0=1.0, fwhm_L=5.0, fwhm_G=5.0)\nastropy\/modeling\/tests\/test_functional_models.py:    voi_init = models.Voigt1D(amplitude_L=-1.0, x_0=1.0, fwhm_L=5.0, fwhm_G=5.0)\nastropy\/modeling\/tests\/test_functional_models.py:    models_2d = [models.AiryDisk2D, models.Sersic2D]\nastropy\/modeling\/tests\/test_functional_models.py:    models_1d = [models.Sersic1D]\nastropy\/modeling\/tests\/test_functional_models.py:        class CompoundModel2D(models.Const2D + model_2d):\nastropy\/modeling\/tests\/test_functional_models.py:        f = CompoundModel2D()(x, y)\nastropy\/modeling\/tests\/test_functional_models.py:        class CompoundModel1D(models.Const1D + model_1d):\nastropy\/modeling\/tests\/test_functional_models.py:        f = CompoundModel1D()(x)\nastropy\/modeling\/functional_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/functional_models.py:from collections import OrderedDict\nastropy\/modeling\/functional_models.py:from .core import (Fittable1DModel, Fittable2DModel,\nastropy\/modeling\/functional_models.py:                   ModelDefinitionError)\nastropy\/modeling\/functional_models.py:__all__ = ['AiryDisk2D', 'Moffat1D', 'Moffat2D', 'Box1D', 'Box2D', 'Const1D',\nastropy\/modeling\/functional_models.py:           'Const2D', 'Ellipse2D', 'Disk2D', 'Gaussian1D',\nastropy\/modeling\/functional_models.py:           'Gaussian2D', 'Linear1D', 'Lorentz1D',\nastropy\/modeling\/functional_models.py:           'MexicanHat1D', 'MexicanHat2D', 'RedshiftScaleFactor',\nastropy\/modeling\/functional_models.py:           'Scale', 'Sersic1D', 'Sersic2D', 'Shift', 'Sine1D', 'Trapezoid1D',\nastropy\/modeling\/functional_models.py:           'TrapezoidDisk2D', 'Ring2D', 'Voigt1D']\nastropy\/modeling\/functional_models.py:class Gaussian1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,\nastropy\/modeling\/functional_models.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)\nastropy\/modeling\/functional_models.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,\nastropy\/modeling\/functional_models.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Gaussian1D\nastropy\/modeling\/functional_models.py:        s1 = Gaussian1D()\nastropy\/modeling\/functional_models.py:    Gaussian2D, Box1D, Moffat1D, Lorentz1D\nastropy\/modeling\/functional_models.py:        >>> from astropy.modeling.models import Gaussian1D\nastropy\/modeling\/functional_models.py:        >>> model = Gaussian1D(mean=0, stddev=2)\nastropy\/modeling\/functional_models.py:        Gaussian1D model function.\nastropy\/modeling\/functional_models.py:        Gaussian1D model function derivatives.\nastropy\/modeling\/functional_models.py:        return OrderedDict([('mean', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Gaussian2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    See [1]_ for more details about the 2D Gaussian function.\nastropy\/modeling\/functional_models.py:    Gaussian1D, Box2D, Moffat2D\nastropy\/modeling\/functional_models.py:                    # TODO: Maybe it should be possible for the covariance matrix\nastropy\/modeling\/functional_models.py:        # TODO: Investigate why setting this in Parameter above causes\nastropy\/modeling\/functional_models.py:        >>> from astropy.modeling.models import Gaussian2D\nastropy\/modeling\/functional_models.py:        >>> model = Gaussian2D(x_mean=0, y_mean=0, x_stddev=1, y_stddev=2)\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_mean', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Shift(Fittable1DModel):\nastropy\/modeling\/functional_models.py:class Scale(Fittable1DModel):\nastropy\/modeling\/functional_models.py:class RedshiftScaleFactor(Fittable1DModel):\nastropy\/modeling\/functional_models.py:class Sersic1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Gaussian1D, Moffat1D, Lorentz1D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Sersic1D\nastropy\/modeling\/functional_models.py:        s1 = Sersic1D(amplitude=1, r_eff=5)\nastropy\/modeling\/functional_models.py:                raise ImportError('Sersic1D model requires scipy > 0.11.')\nastropy\/modeling\/functional_models.py:        return OrderedDict([('r_eff', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Sine1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Const1D, Linear1D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Sine1D\nastropy\/modeling\/functional_models.py:        s1 = Sine1D(amplitude=1, frequency=.25)\nastropy\/modeling\/functional_models.py:        return OrderedDict([('frequency', inputs_unit['x'] ** -1),\nastropy\/modeling\/functional_models.py:class Linear1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Const1D\nastropy\/modeling\/functional_models.py:        return OrderedDict([('intercept', outputs_unit['y']),\nastropy\/modeling\/functional_models.py:class Planar2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Linear1D, Polynomial2D\nastropy\/modeling\/functional_models.py:class Lorentz1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Gaussian1D, Box1D, MexicanHat1D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Lorentz1D\nastropy\/modeling\/functional_models.py:        s1 = Lorentz1D()\nastropy\/modeling\/functional_models.py:            Default is chosen to include most (99%) of the\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Voigt1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Gaussian1D, Lorentz1D\nastropy\/modeling\/functional_models.py:    McLean, A. B., Mitchell, C. E. J. & Swanston, D. M. Implementation of an\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Voigt1D\nastropy\/modeling\/functional_models.py:        v1 = Voigt1D(x_0=5, amplitude_L=10, fwhm_L=0.5, fwhm_G=0.9)\nastropy\/modeling\/functional_models.py:        [0.0210, -1.1858, -0.0210, 1.1858]])   # D\nastropy\/modeling\/functional_models.py:        A, B, C, D = cls._abcd\nastropy\/modeling\/functional_models.py:        V = np.sum((C * (Y - A) + D * (X - B))\/(((Y - A) ** 2 + (X - B) ** 2)), axis=-1)\nastropy\/modeling\/functional_models.py:        A, B, C, D = cls._abcd\nastropy\/modeling\/functional_models.py:        alpha = C * (Y - A) + D * (X - B)\nastropy\/modeling\/functional_models.py:        dVdx = np.sum((D\/beta - 2 * (X - B) * alpha \/ np.square(beta)), axis=-1)\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Const1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Const2D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Const1D\nastropy\/modeling\/functional_models.py:        s1 = Const1D()\nastropy\/modeling\/functional_models.py:        return OrderedDict([('amplitude', outputs_unit['y'])])\nastropy\/modeling\/functional_models.py:class Const2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Const1D\nastropy\/modeling\/functional_models.py:        return OrderedDict([('amplitude', outputs_unit['z'])])\nastropy\/modeling\/functional_models.py:class Ellipse2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    A 2D Ellipse model.\nastropy\/modeling\/functional_models.py:    Disk2D, Box2D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Ellipse2D\nastropy\/modeling\/functional_models.py:        e = Ellipse2D(amplitude=100., x_0=x0, y_0=y0, a=a, b=b,\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Disk2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Two dimensional radial symmetric Disk model.\nastropy\/modeling\/functional_models.py:    Box2D, TrapezoidDisk2D\nastropy\/modeling\/functional_models.py:        \"\"\"Two dimensional Disk model function\"\"\"\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Ring2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Disk2D, TrapezoidDisk2D\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Delta1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    \"\"\"One dimensional Dirac delta function.\"\"\"\nastropy\/modeling\/functional_models.py:        raise ModelDefinitionError(\"Not implemented\")\nastropy\/modeling\/functional_models.py:class Delta2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    \"\"\"Two dimensional Dirac delta function.\"\"\"\nastropy\/modeling\/functional_models.py:        raise ModelDefinitionError(\"Not implemented\")\nastropy\/modeling\/functional_models.py:class Box1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Box2D, TrapezoidDisk2D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Box1D\nastropy\/modeling\/functional_models.py:        s1 = Box1D()\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Box2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Box1D, Gaussian2D, Moffat2D\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Trapezoid1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Box1D, Gaussian1D, Moffat1D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Trapezoid1D\nastropy\/modeling\/functional_models.py:        s1 = Trapezoid1D()\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class TrapezoidDisk2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Disk2D, Box2D\nastropy\/modeling\/functional_models.py:        \"\"\"Two dimensional Trapezoid Disk model function\"\"\"\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class MexicanHat1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    MexicanHat2D, Box1D, Gaussian1D, Trapezoid1D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import MexicanHat1D\nastropy\/modeling\/functional_models.py:        s1 = MexicanHat1D()\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class MexicanHat2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    MexicanHat1D, Gaussian2D\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class AiryDisk2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Box2D, TrapezoidDisk2D, Gaussian2D\nastropy\/modeling\/functional_models.py:    limiting angular resolution and is approximately 1.22 * lambda \/ D,\nastropy\/modeling\/functional_models.py:    where lambda is the wavelength of the light and D is the diameter of\nastropy\/modeling\/functional_models.py:                raise ImportError('AiryDisk2D model requires scipy > 0.11.')\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Moffat1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Gaussian1D, Box1D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Moffat1D\nastropy\/modeling\/functional_models.py:        s1 = Moffat1D()\nastropy\/modeling\/functional_models.py:        Derivation of the formula is available in\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Moffat2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Gaussian2D, Box2D\nastropy\/modeling\/functional_models.py:        Derivation of the formula is available in\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Sersic2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Gaussian2D, Moffat2D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Sersic2D\nastropy\/modeling\/functional_models.py:        mod = Sersic2D(amplitude = 1, r_eff = 25, n=4, x_0=50, y_0=50,\nastropy\/modeling\/functional_models.py:                raise ImportError('Sersic2D model requires scipy > 0.11.')\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/convolution\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/utils.py:class DiscretizationError(Exception):\nastropy\/convolution\/utils.py:def add_kernel_arrays_1D(array_1, array_2):\nastropy\/convolution\/utils.py:    Add two 1D kernel arrays of different size.\nastropy\/convolution\/utils.py:def add_kernel_arrays_2D(array_1, array_2):\nastropy\/convolution\/utils.py:    Add two 2D kernel arrays of different size.\nastropy\/convolution\/utils.py:        size is well defined. Necessary only for 2D models.\nastropy\/convolution\/utils.py:                Discretize model by taking the value\nastropy\/convolution\/utils.py:                Discretize model by linearly interpolating\nastropy\/convolution\/utils.py:                For 2D models interpolation is bilinear.\nastropy\/convolution\/utils.py:                Discretize model by taking the average\nastropy\/convolution\/utils.py:                Discretize model by integrating the model\nastropy\/convolution\/utils.py:        Factor of oversampling. Default = 10.\nastropy\/convolution\/utils.py:    scale. Here is the example of a normalized Gaussian1D:\nastropy\/convolution\/utils.py:        from astropy.modeling.models import Gaussian1D\nastropy\/convolution\/utils.py:        gauss_1D = Gaussian1D(1 \/ (0.5 * np.sqrt(2 * np.pi)), 0, 0.5)\nastropy\/convolution\/utils.py:        y_center = discretize_model(gauss_1D, (-2, 3), mode='center')\nastropy\/convolution\/utils.py:        y_corner = discretize_model(gauss_1D, (-2, 3), mode='linear_interp')\nastropy\/convolution\/utils.py:        y_oversample = discretize_model(gauss_1D, (-2, 3), mode='oversample')\nastropy\/convolution\/utils.py:            return discretize_center_1D(model, x_range)\nastropy\/convolution\/utils.py:            return discretize_center_2D(model, x_range, y_range)\nastropy\/convolution\/utils.py:            return discretize_linear_1D(model, x_range)\nastropy\/convolution\/utils.py:            return discretize_bilinear_2D(model, x_range, y_range)\nastropy\/convolution\/utils.py:            return discretize_oversample_1D(model, x_range, factor)\nastropy\/convolution\/utils.py:            return discretize_oversample_2D(model, x_range, y_range, factor)\nastropy\/convolution\/utils.py:            return discretize_integrate_1D(model, x_range)\nastropy\/convolution\/utils.py:            return discretize_integrate_2D(model, x_range, y_range)\nastropy\/convolution\/utils.py:        raise DiscretizationError('Invalid mode.')\nastropy\/convolution\/utils.py:def discretize_center_1D(model, x_range):\nastropy\/convolution\/utils.py:    Discretize model by taking the value at the center of the bin.\nastropy\/convolution\/utils.py:def discretize_center_2D(model, x_range, y_range):\nastropy\/convolution\/utils.py:    Discretize model by taking the value at the center of the pixel.\nastropy\/convolution\/utils.py:def discretize_linear_1D(model, x_range):\nastropy\/convolution\/utils.py:    Discretize model by performing a linear interpolation.\nastropy\/convolution\/utils.py:def discretize_bilinear_2D(model, x_range, y_range):\nastropy\/convolution\/utils.py:    Discretize model by performing a bilinear interpolation.\nastropy\/convolution\/utils.py:def discretize_oversample_1D(model, x_range, factor=10):\nastropy\/convolution\/utils.py:    Discretize model by taking the average on an oversampled grid.\nastropy\/convolution\/utils.py:def discretize_oversample_2D(model, x_range, y_range, factor=10):\nastropy\/convolution\/utils.py:    Discretize model by taking the average on an oversampled grid.\nastropy\/convolution\/utils.py:def discretize_integrate_1D(model, x_range):\nastropy\/convolution\/utils.py:    Discretize model by integrating numerically the model over the bin.\nastropy\/convolution\/utils.py:def discretize_integrate_2D(model, x_range, y_range):\nastropy\/convolution\/utils.py:    Discretize model by integrating the model over the pixel.\nastropy\/modeling\/tests\/test_quantities_rotations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_quantities_rotations.py:    w.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/modeling\/tests\/test_quantities_rotations.py:def test_Rotation2D():\nastropy\/modeling\/tests\/test_quantities_rotations.py:    model = models.Rotation2D(angle=90 * u.deg)\nastropy\/modeling\/tests\/test_quantities_rotations.py:def test_Rotation2D_inverse():\nastropy\/modeling\/tests\/test_quantities_rotations.py:    model = models.Rotation2D(angle=234.23494 * u.deg)\nastropy\/convolution\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_corrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_corrs.py:from .. import Time, TimeDelta\nastropy\/time\/tests\/test_corrs.py:        assert isinstance(hval, TimeDelta)\nastropy\/time\/tests\/test_corrs.py:        assert isinstance(bval, TimeDelta)\nastropy\/modeling\/tests\/test_quantities_evaluation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_quantities_evaluation.py:from ..models import Gaussian1D\nastropy\/modeling\/tests\/test_quantities_evaluation.py:    g = Gaussian1D(1, 1, 0.1)\nastropy\/modeling\/tests\/test_quantities_evaluation.py:    gq = Gaussian1D(1 * u.J, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_evaluation.py:    # TODO: determine what error message should be here\nastropy\/modeling\/tests\/test_quantities_evaluation.py:    g = Gaussian1D(1 * u.Jy, 10 * u.nm, 2 * u.nm)\nastropy\/modeling\/tests\/test_input.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_input.py:from ..core import Model, FittableModel, Fittable1DModel\nastropy\/modeling\/tests\/test_input.py:    (models.Polynomial1D, [2]),\nastropy\/modeling\/tests\/test_input.py:    (models.Legendre1D, [2]),\nastropy\/modeling\/tests\/test_input.py:    (models.Chebyshev1D, [2]),\nastropy\/modeling\/tests\/test_input.py:    (models.Polynomial2D, [2]),\nastropy\/modeling\/tests\/test_input.py:    (models.Legendre2D, [1, 2]),\nastropy\/modeling\/tests\/test_input.py:    (models.Chebyshev2D, [1, 2])\nastropy\/modeling\/tests\/test_input.py:    def test_input1D(self, model, params):\nastropy\/modeling\/tests\/test_input.py:    def test_input2D(self, model, params):\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 set 1D x, 1pset\"\"\"\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(3)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 set 1D x, 2 sets 1D y, 2 param_sets\"\"\"\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(3, n_models=2)\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(3, model_set_axis=0, **params)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 pset, 1 set 1D x, 1 set 1D y, Chebyshev 1D polynomial\"\"\"\nastropy\/modeling\/tests\/test_input.py:        ch1 = models.Chebyshev1D(3)\nastropy\/modeling\/tests\/test_input.py:        1 pset, 1 set 1D x, 1 set 1D y, Legendre 1D polynomial\nastropy\/modeling\/tests\/test_input.py:        leg1 = models.Legendre1D(3)\nastropy\/modeling\/tests\/test_input.py:        p2 = models.Polynomial2D(2)\nastropy\/modeling\/tests\/test_input.py:            p1 = models.Polynomial1D(5)\nastropy\/modeling\/tests\/test_input.py:            p1 = models.Polynomial1D(5, n_models=2)\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(5, n_models=2)\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(5, model_set_axis=0, **params)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 set 1D x, 1 set 1D y, 1 pset NonLinearFitter\"\"\"\nastropy\/modeling\/tests\/test_input.py:        g1 = models.Gaussian1D(10, mean=3, stddev=.2)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 set 1D x, 1 set 1D y, 2 param_sets, NonLinearFitter\"\"\"\nastropy\/modeling\/tests\/test_input.py:            g1 = models.Gaussian1D([10.2, 10], mean=[3, 3.2], stddev=[.23, .2],\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 set 2d x, 1set 2D y, 1 pset, NonLinearFitter\"\"\"\nastropy\/modeling\/tests\/test_input.py:        g2 = models.Gaussian2D(10, x_mean=3, y_mean=4, x_stddev=.3,\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 set 2d x, 1set 2D y, 2 param_sets, NonLinearFitter\"\"\"\nastropy\/modeling\/tests\/test_input.py:            g2 = models.Gaussian2D([10, 10], [3, 3], [4, 4], x_stddev=[.3, .3],\nastropy\/modeling\/tests\/test_input.py:            N param sets , 1 set 1D x --> N 1D y data\nastropy\/modeling\/tests\/test_input.py:        g1 = models.Gaussian1D([10, 10], [3, 3], [.2, .2], n_models=2)\nastropy\/modeling\/tests\/test_input.py:        This case covers: N param sets , N sets 1D x --> N N sets 1D y data\nastropy\/modeling\/tests\/test_input.py:        g1 = models.Gaussian1D([10, 10], [3, 3], [.2, .2], n_models=2)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 data set, 1 pset, Polynomial1D\"\"\"\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(4)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"N data sets, N param_sets, Polynomial1D\"\"\"\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(4, n_models=2)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 pset, 1 2D data set, Polynomial2D\"\"\"\nastropy\/modeling\/tests\/test_input.py:        p2 = models.Polynomial2D(5)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"N param_sets, N 2D data sets, Poly2d\"\"\"\nastropy\/modeling\/tests\/test_input.py:        p2 = models.Polynomial2D(5, n_models=2)\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(5, n_models=2)\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(5)\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(5)\nastropy\/modeling\/tests\/test_input.py:        g = models.Gaussian2D(1., 5., 4., cov_matrix=cov)\nastropy\/modeling\/tests\/test_input.py:class TModel_1_1(Fittable1DModel):\nastropy\/modeling\/tests\/test_input.py:            # Doesn't broadcast\nastropy\/modeling\/tests\/test_input.py:            # Doesn't broadcast\nastropy\/modeling\/tests\/test_input.py:        Scalar parameters with a scalar input should return a 1-D array with\nastropy\/modeling\/tests\/test_input.py:            # Doesn't broadcast with the shape of the parameters, (3,)\nastropy\/modeling\/tests\/test_input.py:class TestSingleInputDoubleOutputSingleModel:\nastropy\/modeling\/tests\/test_input.py:            # Doesn't broadcast\nastropy\/modeling\/tests\/test_input.py:            # Doesn't broadcast\nastropy\/convolution\/kernels.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/kernels.py:from .core import Kernel1D, Kernel2D, Kernel\nastropy\/convolution\/kernels.py:from ..modeling.core import Fittable1DModel, Fittable2DModel\nastropy\/convolution\/kernels.py:__all__ = ['Gaussian1DKernel', 'Gaussian2DKernel', 'CustomKernel',\nastropy\/convolution\/kernels.py:           'Box1DKernel', 'Box2DKernel', 'Tophat2DKernel',\nastropy\/convolution\/kernels.py:           'Trapezoid1DKernel', 'MexicanHat1DKernel', 'MexicanHat2DKernel',\nastropy\/convolution\/kernels.py:           'AiryDisk2DKernel', 'Moffat2DKernel', 'Model1DKernel',\nastropy\/convolution\/kernels.py:           'Model2DKernel', 'TrapezoidDisk2DKernel', 'Ring2DKernel']\nastropy\/convolution\/kernels.py:class Gaussian1DKernel(Kernel1D):\nastropy\/convolution\/kernels.py:    1D Gaussian filter kernel.\nastropy\/convolution\/kernels.py:        Size of the kernel array. Default = 8 * stddev\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by linearly interpolating\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10. If the factor\nastropy\/convolution\/kernels.py:    Box1DKernel, Trapezoid1DKernel, MexicanHat1DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Gaussian1DKernel\nastropy\/convolution\/kernels.py:        gauss_1D_kernel = Gaussian1DKernel(10)\nastropy\/convolution\/kernels.py:        plt.plot(gauss_1D_kernel, drawstyle='steps')\nastropy\/convolution\/kernels.py:        self._model = models.Gaussian1D(1. \/ (np.sqrt(2 * np.pi) * stddev),\nastropy\/convolution\/kernels.py:class Gaussian2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D Gaussian filter kernel.\nastropy\/convolution\/kernels.py:        Size in x direction of the kernel array. Default = 8 * stddev.\nastropy\/convolution\/kernels.py:        Size in y direction of the kernel array. Default = 8 * stddev.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Box2DKernel, Tophat2DKernel, MexicanHat2DKernel, Ring2DKernel,\nastropy\/convolution\/kernels.py:    TrapezoidDisk2DKernel, AiryDisk2DKernel, Moffat2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Gaussian2DKernel\nastropy\/convolution\/kernels.py:        gaussian_2D_kernel = Gaussian2DKernel(10)\nastropy\/convolution\/kernels.py:        plt.imshow(gaussian_2D_kernel, interpolation='none', origin='lower')\nastropy\/convolution\/kernels.py:        self._model = models.Gaussian2D(1. \/ (2 * np.pi * x_stddev * y_stddev),\nastropy\/convolution\/kernels.py:class Box1DKernel(Kernel1D):\nastropy\/convolution\/kernels.py:    1D Box filter kernel.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by linearly interpolating\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian1DKernel, Trapezoid1DKernel, MexicanHat1DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Box1DKernel\nastropy\/convolution\/kernels.py:        box_1D_kernel = Box1DKernel(9)\nastropy\/convolution\/kernels.py:        plt.plot(box_1D_kernel, drawstyle='steps')\nastropy\/convolution\/kernels.py:        self._model = models.Box1D(1. \/ width, 0, width)\nastropy\/convolution\/kernels.py:class Box2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D Box filter kernel.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian2DKernel, Tophat2DKernel, MexicanHat2DKernel, Ring2DKernel,\nastropy\/convolution\/kernels.py:    TrapezoidDisk2DKernel, AiryDisk2DKernel, Moffat2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Box2DKernel\nastropy\/convolution\/kernels.py:        box_2D_kernel = Box2DKernel(9)\nastropy\/convolution\/kernels.py:        plt.imshow(box_2D_kernel, interpolation='none', origin='lower',\nastropy\/convolution\/kernels.py:        self._model = models.Box2D(1. \/ width ** 2, 0, 0, width, width)\nastropy\/convolution\/kernels.py:class Tophat2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D Tophat filter kernel.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian2DKernel, Box2DKernel, MexicanHat2DKernel, Ring2DKernel,\nastropy\/convolution\/kernels.py:    TrapezoidDisk2DKernel, AiryDisk2DKernel, Moffat2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Tophat2DKernel\nastropy\/convolution\/kernels.py:        tophat_2D_kernel = Tophat2DKernel(40)\nastropy\/convolution\/kernels.py:        plt.imshow(tophat_2D_kernel, interpolation='none', origin='lower')\nastropy\/convolution\/kernels.py:        self._model = models.Disk2D(1. \/ (np.pi * radius ** 2), 0, 0, radius)\nastropy\/convolution\/kernels.py:class Ring2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D Ring filter kernel.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian2DKernel, Box2DKernel, Tophat2DKernel, MexicanHat2DKernel,\nastropy\/convolution\/kernels.py:    Ring2DKernel, AiryDisk2DKernel, Moffat2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Ring2DKernel\nastropy\/convolution\/kernels.py:        ring_2D_kernel = Ring2DKernel(9, 8)\nastropy\/convolution\/kernels.py:        plt.imshow(ring_2D_kernel, interpolation='none', origin='lower')\nastropy\/convolution\/kernels.py:        self._model = models.Ring2D(1. \/ (np.pi * (radius_out ** 2 - radius_in ** 2)),\nastropy\/convolution\/kernels.py:class Trapezoid1DKernel(Kernel1D):\nastropy\/convolution\/kernels.py:    1D trapezoid kernel.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by linearly interpolating\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Box1DKernel, Gaussian1DKernel, MexicanHat1DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Trapezoid1DKernel\nastropy\/convolution\/kernels.py:        trapezoid_1D_kernel = Trapezoid1DKernel(17, slope=0.2)\nastropy\/convolution\/kernels.py:        plt.plot(trapezoid_1D_kernel, drawstyle='steps')\nastropy\/convolution\/kernels.py:        self._model = models.Trapezoid1D(1, 0, width, slope)\nastropy\/convolution\/kernels.py:class TrapezoidDisk2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D trapezoid kernel.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian2DKernel, Box2DKernel, Tophat2DKernel, MexicanHat2DKernel,\nastropy\/convolution\/kernels.py:    Ring2DKernel, AiryDisk2DKernel, Moffat2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import TrapezoidDisk2DKernel\nastropy\/convolution\/kernels.py:        trapezoid_2D_kernel = TrapezoidDisk2DKernel(20, slope=0.2)\nastropy\/convolution\/kernels.py:        plt.imshow(trapezoid_2D_kernel, interpolation='none', origin='lower')\nastropy\/convolution\/kernels.py:        self._model = models.TrapezoidDisk2D(1, 0, 0, radius, slope)\nastropy\/convolution\/kernels.py:class MexicanHat1DKernel(Kernel1D):\nastropy\/convolution\/kernels.py:    1D Mexican hat filter kernel.\nastropy\/convolution\/kernels.py:        Size in x direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by linearly interpolating\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Box1DKernel, Gaussian1DKernel, Trapezoid1DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import MexicanHat1DKernel\nastropy\/convolution\/kernels.py:        mexicanhat_1D_kernel = MexicanHat1DKernel(10)\nastropy\/convolution\/kernels.py:        plt.plot(mexicanhat_1D_kernel, drawstyle='steps')\nastropy\/convolution\/kernels.py:        self._model = models.MexicanHat1D(amplitude, 0, width)\nastropy\/convolution\/kernels.py:class MexicanHat2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D Mexican hat filter kernel.\nastropy\/convolution\/kernels.py:        Size in x direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/kernels.py:        Size in y direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian2DKernel, Box2DKernel, Tophat2DKernel, Ring2DKernel,\nastropy\/convolution\/kernels.py:    TrapezoidDisk2DKernel, AiryDisk2DKernel, Moffat2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import MexicanHat2DKernel\nastropy\/convolution\/kernels.py:        mexicanhat_2D_kernel = MexicanHat2DKernel(10)\nastropy\/convolution\/kernels.py:        plt.imshow(mexicanhat_2D_kernel, interpolation='none', origin='lower')\nastropy\/convolution\/kernels.py:        self._model = models.MexicanHat2D(amplitude, 0, 0, width)\nastropy\/convolution\/kernels.py:class AiryDisk2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D Airy disk kernel.\nastropy\/convolution\/kernels.py:        Size in x direction of the kernel array. Default = 8 * radius.\nastropy\/convolution\/kernels.py:        Size in y direction of the kernel array. Default = 8 * radius.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian2DKernel, Box2DKernel, Tophat2DKernel, MexicanHat2DKernel,\nastropy\/convolution\/kernels.py:    Ring2DKernel, TrapezoidDisk2DKernel, AiryDisk2DKernel, Moffat2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import AiryDisk2DKernel\nastropy\/convolution\/kernels.py:        airydisk_2D_kernel = AiryDisk2DKernel(10)\nastropy\/convolution\/kernels.py:        plt.imshow(airydisk_2D_kernel, interpolation='none', origin='lower')\nastropy\/convolution\/kernels.py:        self._model = models.AiryDisk2D(1, 0, 0, radius)\nastropy\/convolution\/kernels.py:class Moffat2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D Moffat kernel.\nastropy\/convolution\/kernels.py:        Size in x direction of the kernel array. Default = 8 * radius.\nastropy\/convolution\/kernels.py:        Size in y direction of the kernel array. Default = 8 * radius.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian2DKernel, Box2DKernel, Tophat2DKernel, MexicanHat2DKernel,\nastropy\/convolution\/kernels.py:    Ring2DKernel, TrapezoidDisk2DKernel, AiryDisk2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Moffat2DKernel\nastropy\/convolution\/kernels.py:        moffat_2D_kernel = Moffat2DKernel(3, 2)\nastropy\/convolution\/kernels.py:        plt.imshow(moffat_2D_kernel, interpolation='none', origin='lower')\nastropy\/convolution\/kernels.py:        self._model = models.Moffat2D((gamma - 1.0) \/ (np.pi * alpha * alpha),\nastropy\/convolution\/kernels.py:class Model1DKernel(Kernel1D):\nastropy\/convolution\/kernels.py:    Create kernel from 1D model.\nastropy\/convolution\/kernels.py:    model : `~astropy.modeling.Fittable1DModel`\nastropy\/convolution\/kernels.py:        Size in x direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by linearly interpolating\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:        If model is not an instance of `~astropy.modeling.Fittable1DModel`\nastropy\/convolution\/kernels.py:    Model2DKernel : Create kernel from `~astropy.modeling.Fittable2DModel`\nastropy\/convolution\/kernels.py:    Define a Gaussian1D model:\nastropy\/convolution\/kernels.py:        >>> from astropy.modeling.models import Gaussian1D\nastropy\/convolution\/kernels.py:        >>> from astropy.convolution.kernels import Model1DKernel\nastropy\/convolution\/kernels.py:        >>> gauss = Gaussian1D(1, 0, 2)\nastropy\/convolution\/kernels.py:        >>> gauss_kernel = Model1DKernel(gauss, x_size=9)\nastropy\/convolution\/kernels.py:        if isinstance(model, Fittable1DModel):\nastropy\/convolution\/kernels.py:            raise TypeError(\"Must be Fittable1DModel\")\nastropy\/convolution\/kernels.py:class Model2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    Create kernel from 2D model.\nastropy\/convolution\/kernels.py:    model : `~astropy.modeling.Fittable2DModel`\nastropy\/convolution\/kernels.py:        Size in x direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/kernels.py:        Size in y direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:        If model is not an instance of `~astropy.modeling.Fittable2DModel`\nastropy\/convolution\/kernels.py:    Model1DKernel : Create kernel from `~astropy.modeling.Fittable1DModel`\nastropy\/convolution\/kernels.py:    Define a Gaussian2D model:\nastropy\/convolution\/kernels.py:        >>> from astropy.modeling.models import Gaussian2D\nastropy\/convolution\/kernels.py:        >>> from astropy.convolution.kernels import Model2DKernel\nastropy\/convolution\/kernels.py:        >>> gauss = Gaussian2D(1, 0, 0, 2, 2)\nastropy\/convolution\/kernels.py:        >>> gauss_kernel = Model2DKernel(gauss, x_size=9)\nastropy\/convolution\/kernels.py:        if isinstance(model, Fittable2DModel):\nastropy\/convolution\/kernels.py:            raise TypeError(\"Must be Fittable2DModel\")\nastropy\/convolution\/kernels.py:class PSFKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    Model2DKernel, Model1DKernel\nastropy\/convolution\/kernels.py:    Define one dimensional array:\nastropy\/convolution\/kernels.py:    Define two dimensional array:\nastropy\/modeling\/tests\/example_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/example_models.py:`~astropy.modeling.FittableModel` defined. There is a dictionary for 1D and a\nastropy\/modeling\/tests\/example_models.py:dictionary for 2D models.\nastropy\/modeling\/tests\/example_models.py:    (2D model option)\nastropy\/modeling\/tests\/example_models.py:    x test range for the model fitter. Depending on the model this can differ\nastropy\/modeling\/tests\/example_models.py:    y test range for the model fitter. Depending on the model this can differ\nastropy\/modeling\/tests\/example_models.py:    e.g. the PowerLaw model should be tested over a few magnitudes.  (2D model\nastropy\/modeling\/tests\/example_models.py:    Gaussian1D, Sine1D, Box1D, Linear1D, Lorentz1D,\nastropy\/modeling\/tests\/example_models.py:    MexicanHat1D, Trapezoid1D, Const1D, Moffat1D,\nastropy\/modeling\/tests\/example_models.py:    Gaussian2D, Const2D, Box2D, MexicanHat2D,\nastropy\/modeling\/tests\/example_models.py:    TrapezoidDisk2D, AiryDisk2D, Moffat2D, Disk2D,\nastropy\/modeling\/tests\/example_models.py:    Ring2D, Sersic1D, Sersic2D, Voigt1D, Planar2D)\nastropy\/modeling\/tests\/example_models.py:from ..polynomial import Polynomial1D, Polynomial2D\nastropy\/modeling\/tests\/example_models.py:    PowerLaw1D, BrokenPowerLaw1D, SmoothlyBrokenPowerLaw1D, ExponentialCutoffPowerLaw1D,\nastropy\/modeling\/tests\/example_models.py:    LogParabola1D)\nastropy\/modeling\/tests\/example_models.py:# 1D Models\nastropy\/modeling\/tests\/example_models.py:models_1D = {\nastropy\/modeling\/tests\/example_models.py:    Gaussian1D: {\nastropy\/modeling\/tests\/example_models.py:    Sine1D: {\nastropy\/modeling\/tests\/example_models.py:    Box1D: {\nastropy\/modeling\/tests\/example_models.py:    Linear1D: {\nastropy\/modeling\/tests\/example_models.py:    Lorentz1D: {\nastropy\/modeling\/tests\/example_models.py:    MexicanHat1D: {\nastropy\/modeling\/tests\/example_models.py:    Trapezoid1D: {\nastropy\/modeling\/tests\/example_models.py:    Const1D: {\nastropy\/modeling\/tests\/example_models.py:    Moffat1D: {\nastropy\/modeling\/tests\/example_models.py:    PowerLaw1D: {\nastropy\/modeling\/tests\/example_models.py:    BrokenPowerLaw1D: {\nastropy\/modeling\/tests\/example_models.py:    SmoothlyBrokenPowerLaw1D: {\nastropy\/modeling\/tests\/example_models.py:    ExponentialCutoffPowerLaw1D: {\nastropy\/modeling\/tests\/example_models.py:    LogParabola1D: {\nastropy\/modeling\/tests\/example_models.py:    Polynomial1D: {\nastropy\/modeling\/tests\/example_models.py:    Sersic1D: {\nastropy\/modeling\/tests\/example_models.py:    Voigt1D: {\nastropy\/modeling\/tests\/example_models.py:# 2D Models\nastropy\/modeling\/tests\/example_models.py:models_2D = {\nastropy\/modeling\/tests\/example_models.py:    Gaussian2D: {\nastropy\/modeling\/tests\/example_models.py:    Const2D: {\nastropy\/modeling\/tests\/example_models.py:    Box2D: {\nastropy\/modeling\/tests\/example_models.py:    MexicanHat2D: {\nastropy\/modeling\/tests\/example_models.py:    TrapezoidDisk2D: {\nastropy\/modeling\/tests\/example_models.py:    AiryDisk2D: {\nastropy\/modeling\/tests\/example_models.py:    Moffat2D: {\nastropy\/modeling\/tests\/example_models.py:    Polynomial2D: {\nastropy\/modeling\/tests\/example_models.py:    Disk2D: {\nastropy\/modeling\/tests\/example_models.py:    Ring2D: {\nastropy\/modeling\/tests\/example_models.py:    Sersic2D: {\nastropy\/modeling\/tests\/example_models.py:    Planar2D: {\nastropy\/modeling\/tests\/test_blackbody.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_blackbody.py:from ..blackbody import BlackBody1D, blackbody_nu, blackbody_lambda, FNU\nastropy\/modeling\/tests\/test_blackbody.py:class TestBlackbody1D:\nastropy\/modeling\/tests\/test_blackbody.py:        b = BlackBody1D(temperature=temperature,\nastropy\/modeling\/tests\/test_blackbody.py:        b = BlackBody1D(3000 * u.K)\nastropy\/convolution\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/core.py:A filter kernel is mainly characterized by its response function. In the 1D\nastropy\/convolution\/core.py:case we speak of \"impulse response function\", in the 2D case we call it \"point\nastropy\/convolution\/core.py:Currently only symmetric 2D kernels are supported.\nastropy\/convolution\/core.py:from .utils import (discretize_model, add_kernel_arrays_1D,\nastropy\/convolution\/core.py:                    add_kernel_arrays_2D)\nastropy\/convolution\/core.py:__all__ = ['Kernel', 'Kernel1D', 'Kernel2D', 'kernel_arithmetics']\nastropy\/convolution\/core.py:        Deviation from the normalization to one.\nastropy\/convolution\/core.py:        A 2D filter is separable, when its filter array can be written as the\nastropy\/convolution\/core.py:        outer product of two 1D arrays.\nastropy\/convolution\/core.py:        performed by applying the 1D filter array consecutively on every dimension.\nastropy\/convolution\/core.py:class Kernel1D(Kernel):\nastropy\/convolution\/core.py:    Base class for 1D filter kernels.\nastropy\/convolution\/core.py:        Size of the kernel array. Default = 8 * width.\nastropy\/convolution\/core.py:                Discretize model by taking the value\nastropy\/convolution\/core.py:                Discretize model by linearly interpolating\nastropy\/convolution\/core.py:                Discretize model by taking the average\nastropy\/convolution\/core.py:                Discretize model by integrating the\nastropy\/convolution\/core.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/core.py:class Kernel2D(Kernel):\nastropy\/convolution\/core.py:    Base class for 2D filter kernels.\nastropy\/convolution\/core.py:        Size in x direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/core.py:        Size in y direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/core.py:                Discretize model by taking the value\nastropy\/convolution\/core.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/core.py:                Discretize model by taking the average\nastropy\/convolution\/core.py:                Discretize model by integrating the\nastropy\/convolution\/core.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/core.py:    # 1D kernels\nastropy\/convolution\/core.py:    if isinstance(kernel, Kernel1D) and isinstance(value, Kernel1D):\nastropy\/convolution\/core.py:            new_array = add_kernel_arrays_1D(kernel.array, value.array)\nastropy\/convolution\/core.py:            new_array = add_kernel_arrays_1D(kernel.array, -value.array)\nastropy\/convolution\/core.py:        new_kernel = Kernel1D(array=new_array)\nastropy\/convolution\/core.py:    # 2D kernels\nastropy\/convolution\/core.py:    elif isinstance(kernel, Kernel2D) and isinstance(value, Kernel2D):\nastropy\/convolution\/core.py:            new_array = add_kernel_arrays_2D(kernel.array, value.array)\nastropy\/convolution\/core.py:            new_array = add_kernel_arrays_2D(kernel.array, -value.array)\nastropy\/convolution\/core.py:        new_kernel = Kernel2D(array=new_array)\nastropy\/convolution\/core.py:    elif ((isinstance(kernel, Kernel1D) or isinstance(kernel, Kernel2D))\nastropy\/time\/tests\/test_methods.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_methods.py:        # Define arrays with same ordinal properties\nastropy\/modeling\/tests\/data\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_delta.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_delta.py:from .. import (Time, TimeDelta, OperandTypeError, ScaleValueError,\nastropy\/time\/tests\/test_delta.py:                TIME_SCALES, TIME_DELTA_SCALES)\nastropy\/time\/tests\/test_delta.py:class TestTimeDelta():\nastropy\/time\/tests\/test_delta.py:    \"\"\"Test TimeDelta class\"\"\"\nastropy\/time\/tests\/test_delta.py:        self.dt = TimeDelta(100.0, format='sec')\nastropy\/time\/tests\/test_delta.py:        self.dt_array = TimeDelta(np.arange(100, 1000, 100), format='sec')\nastropy\/time\/tests\/test_delta.py:        assert (repr(dt).startswith(\"<TimeDelta object: scale='tai' \"\nastropy\/time\/tests\/test_delta.py:        dt = TimeDelta(100.0, format='jd')\nastropy\/time\/tests\/test_delta.py:        dt2 = TimeDelta([100.0, 200.0], format='jd')\nastropy\/time\/tests\/test_delta.py:        dt = TimeDelta(100.0, format='jd')\nastropy\/time\/tests\/test_delta.py:        dt2 = TimeDelta([100.0, 200.0], format='jd')\nastropy\/time\/tests\/test_delta.py:        \"\"\"Test copying the values of a TimeDelta object by passing it into the\nastropy\/time\/tests\/test_delta.py:        dt2 = TimeDelta(dt, copy=False)\nastropy\/time\/tests\/test_delta.py:        dt2 = TimeDelta(dt, copy=True)\nastropy\/time\/tests\/test_delta.py:        dt2 = TimeDelta(dt, format='sec')\nastropy\/time\/tests\/test_delta.py:        dt = TimeDelta(1000., format='sec')\nastropy\/time\/tests\/test_delta.py:        dt = TimeDelta(86400.0, format='sec')\nastropy\/time\/tests\/test_delta.py:class TestTimeDeltaScales():\nastropy\/time\/tests\/test_delta.py:    \"\"\"Test scale conversion for Time Delta.\nastropy\/time\/tests\/test_delta.py:        for scale in list(TIME_DELTA_SCALES) + [None]:\nastropy\/time\/tests\/test_delta.py:            TimeDelta([0., 1., 10.], format='sec', scale=scale)\nastropy\/time\/tests\/test_delta.py:            TimeDelta([0., 1., 10.], format='sec', scale='utc')\nastropy\/time\/tests\/test_delta.py:        if scale1 in TIME_DELTA_SCALES:\nastropy\/time\/tests\/test_delta.py:        \"\"\"dT(X) +\/- dT2(Y) -- Add\/substract JDs for dT(X) and dT(Y).X\nastropy\/time\/tests\/test_delta.py:        This is always allowed and just adds JDs, i.e., the scale of\nastropy\/time\/tests\/test_delta.py:        the TimeDelta or time-like Quantity will be taken to be X.\nastropy\/time\/tests\/test_delta.py:        dt_none = TimeDelta([0., 1., -1., 1000.], format='sec')\nastropy\/time\/tests\/test_delta.py:        \"\"\"TimeDelta or Quantity holding 1 day always means 24*60*60 seconds\nastropy\/time\/tests\/test_delta.py:        dt_day = TimeDelta(1., format='jd')\nastropy\/time\/tests\/test_comparisons.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_comparisons.py:from .. import Time, TimeDelta, OperandTypeError\nastropy\/time\/tests\/test_comparisons.py:    \"\"\"Test Comparisons of Time and TimeDelta classes\"\"\"\nastropy\/time\/tests\/test_comparisons.py:        dt_gt_td0 = dt > TimeDelta(0., format='sec')\nastropy\/modeling\/tests\/test_compound.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_compound.py:from ..core import Model, ModelDefinitionError\nastropy\/modeling\/tests\/test_compound.py:from ..models import (Const1D, Shift, Scale, Rotation2D, Gaussian1D,\nastropy\/modeling\/tests\/test_compound.py:                      Gaussian2D, Polynomial1D, Polynomial2D,\nastropy\/modeling\/tests\/test_compound.py:                      Chebyshev2D, Legendre2D, Chebyshev1D, Legendre1D,\nastropy\/modeling\/tests\/test_compound.py:                      AffineTransformation2D, Identity, Mapping)\nastropy\/modeling\/tests\/test_compound.py:    # Const1D is perhaps the simplest model to test basic arithmetic with.\nastropy\/modeling\/tests\/test_compound.py:    # TODO: Should define more tests later on for more complicated\nastropy\/modeling\/tests\/test_compound.py:    S = expr(Const1D, Const1D)\nastropy\/modeling\/tests\/test_compound.py:    s = expr(Const1D((2, 2), n_models=2), Const1D((3, 3), n_models=2))\nastropy\/modeling\/tests\/test_compound.py:        s = expr(Const1D((2, 2), n_models=2), Const1D(3, n_models=1))\nastropy\/modeling\/tests\/test_compound.py:    s = expr(Const1D(2), Const1D(3))\nastropy\/modeling\/tests\/test_compound.py:    S1 = expr(Const1D, Const1D(3))\nastropy\/modeling\/tests\/test_compound.py:    S2 = expr(Const1D(2), Const1D)\nastropy\/modeling\/tests\/test_compound.py:    # TODO: We may wish to fix that eventually, so that if a parameter has a\nastropy\/modeling\/tests\/test_compound.py:    R = Rotation2D | Rotation2D\nastropy\/modeling\/tests\/test_compound.py:    g2 = Gaussian1D() + Gaussian1D()\nastropy\/modeling\/tests\/test_compound.py:    g3 = g2 + Gaussian1D()\nastropy\/modeling\/tests\/test_compound.py:    p = Polynomial1D + Polynomial1D\nastropy\/modeling\/tests\/test_compound.py:    G = Gaussian1D\nastropy\/modeling\/tests\/test_compound.py:    G2 = Gaussian2D\nastropy\/modeling\/tests\/test_compound.py:    g = Gaussian1D(1, 2, 3, name='g')\nastropy\/modeling\/tests\/test_compound.py:    p = Polynomial1D(2, name='p')\nastropy\/modeling\/tests\/test_compound.py:    M = Gaussian1D + Const1D\nastropy\/modeling\/tests\/test_compound.py:    assert M[0] is Gaussian1D\nastropy\/modeling\/tests\/test_compound.py:    assert M[1] is Const1D\nastropy\/modeling\/tests\/test_compound.py:    assert M['Gaussian1D'] is M[0]\nastropy\/modeling\/tests\/test_compound.py:    assert M['Const1D'] is M[1]\nastropy\/modeling\/tests\/test_compound.py:    M = Gaussian1D + p\nastropy\/modeling\/tests\/test_compound.py:    assert M[0] is Gaussian1D\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(M['p'], Polynomial1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[0], Gaussian1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[1], Polynomial1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m['g'], Gaussian1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m['p'], Polynomial1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[-1], Polynomial1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[-2], Gaussian1D)\nastropy\/modeling\/tests\/test_compound.py:# TODO: It would be good if there were an easier way to interrogate a compound\nastropy\/modeling\/tests\/test_compound.py:    A = Const1D.rename('A')\nastropy\/modeling\/tests\/test_compound.py:    B = Const1D.rename('B')\nastropy\/modeling\/tests\/test_compound.py:    C = Const1D.rename('C')\nastropy\/modeling\/tests\/test_compound.py:    D = Const1D.rename('D')\nastropy\/modeling\/tests\/test_compound.py:    E = Const1D.rename('E')\nastropy\/modeling\/tests\/test_compound.py:    F = Const1D.rename('F')\nastropy\/modeling\/tests\/test_compound.py:    M = A + B - C * D \/ E ** F\nastropy\/modeling\/tests\/test_compound.py:    assert M['C':'D'](3, 4)(0) == 12\nastropy\/modeling\/tests\/test_compound.py:    assert M['C':'D'].param_names == ('amplitude_2', 'amplitude_3')\nastropy\/modeling\/tests\/test_compound.py:    assert M['D':'E'](4, 5)(0) == 0.8\nastropy\/modeling\/tests\/test_compound.py:    assert M['D':'E'].param_names == ('amplitude_3', 'amplitude_4')\nastropy\/modeling\/tests\/test_compound.py:    A = Const1D.rename('A')\nastropy\/modeling\/tests\/test_compound.py:    B = Const1D.rename('B')\nastropy\/modeling\/tests\/test_compound.py:    C = Const1D.rename('C')\nastropy\/modeling\/tests\/test_compound.py:    D = Const1D.rename('D')\nastropy\/modeling\/tests\/test_compound.py:    E = Const1D.rename('E')\nastropy\/modeling\/tests\/test_compound.py:    F = Const1D.rename('F')\nastropy\/modeling\/tests\/test_compound.py:    M = A + B - C * D \/ E ** F\nastropy\/modeling\/tests\/test_compound.py:    assert m['C':'D'](0) == 12\nastropy\/modeling\/tests\/test_compound.py:    assert m['C':'D'].param_names == ('amplitude_2', 'amplitude_3')\nastropy\/modeling\/tests\/test_compound.py:    assert np.all(m['C':'D'].parameters == [3, 4])\nastropy\/modeling\/tests\/test_compound.py:    assert m['D':'E'](0) == 0.8\nastropy\/modeling\/tests\/test_compound.py:    assert m['D':'E'].param_names == ('amplitude_3', 'amplitude_4')\nastropy\/modeling\/tests\/test_compound.py:    assert np.all(m['D':'E'].parameters == [4, 5])\nastropy\/modeling\/tests\/test_compound.py:    M = Gaussian1D + Const1D\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[0], Gaussian1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[1], Const1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m['Gaussian1D'], Gaussian1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m['Const1D'], Const1D)\nastropy\/modeling\/tests\/test_compound.py:    g = Gaussian1D(1, 2, 3, name='g')\nastropy\/modeling\/tests\/test_compound.py:    p = Polynomial1D(2, name='p')\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[-1], Polynomial1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[-2], Gaussian1D)\nastropy\/modeling\/tests\/test_compound.py:    t = (Shift(2) & Shift(3)) | (Scale(2) & Scale(3)) | Rotation2D(90)\nastropy\/modeling\/tests\/test_compound.py:    Gaussian1D(1, 2, 3) | Gaussian1D(4, 5, 6)])\nastropy\/modeling\/tests\/test_compound.py:    x, y = Rotation2D(90)(1, 2)\nastropy\/modeling\/tests\/test_compound.py:    RS = Rotation2D | Mapping((1, 0))\nastropy\/modeling\/tests\/test_compound.py:    M = Rotation2D & Scale\nastropy\/modeling\/tests\/test_compound.py:    RS = Rotation2D & Scale\nastropy\/modeling\/tests\/test_compound.py:    rotation = Rotation2D(angle=90)\nastropy\/modeling\/tests\/test_compound.py:    TestModel = ident1 & Shift | Rotation2D\nastropy\/modeling\/tests\/test_compound.py:    model_c = Rotation2D(3, name='c')\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:    ModelDefinitionErrors being raised, but that was before we prevented\nastropy\/modeling\/tests\/test_compound.py:    model_c = Gaussian1D(3, 0, 0.1, name='c')\nastropy\/modeling\/tests\/test_compound.py:    p2 = Polynomial2D(1, c0_0=1, c1_0=2, c0_1=3)\nastropy\/modeling\/tests\/test_compound.py:    p1 = Polynomial2D(1, c0_0=1, c1_0=2, c0_1=3)\nastropy\/modeling\/tests\/test_compound.py:    aff = AffineTransformation2D(matrix=[[1, 2], [3, 4]], name='rotation')\nastropy\/modeling\/tests\/test_compound.py:    rot = AffineTransformation2D([[0, -1], [1, 0]])\nastropy\/modeling\/tests\/test_compound.py:    inspect.classify_class_attrs(Gaussian1D + Gaussian1D)\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:        Rotation2D | Gaussian1D\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:        Rotation2D(90) | Gaussian1D(1, 0, 0.1)\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:        Rotation2D + Gaussian1D\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:        Rotation2D(90) + Gaussian1D(1, 0, 0.1)\nastropy\/modeling\/tests\/test_compound.py:        [Gaussian1D(bounds={'stddev': (0, 0.3)}, fixed={'mean': True}) +\nastropy\/modeling\/tests\/test_compound.py:            Gaussian1D(fixed={'mean': True}),\nastropy\/modeling\/tests\/test_compound.py:    poly = Polynomial1D(1, c0=1, c1=2)\nastropy\/modeling\/tests\/test_compound.py:@pytest.mark.parametrize('poly', [Chebyshev2D(1, 2), Polynomial2D(2), Legendre2D(1, 2),\nastropy\/modeling\/tests\/test_compound.py:                                  Chebyshev1D(5), Legendre1D(5), Polynomial1D(5)])\nastropy\/modeling\/tests\/test_compound.py:class _TestPickleModel(Gaussian1D + Gaussian1D):\nastropy\/modeling\/tests\/test_compound.py:    GG = Gaussian1D + Gaussian1D\nastropy\/modeling\/tests\/test_compound.py:    g1 = Gaussian1D(1.0, 0.0, 0.1)\nastropy\/modeling\/tests\/test_compound.py:    g2 = Gaussian1D([2.0, 3.0], [0.0, 0.0], [0.2, 0.3])\nastropy\/time\/tests\/test_quantity_interaction.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_quantity_interaction.py:from .. import Time, TimeDelta, OperandTypeError\nastropy\/time\/tests\/test_quantity_interaction.py:        (even for time-like, since we cannot compare Time to TimeDelta)\"\"\"\nastropy\/time\/tests\/test_quantity_interaction.py:class TestTimeDeltaQuantity():\nastropy\/time\/tests\/test_quantity_interaction.py:    \"\"\"Test interaction of TimeDelta with Quantities\"\"\"\nastropy\/time\/tests\/test_quantity_interaction.py:        \"\"\"Test that TimeDelta can take quantity input.\"\"\"\nastropy\/time\/tests\/test_quantity_interaction.py:        dt1 = TimeDelta(q, format='jd')\nastropy\/time\/tests\/test_quantity_interaction.py:        dt2 = TimeDelta(q, format='sec')\nastropy\/time\/tests\/test_quantity_interaction.py:        dt3 = TimeDelta(q)\nastropy\/time\/tests\/test_quantity_interaction.py:            TimeDelta(2450000.*u.m, format='jd')\nastropy\/time\/tests\/test_quantity_interaction.py:            TimeDelta(100, format='sec') > 10.*u.m\nastropy\/time\/tests\/test_quantity_interaction.py:        dt = TimeDelta(q)\nastropy\/time\/tests\/test_quantity_interaction.py:        with a TimeDelta.  Addition\/subtraction should give TimeDelta\"\"\"\nastropy\/time\/tests\/test_quantity_interaction.py:        t0 = TimeDelta(106400., format='sec')\nastropy\/time\/tests\/test_quantity_interaction.py:        assert isinstance(t1, TimeDelta)\nastropy\/time\/tests\/test_quantity_interaction.py:        \"\"\"Check that TimeDelta is treated as a quantity where possible.\"\"\"\nastropy\/time\/tests\/test_quantity_interaction.py:        t0 = TimeDelta(100000., format='sec')\nastropy\/time\/tests\/test_quantity_interaction.py:        t1 = TimeDelta(np.arange(100000., 100012.).reshape(6, 2), format='sec')\nastropy\/time\/tests\/test_quantity_interaction.py:        \"\"\"Check comparisons of TimeDelta with non-time quantities fails.\"\"\"\nastropy\/time\/tests\/test_quantity_interaction.py:            TimeDelta(100000., format='sec') > 10.*u.m\nastropy\/time\/tests\/test_quantity_interaction.py:        t0 = TimeDelta(np.arange(12.).reshape(4, 3), format='sec')\nastropy\/time\/tests\/test_quantity_interaction.py:class TestDeltaAttributes():\nastropy\/time\/tests\/test_quantity_interaction.py:        # Also check that a TimeDelta works.\nastropy\/time\/tests\/test_quantity_interaction.py:        t.delta_ut1_utc = TimeDelta(0.3, format='sec')\nastropy\/time\/tests\/test_quantity_interaction.py:        t.delta_ut1_utc = TimeDelta(0.5\/24.\/3600., format='jd')\nastropy\/time\/tests\/test_quantity_interaction.py:        # Also check that a TimeDelta works.\nastropy\/time\/tests\/test_quantity_interaction.py:        t.delta_tdb_tt = TimeDelta(40., format='sec')\nastropy\/time\/tests\/test_quantity_interaction.py:        t.delta_tdb_tt = TimeDelta(50.\/24.\/3600., format='jd')\nastropy\/modeling\/tests\/test_core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_core.py:    model = models.Gaussian1D(4, 2, 1)\nastropy\/modeling\/tests\/test_core.py:        models.Gaussian1D(1, 2, 3, wrong=4)\nastropy\/modeling\/tests\/test_core.py:    p = models.Polynomial1D(1, c0=-2, c1=3)\nastropy\/modeling\/tests\/test_core.py:    inv = models.Polynomial1D(1, c0=(2.\/3.), c1=(1.\/3.))\nastropy\/modeling\/tests\/test_core.py:    model = models.Gaussian2D(x_stddev=6.1, y_stddev=3.9, theta=np.pi \/ 3)\nastropy\/modeling\/tests\/test_core.py:                    # this case is tested in Fittable2DModelTester\nastropy\/modeling\/tests\/test_core.py:    model = models.Gaussian1D()\nastropy\/modeling\/tests\/test_core.py:                    # this case is tested in Fittable1DModelTester\nastropy\/modeling\/tests\/test_core.py:    class Ellipsoid3D(custom_model(ellipsoid)):\nastropy\/modeling\/tests\/test_core.py:    model = Ellipsoid3D()\nastropy\/modeling\/tests\/test_core.py:    # 1D models\nastropy\/modeling\/tests\/test_core.py:    g1 = models.Gaussian1D()\nastropy\/modeling\/tests\/test_core.py:    # 2D models\nastropy\/modeling\/tests\/test_core.py:    g2 = models.Gaussian2D()\nastropy\/modeling\/tests\/test_core.py:    assert models.Gaussian1D.n_submodels() == 1\nastropy\/modeling\/tests\/test_core.py:    assert models.Gaussian2D.n_submodels() == 1\nastropy\/modeling\/tests\/test_core.py:    model = (models.Gaussian1D(10, 2,3) | models.Shift(2)) & models.Rotation2D(21.3)\nastropy\/time\/tests\/test_precision.py:from .. import Time, TimeDelta\nastropy\/time\/tests\/test_precision.py:dt_tiny = TimeDelta(2. ** -52, format='jd')\nastropy\/time\/tests\/test_precision.py:    dt_big = TimeDelta(20000., format='jd')\nastropy\/time\/tests\/test_precision.py:    dt_frac = dt_big_small_by_6 - TimeDelta(3333., format='jd')\nastropy\/time\/tests\/test_sidereal.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_sidereal.py:from ..core import SIDEREAL_TIME_MODELS\nastropy\/time\/tests\/test_sidereal.py:        for model in SIDEREAL_TIME_MODELS[kind]:\nastropy\/time\/tests\/test_sidereal.py:    # all tests use the following JD inputs\nastropy\/time\/tests\/test_sidereal.py:        assert kind in SIDEREAL_TIME_MODELS.keys()\nastropy\/time\/tests\/test_sidereal.py:        assert model_name in SIDEREAL_TIME_MODELS[kind]\nastropy\/time\/tests\/test_sidereal.py:        model = SIDEREAL_TIME_MODELS[kind][model_name]\nastropy\/time\/tests\/test_sidereal.py:                SIDEREAL_TIME_MODELS[kind].keys(), 2):\nastropy\/time\/tests\/test_sidereal.py:        for model in (set(SIDEREAL_TIME_MODELS[other].keys()) -\nastropy\/time\/tests\/test_sidereal.py:                      set(SIDEREAL_TIME_MODELS[kind].keys())):\nastropy\/modeling\/tests\/test_separable.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_separable.py:rot = models.Rotation2D(2, name='rotation')\nastropy\/modeling\/tests\/test_separable.py:p2 = models.Polynomial2D(1, name='p2')\nastropy\/modeling\/tests\/test_separable.py:p22 = models.Polynomial2D(2, name='p22')\nastropy\/modeling\/tests\/test_separable.py:p1 = models.Polynomial1D(1, name='p1')\nastropy\/modeling\/tests\/test_models_quantities.py:from collections import OrderedDict\nastropy\/modeling\/tests\/test_models_quantities.py:from ..functional_models import (Gaussian1D,\nastropy\/modeling\/tests\/test_models_quantities.py:                                 Sersic1D, Sine1D, Linear1D,\nastropy\/modeling\/tests\/test_models_quantities.py:                                 Lorentz1D, Voigt1D, Const1D,\nastropy\/modeling\/tests\/test_models_quantities.py:                                 Box1D, Trapezoid1D, MexicanHat1D,\nastropy\/modeling\/tests\/test_models_quantities.py:                                 Moffat1D, Gaussian2D, Const2D, Ellipse2D,\nastropy\/modeling\/tests\/test_models_quantities.py:                                 Disk2D, Ring2D, Box2D, TrapezoidDisk2D,\nastropy\/modeling\/tests\/test_models_quantities.py:                                 MexicanHat2D, AiryDisk2D, Moffat2D, Sersic2D)\nastropy\/modeling\/tests\/test_models_quantities.py:from ..powerlaws import (PowerLaw1D, BrokenPowerLaw1D, SmoothlyBrokenPowerLaw1D,\nastropy\/modeling\/tests\/test_models_quantities.py:                         ExponentialCutoffPowerLaw1D, LogParabola1D)\nastropy\/modeling\/tests\/test_models_quantities.py:from ..polynomial import Polynomial1D, Polynomial2D\nastropy\/modeling\/tests\/test_models_quantities.py:FUNC_MODELS_1D = [\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Gaussian1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Sersic1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Sine1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Linear1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Lorentz1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Voigt1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Const1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Box1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Trapezoid1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': MexicanHat1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Moffat1D,\nastropy\/modeling\/tests\/test_models_quantities.py:FUNC_MODELS_2D = [\nastropy\/modeling\/tests\/test_models_quantities.py: {'class': Gaussian2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Const2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Disk2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': TrapezoidDisk2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Ellipse2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Ring2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Box2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': MexicanHat2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': AiryDisk2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Moffat2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Sersic2D,\nastropy\/modeling\/tests\/test_models_quantities.py:POWERLAW_MODELS = [\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': PowerLaw1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': BrokenPowerLaw1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': SmoothlyBrokenPowerLaw1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': ExponentialCutoffPowerLaw1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': LogParabola1D,\nastropy\/modeling\/tests\/test_models_quantities.py:POLY_MODELS = [\nastropy\/modeling\/tests\/test_models_quantities.py:    {'class': Polynomial1D,\nastropy\/modeling\/tests\/test_models_quantities.py:    {'class': Polynomial1D,\nastropy\/modeling\/tests\/test_models_quantities.py:    {'class': Polynomial1D,\nastropy\/modeling\/tests\/test_models_quantities.py:    {'class': Polynomial2D,\nastropy\/modeling\/tests\/test_models_quantities.py:    {'class': Polynomial2D,\nastropy\/modeling\/tests\/test_models_quantities.py:    {'class': Polynomial2D,\nastropy\/modeling\/tests\/test_models_quantities.py:MODELS = FUNC_MODELS_1D + FUNC_MODELS_2D + POWERLAW_MODELS\nastropy\/modeling\/tests\/test_models_quantities.py:SCIPY_MODELS = set([Sersic1D, Sersic2D, AiryDisk2D])\nastropy\/modeling\/tests\/test_models_quantities.py:@pytest.mark.parametrize('model', MODELS)\nastropy\/modeling\/tests\/test_models_quantities.py:    if not HAS_SCIPY and model['class'] in SCIPY_MODELS:\nastropy\/modeling\/tests\/test_models_quantities.py:            kwargs = OrderedDict(zip(('x', 'y'), args))\nastropy\/modeling\/tests\/test_models_quantities.py:            kwargs = OrderedDict(zip(('x', 'y', 'z'), args))\nastropy\/modeling\/tests\/test_models_quantities.py:@pytest.mark.parametrize('model', MODELS)\nastropy\/modeling\/tests\/test_models_quantities.py:    if not HAS_SCIPY and model['class'] in SCIPY_MODELS:\nastropy\/modeling\/tests\/test_models_quantities.py:@pytest.mark.parametrize('model', MODELS)\nastropy\/modeling\/tests\/test_models_quantities.py:    if not HAS_SCIPY and model['class'] in SCIPY_MODELS:\nastropy\/modeling\/tests\/test_models_quantities.py:@pytest.mark.parametrize('model', MODELS)\nastropy\/modeling\/tests\/test_models_quantities.py:    if not HAS_SCIPY and model['class'] in SCIPY_MODELS:\nastropy\/modeling\/tests\/test_models_quantities.py:@pytest.mark.parametrize('model', MODELS)\nastropy\/modeling\/tests\/test_models_quantities.py:    if not HAS_SCIPY and model['class'] in SCIPY_MODELS:\nastropy\/modeling\/tests\/test_models_quantities.py:@pytest.mark.parametrize('model', MODELS)\nastropy\/time\/tests\/test_pickle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_quantities_fitting.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_quantities_fitting.py:from ..models import Gaussian1D\nastropy\/modeling\/tests\/test_quantities_fitting.py:    g_init = Gaussian1D()\nastropy\/modeling\/tests\/test_quantities_fitting.py:    # TODO: update actual numerical results once implemented, but these should\nastropy\/modeling\/tests\/test_quantities_fitting.py:    g_init = Gaussian1D(amplitude=1. * u.mJy, mean=3 * u.cm, stddev=2 * u.mm)\nastropy\/modeling\/tests\/test_quantities_fitting.py:    # TODO: update actual numerical results once implemented, but these should\nastropy\/modeling\/tests\/test_quantities_fitting.py:    g_init = Gaussian1D(amplitude=1. * u.mJy, mean=3 * u.cm, stddev=2 * u.mm)\nastropy\/modeling\/tests\/test_quantities_fitting.py:    g_init = Gaussian1D(amplitude=1., mean=3, stddev=2)\nastropy\/modeling\/tests\/test_quantities_fitting.py:    g_init = Gaussian1D(amplitude=1., mean=3 * u.m, stddev=2 * u.m)\nastropy\/modeling\/tests\/test_quantities_fitting.py:    g_init = Gaussian1D(amplitude=1. * u.Jy, mean=3 * u.m, stddev=2 * u.cm)\nastropy\/convolution\/tests\/test_convolve_speeds.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_convolve_speeds.py:        print(\"\\n{}-dimensional arrays ('n' is the size of the image AND \"\nastropy\/convolution\/tests\/test_convolve_speeds.py:            # test ODD sizes too\nastropy\/convolution\/tests\/test_convolve_speeds.py:1-dimensional arrays ('n' is the size of the image AND the kernel)\nastropy\/convolution\/tests\/test_convolve_speeds.py:2-dimensional arrays ('n' is the size of the image AND the kernel)\nastropy\/convolution\/tests\/test_convolve_speeds.py:3-dimensional arrays ('n' is the size of the image AND the kernel)\nastropy\/convolution\/tests\/test_convolve_speeds.py:1-dimensional arrays ('n' is the size of the image AND the kernel)\nastropy\/convolution\/tests\/test_convolve_speeds.py:2-dimensional arrays ('n' is the size of the image AND the kernel)\nastropy\/convolution\/tests\/test_convolve_speeds.py:3-dimensional arrays ('n' is the size of the image AND the kernel)\nastropy\/modeling\/tests\/irafutil.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/irafutil.py:class IDB:\nastropy\/modeling\/tests\/irafutil.py:class ReidentifyRecord(IDB):\nastropy\/modeling\/tests\/test_mappings.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_mappings.py:from ..models import Shift, Rotation2D, Gaussian1D, Identity, Mapping\nastropy\/modeling\/tests\/test_mappings.py:    rotation = Rotation2D(60)\nastropy\/modeling\/tests\/test_mappings.py:    rotation = Rotation2D(angle=60)\nastropy\/modeling\/tests\/test_mappings.py:    m = Identity(1) | Mapping((0, )) | Gaussian1D(1, 5, 4)\nastropy\/modeling\/tests\/test_parameters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_parameters.py:    # TODO: shouldn't setting a max < min give an error?\nastropy\/modeling\/tests\/test_parameters.py:        information to create a 1D Chebyshev model and perform the same fit.\nastropy\/modeling\/tests\/test_parameters.py:        self.model = models.Chebyshev1D(order - 1)\nastropy\/modeling\/tests\/test_parameters.py:        self.gmodel = models.Gaussian1D(2, mean=3, stddev=4)\nastropy\/modeling\/tests\/test_parameters.py:    def testPolynomial1D(self):\nastropy\/modeling\/tests\/test_parameters.py:        p1 = models.Polynomial1D(3, **d)\nastropy\/modeling\/tests\/test_parameters.py:        p1 = models.Polynomial1D(3, n_models=3)\nastropy\/modeling\/tests\/test_parameters.py:        p1 = models.Polynomial1D(3, n_models=3)\nastropy\/modeling\/tests\/test_parameters.py:        p2 = models.Polynomial2D(degree=3)\nastropy\/modeling\/tests\/test_parameters.py:        p2 = models.Polynomial2D(2, **kw)\nastropy\/modeling\/tests\/test_parameters.py:        self.gmodel = models.Gaussian1D([12, 10], [3.5, 5.2], stddev=[.4, .7],\nastropy\/convolution\/tests\/test_convolve_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_convolve_models.py:class TestConvolve1DModels:\nastropy\/convolution\/tests\/test_convolve_models.py:        kernel = models.Gaussian1D(1, 0, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        model = models.Gaussian1D(1, 0, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        kernel = models.Gaussian1D(1, 0, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        model = models.Gaussian1D(1, 0, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        kernel = models.Gaussian1D(1, 0, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        model = models.Gaussian1D(1, 0, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        kernel = models.Gaussian1D(1 \/ math.sqrt(2 * np.pi), 1, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        model = models.Gaussian1D(1 \/ math.sqrt(2 * np.pi), 3, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        ans = models.Gaussian1D(1 \/ (2 * math.sqrt(np.pi)), 4, np.sqrt(2))\nastropy\/convolution\/tests\/test_convolve_models.py:        kernel = models.Box1D()\nastropy\/convolution\/tests\/test_convolve_models.py:        model = models.Box1D()\nastropy\/convolution\/tests\/test_convolve_models.py:        b1 = models.Box1D()\nastropy\/convolution\/tests\/test_convolve_models.py:        g1 = models.Gaussian1D()\nastropy\/convolution\/tests\/test_convolve_models.py:        fake_model = models.Gaussian1D(amplitude=10)\nastropy\/convolution\/tests\/test_convolve_kernels.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_convolve_kernels.py:from ..kernels import Gaussian2DKernel, Box2DKernel, Tophat2DKernel\nastropy\/convolution\/tests\/test_convolve_kernels.py:from ..kernels import Moffat2DKernel\nastropy\/convolution\/tests\/test_convolve_kernels.py:SHAPES_ODD = [[15, 15], [31, 31]]\nastropy\/convolution\/tests\/test_convolve_kernels.py:WIDTHS = [2, 3, 4, 5]\nastropy\/convolution\/tests\/test_convolve_kernels.py:for shape in SHAPES_ODD:\nastropy\/convolution\/tests\/test_convolve_kernels.py:    for width in WIDTHS:\nastropy\/convolution\/tests\/test_convolve_kernels.py:        KERNELS.append(Gaussian2DKernel(width,\nastropy\/convolution\/tests\/test_convolve_kernels.py:        KERNELS.append(Box2DKernel(width,\nastropy\/convolution\/tests\/test_convolve_kernels.py:        KERNELS.append(Tophat2DKernel(width,\nastropy\/convolution\/tests\/test_convolve_kernels.py:        KERNELS.append(Moffat2DKernel(width, 2,\nastropy\/convolution\/tests\/test_convolve_kernels.py:class Test2DConvolutions:\nastropy\/convolution\/tests\/test_convolve_kernels.py:    @pytest.mark.parametrize(('shape', 'width'), list(itertools.product(SHAPES_ODD, WIDTHS)))\nastropy\/convolution\/tests\/test_convolve_kernels.py:    @pytest.mark.parametrize(('shape', 'width'), list(itertools.product(SHAPES_ODD, [1, 3, 5])))\nastropy\/convolution\/tests\/test_convolve_kernels.py:    def test_smallkernel_Box2DKernel(self, shape, width):\nastropy\/convolution\/tests\/test_convolve_kernels.py:        Compares a small uniform kernel to the Box2DKernel\nastropy\/convolution\/tests\/test_convolve_kernels.py:        kernel2 = Box2DKernel(width, mode='oversample', factor=10)\nastropy\/convolution\/tests\/test_kernel_class.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_kernel_class.py:    Gaussian1DKernel, Gaussian2DKernel, Box1DKernel, Box2DKernel,\nastropy\/convolution\/tests\/test_kernel_class.py:    Trapezoid1DKernel, TrapezoidDisk2DKernel, MexicanHat1DKernel,\nastropy\/convolution\/tests\/test_kernel_class.py:    Tophat2DKernel, MexicanHat2DKernel, AiryDisk2DKernel, Ring2DKernel,\nastropy\/convolution\/tests\/test_kernel_class.py:    CustomKernel, Model1DKernel, Model2DKernel, Kernel1D, Kernel2D)\nastropy\/convolution\/tests\/test_kernel_class.py:from ...modeling.models import Box2D, Gaussian1D, Gaussian2D\nastropy\/convolution\/tests\/test_kernel_class.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/convolution\/tests\/test_kernel_class.py:WIDTHS_ODD = [3, 5, 7, 9]\nastropy\/convolution\/tests\/test_kernel_class.py:WIDTHS_EVEN = [2, 4, 8, 16]\nastropy\/convolution\/tests\/test_kernel_class.py:MODES = ['center', 'linear_interp', 'oversample', 'integrate']\nastropy\/convolution\/tests\/test_kernel_class.py:KERNEL_TYPES = [Gaussian1DKernel, Gaussian2DKernel,\nastropy\/convolution\/tests\/test_kernel_class.py:                Box1DKernel, Box2DKernel,\nastropy\/convolution\/tests\/test_kernel_class.py:                Trapezoid1DKernel, TrapezoidDisk2DKernel,\nastropy\/convolution\/tests\/test_kernel_class.py:                MexicanHat1DKernel, Tophat2DKernel, AiryDisk2DKernel, Ring2DKernel]\nastropy\/convolution\/tests\/test_kernel_class.py:delta_pulse_1D = np.zeros(81)\nastropy\/convolution\/tests\/test_kernel_class.py:delta_pulse_1D[40] = 1\nastropy\/convolution\/tests\/test_kernel_class.py:delta_pulse_2D = np.zeros((81, 81))\nastropy\/convolution\/tests\/test_kernel_class.py:delta_pulse_2D[40, 40] = 1\nastropy\/convolution\/tests\/test_kernel_class.py:random_data_1D = np.random.rand(61)\nastropy\/convolution\/tests\/test_kernel_class.py:random_data_2D = np.random.rand(61, 61)\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('width'), WIDTHS_ODD)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_kernel_1D = Gaussian1DKernel(width)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_kernel_1D.normalize()\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_kernel_2D = Gaussian2DKernel(width)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_kernel_2D.normalize()\nastropy\/convolution\/tests\/test_kernel_class.py:        astropy_1D = convolve(delta_pulse_1D, gauss_kernel_1D, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:        astropy_2D = convolve(delta_pulse_2D, gauss_kernel_2D, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:        scipy_1D = filters.gaussian_filter(delta_pulse_1D, width)\nastropy\/convolution\/tests\/test_kernel_class.py:        scipy_2D = filters.gaussian_filter(delta_pulse_2D, width)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert_almost_equal(astropy_1D, scipy_1D, decimal=12)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert_almost_equal(astropy_2D, scipy_2D, decimal=12)\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('width'), WIDTHS_ODD)\nastropy\/convolution\/tests\/test_kernel_class.py:        mexican_kernel_1D = MexicanHat1DKernel(width)\nastropy\/convolution\/tests\/test_kernel_class.py:        mexican_kernel_2D = MexicanHat2DKernel(width)\nastropy\/convolution\/tests\/test_kernel_class.py:        astropy_1D = convolve(delta_pulse_1D, mexican_kernel_1D, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:        astropy_2D = convolve(delta_pulse_2D, mexican_kernel_2D, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            astropy_1D = convolve(delta_pulse_1D, mexican_kernel_1D, boundary='fill', normalize_kernel=True)\nastropy\/convolution\/tests\/test_kernel_class.py:            astropy_2D = convolve(delta_pulse_2D, mexican_kernel_2D, boundary='fill', normalize_kernel=True)\nastropy\/convolution\/tests\/test_kernel_class.py:        scipy_1D = -filters.gaussian_laplace(delta_pulse_1D, width)\nastropy\/convolution\/tests\/test_kernel_class.py:        scipy_2D = -filters.gaussian_laplace(delta_pulse_2D, width)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert_almost_equal(astropy_1D, scipy_1D, decimal=5)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert_almost_equal(astropy_2D, scipy_2D, decimal=5)\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('kernel_type', 'width'), list(itertools.product(KERNEL_TYPES, WIDTHS_ODD)))\nastropy\/convolution\/tests\/test_kernel_class.py:        if kernel_type == AiryDisk2DKernel and not HAS_SCIPY:\nastropy\/convolution\/tests\/test_kernel_class.py:            pytest.skip(\"Omitting AiryDisk2DKernel, which requires SciPy\")\nastropy\/convolution\/tests\/test_kernel_class.py:        if not kernel_type == Ring2DKernel:\nastropy\/convolution\/tests\/test_kernel_class.py:            c1 = convolve_fft(delta_pulse_1D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c2 = convolve(delta_pulse_1D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c1 = convolve_fft(delta_pulse_2D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c2 = convolve(delta_pulse_2D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('kernel_type', 'width'), list(itertools.product(KERNEL_TYPES, WIDTHS_ODD)))\nastropy\/convolution\/tests\/test_kernel_class.py:        if kernel_type == AiryDisk2DKernel and not HAS_SCIPY:\nastropy\/convolution\/tests\/test_kernel_class.py:            pytest.skip(\"Omitting AiryDisk2DKernel, which requires SciPy\")\nastropy\/convolution\/tests\/test_kernel_class.py:        if not kernel_type == Ring2DKernel:\nastropy\/convolution\/tests\/test_kernel_class.py:            c1 = convolve_fft(random_data_1D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c2 = convolve(random_data_1D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c1 = convolve_fft(random_data_2D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c2 = convolve(random_data_2D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('width'), WIDTHS_ODD)\nastropy\/convolution\/tests\/test_kernel_class.py:        c2 = convolve_fft(delta_pulse_2D, kernel, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:        c1 = convolve(delta_pulse_2D, kernel, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('width'), WIDTHS_ODD)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_smallkernel_vs_Box2DKernel(self, width):\nastropy\/convolution\/tests\/test_kernel_class.py:        kernel2 = Box2DKernel(width)\nastropy\/convolution\/tests\/test_kernel_class.py:        c2 = convolve_fft(delta_pulse_2D, kernel2, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:        c1 = convolve_fft(delta_pulse_2D, kernel1, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_convolve_1D_kernels(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_1 = Gaussian1DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_2 = Gaussian1DKernel(4)\nastropy\/convolution\/tests\/test_kernel_class.py:        test_gauss_3 = Gaussian1DKernel(5)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_convolve_2D_kernels(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_1 = Gaussian2DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_2 = Gaussian2DKernel(4)\nastropy\/convolution\/tests\/test_kernel_class.py:        test_gauss_3 = Gaussian2DKernel(5)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian1DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian1DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert type(gauss_new) is Gaussian1DKernel\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian1DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert type(gauss_new) is Gaussian1DKernel\nastropy\/convolution\/tests\/test_kernel_class.py:        \"\"\"Test that multiplying two 1D kernels raises an exception.\"\"\"\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian1DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        \"\"\"Test that multiplying two 2D kernels raises an exception.\"\"\"\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian2DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        Test that multiplying a 1D kernel with a 2D kernel raises an\nastropy\/convolution\/tests\/test_kernel_class.py:            Gaussian1DKernel(3) * Gaussian2DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:            Gaussian1DKernel(3) + 1\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_model_1D_kernel(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check Model1DKernel against Gaussian1Dkernel\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian1D(1. \/ np.sqrt(2 * np.pi * stddev**2), 0, stddev)\nastropy\/convolution\/tests\/test_kernel_class.py:        model_gauss_kernel = Model1DKernel(gauss, x_size=21)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_kernel = Gaussian1DKernel(stddev, x_size=21)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_model_2D_kernel(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check Model2DKernel against Gaussian2Dkernel\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian2D(1. \/ (2 * np.pi * stddev**2), 0, 0, stddev, stddev)\nastropy\/convolution\/tests\/test_kernel_class.py:        model_gauss_kernel = Model2DKernel(gauss, x_size=21)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_kernel = Gaussian2DKernel(stddev, x_size=21)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_custom_1D_kernel(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check CustomKernel against Box1DKernel.\nastropy\/convolution\/tests\/test_kernel_class.py:        # Define one dimensional array:\nastropy\/convolution\/tests\/test_kernel_class.py:        box = Box1DKernel(5)\nastropy\/convolution\/tests\/test_kernel_class.py:        c2 = convolve(delta_pulse_1D, custom, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:        c1 = convolve(delta_pulse_1D, box, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_custom_2D_kernel(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check CustomKernel against Box2DKernel.\nastropy\/convolution\/tests\/test_kernel_class.py:        # Define one dimensional array:\nastropy\/convolution\/tests\/test_kernel_class.py:        box = Box2DKernel(5)\nastropy\/convolution\/tests\/test_kernel_class.py:        c2 = convolve(delta_pulse_2D, custom, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:        c1 = convolve(delta_pulse_2D, box, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_custom_1D_kernel_list(self):\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_custom_2D_kernel_list(self):\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_custom_1D_kernel_zerosum(self):\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_custom_2D_kernel_zerosum(self):\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_add_1D_kernels(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check if adding of two 1D kernels works.\nastropy\/convolution\/tests\/test_kernel_class.py:        box_1 = Box1DKernel(5)\nastropy\/convolution\/tests\/test_kernel_class.py:        box_2 = Box1DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        box_3 = Box1DKernel(1)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_add_2D_kernels(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check if adding of two 1D kernels works.\nastropy\/convolution\/tests\/test_kernel_class.py:        box_1 = Box2DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        box_2 = Box2DKernel(1)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_Gaussian1DKernel_even_size(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian1DKernel(3, x_size=10)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_Gaussian2DKernel_even_size(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian2DKernel(3, x_size=10, y_size=10)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_Gaussian2DKernel_rotated(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/convolution\/tests\/test_kernel_class.py:            Gaussian2DKernel(stddev=10)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian2DKernel(\nastropy\/convolution\/tests\/test_kernel_class.py:        box = Box2DKernel(5)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert isinstance(box.model, Box2D)\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('kernel_type', 'mode'), list(itertools.product(KERNEL_TYPES, MODES)))\nastropy\/convolution\/tests\/test_kernel_class.py:        if kernel_type == AiryDisk2DKernel and not HAS_SCIPY:\nastropy\/convolution\/tests\/test_kernel_class.py:            pytest.skip(\"Omitting AiryDisk2DKernel, which requires SciPy\")\nastropy\/convolution\/tests\/test_kernel_class.py:        if not kernel_type == Ring2DKernel:\nastropy\/convolution\/tests\/test_kernel_class.py:            c1 = convolve_fft(delta_pulse_1D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c2 = convolve(delta_pulse_1D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c1 = convolve_fft(delta_pulse_2D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c2 = convolve(delta_pulse_2D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('width'), WIDTHS_EVEN)\nastropy\/convolution\/tests\/test_kernel_class.py:        kernel_1D = Box1DKernel(width)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert kernel_1D.shape[0] % 2 != 0\nastropy\/convolution\/tests\/test_kernel_class.py:        assert kernel_1D.array.sum() == 1.\nastropy\/convolution\/tests\/test_kernel_class.py:        kernel_2D = Box2DKernel(width)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert np.all([_ % 2 != 0 for _ in kernel_2D.shape])\nastropy\/convolution\/tests\/test_kernel_class.py:        assert kernel_2D.array.sum() == 1.\nastropy\/convolution\/tests\/test_kernel_class.py:        Test that an error is raised if ``Kernel1D`` ``x_size`` is not\nastropy\/convolution\/tests\/test_kernel_class.py:            Gaussian1DKernel(3, x_size=1.2)\nastropy\/convolution\/tests\/test_kernel_class.py:        Test that an error is raised if ``Kernel2D`` ``x_size`` is not\nastropy\/convolution\/tests\/test_kernel_class.py:            Gaussian2DKernel(3, x_size=1.2)\nastropy\/convolution\/tests\/test_kernel_class.py:        Test that an error is raised if ``Kernel2D`` ``y_size`` is not\nastropy\/convolution\/tests\/test_kernel_class.py:            Gaussian2DKernel(3, x_size=5, y_size=1.2)\nastropy\/convolution\/tests\/test_kernel_class.py:        specified for ``Kernel1D``.\nastropy\/convolution\/tests\/test_kernel_class.py:            Kernel1D()\nastropy\/convolution\/tests\/test_kernel_class.py:        specified for ``Kernel2D``.\nastropy\/convolution\/tests\/test_kernel_class.py:            Kernel2D()\nastropy\/convolution\/tests\/test_pickle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_pickle.py:                          (conv.Gaussian1DKernel, [1.0],\nastropy\/convolution\/tests\/test_pickle.py:                          (conv.Gaussian2DKernel, [1.0],\nastropy\/convolution\/tests\/test_discretize.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_discretize.py:    Gaussian1D, Box1D, MexicanHat1D, Gaussian2D, Box2D, MexicanHat2D)\nastropy\/convolution\/tests\/test_discretize.py:from ...modeling.tests.example_models import models_1D, models_2D\nastropy\/convolution\/tests\/test_discretize.py:test_models_1D = [Gaussian1D, Box1D, MexicanHat1D]\nastropy\/convolution\/tests\/test_discretize.py:test_models_2D = [Gaussian2D, Box2D, MexicanHat2D]\nastropy\/convolution\/tests\/test_discretize.py:@pytest.mark.parametrize(('model_class', 'mode'), list(itertools.product(test_models_1D, modes)))\nastropy\/convolution\/tests\/test_discretize.py:def test_pixel_sum_1D(model_class, mode):\nastropy\/convolution\/tests\/test_discretize.py:    if model_class == Box1D and mode == \"center\":\nastropy\/convolution\/tests\/test_discretize.py:    parameters = models_1D[model_class]\nastropy\/convolution\/tests\/test_discretize.py:    values = discretize_model(model, models_1D[model_class]['x_lim'], mode=mode)\nastropy\/convolution\/tests\/test_discretize.py:    assert_allclose(values.sum(), models_1D[model_class]['integral'], atol=0.0001)\nastropy\/convolution\/tests\/test_discretize.py:def test_gaussian_eval_1D(mode):\nastropy\/convolution\/tests\/test_discretize.py:    Discretize Gaussian with different modes and check\nastropy\/convolution\/tests\/test_discretize.py:    if result is at least similar to Gaussian1D.eval().\nastropy\/convolution\/tests\/test_discretize.py:    model = Gaussian1D(1, 0, 20)\nastropy\/convolution\/tests\/test_discretize.py:@pytest.mark.parametrize(('model_class', 'mode'), list(itertools.product(test_models_2D, modes)))\nastropy\/convolution\/tests\/test_discretize.py:def test_pixel_sum_2D(model_class, mode):\nastropy\/convolution\/tests\/test_discretize.py:    if model_class == Box2D and mode == \"center\":\nastropy\/convolution\/tests\/test_discretize.py:    parameters = models_2D[model_class]\nastropy\/convolution\/tests\/test_discretize.py:    values = discretize_model(model, models_2D[model_class]['x_lim'],\nastropy\/convolution\/tests\/test_discretize.py:                              models_2D[model_class]['y_lim'], mode=mode)\nastropy\/convolution\/tests\/test_discretize.py:    assert_allclose(values.sum(), models_2D[model_class]['integral'], atol=0.0001)\nastropy\/convolution\/tests\/test_discretize.py:def test_gaussian_eval_2D(mode):\nastropy\/convolution\/tests\/test_discretize.py:    Discretize Gaussian with different modes and check\nastropy\/convolution\/tests\/test_discretize.py:    if result is at least similar to Gaussian2D.eval()\nastropy\/convolution\/tests\/test_discretize.py:    model = Gaussian2D(0.01, 0, 0, 1, 1)\nastropy\/convolution\/tests\/test_discretize.py:def test_gaussian_eval_2D_integrate_mode():\nastropy\/convolution\/tests\/test_discretize.py:    Discretize Gaussian with integrate mode\nastropy\/convolution\/tests\/test_discretize.py:    model_list = [Gaussian2D(.01, 0, 0, 2, 2),\nastropy\/convolution\/tests\/test_discretize.py:                  Gaussian2D(.01, 0, 0, 1, 2),\nastropy\/convolution\/tests\/test_discretize.py:                  Gaussian2D(.01, 0, 0, 2, 1)]\nastropy\/convolution\/tests\/test_discretize.py:def test_subpixel_gauss_1D():\nastropy\/convolution\/tests\/test_discretize.py:    Test subpixel accuracy of the integrate mode with gaussian 1D model.\nastropy\/convolution\/tests\/test_discretize.py:    gauss_1D = Gaussian1D(1, 0, 0.1)\nastropy\/convolution\/tests\/test_discretize.py:    values = discretize_model(gauss_1D, (-1, 2), mode='integrate', factor=100)\nastropy\/convolution\/tests\/test_discretize.py:def test_subpixel_gauss_2D():\nastropy\/convolution\/tests\/test_discretize.py:    Test subpixel accuracy of the integrate mode with gaussian 2D model.\nastropy\/convolution\/tests\/test_discretize.py:    gauss_2D = Gaussian2D(1, 0, 0, 0.1, 0.1)\nastropy\/convolution\/tests\/test_discretize.py:    values = discretize_model(gauss_2D, (-1, 2), (-1, 2), mode='integrate', factor=100)\nastropy\/convolution\/convolve.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/convolve.py:from .core import Kernel, Kernel1D, Kernel2D, MAX_NORMALIZATION\nastropy\/convolution\/convolve.py:# Disabling all doctests in this module until a better way of handling warnings\nastropy\/convolution\/convolve.py:BOUNDARY_OPTIONS = [None, 'fill', 'wrap', 'extend']\nastropy\/convolution\/convolve.py:    array : `numpy.ndarray` or `~astropy.nddata.NDData`\nastropy\/convolution\/convolve.py:        3-dimensional array.  If an `~astropy.nddata.NDData`, the ``mask`` of\nastropy\/convolution\/convolve.py:        the `~astropy.nddata.NDData` will be used as the ``mask`` argument.\nastropy\/convolution\/convolve.py:        normalized. Default is \"1e-8\".\nastropy\/convolution\/convolve.py:    if boundary not in BOUNDARY_OPTIONS:\nastropy\/convolution\/convolve.py:                         .format(BOUNDARY_OPTIONS))\nastropy\/convolution\/convolve.py:    # if it's a floating point type.  Don't bother with this for lists --\nastropy\/convolution\/convolve.py:            if isinstance(array, Kernel1D) and isinstance(kernel, Kernel1D):\nastropy\/convolution\/convolve.py:                new_kernel = Kernel1D(array=new_array)\nastropy\/convolution\/convolve.py:            elif isinstance(array, Kernel2D) and isinstance(kernel, Kernel2D):\nastropy\/convolution\/convolve.py:                new_kernel = Kernel2D(array=new_array)\nastropy\/convolution\/convolve.py:                raise Exception(\"Can't convolve 1D and 2D kernel.\")\nastropy\/convolution\/convolve.py:        normalized. Default is \"1e-8\".\nastropy\/convolution\/convolve.py:        Default on.  Zero-pad image to the nearest 2^n.  With\nastropy\/convolution\/convolve.py:        Default on.  Return an image of the size of the larger of the input\nastropy\/convolution\/convolve.py:        ``ifft(fft(image)*fft(kernel))``).  Useful for making PSDs.\nastropy\/time\/tests\/test_guess.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_fitters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_fitters.py:from ..core import Fittable2DModel, Parameter\nastropy\/modeling\/tests\/test_fitters.py:_RANDOM_SEED = 0x1337\nastropy\/modeling\/tests\/test_fitters.py:class TestPolynomial2D:\nastropy\/modeling\/tests\/test_fitters.py:    \"\"\"Tests for 2D polynomail fitting.\"\"\"\nastropy\/modeling\/tests\/test_fitters.py:        self.model = models.Polynomial2D(2)\nastropy\/modeling\/tests\/test_fitters.py:    def test_poly2D_fitting(self):\nastropy\/modeling\/tests\/test_fitters.py:    def test_polynomial2D_nonlinear_fitting(self):\nastropy\/modeling\/tests\/test_fitters.py:class TestICheb2D:\nastropy\/modeling\/tests\/test_fitters.py:    Tests 2D Chebyshev polynomial fitting\nastropy\/modeling\/tests\/test_fitters.py:    Create a 2D polynomial (z) using Polynomial2DModel and default coefficients\nastropy\/modeling\/tests\/test_fitters.py:    Fit z using a ICheb2D model\nastropy\/modeling\/tests\/test_fitters.py:    Evaluate the ICheb2D polynomial and compare with the initial z\nastropy\/modeling\/tests\/test_fitters.py:        self.pmodel = models.Polynomial2D(2)\nastropy\/modeling\/tests\/test_fitters.py:        self.cheb2 = models.Chebyshev2D(2, 2)\nastropy\/modeling\/tests\/test_fitters.py:    def test_poly2D_cheb2D(self):\nastropy\/modeling\/tests\/test_fitters.py:    def test_chebyshev2D_nonlinear_fitting(self):\nastropy\/modeling\/tests\/test_fitters.py:        cheb2d = models.Chebyshev2D(2, 2)\nastropy\/modeling\/tests\/test_fitters.py:    def test_chebyshev2D_nonlinear_fitting_with_weights(self):\nastropy\/modeling\/tests\/test_fitters.py:        cheb2d = models.Chebyshev2D(2, 2)\nastropy\/modeling\/tests\/test_fitters.py:        self.g1 = models.Gaussian1D(10, mean=14.9, stddev=.3)\nastropy\/modeling\/tests\/test_fitters.py:        self.g2 = models.Gaussian1D(10, mean=13, stddev=.4)\nastropy\/modeling\/tests\/test_fitters.py:        with NumpyRNGContext(_RANDOM_SEED):\nastropy\/modeling\/tests\/test_fitters.py:    def test_chebyshev1D(self):\nastropy\/modeling\/tests\/test_fitters.py:        \"\"\"Tests fitting a 1D Chebyshev polynomial to some real world data.\"\"\"\nastropy\/modeling\/tests\/test_fitters.py:        initial_model = models.Chebyshev1D(order - 1,\nastropy\/modeling\/tests\/test_fitters.py:        init_model = models.Polynomial1D(degree=2, c0=[1, 1], n_models=2)\nastropy\/modeling\/tests\/test_fitters.py:        with NumpyRNGContext(_RANDOM_SEED):\nastropy\/modeling\/tests\/test_fitters.py:        \"\"\"Tests fitted multiple 2-D models simultaneously.\"\"\"\nastropy\/modeling\/tests\/test_fitters.py:        init_model = models.Polynomial2D(degree=2, c0_0=[1, 1], n_models=2)\nastropy\/modeling\/tests\/test_fitters.py:        with NumpyRNGContext(_RANDOM_SEED):\nastropy\/modeling\/tests\/test_fitters.py:        init_model = models.Polynomial1D(degree=2, c1=1)\nastropy\/modeling\/tests\/test_fitters.py:        init_model = models.Polynomial1D(degree=2, c1=[1, -2], n_models=2)\nastropy\/modeling\/tests\/test_fitters.py:        init_model = models.Polynomial2D(degree=2, c1_0=[1, 2], c0_1=[-0.5, 1],\nastropy\/modeling\/tests\/test_fitters.py:        with NumpyRNGContext(_RANDOM_SEED):\nastropy\/modeling\/tests\/test_fitters.py:        self.gauss = models.Gaussian1D(100, 5, stddev=1)\nastropy\/modeling\/tests\/test_fitters.py:        `Gaussian1D`.\nastropy\/modeling\/tests\/test_fitters.py:        g1e = models.Gaussian1D(100, 5.0, stddev=1)\nastropy\/modeling\/tests\/test_fitters.py:        `Gaussian1D`.\nastropy\/modeling\/tests\/test_fitters.py:        g1e = models.Gaussian1D(100, 5.0, stddev=1)\nastropy\/modeling\/tests\/test_fitters.py:        g1 = models.Gaussian1D(100, 5, stddev=1)\nastropy\/modeling\/tests\/test_fitters.py:        class Rosenbrock(Fittable2DModel):\nastropy\/modeling\/tests\/test_fitters.py:        with NumpyRNGContext(_RANDOM_SEED):\nastropy\/modeling\/tests\/test_fitters.py:        with NumpyRNGContext(_RANDOM_SEED):\nastropy\/modeling\/tests\/test_fitters.py:        mod = models.Linear1D(a, b)\nastropy\/modeling\/tests\/test_fitters.py:class Test1DFittingWithOutlierRemoval:\nastropy\/modeling\/tests\/test_fitters.py:        g_init = models.Gaussian1D(amplitude=1., mean=0, stddev=1.)\nastropy\/modeling\/tests\/test_fitters.py:class Test2DFittingWithOutlierRemoval:\nastropy\/modeling\/tests\/test_fitters.py:        def Gaussian_2D(p, pos):\nastropy\/modeling\/tests\/test_fitters.py:        self.z = Gaussian_2D(self.model_params, np.array([self.y, self.x]))\nastropy\/modeling\/tests\/test_fitters.py:        g2_init = models.Gaussian2D(amplitude=guess[0], x_mean=guess[1],\nastropy\/modeling\/tests\/test_fitters.py:    with NumpyRNGContext(_RANDOM_SEED):\nastropy\/modeling\/tests\/test_fitters.py:    g2 = models.Gaussian2D(10, 10, 9, 2, 3)\nastropy\/modeling\/tests\/test_fitters.py:    gmod = fitter(models.Gaussian2D(15, 7, 8, 1.3, 1.2), Xin, Yin, z + zsig)\nastropy\/modeling\/tests\/test_fitters.py:    p2 = models.Polynomial2D(3)\nastropy\/modeling\/tests\/test_fitters.py:    pmod = fitter(models.Polynomial2D(3), Xin, Yin, z + zsig)\nastropy\/modeling\/tests\/test_fitters.py:    model = models.Gaussian1D(10, 4, .3)\nastropy\/utils\/data_info.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/data_info.py:\"\"\"This module contains functions and methods that relate to the DataInfo class\nastropy\/utils\/data_info.py:A DataInfo object is attached to the Quantity, SkyCoord, and Time classes in\nastropy\/utils\/data_info.py:from collections import OrderedDict\nastropy\/utils\/data_info.py:           'DataInfo', 'MixinInfo', 'ParentDtypeInfo']\nastropy\/utils\/data_info.py:                        'Mean of empty slice|Degrees of freedom <= 0'),)\nastropy\/utils\/data_info.py:        return OrderedDict(zip(names, outs))\nastropy\/utils\/data_info.py:class DataInfo:\nastropy\/utils\/data_info.py:    Descriptor that data classes use to add an ``info`` attribute for storing\nastropy\/utils\/data_info.py:    called ``info`` so that the DataInfo() object can be stored in the\nastropy\/utils\/data_info.py:        is a DataInfo() object that is bound to a data object instance. Default is False.\nastropy\/utils\/data_info.py:        if isinstance(value, DataInfo):\nastropy\/utils\/data_info.py:            raise TypeError('info must be set with a DataInfo instance')\nastropy\/utils\/data_info.py:        OrderedDict containing the information attributes.\nastropy\/utils\/data_info.py:            OrderedDict with information attributes is returned\nastropy\/utils\/data_info.py:        info : OrderedDict if out==None else None\nastropy\/utils\/data_info.py:        info = OrderedDict()\nastropy\/utils\/data_info.py:class BaseColumnInfo(DataInfo):\nastropy\/utils\/data_info.py:    attr_names = DataInfo.attr_names.union(['parent_table', 'indices'])\nastropy\/utils\/data_info.py:class ParentDtypeInfo(MixinInfo):\nastropy\/modeling\/separable.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/separable.py:from .core import Model, _CompoundModel, ModelDefinitionError\nastropy\/modeling\/separable.py:    >>> from astropy.modeling.models import Shift, Scale, Rotation2D, Polynomial2D\nastropy\/modeling\/separable.py:    >>> is_separable(Shift(1) & Shift(2) | Rotation2D(2))\nastropy\/modeling\/separable.py:        Polynomial2D(1) & Polynomial2D(2))\nastropy\/modeling\/separable.py:        raise ModelDefinitionError(\nastropy\/modeling\/separable.py:        raise ModelDefinitionError(\nastropy\/modeling\/tests\/test_polynomial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_polynomial.py:from ..polynomial import (Chebyshev1D, Hermite1D, Legendre1D, Polynomial1D,\nastropy\/modeling\/tests\/test_polynomial.py:                          Chebyshev2D, Hermite2D, Legendre2D, Polynomial2D, SIP,\nastropy\/modeling\/tests\/test_polynomial.py:from ..functional_models import Linear1D\nastropy\/modeling\/tests\/test_polynomial.py:    Chebyshev1D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Hermite1D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Legendre1D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Polynomial1D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Linear1D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Chebyshev2D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Hermite2D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Legendre2D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Polynomial2D: {\nastropy\/modeling\/tests\/test_polynomial.py:    # TODO: Most of these test cases have some pretty repetitive setup that we\nastropy\/modeling\/tests\/test_polynomial.py:    def test_linear_fitter_1D(self, model_class, constraints):\nastropy\/modeling\/tests\/test_polynomial.py:    def test_non_linear_fitter_1D(self, model_class, constraints):\nastropy\/modeling\/tests\/test_polynomial.py:    def test_linear_fitter_2D(self, model_class, constraints):\nastropy\/modeling\/tests\/test_polynomial.py:    def test_non_linear_fitter_2D(self, model_class, constraints):\nastropy\/modeling\/tests\/test_polynomial.py:    if '1D' in model_class.__name__:\nastropy\/modeling\/tests\/test_polynomial.py:    a_order = a_pars.pop('A_ORDER')\nastropy\/modeling\/tests\/test_polynomial.py:    b_order = b_pars.pop('B_ORDER')\nastropy\/modeling\/tests\/test_polynomial.py:    a_order = a_pars.pop('A_ORDER')\nastropy\/modeling\/tests\/test_polynomial.py:    b_order = b_pars.pop('B_ORDER')\nastropy\/modeling\/tests\/test_polynomial.py:    ap_order = ap_pars.pop('AP_ORDER')\nastropy\/modeling\/tests\/test_polynomial.py:    bp_order = bp_pars.pop('BP_ORDER')\nastropy\/modeling\/tests\/test_polynomial.py:    del a_pars['A_DMAX']\nastropy\/modeling\/tests\/test_polynomial.py:    del b_pars['B_DMAX']\nastropy\/modeling\/tests\/test_polynomial.py:@pytest.mark.parametrize('cls', (Polynomial1D, Chebyshev1D, Legendre1D,\nastropy\/modeling\/tests\/test_polynomial.py:                                 Polynomial2D, Chebyshev2D, Legendre2D))\nastropy\/modeling\/tests\/test_polynomial.py:    if cls.n_inputs == 1:  # Test 1D polynomials\nastropy\/modeling\/tests\/test_polynomial.py:    elif cls.n_inputs == 2:  # Test 2D polynomials\nastropy\/modeling\/tests\/test_polynomial.py:    Ensure that OrthoPolynomialBase (ie. Chebyshev2D & Legendre2D) models get\nastropy\/modeling\/tests\/test_polynomial.py:    simple_model = Chebyshev2D(2, 2)\nastropy\/modeling\/tests\/test_polynomial.py:    compound_model = Identity(2) | Chebyshev2D(2, 2)\nastropy\/modeling\/tests\/test_utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_utils.py:from ..models import Ellipse2D\nastropy\/modeling\/tests\/test_utils.py:# TODO: It might prove useful to implement a simple expression parser to build\nastropy\/modeling\/tests\/test_utils.py:    model = Ellipse2D(amplitude, x0, y0, a, b, theta)\nastropy\/convolution\/tests\/test_convolve_fft.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_convolve_fft.py:VALID_DTYPES = []\nastropy\/convolution\/tests\/test_convolve_fft.py:        VALID_DTYPES.append((dtype_array, dtype_kernel))\nastropy\/convolution\/tests\/test_convolve_fft.py:BOUNDARY_OPTIONS = [None, 'fill', 'wrap']\nastropy\/convolution\/tests\/test_convolve_fft.py:options = list(itertools.product(BOUNDARY_OPTIONS,\nastropy\/convolution\/tests\/test_convolve_fft.py:class TestConvolve1D:\nastropy\/convolution\/tests\/test_convolve_fft.py:    options_unity1withnan = list(itertools.product(BOUNDARY_OPTIONS,\nastropy\/convolution\/tests\/test_convolve_fft.py:class TestConvolve2D:\nastropy\/convolution\/tests\/test_convolve_fft.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/io\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/registry.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/registry.py:from collections import OrderedDict\nastropy\/io\/registry.py:_readers = OrderedDict()\nastropy\/io\/registry.py:_writers = OrderedDict()\nastropy\/io\/registry.py:_identifiers = OrderedDict()\nastropy\/io\/registry.py:        search for both.  Default is None.\nastropy\/io\/registry.py:        # Indices represent \"Data Class\", \"Deprecated\" and \"Format\".\nastropy\/io\/registry.py:    format_table = Table(data, names=('Data class', 'Format', 'Read', 'Write',\nastropy\/io\/registry.py:                                      'Auto-identify', 'Deprecated'))\nastropy\/io\/registry.py:    if not np.any(format_table['Deprecated'] == 'Yes'):\nastropy\/io\/registry.py:        format_table.remove_column('Deprecated')\nastropy\/io\/registry.py:    # Include only formats that have a reader, and drop the 'Data class' column\nastropy\/io\/registry.py:    format_table.remove_column('Data class')\nastropy\/io\/registry.py:    if 'Deprecated' in format_table.colnames:\nastropy\/io\/registry.py:                          'Deprecated format names like ``aastex`` will be '\nastropy\/io\/registry.py:    # Depending on Python version and whether class_readwrite_func is\nastropy\/io\/registry.py:        Default is ``False``.\nastropy\/io\/registry.py:        Default is ``False``.\nastropy\/io\/registry.py:        Default is ``False``.\nastropy\/io\/registry.py:    format_table.remove_column('Data class')\nastropy\/io\/registry.py:    Determine if class2 is the \"best\" match for class1 in the list\nastropy\/modeling\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/core.py:from collections import defaultdict, OrderedDict\nastropy\/modeling\/core.py:                     InheritDocstrings, OrderedDescriptorContainer,\nastropy\/modeling\/core.py:from ..utils.exceptions import AstropyDeprecationWarning\nastropy\/modeling\/core.py:                    ExpressionTree, AliasDict, get_inputs_and_params,\nastropy\/modeling\/core.py:__all__ = ['Model', 'FittableModel', 'Fittable1DModel', 'Fittable2DModel',\nastropy\/modeling\/core.py:           'custom_model', 'ModelDefinitionError']\nastropy\/modeling\/core.py:class ModelDefinitionError(TypeError):\nastropy\/modeling\/core.py:class _ModelMeta(OrderedDescriptorContainer, InheritDocstrings, abc.ABCMeta):\nastropy\/modeling\/core.py:    # Default empty dict for _parameters_, which will be empty on model\nastropy\/modeling\/core.py:    _parameters_ = OrderedDict()\nastropy\/modeling\/core.py:        # Make sure OrderedDescriptorContainer gets to run before doing\nastropy\/modeling\/core.py:            # Delete any ABC-related attributes--these will be restored when\nastropy\/modeling\/core.py:            # Delete custom __init__ and __call__ if they exist:\nastropy\/modeling\/core.py:            >>> from astropy.modeling.models import Rotation2D\nastropy\/modeling\/core.py:            >>> SkyRotation = Rotation2D.rename('SkyRotation')\nastropy\/modeling\/core.py:            Name: SkyRotation (Rotation2D)\nastropy\/modeling\/core.py:            >>> issubclass(SkyRotation, Rotation2D)\nastropy\/modeling\/core.py:            >>> isinstance(r, Rotation2D)\nastropy\/modeling\/core.py:        # TODO: Much of this is verbatim from _create_inverse_property--I feel\nastropy\/modeling\/core.py:                raise ModelDefinitionError(exc.args[0])\nastropy\/modeling\/core.py:            # TODO: Maybe warn in the above case?\nastropy\/modeling\/core.py:        # TODO: Might be convenient if calling the bounding box also\nastropy\/modeling\/core.py:                raise ModelDefinitionError(\nastropy\/modeling\/core.py:            # Don't create a custom __call__ for classes that already have one\nastropy\/modeling\/core.py:        Dictionary ``{parameter_name: bool}`` setting the fixed constraint\nastropy\/modeling\/core.py:        Dictionary ``{parameter_name: callable}`` of parameters which are\nastropy\/modeling\/core.py:        Dictionary ``{parameter_name: value}`` of lower and upper bounds of\nastropy\/modeling\/core.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,\nastropy\/modeling\/core.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)\nastropy\/modeling\/core.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,\nastropy\/modeling\/core.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)\nastropy\/modeling\/core.py:    meta = metadata.MetaData()\nastropy\/modeling\/core.py:    # Default n_models attribute, so that __len__ is still defined even when a\nastropy\/modeling\/core.py:    # Default equivalencies to apply to input values. If set, this should be a\nastropy\/modeling\/core.py:        * for 1D: ``(x_low, x_high)``\nastropy\/modeling\/core.py:        * for 2D: ``((y_low, y_high), (x_low, x_high))``\nastropy\/modeling\/core.py:        * for 3D: ``((z_low, z_high), (y_low, y_high), (x_low, x_high))``\nastropy\/modeling\/core.py:        Setting the ``bounding_box`` limits for a 1D and 2D model:\nastropy\/modeling\/core.py:        >>> from astropy.modeling.models import Gaussian1D, Gaussian2D\nastropy\/modeling\/core.py:        >>> model_1d = Gaussian1D()\nastropy\/modeling\/core.py:        >>> model_2d = Gaussian2D(x_stddev=1, y_stddev=1)\nastropy\/modeling\/core.py:        Setting the bounding_box limits for a user-defined 3D `custom_model`:\nastropy\/modeling\/core.py:        >>> Const3D = custom_model(const3d)\nastropy\/modeling\/core.py:        >>> model_3d = Const3D()\nastropy\/modeling\/core.py:        >>> model_1d.bounding_box  # doctest: +IGNORE_EXCEPTION_DETAIL\nastropy\/modeling\/core.py:            # TODO: Ensure that negative model_set_axis arguments are respected\nastropy\/modeling\/core.py:            constraints[cons_type] = AliasDict(orig, aliases)\nastropy\/modeling\/core.py:                # Default to zero\nastropy\/modeling\/core.py:        # Determine the number of model sets: If the model_set_axis is\nastropy\/modeling\/core.py:        # TODO: This is a bit ugly, but easier to deal with than how this was\nastropy\/modeling\/core.py:            # into separate objects.  Doing things this way ensures a 1-D\nastropy\/modeling\/core.py:        # TODO: Returning an array from this method may be entirely pointless\nastropy\/modeling\/core.py:        # TODO: I think this could be reworked to preset model sets better\nastropy\/modeling\/core.py:class Fittable1DModel(FittableModel):\nastropy\/modeling\/core.py:class Fittable2DModel(FittableModel):\nastropy\/modeling\/core.py:# TODO: Support a couple unary operators--at least negation?\nastropy\/modeling\/core.py:_ORDER_OF_OPERATORS = [('|',), ('&',), ('+', '-'), ('*', '\/'), ('**',)]\nastropy\/modeling\/core.py:OPERATOR_PRECEDENCE = {}\nastropy\/modeling\/core.py:for idx, ops in enumerate(_ORDER_OF_OPERATORS):\nastropy\/modeling\/core.py:        OPERATOR_PRECEDENCE[op] = idx\nastropy\/modeling\/core.py:            # Delete _evaluate from the members dict\nastropy\/modeling\/core.py:    # TODO: Maybe we could use make_function_with_signature for evaluate, but\nastropy\/modeling\/core.py:    # TODO: This supports creating a new compound model from two existing\nastropy\/modeling\/core.py:                cm1 = Gaussian1D(1, 5, .1) + Gaussian1D()\nastropy\/modeling\/core.py:            # TODO: Any effort to restructure the tree-like data structure for\nastropy\/modeling\/core.py:        # TODO: These aren't the full rules for handling inputs and outputs, but\nastropy\/modeling\/core.py:                raise ModelDefinitionError(\nastropy\/modeling\/core.py:                raise ModelDefinitionError(\nastropy\/modeling\/core.py:        TODO: Consider fixing things so the aforementioned class-based case\nastropy\/modeling\/core.py:    # TODO: Perhaps, just perhaps, the post-order (or ???-order) ordering of\nastropy\/modeling\/core.py:        # TODO: I'm not 100% happy with this design, and maybe we need some\nastropy\/modeling\/core.py:                # TODO: Reevaluate this if it turns out to be confusing, though\nastropy\/modeling\/core.py:        # TODO: At some point might be useful to make a public version of this,\nastropy\/modeling\/core.py:        return cls._tree.format_expression(OPERATOR_PRECEDENCE)\nastropy\/modeling\/core.py:    # TODO: The way this works is highly inefficient--the inverse is created by\nastropy\/modeling\/core.py:    Define a sinusoidal model function as a custom 1D model::\nastropy\/modeling\/core.py:    The next example demonstrates a 2D Moffat function model, and also\nastropy\/modeling\/core.py:        ... def Moffat2D(x, y, amplitude=1.0, x_0=0.0, y_0=0.0, gamma=1.0,\nastropy\/modeling\/core.py:        >>> print(Moffat2D.__doc__)\nastropy\/modeling\/core.py:        >>> model = Moffat2D()\nastropy\/modeling\/core.py:            AstropyDeprecationWarning)\nastropy\/modeling\/core.py:        raise ModelDefinitionError(\nastropy\/modeling\/core.py:        raise ModelDefinitionError(\nastropy\/modeling\/core.py:        raise ModelDefinitionError(\"derivative function should accept \"\nastropy\/modeling\/core.py:    # TODO: Maybe have a clever scheme for default output name?\nastropy\/modeling\/core.py:        # Ensure that array scalars are always upgrade to 1-D arrays for the\nastropy\/modeling\/tests\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/utils.py:            \"will result in an error in the future\", DeprecationWarning)\nastropy\/samp\/web_profile.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/web_profile.py:CROSS_DOMAIN = get_pkg_data_contents('data\/crossdomain.xml')\nastropy\/samp\/web_profile.py:            response = CROSS_DOMAIN\nastropy\/samp\/web_profile.py:    def do_HEAD(self):\nastropy\/samp\/web_profile.py:Do you give your consent? [yes|no]\"\"\".format(samp_name, request[2])\nastropy\/convolution\/tests\/test_convolve.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_convolve.py:VALID_DTYPES = []\nastropy\/convolution\/tests\/test_convolve.py:        VALID_DTYPES.append((dtype_array, dtype_kernel))\nastropy\/convolution\/tests\/test_convolve.py:BOUNDARY_OPTIONS = [None, 'fill', 'wrap', 'extend']\nastropy\/convolution\/tests\/test_convolve.py:NANHANDLING_OPTIONS = ['interpolate', 'fill']\nastropy\/convolution\/tests\/test_convolve.py:BOUNDARIES_AND_CONVOLUTIONS = (list(zip(itertools.cycle((convolve,)),\nastropy\/convolution\/tests\/test_convolve.py:                                        BOUNDARY_OPTIONS)) + [(convolve_fft,\nastropy\/convolution\/tests\/test_convolve.py:class TestConvolve1D:\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('dtype_array', 'dtype_kernel'), VALID_DTYPES)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('convfunc', 'boundary',), BOUNDARIES_AND_CONVOLUTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:                             itertools.product(BOUNDARY_OPTIONS,\nastropy\/convolution\/tests\/test_convolve.py:                                               NANHANDLING_OPTIONS,\nastropy\/convolution\/tests\/test_convolve.py:                             itertools.product(BOUNDARY_OPTIONS,\nastropy\/convolution\/tests\/test_convolve.py:                                               NANHANDLING_OPTIONS,\nastropy\/convolution\/tests\/test_convolve.py:class TestConvolve2D:\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('dtype_array', 'dtype_kernel'), VALID_DTYPES)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    def test_non_normalized_kernel_2D(self, boundary):\nastropy\/convolution\/tests\/test_convolve.py:class TestConvolve3D:\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('dtype_array', 'dtype_kernel'), VALID_DTYPES)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:                             itertools.product(BOUNDARY_OPTIONS,\nastropy\/convolution\/tests\/test_convolve.py:                                               NANHANDLING_OPTIONS))\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:@pytest.mark.parametrize(('convfunc', 'boundary'), BOUNDARIES_AND_CONVOLUTIONS)\nastropy\/io\/ascii\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/connect.py:    out = Table(list(zip(*rows)), names=('Format', 'Suffix', 'Write', 'Description'))\nastropy\/io\/ascii\/connect.py:    for colname in ('Format', 'Description'):\nastropy\/io\/ascii\/ui.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/ui.py:from ...utils.exceptions import AstropyWarning, AstropyDeprecationWarning\nastropy\/io\/ascii\/ui.py:# Default setting for guess parameter in read()\nastropy\/io\/ascii\/ui.py:    Determine if ``table`` probably contains HTML content.  See PR #3693 and issue\nastropy\/io\/ascii\/ui.py:        if re.match(r'\\s* <! \\s* DOCTYPE \\s* HTML', table, re.IGNORECASE | re.VERBOSE):\nastropy\/io\/ascii\/ui.py:        # Look for <TABLE .. >, <TR .. >, <TD .. > tag openers.\nastropy\/io\/ascii\/ui.py:        Reader class (DEPRECATED). Default is :class:`Basic`.\nastropy\/io\/ascii\/ui.py:        Dictionary of converters.\nastropy\/io\/ascii\/ui.py:        Try to guess the table format. Defaults to None.\nastropy\/io\/ascii\/ui.py:        Dictionary of converters\nastropy\/io\/ascii\/ui.py:            Fortran-style scientific notation like ``'3.14159D+00'`` (``'E'``, ``'D'``, ``'Q'``),\nastropy\/io\/ascii\/ui.py:            approximately ``chunk_size`` bytes. Default is reading table in one pass.\nastropy\/io\/ascii\/ui.py:        Reader class (DEPRECATED)\nastropy\/io\/ascii\/ui.py:    # Downstream readers might munge kwargs\nastropy\/io\/ascii\/ui.py:        # #2001.  If a `readme` arg was passed that implies CDS format, in\nastropy\/io\/ascii\/ui.py:            # Do guess_kwargs.update(read_kwargs) except that if guess_args has\nastropy\/io\/ascii\/ui.py:    # Define whitelist of exceptions that are expected from readers when\nastropy\/io\/ascii\/ui.py:                              dict(Reader=daophot.Daophot),\nastropy\/io\/ascii\/ui.py:        Writer class (DEPRECATED). Defaults to :class:`Basic`.\nastropy\/io\/ascii\/ui.py:        Dictionary of format specifiers or formatting functions\nastropy\/io\/ascii\/ui.py:        Output [filename, file-like object]. Defaults to``sys.stdout``.\nastropy\/io\/ascii\/ui.py:        Output table format. Defaults to 'basic'.\nastropy\/io\/ascii\/ui.py:        Dictionary of format specifiers or formatting functions\nastropy\/io\/ascii\/ui.py:        Writer class (DEPRECATED).\nastropy\/io\/ascii\/ui.py:                        output), AstropyDeprecationWarning)\nastropy\/modeling\/tests\/test_quantities_model.py:from ..functional_models import Gaussian1D\nastropy\/modeling\/tests\/test_quantities_model.py:    g = Gaussian1D(mean=3 * u.m, stddev=3 * u.cm, amplitude=3 * u.Jy)\nastropy\/modeling\/tests\/test_quantities_model.py:    g = Gaussian1D(amplitude=[1 * u.J, 2. * u.J],\nastropy\/io\/misc\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_ut1.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_ut1.py:        assert status == iers.FROM_IERS_A_PREDICTION\nastropy\/time\/tests\/test_ut1.py:        assert status == iers.FROM_IERS_A_PREDICTION\nastropy\/io\/fits\/verify.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/verify.py:            # Don't print out fixable issues; the first element of each verify\nastropy\/io\/fits\/verify.py:            # Don't print *unfixable* issues, but do print fixed issues; this\nastropy\/io\/ascii\/basic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/basic.py:class BasicData(core.BaseData):\nastropy\/io\/ascii\/basic.py:    Basic table Data Reader\nastropy\/io\/ascii\/basic.py:      # Default delimiter is the space character.\nastropy\/io\/ascii\/basic.py:      # Data starts after the header column definition, blank lines ignored\nastropy\/io\/ascii\/basic.py:    data_class = BasicData\nastropy\/io\/ascii\/basic.py:class NoHeaderData(BasicData):\nastropy\/io\/ascii\/basic.py:    Data starts at first uncommented line since there is no header line.\nastropy\/io\/ascii\/basic.py:    data_class = NoHeaderData\nastropy\/io\/ascii\/basic.py:    data_class = NoHeaderData\nastropy\/io\/ascii\/basic.py:class TabHeaderSplitter(core.DefaultSplitter):\nastropy\/io\/ascii\/basic.py:class TabDataSplitter(TabHeaderSplitter):\nastropy\/io\/ascii\/basic.py:    Don't strip data value whitespace since that is significant in TSV tables\nastropy\/io\/ascii\/basic.py:class TabData(BasicData):\nastropy\/io\/ascii\/basic.py:    splitter_class = TabDataSplitter\nastropy\/io\/ascii\/basic.py:    data_class = TabData\nastropy\/io\/ascii\/basic.py:class CsvSplitter(core.DefaultSplitter):\nastropy\/io\/ascii\/basic.py:class CsvData(BasicData):\nastropy\/io\/ascii\/basic.py:    Data that uses the :class:`astropy.io.ascii.basic.CsvSplitter`\nastropy\/io\/ascii\/basic.py:    data_class = CsvData\nastropy\/io\/ascii\/basic.py:    Header for RDB tables\nastropy\/io\/ascii\/basic.py:        This is a specialized get_cols for the RDB type:\nastropy\/io\/ascii\/basic.py:        Line 0: RDB col names\nastropy\/io\/ascii\/basic.py:        Line 1: RDB col definitions\nastropy\/io\/ascii\/basic.py:        Line 2+: RDB data rows\nastropy\/io\/ascii\/basic.py:            raise ValueError('RDB header requires 2 lines')\nastropy\/io\/ascii\/basic.py:            raise ValueError('RDB header mismatch between number of column names and column types')\nastropy\/io\/ascii\/basic.py:            raise ValueError('RDB types definitions do not all match [num](N|S): {}'.format(raw_types))\nastropy\/io\/ascii\/basic.py:class RdbData(TabData):\nastropy\/io\/ascii\/basic.py:    Data reader for RDB data. Starts reading at line 2.\nastropy\/io\/ascii\/basic.py:    line.  The RDB format meets this definition.  Example::\nastropy\/io\/ascii\/basic.py:    data_class = RdbData\nastropy\/io\/votable\/xmlutil.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/xmlutil.py:def check_id(ID, name='ID', config=None, pos=None):\nastropy\/io\/votable\/xmlutil.py:    Raises a `~astropy.io.votable.exceptions.VOTableSpecError` if *ID*\nastropy\/io\/votable\/xmlutil.py:    is not a valid XML ID_.\nastropy\/io\/votable\/xmlutil.py:    if (ID is not None and not xml_check.check_id(ID)):\nastropy\/io\/votable\/xmlutil.py:        warn_or_raise(W02, W02, (name, ID), config, pos)\nastropy\/io\/votable\/xmlutil.py:def fix_id(ID, config=None, pos=None):\nastropy\/io\/votable\/xmlutil.py:    if ID is None:\nastropy\/io\/votable\/xmlutil.py:    corrected = xml_check.fix_id(ID)\nastropy\/io\/votable\/xmlutil.py:    if corrected != ID:\nastropy\/io\/votable\/xmlutil.py:        vo_warn(W03, (ID, corrected), config, pos)\nastropy\/io\/votable\/xmlutil.py:        For version \\\"1.0\\\", it is checked against a DTD, since that\nastropy\/io\/ascii\/fastbasic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/fastbasic.py:from collections import OrderedDict\nastropy\/io\/ascii\/fastbasic.py:        meta = OrderedDict()\nastropy\/io\/ascii\/fastbasic.py:        meta = OrderedDict()\nastropy\/io\/ascii\/fastbasic.py:            raise ValueError('RDB header requires 2 lines')\nastropy\/io\/ascii\/fastbasic.py:            raise ValueError('RDB header mismatch between number of '\nastropy\/io\/ascii\/fastbasic.py:            raise ValueError('RDB type definitions do not all match '\nastropy\/io\/misc\/hdf5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/hdf5.py:This package contains functions for reading and writing HDF5 tables that are\nastropy\/io\/misc\/hdf5.py:# NOTE: Do not import anything from astropy.table here.\nastropy\/io\/misc\/hdf5.py:from ...utils.exceptions import AstropyUserWarning, AstropyDeprecationWarning\nastropy\/io\/misc\/hdf5.py:HDF5_SIGNATURE = b'\\x89HDF\\r\\n\\x1a\\n'\nastropy\/io\/misc\/hdf5.py:    Find all structured arrays in an HDF5 file\nastropy\/io\/misc\/hdf5.py:        if isinstance(obj, h5py.Dataset) and obj.dtype.kind == 'V':\nastropy\/io\/misc\/hdf5.py:        return signature == HDF5_SIGNATURE\nastropy\/io\/misc\/hdf5.py:        return isinstance(args[0], (h5py.highlevel.File, h5py.highlevel.Group, h5py.highlevel.Dataset))\nastropy\/io\/misc\/hdf5.py:    Read a Table object from an HDF5 file\nastropy\/io\/misc\/hdf5.py:    table is present in the HDF5 file or group, the first table is read in and\nastropy\/io\/misc\/hdf5.py:        :class:`h5py:Dataset` If a string, the filename to read the table from.\nastropy\/io\/misc\/hdf5.py:        The path from which to read the table inside the HDF5 file.\nastropy\/io\/misc\/hdf5.py:        raise Exception(\"h5py is required to read and write HDF5 files\")\nastropy\/io\/misc\/hdf5.py:                raise ValueError(\"no table found in HDF5 group {0}\".\nastropy\/io\/misc\/hdf5.py:    elif not isinstance(input, h5py.highlevel.Dataset):\nastropy\/io\/misc\/hdf5.py:    # If we are here, `input` should be a Dataset object, which we can now\nastropy\/io\/misc\/hdf5.py:    # attributes of the HDF5 dataset.\nastropy\/io\/misc\/hdf5.py:    # that *require* YAML serialization.  HDF5 already has support for\nastropy\/io\/misc\/hdf5.py:                                \"to HDF5 without PyYAML installed.\"\nastropy\/io\/misc\/hdf5.py:    Write a Table object to an HDF5 file\nastropy\/io\/misc\/hdf5.py:        Data table that is to be written to file.\nastropy\/io\/misc\/hdf5.py:        The path to which to write the table inside the HDF5 file.\nastropy\/io\/misc\/hdf5.py:        Whether to compress the table inside the HDF5 file. If set to `True`,\nastropy\/io\/misc\/hdf5.py:        Whether to append the table to an existing HDF5 file.\nastropy\/io\/misc\/hdf5.py:        raise Exception(\"h5py is required to read and write HDF5 files\")\nastropy\/io\/misc\/hdf5.py:            # Delete only the dataset itself\nastropy\/io\/misc\/hdf5.py:    # HDF5 can store natively (name, dtype) with no meta.\nastropy\/io\/misc\/hdf5.py:                          AstropyDeprecationWarning)\nastropy\/io\/misc\/hdf5.py:                \"Attributes could not be written to the output HDF5 \"\nastropy\/io\/misc\/hdf5.py:        # Write the Table meta dict key:value pairs to the file as HDF5\nastropy\/io\/misc\/hdf5.py:                              \"HDF5 files - skipping. (Consider specifying \"\nastropy\/io\/misc\/hdf5.py:    Register HDF5 with Unified I\/O.\nastropy\/io\/votable\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/connect.py:        The table to read in.  If a `str`, it is an ID corresponding\nastropy\/io\/votable\/connect.py:        to the ID of the table in the file (not all VOTable files\nastropy\/io\/votable\/connect.py:        assign IDs to their tables).  If an `int`, it is the index of\nastropy\/io\/votable\/connect.py:        (default), use the ID attributes as the column names.\nastropy\/io\/votable\/connect.py:            if table.ID is not None:\nastropy\/io\/votable\/connect.py:                table_id_mapping[table.ID] = table\nastropy\/io\/votable\/connect.py:        The table ID to use. If this is not specified, the 'ID' keyword in the\nastropy\/io\/votable\/connect.py:        (text representation), ``binary`` or ``binary2``.  Default is\nastropy\/io\/ascii\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/__init__.py:                   BaseData,\nastropy\/io\/ascii\/__init__.py:                   BaseSplitter, DefaultSplitter, WhitespaceSplitter,\nastropy\/io\/ascii\/__init__.py:from .basic import (Basic, BasicHeader, BasicData,\nastropy\/io\/ascii\/__init__.py:from .daophot import Daophot\nastropy\/io\/ascii\/__init__.py:                         FixedWidthHeader, FixedWidthData)\nastropy\/io\/ascii\/rst.py:# Licensed under a 3-clause BSD style license\nastropy\/io\/ascii\/rst.py:from .core import DefaultSplitter\nastropy\/io\/ascii\/rst.py:                         FixedWidthData,\nastropy\/io\/ascii\/rst.py:                         FixedWidthTwoLineDataSplitter)\nastropy\/io\/ascii\/rst.py:    splitter_class = DefaultSplitter\nastropy\/io\/ascii\/rst.py:class SimpleRSTData(FixedWidthData):\nastropy\/io\/ascii\/rst.py:    splitter_class = FixedWidthTwoLineDataSplitter\nastropy\/io\/ascii\/rst.py:    data_class = SimpleRSTData\nastropy\/io\/misc\/tests\/test_yaml.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_introspection.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/util.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/util.py:# STDLIB\nastropy\/io\/votable\/util.py:        If `True`, create a gzip-compressed file.  (Default is `False`).\nastropy\/io\/votable\/util.py:# <http:\/\/www.ivoa.net\/Documents\/REC\/DM\/STC-20071030.html>\nastropy\/io\/votable\/util.py:    'SUPER_GALACTIC', 'AZ_EL', 'BODY', 'GEO_C', 'GEO_D', 'MAG', 'GSE', 'GSM',\nastropy\/io\/votable\/util.py:    <http:\/\/www.ivoa.net\/Documents\/REC\/DAL\/SSA-20080201.html>`_.\nastropy\/io\/votable\/util.py:        TODO\nastropy\/convolution\/tests\/test_convolve_nddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_convolve_nddata.py:from ..kernels import Gaussian2DKernel\nastropy\/convolution\/tests\/test_convolve_nddata.py:from ...nddata import NDData\nastropy\/convolution\/tests\/test_convolve_nddata.py:    ndd = NDData(arr)\nastropy\/convolution\/tests\/test_convolve_nddata.py:    test_kernel = Gaussian2DKernel(1)\nastropy\/convolution\/tests\/test_convolve_nddata.py:    ndd_base = NDData(arr)\nastropy\/convolution\/tests\/test_convolve_nddata.py:    ndd_mask = NDData(arr, mask=mask)\nastropy\/convolution\/tests\/test_convolve_nddata.py:    ndd_nan = NDData(arrnan)\nastropy\/convolution\/tests\/test_convolve_nddata.py:    test_kernel = Gaussian2DKernel(1)\nastropy\/io\/fits\/_numpy_hacks.py:            \"Dtype must be a structured dtype, and length of offsets list \"\nastropy\/io\/misc\/tests\/test_pickle_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/tests\/test_pickle_helpers.py:from ....utils.exceptions import AstropyDeprecationWarning\nastropy\/io\/misc\/tests\/test_pickle_helpers.py:    with catch_warnings(AstropyDeprecationWarning):\nastropy\/io\/ascii\/ipac.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/ipac.py:from collections import defaultdict, OrderedDict\nastropy\/io\/ascii\/ipac.py:class IpacFormatErrorDBMS(Exception):\nastropy\/io\/ascii\/ipac.py:            'http:\/\/irsa.ipac.caltech.edu\/applications\/DDGEN\/Doc\/DBMSrestriction.html')\nastropy\/io\/ascii\/ipac.py:            'http:\/\/irsa.ipac.caltech.edu\/applications\/DDGEN\/Doc\/ipac_tbl.html')\nastropy\/io\/ascii\/ipac.py:    # Defined ordered list of possible types.  Ordering is needed to\nastropy\/io\/ascii\/ipac.py:        http:\/\/irsa.ipac.caltech.edu\/applications\/DDGEN\/Doc\/ipac_tbl.html#kw\nastropy\/io\/ascii\/ipac.py:        table_meta['keywords'] = OrderedDict()\nastropy\/io\/ascii\/ipac.py:        if self.DBMS:\nastropy\/io\/ascii\/ipac.py:            IpacFormatE = IpacFormatErrorDBMS\nastropy\/io\/ascii\/ipac.py:        if self.DBMS:\nastropy\/io\/ascii\/ipac.py:                raise IpacFormatE('IPAC DBMS tables are not case sensitive. '\nastropy\/io\/ascii\/ipac.py:            if self.DBMS and not(name[0].isalpha() or (name[0] == '_')):\nastropy\/io\/ascii\/ipac.py:            if self.DBMS:\nastropy\/io\/ascii\/ipac.py:class IpacDataSplitter(fixedwidth.FixedWidthSplitter):\nastropy\/io\/ascii\/ipac.py:class IpacData(fixedwidth.FixedWidthData):\nastropy\/io\/ascii\/ipac.py:    splitter_class = IpacDataSplitter\nastropy\/io\/ascii\/ipac.py:    http:\/\/irsa.ipac.caltech.edu\/applications\/DDGEN\/Doc\/ipac_tbl.html::\nastropy\/io\/ascii\/ipac.py:    DBMS : bool, optional\nastropy\/io\/ascii\/ipac.py:        to the `IPAC\/DBMS <http:\/\/irsa.ipac.caltech.edu\/applications\/DDGEN\/Doc\/DBMSrestriction.html>`_\nastropy\/io\/ascii\/ipac.py:        `IPAC <http:\/\/irsa.ipac.caltech.edu\/applications\/DDGEN\/Doc\/ipac_tbl.html>`_\nastropy\/io\/ascii\/ipac.py:    data_class = IpacData\nastropy\/io\/ascii\/ipac.py:    def __init__(self, definition='ignore', DBMS=False):\nastropy\/io\/ascii\/ipac.py:        self.header.DBMS = DBMS\nastropy\/io\/misc\/tests\/test_hdf5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/tests\/test_hdf5.py:from ....time import Time, TimeDelta\nastropy\/io\/misc\/tests\/test_hdf5.py:ALL_DTYPES = [np.uint8, np.uint16, np.uint32, np.uint64, np.int8,\nastropy\/io\/misc\/tests\/test_hdf5.py:    assert exc.value.args[0] == 'no table found in HDF5 group \/'\nastropy\/io\/misc\/tests\/test_hdf5.py:@pytest.mark.parametrize(('dtype'), ALL_DTYPES)\nastropy\/io\/misc\/tests\/test_hdf5.py:    for dtype in ALL_DTYPES:\nastropy\/io\/misc\/tests\/test_hdf5.py:    for dtype in ALL_DTYPES:\nastropy\/io\/misc\/tests\/test_hdf5.py:        \"Attributes could not be written to the output HDF5 \"\nastropy\/io\/misc\/tests\/test_hdf5.py:        \"Attribute `f` of type {0} cannot be written to HDF5 files - skipping\".format(type(t1.meta['f'])))\nastropy\/io\/misc\/tests\/test_hdf5.py:    # Regression test - ensure that Datasets are recognized automatically\nastropy\/io\/misc\/tests\/test_hdf5.py:        # Mixin info.meta can None instead of empty OrderedDict(), #6720 would\nastropy\/io\/misc\/tests\/test_hdf5.py:# Testing HDF5 table read\/write with mixins.  This is mostly\nastropy\/io\/misc\/tests\/test_hdf5.py:    'dt': TimeDelta([1, 2] * u.day),\nastropy\/io\/misc\/tests\/test_hdf5.py:            # Downgrade Quantity to Column + unit\nastropy\/io\/misc\/tests\/test_hdf5.py:    assert \"cannot write type SkyCoord column 'col0' to HDF5 without PyYAML\" in str(err)\nastropy\/io\/ascii\/cds.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/cds.py:  Classes to read CDS \/ Vizier table format\nastropy\/io\/ascii\/cds.py:            raise ValueError('Unrecognized CDS format \"{}\" for column \"{}\"'.format(\nastropy\/io\/ascii\/cds.py:        Initialize the header Column objects from the table ``lines`` for a CDS\nastropy\/io\/ascii\/cds.py:                    match = re.match(r'Byte-by-byte Description of file: (?P<name>.+)$',\nastropy\/io\/ascii\/cds.py:            if re.match(r'Byte-by-byte Description', line, re.IGNORECASE):\nastropy\/io\/ascii\/cds.py:                    col.unit = None  # \"---\" is the marker for no unit in CDS table\nastropy\/io\/ascii\/cds.py:                        # CDS tables can use -, --, ---, or ---- to mark missing values\nastropy\/io\/ascii\/cds.py:                    raise ValueError('Line \"{}\" not parsable as CDS header'.format(line))\nastropy\/io\/ascii\/cds.py:class CdsData(core.BaseData):\nastropy\/io\/ascii\/cds.py:    \"\"\"CDS table data reader\nastropy\/io\/ascii\/cds.py:        \"\"\"Skip over CDS header by finding the last section delimiter\"\"\"\nastropy\/io\/ascii\/cds.py:            raise core.InconsistentTableError('No CDS section delimiter found')\nastropy\/io\/ascii\/cds.py:    \"\"\"Read a CDS format table.  See http:\/\/vizier.u-strasbg.fr\/doc\/catstd.htx.\nastropy\/io\/ascii\/cds.py:      ADC_Keywords: Keyword ; Another keyword ; etc\nastropy\/io\/ascii\/cds.py:      Description:\nastropy\/io\/ascii\/cds.py:      Byte-by-byte Description of file: datafile3.txt\nastropy\/io\/ascii\/cds.py:      Note (1): A CDS file can contain sections with various metadata.\nastropy\/io\/ascii\/cds.py:    **About parsing the CDS format**\nastropy\/io\/ascii\/cds.py:    The CDS format consists of a table description and the table data.  These\nastropy\/io\/ascii\/cds.py:    combined in a single file.  Different subsections within the description\nastropy\/io\/ascii\/cds.py:    starting with \"Byte-by-byte Description of file:\".\nastropy\/io\/ascii\/cds.py:    parameter indicating the CDS ReadMe file.  If not supplied it is assumed that\nastropy\/io\/ascii\/cds.py:    The table name and the CDS ReadMe file can be entered as URLs.  This can be used\nastropy\/io\/ascii\/cds.py:    CDS::\nastropy\/io\/ascii\/cds.py:    data table matches expectation based on the input CDS file.\nastropy\/io\/ascii\/cds.py:      InconsistentTableError: No CDS section delimiter found\nastropy\/io\/ascii\/cds.py:    _description = 'CDS format table'\nastropy\/io\/ascii\/cds.py:    data_class = CdsData\nastropy\/io\/fits\/tests\/test_compression_failures.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        assert 'CompImageHDU.data must be a numpy.ndarray' in str(exc)\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)), quantize_method=1)\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu._header['ZDITHER0'] = 'a'\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:    @pytest.mark.parametrize('kw', ['NAXIS1', 'NAXIS2', 'TFIELDS', 'PCOUNT'])\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:         ('TFIELDS', 999)])\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10), dtype=np.int32))\nastropy\/io\/votable\/tree.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tree.py:# TODO: Test FITS parsing\nastropy\/io\/votable\/tree.py:# STDLIB\nastropy\/io\/votable\/tree.py:# THIRD-PARTY\nastropy\/io\/votable\/tree.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/io\/votable\/tree.py:from ...utils.misc import InheritDocstrings\nastropy\/io\/votable\/tree.py:DEFAULT_CHUNK_SIZE = 256\nastropy\/io\/votable\/tree.py:    Like `_lookup_by_attr_factory`, but looks in both the \"ID\" and\nastropy\/io\/votable\/tree.py:        with the attribute ID == *ref* or name == *ref*.  If *before*\nastropy\/io\/votable\/tree.py:                if ref in (element.ID, element.name):\nastropy\/io\/votable\/tree.py:            if ref in (element.ID, element.name):\nastropy\/io\/votable\/tree.py:            \"No {} with ID or name '{}' found before the referencing {}\".format(\nastropy\/io\/votable\/tree.py:def resolve_id(ID, id, config=None, pos=None):\nastropy\/io\/votable\/tree.py:    if ID is None and id is not None:\nastropy\/io\/votable\/tree.py:    return ID\nastropy\/io\/votable\/tree.py:        A UCD string.\nastropy\/io\/votable\/tree.py:class _IDProperty:\nastropy\/io\/votable\/tree.py:    def ID(self):\nastropy\/io\/votable\/tree.py:        The XML ID_ of the element.  May be `None` or a string\nastropy\/io\/votable\/tree.py:        conforming to XML ID_ syntax.\nastropy\/io\/votable\/tree.py:        return self._ID\nastropy\/io\/votable\/tree.py:    @ID.setter\nastropy\/io\/votable\/tree.py:    def ID(self, ID):\nastropy\/io\/votable\/tree.py:        xmlutil.check_id(ID, 'ID', self._config, self._pos)\nastropy\/io\/votable\/tree.py:        self._ID = ID\nastropy\/io\/votable\/tree.py:    @ID.deleter\nastropy\/io\/votable\/tree.py:    def ID(self):\nastropy\/io\/votable\/tree.py:        self._ID = None\nastropy\/io\/votable\/tree.py:class _DescriptionProperty:\nastropy\/io\/votable\/tree.py:        DESCRIPTION_ element.\nastropy\/io\/votable\/tree.py:class Element(metaclass=InheritDocstrings):\nastropy\/io\/votable\/tree.py:    A base class for simple elements, such as FIELD, PARAM and INFO\nastropy\/io\/votable\/tree.py:    A base class for simple elements, such as FIELD, PARAM and INFO\nastropy\/io\/votable\/tree.py:class Link(SimpleElement, _IDProperty):\nastropy\/io\/votable\/tree.py:    _attr_list = ['ID', 'content_role', 'content_type', 'title', 'value',\nastropy\/io\/votable\/tree.py:    def __init__(self, ID=None, title=None, value=None, href=None, action=None,\nastropy\/io\/votable\/tree.py:        self.ID = resolve_id(ID, id, config, pos)\nastropy\/io\/votable\/tree.py:        Defines the MIME role of the referenced object.  Must be one of:\nastropy\/io\/votable\/tree.py:        \"\"\"Defines the MIME content type of the referenced object.\"\"\"\nastropy\/io\/votable\/tree.py:class Info(SimpleElementWithContent, _IDProperty, _XtypeProperty,\nastropy\/io\/votable\/tree.py:    _attr_list_11 = ['ID', 'name', 'value']\nastropy\/io\/votable\/tree.py:    def __init__(self, ID=None, name=None, value=None, id=None, xtype=None,\nastropy\/io\/votable\/tree.py:        self.ID = (resolve_id(ID, id, config, pos) or\nastropy\/io\/votable\/tree.py:        Refer to another INFO_ element by ID_, defined previously in\nastropy\/io\/votable\/tree.py:        # TODO: actually apply the reference\nastropy\/io\/votable\/tree.py:class Values(Element, _IDProperty):\nastropy\/io\/votable\/tree.py:    VALUES_ element: used within FIELD_ and PARAM_ elements to define the domain of values.\nastropy\/io\/votable\/tree.py:    def __init__(self, votable, field, ID=None, null=None, ref=None,\nastropy\/io\/votable\/tree.py:        self.ID = resolve_id(ID, id, config, pos)\nastropy\/io\/votable\/tree.py:        [*required*] Defines the applicability of the domain defined\nastropy\/io\/votable\/tree.py:        Refer to another VALUES_ element by ID_, defined previously in\nastropy\/io\/votable\/tree.py:        return (self.ref is None and self.null is None and self.ID is None and\nastropy\/io\/votable\/tree.py:                           self, ['ID', 'null', 'ref'])):\nastropy\/io\/votable\/tree.py:        for key in ['ID', 'null']:\nastropy\/io\/votable\/tree.py:        for key in ['ID', 'null']:\nastropy\/io\/votable\/tree.py:class Field(SimpleElement, _IDProperty, _NameProperty, _XtypeProperty,\nastropy\/io\/votable\/tree.py:    FIELD_ element: describes the datatype of a particular column of data.\nastropy\/io\/votable\/tree.py:    If *ID* is provided, it is used for the column name in the\nastropy\/io\/votable\/tree.py:    resulting recarray of the table.  If no *ID* is provided, *name*\nastropy\/io\/votable\/tree.py:    _attr_list_11 = ['ID', 'name', 'datatype', 'arraysize', 'ucd',\nastropy\/io\/votable\/tree.py:    _element_name = 'FIELD'\nastropy\/io\/votable\/tree.py:    def __init__(self, votable, ID=None, name=None, datatype=None,\nastropy\/io\/votable\/tree.py:        # TODO: REMOVE ME ----------------------------------------\nastropy\/io\/votable\/tree.py:            ID == 'cprojection' and ucd == 'VOX:WCS_CoordProjection' and\nastropy\/io\/votable\/tree.py:        self.ID = (resolve_id(ID, id, config, pos) or\nastropy\/io\/votable\/tree.py:            self.name = self.ID\nastropy\/io\/votable\/tree.py:        if self._ID is None and name is None:\nastropy\/io\/votable\/tree.py:            new_id = field.ID\nastropy\/io\/votable\/tree.py:                new_id = field.ID + \"_{:d}\".format(i)\nastropy\/io\/votable\/tree.py:            if new_id != field.ID:\nastropy\/io\/votable\/tree.py:                vo_warn(W32, (field.ID, new_id), field._config, field._pos)\nastropy\/io\/votable\/tree.py:            field.ID = new_id\nastropy\/io\/votable\/tree.py:            unique[new_id] = field.ID\nastropy\/io\/votable\/tree.py:                new_name = field.ID\nastropy\/io\/votable\/tree.py:            if new_name != field.ID:\nastropy\/io\/votable\/tree.py:            vo_raise(E06, (datatype, self.ID), self._config, self._pos)\nastropy\/io\/votable\/tree.py:    # ref on FIELD and PARAM behave differently than elsewhere -- here\nastropy\/io\/votable\/tree.py:        On FIELD_ elements, ref is used only for informational\nastropy\/io\/votable\/tree.py:        \"\"\"A string specifying the units_ for the FIELD_.\"\"\"\nastropy\/io\/votable\/tree.py:        FIELD_ contains more than a single value.\nastropy\/io\/votable\/tree.py:        The type attribute on FIELD_ elements is reserved for future\nastropy\/io\/votable\/tree.py:        details about the meaning of the FIELD_.  This is purely\nastropy\/io\/votable\/tree.py:                elif tag == 'DESCRIPTION':\nastropy\/io\/votable\/tree.py:                        'DESCRIPTION', data.keys(), config, pos)\nastropy\/io\/votable\/tree.py:                if tag == 'DESCRIPTION':\nastropy\/io\/votable\/tree.py:                w.element('DESCRIPTION', self.description, wrap=True)\nastropy\/io\/votable\/tree.py:            # TODO: Use units framework when it's available\nastropy\/io\/votable\/tree.py:        # TODO: Use the unit framework when available\nastropy\/io\/votable\/tree.py:        # TODO: Parse format into precision and width\nastropy\/io\/votable\/tree.py:    def __init__(self, votable, ID=None, name=None, value=None, datatype=None,\nastropy\/io\/votable\/tree.py:        Field.__init__(self, votable, ID=ID, name=name, datatype=datatype,\nastropy\/io\/votable\/tree.py:    _attr_list = ['ID', 'equinox', 'epoch', 'system']\nastropy\/io\/votable\/tree.py:    def __init__(self, ID=None, equinox=None, epoch=None, system=None, id=None,\nastropy\/io\/votable\/tree.py:        self.ID = resolve_id(ID, id, config, pos)\nastropy\/io\/votable\/tree.py:    def ID(self):\nastropy\/io\/votable\/tree.py:        [*required*] The XML ID of the COOSYS_ element, used for\nastropy\/io\/votable\/tree.py:        XML ID_ syntax.\nastropy\/io\/votable\/tree.py:        return self._ID\nastropy\/io\/votable\/tree.py:    @ID.setter\nastropy\/io\/votable\/tree.py:    def ID(self, ID):\nastropy\/io\/votable\/tree.py:            if ID is None:\nastropy\/io\/votable\/tree.py:        xmlutil.check_id(ID, 'ID', self._config, self._pos)\nastropy\/io\/votable\/tree.py:        self._ID = ID\nastropy\/io\/votable\/tree.py:    FIELDref_ element: used inside of GROUP_ elements to refer to remote FIELD_ elements.\nastropy\/io\/votable\/tree.py:    _element_name = \"FIELDref\"\nastropy\/io\/votable\/tree.py:        *ref* is the ID to reference a :class:`Field` object defined\nastropy\/io\/votable\/tree.py:        \"\"\"The ID_ of the FIELD_ that this FIELDref_ references.\"\"\"\nastropy\/io\/votable\/tree.py:            if isinstance(field, Field) and field.ID == self.ref:\nastropy\/io\/votable\/tree.py:      *ref*: An XML ID referring to a <PARAM> element.\nastropy\/io\/votable\/tree.py:        \"\"\"The ID_ of the PARAM_ that this PARAMref_ references.\"\"\"\nastropy\/io\/votable\/tree.py:            if isinstance(param, Param) and param.ID == self.ref:\nastropy\/io\/votable\/tree.py:class Group(Element, _IDProperty, _NameProperty, _UtypeProperty,\nastropy\/io\/votable\/tree.py:            _UcdProperty, _DescriptionProperty):\nastropy\/io\/votable\/tree.py:    GROUP_ element: groups FIELD_ and PARAM_ elements.\nastropy\/io\/votable\/tree.py:    def __init__(self, table, ID=None, name=None, ref=None, ucd=None,\nastropy\/io\/votable\/tree.py:        self.ID = (resolve_id(ID, id, config, pos)\nastropy\/io\/votable\/tree.py:            'FIELDref': self._add_fieldref,\nastropy\/io\/votable\/tree.py:            'DESCRIPTION': self._ignore_add}\nastropy\/io\/votable\/tree.py:                if tag == 'DESCRIPTION':\nastropy\/io\/votable\/tree.py:                self, ['ID', 'name', 'ref', 'ucd', 'utype'])):\nastropy\/io\/votable\/tree.py:                w.element(\"DESCRIPTION\", self.description, wrap=True)\nastropy\/io\/votable\/tree.py:class Table(Element, _IDProperty, _NameProperty, _UcdProperty,\nastropy\/io\/votable\/tree.py:            _DescriptionProperty):\nastropy\/io\/votable\/tree.py:        based on the <FIELD> elements of the table.  The mask is\nastropy\/io\/votable\/tree.py:    def __init__(self, votable, ID=None, name=None, ref=None, ucd=None,\nastropy\/io\/votable\/tree.py:        self.ID = (resolve_id(ID, id, config, pos)\nastropy\/io\/votable\/tree.py:        Refer to another TABLE, previously defined, by the *ref* ID_\nastropy\/io\/votable\/tree.py:        for all metadata (FIELD_, PARAM_ etc.) information.\nastropy\/io\/votable\/tree.py:          'tabledata' (TABLEDATA_), 'binary' (BINARY_), 'binary2' (BINARY2_)\nastropy\/io\/votable\/tree.py:                if x._unique_name == x.ID:\nastropy\/io\/votable\/tree.py:                    id = x.ID\nastropy\/io\/votable\/tree.py:                    id = (x._unique_name, x.ID)\nastropy\/io\/votable\/tree.py:            if table_id != self.ID:\nastropy\/io\/votable\/tree.py:                    if tag == 'DATA':\nastropy\/io\/votable\/tree.py:                            'DATA', data.keys(), config, pos)\nastropy\/io\/votable\/tree.py:                    elif tag == 'DESCRIPTION':\nastropy\/io\/votable\/tree.py:                'FIELD': self._add_field,\nastropy\/io\/votable\/tree.py:                'DESCRIPTION': self._ignore_add}\nastropy\/io\/votable\/tree.py:                    if tag == 'DATA':\nastropy\/io\/votable\/tree.py:                            'DATA', data.keys(), config, pos)\nastropy\/io\/votable\/tree.py:                    if tag == 'DESCRIPTION':\nastropy\/io\/votable\/tree.py:                        # contains no DATA section\nastropy\/io\/votable\/tree.py:        names = [x.ID for x in fields]\nastropy\/io\/votable\/tree.py:        # Deal with a subset of the columns, if requested.\nastropy\/io\/votable\/tree.py:                    if tag == 'TABLEDATA':\nastropy\/io\/votable\/tree.py:                            'TABLEDATA', data.keys(), config, pos)\nastropy\/io\/votable\/tree.py:            if not start and tag == 'DATA':\nastropy\/io\/votable\/tree.py:        chunk_size = config.get('chunk_size', DEFAULT_CHUNK_SIZE)\nastropy\/io\/votable\/tree.py:                        if tag == 'TD':\nastropy\/io\/votable\/tree.py:                                                    fields[i].ID))\nastropy\/io\/votable\/tree.py:                                                    fields[i].ID))\nastropy\/io\/votable\/tree.py:            elif not start and tag == 'TABLEDATA':\nastropy\/io\/votable\/tree.py:                                numrows, fields[i].ID))\nastropy\/io\/votable\/tree.py:                ('ID', 'name', 'ref', 'ucd', 'utype', 'nrows'))):\nastropy\/io\/votable\/tree.py:                w.element(\"DESCRIPTION\", self.description, wrap=True)\nastropy\/io\/votable\/tree.py:                group = Group(self, ID=\"_g{0}\".format(index))\nastropy\/io\/votable\/tree.py:                with w.tag('DATA'):\nastropy\/io\/votable\/tree.py:        with w.tag('TABLEDATA'):\nastropy\/io\/votable\/tree.py:                td = indent_spaces + \" <TD>{}<\/TD>\\n\"\nastropy\/io\/votable\/tree.py:                td_empty = indent_spaces + \" <TD\/>\\n\"\nastropy\/io\/votable\/tree.py:                                        row, self.fields[i].ID))\nastropy\/io\/votable\/tree.py:                                    row, fields[i].ID))\nastropy\/io\/votable\/tree.py:           Otherwise (default), use the ID attributes as the column\nastropy\/io\/votable\/tree.py:        for key in ['ID', 'name', 'ref', 'ucd', 'utype', 'description']:\nastropy\/io\/votable\/tree.py:            names = [field.ID for field in self.fields]\nastropy\/io\/votable\/tree.py:        for key in ['ID', 'name', 'ref', 'ucd', 'utype']:\nastropy\/io\/votable\/tree.py:        Recursively iterate over all FIELD and PARAM elements in the\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_fields_and_params', 'FIELD or PARAM',\nastropy\/io\/votable\/tree.py:        Looks up a FIELD or PARAM element by the given ID.\nastropy\/io\/votable\/tree.py:        'iter_fields_and_params', 'FIELD or PARAM',\nastropy\/io\/votable\/tree.py:        Looks up a FIELD or PARAM element by the given ID or name.\nastropy\/io\/votable\/tree.py:        'utype', False, 'iter_fields_and_params', 'FIELD or PARAM',\nastropy\/io\/votable\/tree.py:        Looks up a FIELD or PARAM element by the given utype and\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_groups', 'GROUP',\nastropy\/io\/votable\/tree.py:        Looks up a GROUP element by the given ID.  Used by the group's\nastropy\/io\/votable\/tree.py:class Resource(Element, _IDProperty, _NameProperty, _UtypeProperty,\nastropy\/io\/votable\/tree.py:               _DescriptionProperty):\nastropy\/io\/votable\/tree.py:    def __init__(self, name=None, ID=None, utype=None, type='results',\nastropy\/io\/votable\/tree.py:        self.ID = resolve_id(ID, id, config, pos)\nastropy\/io\/votable\/tree.py:            (FIELD_ elements), but no actual data.\nastropy\/io\/votable\/tree.py:            'DESCRIPTION': self._ignore_add\nastropy\/io\/votable\/tree.py:            elif tag == 'DESCRIPTION':\nastropy\/io\/votable\/tree.py:        attrs = w.object_attrs(self, ('ID', 'type', 'utype'))\nastropy\/io\/votable\/tree.py:                w.element(\"DESCRIPTION\", self.description, wrap=True)\nastropy\/io\/votable\/tree.py:        Recursively iterates over all FIELD_ and PARAM_ elements in\nastropy\/io\/votable\/tree.py:class VOTableFile(Element, _IDProperty, _DescriptionProperty):\nastropy\/io\/votable\/tree.py:    def __init__(self, ID=None, id=None, config=None, pos=None, version=\"1.3\"):\nastropy\/io\/votable\/tree.py:        self.ID = resolve_id(ID, id, config, pos)\nastropy\/io\/votable\/tree.py:            'DEFINITIONS': self._add_definitions,\nastropy\/io\/votable\/tree.py:            'DESCRIPTION': self._ignore_add,\nastropy\/io\/votable\/tree.py:            elif tag == 'DESCRIPTION':\nastropy\/io\/votable\/tree.py:            When `True`, write to a gzip-compressed file.  (Default:\nastropy\/io\/votable\/tree.py:                    w.element(\"DESCRIPTION\", self.description, wrap=True)\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_tables', 'TABLE',\nastropy\/io\/votable\/tree.py:        Looks up a TABLE_ element by the given ID.  Used by the table\nastropy\/io\/votable\/tree.py:        Recursively iterate over all FIELD_ and PARAM_ elements in the\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_fields_and_params', 'FIELD',\nastropy\/io\/votable\/tree.py:        Looks up a FIELD_ element by the given ID_.  Used by the field's\nastropy\/io\/votable\/tree.py:        'utype', False, 'iter_fields_and_params', 'FIELD',\nastropy\/io\/votable\/tree.py:        Looks up a FIELD_ element by the given utype and returns an\nastropy\/io\/votable\/tree.py:        'iter_fields_and_params', 'FIELD',\nastropy\/io\/votable\/tree.py:        Looks up a FIELD_ element by the given ID_ or name.\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_values', 'VALUES',\nastropy\/io\/votable\/tree.py:        Looks up a VALUES_ element by the given ID.  Used by the values\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_groups', 'GROUP',\nastropy\/io\/votable\/tree.py:        Looks up a GROUP_ element by the given ID.  Used by the group's\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_coosys', 'COOSYS',\nastropy\/io\/votable\/tree.py:        \"\"\"Looks up a COOSYS_ element by the given ID.\"\"\")\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_info', 'INFO',\nastropy\/io\/votable\/tree.py:        \"\"\"Looks up a INFO element by the given ID.\"\"\")\nastropy\/io\/votable\/tree.py:            Set the given ID attribute on the returned Table instance.\nastropy\/io\/votable\/tree.py:            votable.ID = table_id\nastropy\/io\/misc\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_checksum.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_checksum.py:from ..hdu.base import _ValidHDU\nastropy\/io\/fits\/tests\/test_checksum.py:            message='Datasum verification failed')\nastropy\/io\/fits\/tests\/test_checksum.py:        self._old_get_timestamp = _ValidHDU._get_timestamp\nastropy\/io\/fits\/tests\/test_checksum.py:        _ValidHDU._get_timestamp = lambda self: '2013-12-20T13:36:10'\nastropy\/io\/fits\/tests\/test_checksum.py:        _ValidHDU._get_timestamp = self._old_get_timestamp\nastropy\/io\/fits\/tests\/test_checksum.py:        hdu = fits.PrimaryHDU(n)\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert hdul[0].header['DATASUM'] == '4950'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in hdul1[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert hdul1[0].header['DATASUM'] == '1891563534'\nastropy\/io\/fits\/tests\/test_checksum.py:                    assert hdr1['DATASUM'] == hdr2['DATASUM']\nastropy\/io\/fits\/tests\/test_checksum.py:                    assert hdr1['DATASUM'] != hdr3['DATASUM']\nastropy\/io\/fits\/tests\/test_checksum.py:            ('aDcXaCcXaCcXaCcX', '0'), ('oYiGqXi9oXiEoXi9', '1746888714'),\nastropy\/io\/fits\/tests\/test_checksum.py:                    assert 'DATASUM' in hdul[idx].header\nastropy\/io\/fits\/tests\/test_checksum.py:                    assert hdul[idx].header['DATASUM'] == checksums[idx][1]\nastropy\/io\/fits\/tests\/test_checksum.py:        x = fits.hdu.groups.GroupData(imdata, parnames=[str('abc'), str('xyz')],\nastropy\/io\/fits\/tests\/test_checksum.py:        hdu = fits.GroupsHDU(x)\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['CHECKSUM'] == '3eDQAZDO4dDOAZDO'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['DATASUM'] == '2797758084'\nastropy\/io\/fits\/tests\/test_checksum.py:        cols = fits.ColDefs([col1, col2])\nastropy\/io\/fits\/tests\/test_checksum.py:        tbhdu = fits.BinTableHDU.from_columns(cols)\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['CHECKSUM'] == 'D8iBD6ZAD6fAD6ZA'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[1].header['CHECKSUM'] == 'aD1Oa90MaC0Ma90M'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[1].header['DATASUM'] == '1062205743'\nastropy\/io\/fits\/tests\/test_checksum.py:        tbhdu = fits.BinTableHDU.from_columns([c1, c2])\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['CHECKSUM'] == 'D8iBD6ZAD6fAD6ZA'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[1].header['DATASUM'] == '1507485'\nastropy\/io\/fits\/tests\/test_checksum.py:        # too much precision when scaling so it was changed to a D\nastropy\/io\/fits\/tests\/test_checksum.py:        c2 = fits.Column(name='def', format='D', array=r1, bscale=2.3,\nastropy\/io\/fits\/tests\/test_checksum.py:        x = fits.ColDefs([c1, c2, c3])\nastropy\/io\/fits\/tests\/test_checksum.py:        hdu = fits.TableHDU.from_columns(x)\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['CHECKSUM'] == 'D8iBD6ZAD6fAD6ZA'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert hdul[1].header['CHECKSUM'] == '51IDA1G981GCA1G9'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert hdul[1].header['DATASUM'] == '1948208413'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert h2[0].header['CHECKSUM'] == 'D8iBD6ZAD6fAD6ZA'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in h2[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert h2[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in h2[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert h2[1].header['DATASUM'] == '113055149'\nastropy\/io\/fits\/tests\/test_checksum.py:        hdu = fits.ImageHDU(n)\nastropy\/io\/fits\/tests\/test_checksum.py:        comp_hdu = fits.CompImageHDU(hdu.data, hdu.header)\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['CHECKSUM'] == 'D8iBD6ZAD6fAD6ZA'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[1]._header['DATASUM'] == '2453673070'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'ZDATASUM' in header_comp\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in header_uncomp\nastropy\/io\/fits\/tests\/test_checksum.py:                assert header_uncomp['DATASUM'] == '160565700'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert header_comp['ZDATASUM'] == header_uncomp['DATASUM']\nastropy\/io\/fits\/tests\/test_checksum.py:        hdu = fits.ImageHDU(n)\nastropy\/io\/fits\/tests\/test_checksum.py:        comp_hdu = fits.CompImageHDU(hdu.data, hdu.header)\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['CHECKSUM'] == 'D8iBD6ZAD6fAD6ZA'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert hdul[1]._header['DATASUM'] == '1277667818'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'ZDATASUM' in header_comp\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in header_uncomp\nastropy\/io\/fits\/tests\/test_checksum.py:                assert header_uncomp['DATASUM'] == '2393636889'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert header_comp['ZDATASUM'] == header_uncomp['DATASUM']\nastropy\/io\/fits\/tests\/test_checksum.py:        hdu = fits.ImageHDU(n)\nastropy\/io\/fits\/tests\/test_checksum.py:        datasum are added to HDUs that did not previously have one.\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[1].header['CHECKSUM'] == '99daD8bX98baA8bU'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[1].header['DATASUM'] == '1829680925'\nastropy\/io\/fits\/tests\/test_checksum.py:        hdu = fits.ImageHDU(n)\nastropy\/io\/fits\/tests\/test_checksum.py:                pytest.fail(msg='Missing DATASUM keyword')\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in header2\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' not in header2\nastropy\/io\/fits\/tests\/test_checksum.py:            hdul[0].header['DATASUM'] = '1       '\nastropy\/io\/fits\/tests\/test_checksum.py:            hdul[1].header['DATASUM'] = '2349680925'\nastropy\/io\/fits\/tests\/test_checksum.py:            hdul[1].header['CHECKSUM'] = '11daD8bX98baA8bU'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert hdul[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert hdul[1].header['DATASUM'] == ref[1].header['DATASUM']\nastropy\/io\/fits\/tests\/test_checksum.py:            pytest.fail(msg='Missing DATASUM keyword')\nastropy\/io\/fits\/util.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/util.py:            self._listeners = weakref.WeakValueDictionary()\nastropy\/io\/fits\/util.py:        # TODO: This hasn't come up often, but if anyone needs to pickle HDU\nastropy\/io\/fits\/util.py:        # objects it will be necessary when HDU objects' states are restored to\nastropy\/io\/fits\/util.py:    >>> class D(B,C): pass\nastropy\/io\/fits\/util.py:    >>> class E(D): pass\nastropy\/io\/fits\/util.py:    D\nastropy\/io\/fits\/util.py:        # Define new signal interput handler\nastropy\/io\/fits\/util.py:                    signal.signal(signal.SIGINT, signal.SIG_DFL)\nastropy\/io\/fits\/util.py:        except UnicodeDecodeError:\nastropy\/io\/fits\/util.py:        # Don't silently pass through on non-string arrays; we don't want\nastropy\/io\/fits\/util.py:    # Doesn't look like a file-like object, for example strings, urls or paths.\nastropy\/io\/fits\/util.py:        if mode == gzip.READ:\nastropy\/io\/fits\/util.py:CHUNKED_FROMFILE = None\nastropy\/io\/fits\/util.py:        global CHUNKED_FROMFILE\nastropy\/io\/fits\/util.py:        if CHUNKED_FROMFILE is None:\nastropy\/io\/fits\/util.py:                CHUNKED_FROMFILE = True\nastropy\/io\/fits\/util.py:                CHUNKED_FROMFILE = False\nastropy\/io\/fits\/util.py:        if CHUNKED_FROMFILE:\nastropy\/io\/fits\/util.py:    # on a 1-D version of the array; large memory may still be needed in the\nastropy\/io\/fits\/util.py:    # be represented as a contiguous 1-D array in memory).\nastropy\/io\/fits\/util.py:    # Attempt to have the strings as a 1-D array to give the chunk known size.\nastropy\/io\/votable\/ucd.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/ucd.py:This file contains routines to verify the correctness of UCD strings.\nastropy\/io\/votable\/ucd.py:# STDLIB\nastropy\/io\/votable\/ucd.py:class UCDWords:\nastropy\/io\/votable\/ucd.py:    Manages a list of acceptable UCD words.\nastropy\/io\/votable\/ucd.py:        Returns the official English description of the given UCD\nastropy\/io\/votable\/ucd.py:    Parse the UCD into its component parts.\nastropy\/io\/votable\/ucd.py:        The UCD string\nastropy\/io\/votable\/ucd.py:        If `True`, then each word in the UCD will be verified against\nastropy\/io\/votable\/ucd.py:        the UCD1+ controlled vocabulary, (as required by the VOTable\nastropy\/io\/votable\/ucd.py:        If `True`, the UCD may contain a colon (as defined in earlier\nastropy\/io\/votable\/ucd.py:        _ucd_singleton = UCDWords()\nastropy\/io\/votable\/ucd.py:        raise ValueError(\"UCD has invalid character '{}' in '{}'\".format(\nastropy\/io\/votable\/ucd.py:        The UCD string\nastropy\/io\/votable\/ucd.py:        If `True`, then each word in the UCD will be verified against\nastropy\/io\/votable\/ucd.py:        the UCD1+ controlled vocabulary, (as required by the VOTable\nastropy\/io\/votable\/ucd.py:        If `True`, the UCD may contain a colon (as defined in earlier\nastropy\/io\/fits\/tests\/test_division.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_division.py:class TestDivisionFunctions(FitsTestCase):\nastropy\/io\/fits\/tests\/test_division.py:        h = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_nonstandard.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_nonstandard.py:        A round trip test of creating a FitsHDU, adding a FITS file to it,\nastropy\/io\/fits\/tests\/test_nonstandard.py:        writing the FitsHDU out as part of a new FITS file, and then reading\nastropy\/io\/fits\/tests\/test_nonstandard.py:        \"\"\"Regression test on `FitsHDU.fromfile`\"\"\"\nastropy\/io\/fits\/tests\/test_nonstandard.py:        phdu = fits.PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_nonstandard.py:        imghdu = fits.ImageHDU(data=a + 1)\nastropy\/io\/fits\/tests\/test_nonstandard.py:        phdu.header['TEST4'] = 'D'\nastropy\/io\/fits\/tests\/test_nonstandard.py:        hdul = fits.HDUList([phdu, imghdu])\nastropy\/io\/fits\/tests\/test_nonstandard.py:        fitshdu = fits.FitsHDU.fromfile(self.temp('test.fits'))\nastropy\/io\/fits\/tests\/test_nonstandard.py:        assert fits.FITSDiff(hdul, hdul2).identical\nastropy\/io\/fits\/tests\/test_nonstandard.py:        fitshdu = fits.FitsHDU.fromhdulist(hdul_orig, compress=compression)\nastropy\/io\/fits\/tests\/test_nonstandard.py:        assert isinstance(hdul[-1], fits.FitsHDU)\nastropy\/io\/fits\/tests\/test_nonstandard.py:        assert isinstance(wrapped, fits.HDUList)\nastropy\/io\/fits\/__init__.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/__init__.py:# TODO: Make it possible to set these variables via environment variables\nastropy\/io\/fits\/__init__.py:        'If True, use lazy loading of HDUs when opening FITS files by '\nastropy\/io\/fits\/__init__.py:        'default; that is fits.open() will only seek for and read HDUs on '\nastropy\/io\/fits\/__init__.py:        'demand rather than reading all HDUs at once.  See the documentation '\nastropy\/io\/fits\/__init__.py:from .hdu.groups import GroupData\nastropy\/io\/fits\/__init__.py:           ['FITS_record', 'FITS_rec', 'GroupData', 'open', 'Section',\nastropy\/io\/votable\/validator\/result.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/validator\/result.py:# STDLIB\nastropy\/io\/votable\/validator\/result.py:                fd.write('FAILED: {0}\\n'.format(reason).encode('utf-8'))\nastropy\/io\/fits\/diff.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/diff.py:FITS files, individual HDUs, FITS headers, or just FITS data.\nastropy\/io\/fits\/diff.py:from .card import Card, BLANK_CARD\nastropy\/io\/fits\/diff.py:# HDUList is used in one of the doctests\nastropy\/io\/fits\/diff.py:from .hdu.table import _TableLikeHDU\nastropy\/io\/fits\/diff.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/io\/fits\/diff.py:__all__ = ['FITSDiff', 'HDUDiff', 'HeaderDiff', 'ImageDataDiff', 'RawDataDiff',\nastropy\/io\/fits\/diff.py:           'TableDataDiff']\nastropy\/io\/fits\/diff.py:class _BaseDiff:\nastropy\/io\/fits\/diff.py:    Instantiating a ``_BaseDiff`` also causes the diff itself to be executed.\nastropy\/io\/fits\/diff.py:    The returned ``_BaseDiff`` instance has a number of attribute that describe\nastropy\/io\/fits\/diff.py:    The most basic attribute, present on all ``_BaseDiff`` instances, is\nastropy\/io\/fits\/diff.py:        The ``_BaseDiff`` class does not implement a ``_diff`` method and\nastropy\/io\/fits\/diff.py:        appropriate subclass of ``_BaseDiff`` for the objects being compared\nastropy\/io\/fits\/diff.py:        (for example, use `HeaderDiff` to compare two `Header` objects.\nastropy\/io\/fits\/diff.py:        A ``_BaseDiff`` object acts as `True` in a boolean context if the two\nastropy\/io\/fits\/diff.py:        Returns a new Diff object of a specific subclass from an existing diff\nastropy\/io\/fits\/diff.py:            >>> hdul1, hdul2 = fits.HDUList(), fits.HDUList()\nastropy\/io\/fits\/diff.py:            >>> fd = fits.FITSDiff(hdul1, hdul2, ignore_keywords=['*'])\nastropy\/io\/fits\/diff.py:            >>> hd = fits.HeaderDiff.fromdiff(fd, headera, headerb)\nastropy\/io\/fits\/diff.py:        # The first 3 arguments of any Diff initializer are self, a, and b.\nastropy\/io\/fits\/diff.py:        Any subclass of ``_BaseDiff`` must have at least one ``.diff_*``\nastropy\/io\/fits\/diff.py:            ``OSError`` if ``False`` and the output file exists. Default is\nastropy\/io\/fits\/diff.py:class FITSDiff(_BaseDiff):\nastropy\/io\/fits\/diff.py:    \"\"\"Diff two FITS files by filename, or two `HDUList` objects.\nastropy\/io\/fits\/diff.py:    `FITSDiff` objects have the following diff attributes:\nastropy\/io\/fits\/diff.py:      numbers of HDUs, this contains a 2-tuple of the number of HDUs in each\nastropy\/io\/fits\/diff.py:    - ``diff_hdus``: If any HDUs with the same index are different, this\nastropy\/io\/fits\/diff.py:      contains a list of 2-tuples of the HDU index and the `HDUDiff` object\nastropy\/io\/fits\/diff.py:      representing the differences between the two HDUs.\nastropy\/io\/fits\/diff.py:        a : str or `HDUList`\nastropy\/io\/fits\/diff.py:            The filename of a FITS file on disk, or an `HDUList` object.\nastropy\/io\/fits\/diff.py:        b : str or `HDUList`\nastropy\/io\/fits\/diff.py:            The filename of a FITS file on disk, or an `HDUList` object to\nastropy\/io\/fits\/diff.py:            The number of pixel\/table values to output when reporting HDU data\nastropy\/io\/fits\/diff.py:                AstropyDeprecationWarning)\nastropy\/io\/fits\/diff.py:        # TODO: Somehow or another simplify the passing around of diff\nastropy\/io\/fits\/diff.py:            hdu_diff = HDUDiff.fromdiff(self, self.a[idx], self.b[idx])\nastropy\/io\/fits\/diff.py:            self._writeln('Files contain different numbers of HDUs:')\nastropy\/io\/fits\/diff.py:                self._writeln('No differences found between common HDUs.')\nastropy\/io\/fits\/diff.py:                self._writeln('Primary HDU:')\nastropy\/io\/fits\/diff.py:                self._writeln('Extension HDU {}:'.format(idx))\nastropy\/io\/fits\/diff.py:class HDUDiff(_BaseDiff):\nastropy\/io\/fits\/diff.py:    Diff two HDU objects, including their headers and their data (but only if\nastropy\/io\/fits\/diff.py:    both HDUs contain the same type of data (image, table, or unknown).\nastropy\/io\/fits\/diff.py:    `HDUDiff` objects have the following diff attributes:\nastropy\/io\/fits\/diff.py:    - ``diff_extnames``: If the two HDUs have different EXTNAME values, this\nastropy\/io\/fits\/diff.py:    - ``diff_extvers``: If the two HDUS have different EXTVER values, this\nastropy\/io\/fits\/diff.py:    - ``diff_extlevels``: If the two HDUs have different EXTLEVEL values, this\nastropy\/io\/fits\/diff.py:    - ``diff_extension_types``: If the two HDUs have different XTENSION values,\nastropy\/io\/fits\/diff.py:    - ``diff_headers``: Contains a `HeaderDiff` object for the headers of the\nastropy\/io\/fits\/diff.py:      two HDUs. This will always contain an object--it may be determined\nastropy\/io\/fits\/diff.py:    - ``diff_data``: Contains either a `ImageDataDiff`, `TableDataDiff`, or\nastropy\/io\/fits\/diff.py:      `RawDataDiff` as appropriate for the data in the HDUs, and only if the\nastropy\/io\/fits\/diff.py:      two HDUs have non-empty data of the same type (`RawDataDiff` is used for\nastropy\/io\/fits\/diff.py:      HDUs containing non-empty data of an indeterminate type).\nastropy\/io\/fits\/diff.py:        See `FITSDiff` for explanations of the initialization parameters.\nastropy\/io\/fits\/diff.py:                AstropyDeprecationWarning)\nastropy\/io\/fits\/diff.py:        self.diff_headers = HeaderDiff.fromdiff(self, self.a.header.copy(),\nastropy\/io\/fits\/diff.py:            # TODO: Perhaps have some means of marking this case\nastropy\/io\/fits\/diff.py:            self.diff_data = ImageDataDiff.fromdiff(self, self.a.data,\nastropy\/io\/fits\/diff.py:        elif (isinstance(self.a, _TableLikeHDU) and\nastropy\/io\/fits\/diff.py:              isinstance(self.b, _TableLikeHDU)):\nastropy\/io\/fits\/diff.py:            # TODO: Replace this if\/when _BaseHDU grows a .is_table property\nastropy\/io\/fits\/diff.py:            self.diff_data = TableDataDiff.fromdiff(self, self.a.data,\nastropy\/io\/fits\/diff.py:            # Don't diff the data for unequal extension types that are not\nastropy\/io\/fits\/diff.py:            self.diff_data = RawDataDiff.fromdiff(self, self.a.data,\nastropy\/io\/fits\/diff.py:            self._writeln(\" Data contains differences:\")\nastropy\/io\/fits\/diff.py:class HeaderDiff(_BaseDiff):\nastropy\/io\/fits\/diff.py:    Diff two `Header` objects.\nastropy\/io\/fits\/diff.py:    `HeaderDiff` objects have the following diff attributes:\nastropy\/io\/fits\/diff.py:    `HeaderDiff` objects also have a ``common_keywords`` attribute that lists\nastropy\/io\/fits\/diff.py:        See `FITSDiff` for explanations of the initialization parameters.\nastropy\/io\/fits\/diff.py:                AstropyDeprecationWarning)\nastropy\/io\/fits\/diff.py:        # TODO: Implement this\nastropy\/io\/fits\/diff.py:            raise TypeError('HeaderDiff can only diff astropy.io.fits.Header '\nastropy\/io\/fits\/diff.py:    # TODO: This doesn't pay much attention to the *order* of the keywords,\nastropy\/io\/fits\/diff.py:            cardsa = [c for c in self.a.cards if str(c) != BLANK_CARD]\nastropy\/io\/fits\/diff.py:            cardsb = [c for c in self.b.cards if str(c) != BLANK_CARD]\nastropy\/io\/fits\/diff.py:        # TODO: HIERARCH keywords should be handled case-sensitively I think\nastropy\/io\/fits\/diff.py:# TODO: It might be good if there was also a threshold option for percentage of\nastropy\/io\/fits\/diff.py:class ImageDataDiff(_BaseDiff):\nastropy\/io\/fits\/diff.py:    Diff two image data arrays (really any array from a PRIMARY HDU or an IMAGE\nastropy\/io\/fits\/diff.py:    extension HDU, though the data unit is assumed to be \"pixels\").\nastropy\/io\/fits\/diff.py:    `ImageDataDiff` objects have the following diff attributes:\nastropy\/io\/fits\/diff.py:        See `FITSDiff` for explanations of the initialization parameters.\nastropy\/io\/fits\/diff.py:                AstropyDeprecationWarning)\nastropy\/io\/fits\/diff.py:            # Don't do any further comparison if the dimensions differ\nastropy\/io\/fits\/diff.py:            # TODO: Perhaps we could, however, diff just the intersection\nastropy\/io\/fits\/diff.py:            self._writeln(' Data dimensions differ:')\nastropy\/io\/fits\/diff.py:            self._writeln(' Data differs at {}:'.format(index))\nastropy\/io\/fits\/diff.py:class RawDataDiff(ImageDataDiff):\nastropy\/io\/fits\/diff.py:    `RawDataDiff` is just a special case of `ImageDataDiff` where the images\nastropy\/io\/fits\/diff.py:    non-standard extension HDUs that were not recognized as containing image or\nastropy\/io\/fits\/diff.py:    `ImageDataDiff` objects have the following diff attributes:\nastropy\/io\/fits\/diff.py:      `ImageDataDiff` objects. Though the \"dimension\" of each array is just an\nastropy\/io\/fits\/diff.py:    - ``diff_bytes``: Like the ``diff_pixels`` attribute of `ImageDataDiff`\nastropy\/io\/fits\/diff.py:    - ``diff_total`` and ``diff_ratio``: Same as `ImageDataDiff`.\nastropy\/io\/fits\/diff.py:        See `FITSDiff` for explanations of the initialization parameters.\nastropy\/io\/fits\/diff.py:            self._writeln(' Data sizes differ:')\nastropy\/io\/fits\/diff.py:            self._writeln(' Data differs at byte {}:'.format(index))\nastropy\/io\/fits\/diff.py:class TableDataDiff(_BaseDiff):\nastropy\/io\/fits\/diff.py:    Diff two table data arrays. It doesn't matter whether the data originally\nastropy\/io\/fits\/diff.py:    `TableDataDiff` objects have the following diff attributes:\nastropy\/io\/fits\/diff.py:      have different secondary attributes, such as TUNIT or TDISP.  The format\nastropy\/io\/fits\/diff.py:    - ``diff_values``: `TableDataDiff` compares the data in each table on a\nastropy\/io\/fits\/diff.py:      attribute on `ImageDataDiff` objects, though the \"index\" consists of a\nastropy\/io\/fits\/diff.py:    - ``diff_total`` and ``diff_ratio``: Same as `ImageDataDiff`.\nastropy\/io\/fits\/diff.py:    `TableDataDiff` objects also have a ``common_columns`` attribute that lists\nastropy\/io\/fits\/diff.py:        See `FITSDiff` for explanations of the initialization parameters.\nastropy\/io\/fits\/diff.py:                AstropyDeprecationWarning)\nastropy\/io\/fits\/diff.py:        # TODO: It might be nice to optionally compare the first n rows where n\nastropy\/io\/fits\/diff.py:                    # Don't save any more diff values\nastropy\/io\/fits\/diff.py:    Diff two scalar values.  If both values are floats they are compared to\nastropy\/io\/fits\/tests\/test_fitsdiff.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_fitsdiff.py:from ..hdu import PrimaryHDU\nastropy\/io\/fits\/tests\/test_fitsdiff.py:from ....utils.exceptions import AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_fitsdiff.py:class TestFITSDiff_script(FitsTestCase):\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:            '     Data differs at [1, 2]:',\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:Primary HDU:\\n\\n   Data contains differences:\nastropy\/io\/fits\/tests\/test_fitsdiff.py:     Data differs at [1, 2]:\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        with catch_warnings(AstropyDeprecationWarning) as warning_lines:\nastropy\/io\/fits\/tests\/test_fitsdiff.py:            assert warning_lines[0].category == AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitscheck.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_fitscheck.py:            hdul[0].header['DATASUM'] = '1       '\nastropy\/io\/fits\/tests\/test_fitscheck.py:            hdul[1].header['DATASUM'] = '2349680925'\nastropy\/io\/fits\/tests\/test_fitscheck.py:            hdul[1].header['CHECKSUM'] = '11daD8bX98baA8bU'\nastropy\/io\/fits\/tests\/test_fitscheck.py:        assert 'BAD' in stderr\nastropy\/io\/fits\/tests\/test_fitscheck.py:        assert 'BAD' in stderr\nastropy\/io\/fits\/tests\/test_structured.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_convenience.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_convenience.py:        assert isinstance(hdu, fits.BinTableHDU)\nastropy\/io\/fits\/tests\/test_convenience.py:        hdus = [fits.PrimaryHDU(np.zeros((10, 10))),\nastropy\/io\/fits\/tests\/test_convenience.py:                fits.ImageHDU(np.zeros((10, 10)))]\nastropy\/io\/fits\/tests\/test_convenience.py:        fits.HDUList(hdus).writeto(filename)\nastropy\/io\/fits\/tests\/test_convenience.py:        Test that FITSDiff can run the different inputs without crashing.\nastropy\/io\/fits\/tests\/test_convenience.py:        # Test HDU object inputs\nastropy\/io\/fits\/header.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/header.py:from .card import Card, _pad, KEYWORD_LENGTH\nastropy\/io\/fits\/header.py:# This regular expression can match a *valid* END card which just consists of\nastropy\/io\/fits\/header.py:# the string 'END' followed by all spaces, or an *invalid* end card which\nastropy\/io\/fits\/header.py:# consists of END, followed by any character that is *not* a valid character\nastropy\/io\/fits\/header.py:# for a valid FITS keyword (that is, this is not a keyword like 'ENDER' which\nastropy\/io\/fits\/header.py:# starts with 'END' but is not 'END'), followed by any arbitrary bytes.  An\nastropy\/io\/fits\/header.py:# invalid end card may also consist of just 'END' with no trailing bytes.\nastropy\/io\/fits\/header.py:HEADER_END_RE = re.compile(encode_ascii(\nastropy\/io\/fits\/header.py:    r'(?:(?P<valid>END {77}) *)|(?P<invalid>END$|END {0,76}[^A-Z0-9_-])'))\nastropy\/io\/fits\/header.py:VALID_HEADER_CHARS = set(map(chr, range(0x20, 0x7F)))\nastropy\/io\/fits\/header.py:END_CARD = 'END' + ' ' * 77\nastropy\/io\/fits\/header.py:            Default is ``False``.\nastropy\/io\/fits\/header.py:        Creates an HDU header from a byte string containing the entire header\nastropy\/io\/fits\/header.py:        require_full_cardlength = set(sep).issubset(VALID_HEADER_CHARS)\nastropy\/io\/fits\/header.py:                if next_image == END_CARD:\nastropy\/io\/fits\/header.py:                if next_image.split(sep)[0].rstrip() == 'END':\nastropy\/io\/fits\/header.py:            If True (the default) the header must end with an END card in order\nastropy\/io\/fits\/header.py:            to be considered valid.  If an END card is not found an\nastropy\/io\/fits\/header.py:        handling.  Also used by `_BaseHDU.fromstring`.\nastropy\/io\/fits\/header.py:            # TODO: There needs to be error handling at *this* level for\nastropy\/io\/fits\/header.py:        # continue reading header blocks until END card or EOF is reached\nastropy\/io\/fits\/header.py:            # find the END card\nastropy\/io\/fits\/header.py:            # TODO: Pass this error to validation framework as an ERROR,\nastropy\/io\/fits\/header.py:            raise OSError('Header missing END card.')\nastropy\/io\/fits\/header.py:                # TODO: Pass this warning to validation framework\nastropy\/io\/fits\/header.py:                # TODO: Pass this warning to validation framework\nastropy\/io\/fits\/header.py:            # TODO: Pass this error to validation framework\nastropy\/io\/fits\/header.py:        Utility method to search a header block for the END card and handle\nastropy\/io\/fits\/header.py:        invalid END cards.\nastropy\/io\/fits\/header.py:        for mo in HEADER_END_RE.finditer(block):\nastropy\/io\/fits\/header.py:            # Ensure the END card was found, and it started on the\nastropy\/io\/fits\/header.py:                    # TODO: Pass this warning up to the validation framework\nastropy\/io\/fits\/header.py:                        'Unexpected bytes trailing END keyword: {0}; these '\nastropy\/io\/fits\/header.py:                    # TODO: Pass this warning up to the validation framework\nastropy\/io\/fits\/header.py:                        'END keyword; additional spaces will be appended to '\nastropy\/io\/fits\/header.py:                # Sanitize out invalid END card now that the appropriate\nastropy\/io\/fits\/header.py:                block = (block[:offset] + encode_ascii(END_CARD) +\nastropy\/io\/fits\/header.py:                         block[offset + len(END_CARD):])\nastropy\/io\/fits\/header.py:        By default this uses no separator between cards, adds the END card, and\nastropy\/io\/fits\/header.py:            If True (default) adds the END card to the end of the header\nastropy\/io\/fits\/header.py:            s += sep + _pad('END')\nastropy\/io\/fits\/header.py:        FITS file, with the END card included and padding to the next multiple\nastropy\/io\/fits\/header.py:            If `True` (default) adds the END card to the end of the header\nastropy\/io\/fits\/header.py:            ``OSError`` if ``False`` and the output file exists. Default is\nastropy\/io\/fits\/header.py:           standard HDU types, so that this header can be used in a different\nastropy\/io\/fits\/header.py:           HDU.\nastropy\/io\/fits\/header.py:        # Don't try to make a temporary card though if they keyword looks like\nastropy\/io\/fits\/header.py:        if (len(keyword) <= KEYWORD_LENGTH and\nastropy\/io\/fits\/header.py:                # Don't do this unless there is at least one blanks at the end\nastropy\/io\/fits\/header.py:            HDUs, so that only more general keywords are added from extension\nastropy\/io\/fits\/header.py:                        # Dumbly update the first keyword to either SIMPLE or\nastropy\/io\/fits\/header.py:            rather than before it.  Defaults to `False`.\nastropy\/io\/fits\/header.py:            # Don't pass through ints to _cardindex because it will not take\nastropy\/io\/fits\/header.py:            if len(keyword) > KEYWORD_LENGTH or '.' in keyword:\nastropy\/io\/fits\/header.py:        maxlen = Card.length - KEYWORD_LENGTH\nastropy\/io\/fits\/header.py:        # TODO: Previously this only deleted some cards specific to an HDU if\nastropy\/io\/fits\/header.py:        # a way for HDU classes to specify some headers that are specific only\nastropy\/io\/fits\/header.py:        if 'TFIELDS' in self:\nastropy\/io\/fits\/header.py:            tfields = self['TFIELDS']\nastropy\/io\/fits\/header.py:                     'TUNIT', 'TDISP', 'TDIM', 'THEAP', 'TBCOL'):\nastropy\/io\/fits\/header.py:        for name in ('SIMPLE', 'XTENSION', 'BITPIX', 'NAXIS', 'EXTEND',\nastropy\/io\/fits\/header.py:                     'TFIELDS'):\nastropy\/io\/fits\/header.py:    # TODO: Consider giving this dict\/list methods like Header itself\nastropy\/io\/fits\/header.py:        keyword_length = KEYWORD_LENGTH\nastropy\/io\/fits\/header.py:    Determine the size of a FITS header block if a non-blank separator is used\nastropy\/io\/fits\/tests\/test_fitstime.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_fitstime.py:from ....time import Time, TimeDelta\nastropy\/io\/fits\/tests\/test_fitstime.py:from ....time.formats import FITS_DEPRECATED_SCALES\nastropy\/io\/fits\/tests\/test_fitstime.py:        t.meta['DATE'] = '1999-01-01T00:00:00'\nastropy\/io\/fits\/tests\/test_fitstime.py:        t.meta['MJD-OBS'] = 56670\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Test DATE\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert isinstance(tm.meta['DATE'], Time)\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['DATE'].value == t.meta['DATE'] + '(UTC)'\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['DATE'].format == 'fits'\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Default time scale according to the FITS standard is UTC\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['DATE'].scale == 'utc'\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Test MJD-xxx\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert isinstance(tm.meta['MJD-OBS'], Time)\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['MJD-OBS'].value == t.meta['MJD-OBS']\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['MJD-OBS'].format == 'mjd'\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['MJD-OBS'].scale == 'utc'\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Test DATE\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert isinstance(tm.meta['DATE'], Time)\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['DATE'].value == t.meta['DATE'] + '(UTC)'\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['DATE'].scale == 'utc'\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Test MJD-xxx\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert isinstance(tm.meta['MJD-OBS'], Time)\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['MJD-OBS'].value == t.meta['MJD-OBS']\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['MJD-OBS'].scale == FITS_DEPRECATED_SCALES[t.meta['TIMESYS']]\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Test DATE\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert not isinstance(tm.meta['DATE'], Time)\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['DATE'] == t.meta['DATE']\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Test MJD-xxx\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert not isinstance(tm.meta['MJD-OBS'], Time)\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['MJD-OBS'] == t.meta['MJD-OBS']\nastropy\/io\/fits\/tests\/test_fitstime.py:        ref_time = Time(non_native.meta['MJDREF'], format='mjd',\nastropy\/io\/fits\/tests\/test_fitstime.py:        delta_time = TimeDelta(non_native['time'])\nastropy\/io\/fits\/tests\/test_fitstime.py:        Test that ISO-8601 Datetime String Columns are read correctly.\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Datetime column\nastropy\/io\/fits\/tests\/test_fitstime.py:        bhdu = fits.BinTableHDU.from_columns([c])\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Datetime column\nastropy\/io\/fits\/tests\/test_fitstime.py:        bhdu = fits.BinTableHDU.from_columns([c], header=fits.Header(cards))\nastropy\/io\/fits\/tests\/test_fitstime.py:        bhdu = fits.BinTableHDU.from_columns([c], header=fits.Header(cards))\nastropy\/io\/fits\/tests\/test_fitstime.py:        c = fits.Column(name='gps_time', format='D', unit='s', coord_type='GPS',\nastropy\/io\/fits\/tests\/test_fitstime.py:        bhdu = fits.BinTableHDU.from_columns([c], header=fits.Header(cards))\nastropy\/io\/fits\/tests\/test_fitstime.py:        c = fits.Column(name='local_time', format='D', unit='d',\nastropy\/io\/fits\/tests\/test_fitstime.py:        bhdu = fits.BinTableHDU.from_columns([c])\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Default scale is UTC\nastropy\/io\/fits\/tests\/test_fitstime.py:        bhdu = fits.BinTableHDU.from_columns([c])\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Default value for time reference position is \"TOPOCENTER\"\nastropy\/io\/fits\/tests\/test_fitstime.py:        bhdu = fits.BinTableHDU.from_columns([c])\nastropy\/io\/fits\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/__init__.py:        # TODO: Replace this when there's a better way to in the config API to\nastropy\/io\/fits\/tests\/__init__.py:        os.chmod(self.temp(filename), stat.S_IREAD | stat.S_IWRITE)\nastropy\/io\/fits\/tests\/test_connect.py:from .. import HDUList, PrimaryHDU, BinTableHDU\nastropy\/io\/fits\/tests\/test_connect.py:from ....time import Time, TimeDelta\nastropy\/io\/fits\/tests\/test_connect.py:DATA = os.path.join(os.path.dirname(__file__), 'data')\nastropy\/io\/fits\/tests\/test_connect.py:        # Disabled for now, as there is no obvious way to handle masking of\nastropy\/io\/fits\/tests\/test_connect.py:        # TODO: Re-enable these tests if some workaround for this can be found\nastropy\/io\/fits\/tests\/test_connect.py:        hdu = BinTableHDU(self.data)\nastropy\/io\/fits\/tests\/test_connect.py:        hdu = BinTableHDU(self.data)\nastropy\/io\/fits\/tests\/test_connect.py:        hdu.columns[0].unit = 'RADIANS'\nastropy\/io\/fits\/tests\/test_connect.py:class TestMultipleHDU:\nastropy\/io\/fits\/tests\/test_connect.py:        hdu1 = PrimaryHDU()\nastropy\/io\/fits\/tests\/test_connect.py:        hdu2 = BinTableHDU(self.data1, name='first')\nastropy\/io\/fits\/tests\/test_connect.py:        hdu3 = BinTableHDU(self.data2, name='second')\nastropy\/io\/fits\/tests\/test_connect.py:        self.hdus = HDUList([hdu1, hdu2, hdu3])\nastropy\/io\/fits\/tests\/test_connect.py:    t = Table.read(os.path.join(DATA, 'tb.fits'))\nastropy\/io\/fits\/tests\/test_connect.py:    filename = os.path.join(DATA, 'stddata.fits')\nastropy\/io\/fits\/tests\/test_connect.py:        # Mixin info.meta can None instead of empty OrderedDict(), #6720 would\nastropy\/io\/fits\/tests\/test_connect.py:    'dt': TimeDelta([1, 2] * u.day),\nastropy\/io\/fits\/tests\/test_connect.py:            # Downgrade Quantity to Column + unit\nastropy\/io\/votable\/validator\/main.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/validator\/main.py:# STDLIB\nastropy\/io\/votable\/validator\/main.py:    Downloads of each given URL will be performed only once and cached\nastropy\/io\/votable\/validator\/main.py:    color_print('Downloading VO files', 'green')\nastropy\/io\/fits\/tests\/test_core.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_core.py:from ..diff import FITSDiff\nastropy\/io\/fits\/tests\/test_core.py:        p = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_core.py:        l = fits.HDUList()\nastropy\/io\/fits\/tests\/test_core.py:        t = fits.BinTableHDU.from_columns([c])\nastropy\/io\/fits\/tests\/test_core.py:        assert FITSDiff(hdulist2, hdulist).identical is True\nastropy\/io\/fits\/tests\/test_core.py:        p = fits.ColDefs([])\nastropy\/io\/fits\/tests\/test_core.py:            # TODO: The warning raised by this test is actually indication of a\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        class TestHDU(fits.hdu.base.NonstandardExtHDU):\nastropy\/io\/fits\/tests\/test_core.py:                # Since creating this HDU class adds it to the registry we\nastropy\/io\/fits\/tests\/test_core.py:                # HDU from a file should be handled by this class\nastropy\/io\/fits\/tests\/test_core.py:        hdu = TestHDU(header=fits.Header())\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:            hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        # silentfix+warn should be quiet about the fixed HDU and only warn\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:            hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        Tests creating a fully-formed HDU object from a string containing the\nastropy\/io\/fits\/tests\/test_core.py:        bytes of the HDU.\nastropy\/io\/fits\/tests\/test_core.py:            hdu = fits.PrimaryHDU.fromstring(dat[:hdulen])\nastropy\/io\/fits\/tests\/test_core.py:            assert isinstance(hdu, fits.PrimaryHDU)\nastropy\/io\/fits\/tests\/test_core.py:            assert isinstance(hdu, fits.PrimaryHDU)\nastropy\/io\/fits\/tests\/test_core.py:                hdu = fits.ImageHDU.fromstring(dat[offset:offset + hdulen])\nastropy\/io\/fits\/tests\/test_core.py:                assert isinstance(hdu, fits.ImageHDU)\nastropy\/io\/fits\/tests\/test_core.py:        Tests that \"Nonstandard\" HDUs with SIMPLE = F are read and written\nastropy\/io\/fits\/tests\/test_core.py:        without prepending a superfluous and unwanted standard primary HDU.\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.PrimaryHDU(data=data)\nastropy\/io\/fits\/tests\/test_core.py:        info = [(0, '', 1, 'NonstandardHDU', 5, (), '', '')]\nastropy\/io\/fits\/tests\/test_core.py:            # NonstandardHDUs just treat the data as an unspecified array of\nastropy\/io\/fits\/tests\/test_core.py:        \"\"\"Test getting\/setting the EXTNAME of an HDU.\"\"\"\nastropy\/io\/fits\/tests\/test_core.py:        h1 = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_core.py:        # Normally a PRIMARY HDU should not have an EXTNAME, though it should\nastropy\/io\/fits\/tests\/test_core.py:        # The current version of the FITS standard does allow PRIMARY HDUs to\nastropy\/io\/fits\/tests\/test_core.py:        # If we delete an EXTNAME keyword from a PRIMARY HDU it should go back\nastropy\/io\/fits\/tests\/test_core.py:        # For extension HDUs the situation is a bit simpler:\nastropy\/io\/fits\/tests\/test_core.py:        h2 = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        h2.header['EXTNAME'] = 'GOODBYE'\nastropy\/io\/fits\/tests\/test_core.py:        assert h2.name == 'GOODBYE'\nastropy\/io\/fits\/tests\/test_core.py:        \"\"\"Test getting\/setting the EXTVER and EXTLEVEL of and HDU.\"\"\"\nastropy\/io\/fits\/tests\/test_core.py:        h1 = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_core.py:        HDUList could write a corrupted file.\nastropy\/io\/fits\/tests\/test_core.py:        h = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_core.py:        h = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_core.py:        h = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.PrimaryHDU(data=data)\nastropy\/io\/fits\/tests\/test_core.py:        hdul = [fits.PrimaryHDU(), fits.ImageHDU()]\nastropy\/io\/fits\/tests\/test_core.py:        hdul = fits.HDUList(hdul)\nastropy\/io\/fits\/tests\/test_core.py:        hdul.insert(1, fits.ImageHDU())\nastropy\/io\/fits\/tests\/test_core.py:                pytest.raises(ValueError, fits.HDUList.fromfile, f)\nastropy\/io\/fits\/tests\/test_core.py:            with fits.HDUList.fromfile(f) as h:\nastropy\/io\/fits\/tests\/test_core.py:                with fits.HDUList.fromfile(f) as h:\nastropy\/io\/fits\/tests\/test_core.py:            with fits.HDUList.fromfile(f) as h:\nastropy\/io\/fits\/tests\/test_core.py:                # are no HDUs\nastropy\/io\/fits\/tests\/test_core.py:            with fits.HDUList.fromfile(f) as h:\nastropy\/io\/fits\/tests\/test_core.py:            with fits.HDUList.fromfile(f) as h:\nastropy\/io\/fits\/tests\/test_core.py:            # Double check that writing without mmap still worked\nastropy\/io\/fits\/tests\/test_core.py:        HDU data references left.\nastropy\/io\/fits\/tests\/test_core.py:        # The HDUList is closed; in fact, get rid of it completely\nastropy\/io\/fits\/tests\/test_core.py:        Demonstrates that FITS files can still be read from \"file-like\" objects\nastropy\/io\/fits\/tests\/test_core.py:        Demonstrates that writing an HDU containing a discontiguous Numpy array\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.PrimaryHDU(data=data)\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.PrimaryHDU(data=np.arange(10))\nastropy\/io\/fits\/tests\/test_core.py:            monkeypatch.setattr(fits.hdu.base._BaseHDU, \"_writeto\", _writeto)\nastropy\/io\/fits\/tests\/test_core.py:            hdu = fits.PrimaryHDU(n)\nastropy\/io\/fits\/tests\/test_core.py:            hdulist = fits.HDUList(hdu)\nastropy\/io\/fits\/tests\/test_core.py:        hdul = [fits.PrimaryHDU(), fits.ImageHDU()]\nastropy\/io\/fits\/tests\/test_core.py:        hdul = fits.HDUList(hdul)\nastropy\/io\/fits\/tests\/test_core.py:        monkeypatch.setattr(fits.hdu.base._BaseHDU, \"_writedata\", _writedata)\nastropy\/io\/fits\/tests\/test_core.py:                hdul.insert(1, fits.ImageHDU())\nastropy\/io\/fits\/tests\/test_core.py:            hdul2 = fits.HDUList.fromstring(fileobj.getvalue())\nastropy\/io\/fits\/tests\/test_core.py:            assert FITSDiff(hdul, hdul2).identical\nastropy\/io\/fits\/tests\/test_core.py:    \"\"\"Test functionality of the StreamingHDU class.\"\"\"\nastropy\/io\/fits\/tests\/test_core.py:        Test that streaming an HDU to a file opened in the wrong mode fails as\nastropy\/io\/fits\/tests\/test_core.py:            fits.StreamingHDU(f, header)\nastropy\/io\/fits\/tests\/test_core.py:        \"\"\"Test streaming an HDU to an open file object.\"\"\"\nastropy\/io\/fits\/tests\/test_core.py:        \"\"\"Test streaming an HDU to an open file-like object.\"\"\"\nastropy\/io\/fits\/tests\/test_core.py:        # The file-like object underlying a StreamingHDU must be in binary mode\nastropy\/io\/fits\/tests\/test_core.py:        # Doing this again should update the file with an extension\nastropy\/io\/fits\/tests\/test_core.py:        phdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_core.py:        ihdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        hdul = fits.HDUList([phdu, ihdu])\nastropy\/io\/fits\/tests\/test_core.py:        hd['EXTEND'] = True\nastropy\/io\/fits\/tests\/test_core.py:        return fits.StreamingHDU(fileobj, hd)\nastropy\/io\/fits\/tests\/test_uint.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_uint.py:                hdu = fits.CompImageHDU(np.array([-3, -2, -1, 0, 1, 2, 3], dtype=np.int64))\nastropy\/io\/fits\/tests\/test_uint.py:                hdu = fits.PrimaryHDU(np.array([-3, -2, -1, 0, 1, 2, 3], dtype=np.int64))\nastropy\/io\/fits\/tests\/test_uint.py:                        # TODO: Enable these lines if CompImageHDUs ever grow\nastropy\/io\/fits\/tests\/test_uint.py:            table = fits.BinTableHDU.from_columns([col])\nastropy\/io\/fits\/tests\/test_uint.py:            # a BinTableHDU it gets stored as a view of the original table,\nastropy\/io\/fits\/tests\/test_uint.py:            hdu0 = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_uint.py:            hdulist = fits.HDUList([hdu0, table])\nastropy\/io\/votable\/validator\/html.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/validator\/html.py:# STDLIB\nastropy\/io\/votable\/validator\/html.py:<!DOCTYPE html\nastropy\/io\/votable\/validator\/html.py:        PUBLIC \"-\/\/W3C\/\/DTD XHTML Basic 1.0\/\/EN\"\nastropy\/io\/votable\/validator\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_image.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_image.py:from ....utils.exceptions import AstropyPendingDeprecationWarning\nastropy\/io\/fits\/tests\/test_image.py:from ..hdu.compressed import SUBTRACTIVE_DITHER_1, DITHER_SEED_CHECKSUM\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(name='FOO')\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(header=hdr, name='FOO')\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(ver=2)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(header=hdr, ver=4)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(header=hdr, ver=None)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(header=hdr)\nastropy\/io\/fits\/tests\/test_image.py:        Ensure that a header from one HDU is copied when used to initialize new\nastropy\/io\/fits\/tests\/test_image.py:        HDU.\nastropy\/io\/fits\/tests\/test_image.py:        ifd = fits.HDUList(fits.PrimaryHDU())\nastropy\/io\/fits\/tests\/test_image.py:        primary_hdu = fits.PrimaryHDU(header=phdr)\nastropy\/io\/fits\/tests\/test_image.py:        ofd = fits.HDUList(primary_hdu)\nastropy\/io\/fits\/tests\/test_image.py:        # The function \"open\" reads a FITS file into an HDUList object.  There\nastropy\/io\/fits\/tests\/test_image.py:        # data parts are latent instantiation, so if we close the HDUList\nastropy\/io\/fits\/tests\/test_image.py:        assert str(exc_info.value) == ('HDU not found, possibly because the index '\nastropy\/io\/fits\/tests\/test_image.py:                                       'closed before all HDUs were read')\nastropy\/io\/fits\/tests\/test_image.py:        info = ([(0, 'PRIMARY', 1, 'PrimaryHDU', 138, (), '', '')] +\nastropy\/io\/fits\/tests\/test_image.py:                [(x, 'SCI', x, 'ImageHDU', 61, (40, 40), 'int16', '')\nastropy\/io\/fits\/tests\/test_image.py:        # Test that HDUs cannot be accessed after the file was closed\nastropy\/io\/fits\/tests\/test_image.py:        assert str(exc_info.value) == ('HDU not found, possibly because the index '\nastropy\/io\/fits\/tests\/test_image.py:                                       'closed before all HDUs were read')\nastropy\/io\/fits\/tests\/test_image.py:        # Test that HDUs can be accessed with lazy_load_hdus=False\nastropy\/io\/fits\/tests\/test_image.py:        assert isinstance(r[1], fits.ImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:            assert isinstance(r[1], fits.ImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:        Tests that the EXTNAME keyword works with Primary HDUs as well, and\nastropy\/io\/fits\/tests\/test_image.py:        hdulist['PRIMARY'] will still refer to the first HDU even if it has an\nastropy\/io\/fits\/tests\/test_image.py:        hdul = fits.HDUList([fits.PrimaryHDU(header=prihdr)])\nastropy\/io\/fits\/tests\/test_image.py:        info = [(0, 'XPRIMARY', 1, 'PrimaryHDU', 5, (), '', '')]\nastropy\/io\/fits\/tests\/test_image.py:                # The flush method will write the current HDUList object back\nastropy\/io\/fits\/tests\/test_image.py:                # to the newly created file on disk.  The HDUList is still open\nastropy\/io\/fits\/tests\/test_image.py:                # extension(s) since last flush() will be appended, but any HDU\nastropy\/io\/fits\/tests\/test_image.py:            # readonly mode, the HDU's will be read into the HDUList which can\nastropy\/io\/fits\/tests\/test_image.py:            # file.  A file opened with append mode can only add new HDU's.\nastropy\/io\/fits\/tests\/test_image.py:            # When changes are made to an HDUList which was opened with\nastropy\/io\/fits\/tests\/test_image.py:                # original (or since last flush) HDUList, the changes are\nastropy\/io\/fits\/tests\/test_image.py:                # deleting HDU(s), header was expanded or reduced beyond\nastropy\/io\/fits\/tests\/test_image.py:                # change the data size, the HDUList is written to a temporary\nastropy\/io\/fits\/tests\/test_image.py:                # the write method in HDUList class writes the current HDUList,\nastropy\/io\/fits\/tests\/test_image.py:                # works the same disregard the mode the HDUList was opened\nastropy\/io\/fits\/tests\/test_image.py:        # Another useful new HDUList method is readall.  It will \"touch\" the\nastropy\/io\/fits\/tests\/test_image.py:        # data parts in all HDUs, so even if the HDUList is closed, we can\nastropy\/io\/fits\/tests\/test_image.py:        # create an HDU with data only\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(data=data, name='SCI')\nastropy\/io\/fits\/tests\/test_image.py:        # create an HDU with header and data\nastropy\/io\/fits\/tests\/test_image.py:        # with ImageHDU\nastropy\/io\/fits\/tests\/test_image.py:        hdu2 = fits.ImageHDU(header=r[1].header, data=np.array([1, 2],\nastropy\/io\/fits\/tests\/test_image.py:        # make a defect HDUList first\nastropy\/io\/fits\/tests\/test_image.py:        x = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.HDUList(x)  # HDUList can take a list or one single HDU\nastropy\/io\/fits\/tests\/test_image.py:        text = \"HDUList's 0th element is not a primary HDU.\"\nastropy\/io\/fits\/tests\/test_image.py:        text = (\"HDUList's 0th element is not a primary HDU.  \"\nastropy\/io\/fits\/tests\/test_image.py:                \"Fixed by inserting one as 0th HDU.\")\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(a)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(a)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(a)\nastropy\/io\/fits\/tests\/test_image.py:        # TODO: Generate these perumtions instead of having them all written\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(a)\nastropy\/io\/fits\/tests\/test_image.py:        hdu1 = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_image.py:        hdu2 = fits.ImageHDU(np.random.rand(100,100))\nastropy\/io\/fits\/tests\/test_image.py:        This ensures that an HDU containing unsigned integer data always has\nastropy\/io\/fits\/tests\/test_image.py:            uint_hdu = fits.PrimaryHDU(data=arr)\nastropy\/io\/fits\/tests\/test_image.py:            tmp_uint = fits.PrimaryHDU(arr)\nastropy\/io\/fits\/tests\/test_image.py:            uint_hdu = fits.PrimaryHDU(arr,\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(data=arr)\nastropy\/io\/fits\/tests\/test_image.py:        HDU data.\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(data=arr)\nastropy\/io\/fits\/tests\/test_image.py:            # Allow the HDU to be written, but there should be a warning\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(data=arr)\nastropy\/io\/fits\/tests\/test_image.py:        # TODO: Rewrite this test when scaling with blank support is better\nastropy\/io\/fits\/tests\/test_image.py:        \"\"\"Test use of the BZERO keyword in an image HDU containing float\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(data=arr)\nastropy\/io\/fits\/tests\/test_image.py:        Replacing the original header to an image HDU and saving should update\nastropy\/io\/fits\/tests\/test_image.py:        (Don't update scaled image data if the data is not read)\nastropy\/io\/fits\/tests\/test_image.py:        The scale_back feature for image HDUs.\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(data)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(data=a.copy())\nastropy\/io\/fits\/tests\/test_image.py:        hdul = fits.HDUList.fromstring(file_data)\nastropy\/io\/fits\/tests\/test_image.py:        im = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_image.py:        hdu1 = fits.PrimaryHDU(data=a.copy())\nastropy\/io\/fits\/tests\/test_image.py:        hdu2 = fits.PrimaryHDU(data=a.copy())\nastropy\/io\/fits\/tests\/test_image.py:        fits.PrimaryHDU(a).writeto(self.temp('test.fits'))\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.CompImageHDU()\nastropy\/io\/fits\/tests\/test_image.py:            assert isinstance(hdul[1], fits.CompImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:            assert isinstance(hdul[1], fits.CompImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:        primary_hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_image.py:        ofd = fits.HDUList(primary_hdu)\nastropy\/io\/fits\/tests\/test_image.py:        chdu = fits.CompImageHDU(data, name='SCI',\nastropy\/io\/fits\/tests\/test_image.py:        fits.ImageHDU(data).writeto(self.temp('im1.fits'))\nastropy\/io\/fits\/tests\/test_image.py:        fits.CompImageHDU(data, compression_type='RICE_1', quantize_method=1,\nastropy\/io\/fits\/tests\/test_image.py:        fits.CompImageHDU(data, compression_type='RICE_1', quantize_method=1,\nastropy\/io\/fits\/tests\/test_image.py:    @ignore_warnings(AstropyPendingDeprecationWarning)\nastropy\/io\/fits\/tests\/test_image.py:        not 2D and has a non-2D tile size.\nastropy\/io\/fits\/tests\/test_image.py:        pytest.raises(ValueError, fits.CompImageHDU,\nastropy\/io\/fits\/tests\/test_image.py:    @ignore_warnings(AstropyPendingDeprecationWarning)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.CompImageHDU(data=cube, name='SCI',\nastropy\/io\/fits\/tests\/test_image.py:        SUBTRACTIVE_DITHER_1 quantization method that the correct ZDITHER0 seed\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.CompImageHDU(data=array,\nastropy\/io\/fits\/tests\/test_image.py:                                quantize_method=SUBTRACTIVE_DITHER_1,\nastropy\/io\/fits\/tests\/test_image.py:                                dither_seed=DITHER_SEED_CHECKSUM)\nastropy\/io\/fits\/tests\/test_image.py:            assert isinstance(hdul[1], fits.CompImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:            assert hdul[1]._header['ZQUANTIZ'] == 'SUBTRACTIVE_DITHER_1'\nastropy\/io\/fits\/tests\/test_image.py:            assert 'ZDITHER0' in hdul[1]._header\nastropy\/io\/fits\/tests\/test_image.py:            assert hdul[1]._header['ZDITHER0'] == csum\nastropy\/io\/fits\/tests\/test_image.py:                # The compressed image HDU should show up as a BinTableHDU, but\nastropy\/io\/fits\/tests\/test_image.py:                # *not* a CompImageHDU\nastropy\/io\/fits\/tests\/test_image.py:                assert isinstance(hdul[1], fits.BinTableHDU)\nastropy\/io\/fits\/tests\/test_image.py:                assert not isinstance(hdul[1], fits.CompImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:            assert isinstance(hdul[1], fits.CompImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:            chdu = fits.CompImageHDU(data=hdul[0].data,\nastropy\/io\/fits\/tests\/test_image.py:            chdu = fits.CompImageHDU(data=hdul[0].data,\nastropy\/io\/fits\/tests\/test_image.py:            chdu = fits.CompImageHDU(data=hdul[0].data,\nastropy\/io\/fits\/tests\/test_image.py:        chdu1 = fits.CompImageHDU(data=noise, compressionType='GZIP_1')\nastropy\/io\/fits\/tests\/test_image.py:        chdu2 = fits.CompImageHDU(data=noise, compressionType='GZIP_1',\nastropy\/io\/fits\/tests\/test_image.py:        chdu = fits.CompImageHDU(data1, compressionType='RICE_1',\nastropy\/io\/fits\/tests\/test_image.py:            assert isinstance(hdul[1], fits.CompImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:        structure on CompImageHDU image headers fails.\nastropy\/io\/fits\/tests\/test_image.py:            test_set_keyword(hdr, 'TFIELDS', 8)\nastropy\/io\/fits\/tests\/test_image.py:            test_set_keyword(hdr, 'ZCMPTYPE', 'ASDF')\nastropy\/io\/fits\/tests\/test_image.py:                imghdr.append('TFIELDS')\nastropy\/io\/fits\/tests\/test_image.py:                assert 'TFIELDS' not in imghdr\nastropy\/io\/fits\/tests\/test_image.py:            header.append((\"Q1_OSSTD\", 1, \"[adu] quadrant 1 overscan stddev\"))\nastropy\/io\/fits\/tests\/test_image.py:            header.append((\"Q1_OSMED\", 1, \"[adu] quadrant 1 overscan median\"))\nastropy\/io\/fits\/tests\/test_image.py:                imghdr.insert(1000, 'TFIELDS')\nastropy\/io\/fits\/tests\/test_image.py:                assert 'TFIELDS' not in imghdr\nastropy\/io\/fits\/tests\/test_image.py:                assert tblhdr.count('TFIELDS') == 1\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.CompImageHDU(np.array([0], dtype=np.int32))\nastropy\/io\/fits\/tests\/test_image.py:        # result in use of a GZIP_COMPRESSED_DATA column\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.CompImageHDU(data=arr)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.CompImageHDU(data=arr)\nastropy\/io\/fits\/tests\/test_image.py:        hdu1 = fits.CompImageHDU(data=a.copy())\nastropy\/io\/fits\/tests\/test_image.py:        hdu2 = fits.CompImageHDU(data=a.copy())\nastropy\/io\/fits\/tests\/test_image.py:        fits.CompImageHDU(a).writeto(self.temp('test.fits'))\nastropy\/io\/fits\/tests\/test_image.py:        comp_hdu = fits.CompImageHDU(a)\nastropy\/io\/fits\/tests\/test_image.py:        comp_hdu = fits.CompImageHDU(a)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.CompImageHDU(np.arange(0, 10, dtype=dtype))\nastropy\/io\/fits\/tests\/test_image.py:    that got turned into CompImageHDU to end up with BZERO\/BSCALE before the\nastropy\/io\/fits\/tests\/test_image.py:    TFIELDS.\nastropy\/io\/fits\/tests\/test_image.py:    x0 = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_image.py:    x1 = fits.ImageHDU(np.array(x-50, dtype=int), uint=True)\nastropy\/io\/fits\/tests\/test_image.py:    hdus = fits.HDUList([x0, x1])\nastropy\/io\/fits\/tests\/test_image.py:    # first HDU.\nastropy\/io\/fits\/tests\/test_image.py:    hdus[1] = fits.CompImageHDU(data=hdus[1].data.astype(np.uint32),\nastropy\/io\/fits\/tests\/test_image.py:    hdu = fits.ImageHDU(np.array([1], dtype=np.int32))\nastropy\/io\/fits\/tests\/test_image.py:    # Calling HDUList.info() on a dataset which applies a zeropoint\nastropy\/io\/fits\/tests\/test_image.py:    hdu = fits.ImageHDU(np.zeros((10, 10)))\nastropy\/io\/fits\/tests\/test_image.py:    ghdu = fits.ImageHDU(data=x)\nastropy\/io\/fits\/tests\/test_image.py:    # Same for compressed HDU\nastropy\/io\/fits\/tests\/test_image.py:    ghdu = fits.CompImageHDU(data=x)\nastropy\/io\/fits\/tests\/test_image.py:    # add_datasum does not work for CompImageHDU\nastropy\/io\/fits\/card.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/card.py:FIX_FP_TABLE = str.maketrans('de', 'DE')\nastropy\/io\/fits\/card.py:FIX_FP_TABLE2 = str.maketrans('dD', 'eE')\nastropy\/io\/fits\/card.py:CARD_LENGTH = 80\nastropy\/io\/fits\/card.py:BLANK_CARD = ' ' * CARD_LENGTH\nastropy\/io\/fits\/card.py:KEYWORD_LENGTH = 8  # The max length for FITS-standard keywords\nastropy\/io\/fits\/card.py:VALUE_INDICATOR = '= '  # The standard FITS value indicator\nastropy\/io\/fits\/card.py:HIERARCH_VALUE_INDICATOR = '='  # HIERARCH cards may use a shortened indicator\nastropy\/io\/fits\/card.py:UNDEFINED = Undefined()\nastropy\/io\/fits\/card.py:    length = CARD_LENGTH\nastropy\/io\/fits\/card.py:    _keywd_FSC_RE = re.compile(r'^[A-Z0-9_-]{0,%d}$' % KEYWORD_LENGTH)\nastropy\/io\/fits\/card.py:    # NFSC allows lower case of DE for exponent, allows space between sign,\nastropy\/io\/fits\/card.py:    _digits_FSC = r'(\\.\\d+|\\d+(\\.\\d*)?)([DE][+-]?\\d+)?'\nastropy\/io\/fits\/card.py:    _digits_NFSC = r'(\\.\\d+|\\d+(\\.\\d*)?) *([deDE] *[+-]? *\\d+)?'\nastropy\/io\/fits\/card.py:    # record value keyword cards (ex. 'DP1.AXIS.1')\nastropy\/io\/fits\/card.py:    _commentary_keywords = {'', 'COMMENT', 'HISTORY', 'END'}\nastropy\/io\/fits\/card.py:    _value_indicator = VALUE_INDICATOR\nastropy\/io\/fits\/card.py:            if (len(keyword) <= KEYWORD_LENGTH and\nastropy\/io\/fits\/card.py:                if keyword_upper == 'END':\nastropy\/io\/fits\/card.py:                    raise ValueError(\"Keyword 'END' not allowed.\")\nastropy\/io\/fits\/card.py:                self._value_indicator = HIERARCH_VALUE_INDICATOR\nastropy\/io\/fits\/card.py:            except UnicodeDecodeError:\nastropy\/io\/fits\/card.py:            return self._image == BLANK_CARD\nastropy\/io\/fits\/card.py:        if (len(keyword) <= KEYWORD_LENGTH and\nastropy\/io\/fits\/card.py:        Determine whether or not the card is a record-valued keyword card.\nastropy\/io\/fits\/card.py:            self._check_if_rvkc('DP1', 'AXIS.1: 2')\nastropy\/io\/fits\/card.py:            self._check_if_rvkc('DP1.AXIS.1', 2)\nastropy\/io\/fits\/card.py:            self._check_if_rvkc('DP1     = AXIS.1: 2')\nastropy\/io\/fits\/card.py:            eq_idx = image.find(VALUE_INDICATOR)\nastropy\/io\/fits\/card.py:            rest = image[eq_idx + len(VALUE_INDICATOR):]\nastropy\/io\/fits\/card.py:        keyword = self._image[:KEYWORD_LENGTH].strip()\nastropy\/io\/fits\/card.py:        val_ind_idx = self._image.find(VALUE_INDICATOR)\nastropy\/io\/fits\/card.py:        if (0 <= val_ind_idx <= KEYWORD_LENGTH or keyword_upper in special or\nastropy\/io\/fits\/card.py:                rest = self._image[val_ind_idx + len(VALUE_INDICATOR):]\nastropy\/io\/fits\/card.py:              HIERARCH_VALUE_INDICATOR in self._image):\nastropy\/io\/fits\/card.py:            self._value_indicator = HIERARCH_VALUE_INDICATOR\nastropy\/io\/fits\/card.py:            keyword = self._image.split(HIERARCH_VALUE_INDICATOR, 1)[0][9:]\nastropy\/io\/fits\/card.py:            return self._image[KEYWORD_LENGTH:].rstrip()\nastropy\/io\/fits\/card.py:            value = UNDEFINED\nastropy\/io\/fits\/card.py:                keyword = image[:KEYWORD_LENGTH]\nastropy\/io\/fits\/card.py:                valuecomment = image[KEYWORD_LENGTH:]\nastropy\/io\/fits\/card.py:                                         len=KEYWORD_LENGTH)\nastropy\/io\/fits\/card.py:                return '{:{len}}'.format(self.keyword, len=KEYWORD_LENGTH)\nastropy\/io\/fits\/card.py:            return ' ' * KEYWORD_LENGTH\nastropy\/io\/fits\/card.py:        if not self.field_specifier and len(self.keyword) > KEYWORD_LENGTH:\nastropy\/io\/fits\/card.py:        delimiter = VALUE_INDICATOR\nastropy\/io\/fits\/card.py:                headstr = '{:{len}}= '.format(self.keyword, len=KEYWORD_LENGTH)\nastropy\/io\/fits\/card.py:        maxlen = Card.length - KEYWORD_LENGTH\nastropy\/io\/fits\/card.py:        # Don't try to verify cards that already don't meet any recognizable\nastropy\/io\/fits\/tests\/test_diff.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_diff.py:from ..diff import (FITSDiff, HeaderDiff, ImageDataDiff, TableDataDiff,\nastropy\/io\/fits\/tests\/test_diff.py:                    HDUDiff, report_diff_values)\nastropy\/io\/fits\/tests\/test_diff.py:from ..hdu import HDUList, PrimaryHDU, ImageHDU\nastropy\/io\/fits\/tests\/test_diff.py:from ..hdu.table import BinTableHDU\nastropy\/io\/fits\/tests\/test_diff.py:from ....utils.exceptions import AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_diff.py:class TestDiff(FitsTestCase):\nastropy\/io\/fits\/tests\/test_diff.py:        assert HeaderDiff(ha, hb).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert HeaderDiff(ha.tostring(), hb.tostring()).identical\nastropy\/io\/fits\/tests\/test_diff.py:            HeaderDiff(1, 2)\nastropy\/io\/fits\/tests\/test_diff.py:        assert not HeaderDiff(ha, hb).identical\nastropy\/io\/fits\/tests\/test_diff.py:        hb['D'] = (5, 'Comment')\nastropy\/io\/fits\/tests\/test_diff.py:        assert HeaderDiff(ha, hb).common_keywords == ['A', 'B', 'C']\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        hb['D'] = (5, 'Comment')\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        assert diff.diff_keywords == (['E', 'F'], ['D'])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, rtol=1e-6)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, rtol=1e-5)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, rtol=1e-6)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, rtol=1e-5)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, atol=1e-6)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, atol=1e-5)  # strict inequality\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, rtol=1e-5, atol=1e-5)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, atol=1.1e-5)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, rtol=1e-6, atol=1e-6)\nastropy\/io\/fits\/tests\/test_diff.py:        with catch_warnings(AstropyDeprecationWarning) as warning_lines:\nastropy\/io\/fits\/tests\/test_diff.py:            diff = HeaderDiff(ha, hb, tolerance=1e-6)\nastropy\/io\/fits\/tests\/test_diff.py:            assert warning_lines[0].category == AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_diff.py:        with catch_warnings(AstropyDeprecationWarning) as warning_lines:\nastropy\/io\/fits\/tests\/test_diff.py:            diff = HeaderDiff(ha, hb, rtol=1e-6, tolerance=1e-5)\nastropy\/io\/fits\/tests\/test_diff.py:            assert warning_lines[0].category == AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_diff.py:            diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:            # Don't ignore blanks\nastropy\/io\/fits\/tests\/test_diff.py:            diff = HeaderDiff(ha, hb, ignore_blanks=False)\nastropy\/io\/fits\/tests\/test_diff.py:        assert HeaderDiff(ha, hb).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert HeaderDiff(ha, hc).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert HeaderDiff(hb, hc).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert not HeaderDiff(ha, hb, ignore_blank_cards=False).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert not HeaderDiff(ha, hc, ignore_blank_cards=False).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert HeaderDiff(hb, hc, ignore_blank_cards=False).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert not HeaderDiff(hb, hc, ignore_blank_cards=False).identical\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, ignore_keywords=['*'])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, ignore_keywords=['B'])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, ignore_keywords=['b'])\nastropy\/io\/fits\/tests\/test_diff.py:        hb.comments['B'] = 'D'\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, ignore_comments=['*'])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, ignore_comments=['B'])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, ignore_comments=['b'])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib, rtol=1.0e-4)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib, rtol=1.0e-4)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib, atol=1.0e-4)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib, rtol=1.0e-5, atol=1.0e-5)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib, rtol=1.0e-5, atol=1.0e-6)\nastropy\/io\/fits\/tests\/test_diff.py:        hdu = fits.CompImageHDU(data=data)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = FITSDiff(hdula, hdulb)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib)\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Data dimensions differ' in report\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib)\nastropy\/io\/fits\/tests\/test_diff.py:        c4 = Column('D', format='J', bscale=2.0, array=[0, 1])\nastropy\/io\/fits\/tests\/test_diff.py:        c7 = Column('G', format='D', bzero=-0.1, array=[0.0, 1.0])\nastropy\/io\/fits\/tests\/test_diff.py:        ta = BinTableHDU.from_columns(columns)\nastropy\/io\/fits\/tests\/test_diff.py:        tb = BinTableHDU.from_columns([c.copy() for c in columns])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = TableDataDiff(ta.data, tb.data)\nastropy\/io\/fits\/tests\/test_diff.py:        c1 = Column('D', format='J')\nastropy\/io\/fits\/tests\/test_diff.py:        thdu = BinTableHDU.from_columns([c1, c2], nrows=0)\nastropy\/io\/fits\/tests\/test_diff.py:        hdula = fits.HDUList([thdu])\nastropy\/io\/fits\/tests\/test_diff.py:        hdulb = fits.HDUList([thdu])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = FITSDiff(hdula, hdulb)\nastropy\/io\/fits\/tests\/test_diff.py:        ta = BinTableHDU.from_columns([c1, c2, c3])\nastropy\/io\/fits\/tests\/test_diff.py:        tb = BinTableHDU.from_columns([c1, c4, c5])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = TableDataDiff(ta.data, tb.data, ignore_fields=['B', 'C'])\nastropy\/io\/fits\/tests\/test_diff.py:        ta = BinTableHDU.from_columns([ca, cb])\nastropy\/io\/fits\/tests\/test_diff.py:        tb = BinTableHDU.from_columns([ca, cc])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = TableDataDiff(ta.data, tb.data)\nastropy\/io\/fits\/tests\/test_diff.py:        ta = BinTableHDU.from_columns([cb])\nastropy\/io\/fits\/tests\/test_diff.py:        tb = BinTableHDU.from_columns([ca, cb, cc])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = TableDataDiff(ta.data, tb.data)\nastropy\/io\/fits\/tests\/test_diff.py:        ta = BinTableHDU.from_columns([ca1, cb1])\nastropy\/io\/fits\/tests\/test_diff.py:        tb = BinTableHDU.from_columns([ca2, cb2])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = TableDataDiff(ta.data, tb.data)\nastropy\/io\/fits\/tests\/test_diff.py:        ca4 = Column('D', format='J', bscale=2.0, array=[0.0, 2.0])\nastropy\/io\/fits\/tests\/test_diff.py:        ca7 = Column('G', format='D', bzero=-0.1, array=[0.0, 1.0])\nastropy\/io\/fits\/tests\/test_diff.py:        cb4 = Column('D', format='J', bscale=2.0, array=[2.0, 2.0])\nastropy\/io\/fits\/tests\/test_diff.py:        cb7 = Column('G', format='D', bzero=-0.1, array=[2.0, 3.0])\nastropy\/io\/fits\/tests\/test_diff.py:        ta = BinTableHDU.from_columns([ca1, ca2, ca3, ca4, ca5, ca6, ca7,\nastropy\/io\/fits\/tests\/test_diff.py:        tb = BinTableHDU.from_columns([cb1, cb2, cb3, cb4, cb5, cb6, cb7,\nastropy\/io\/fits\/tests\/test_diff.py:        diff = TableDataDiff(ta.data, tb.data, numdiffs=20)\nastropy\/io\/fits\/tests\/test_diff.py:        assert diff.diff_values[3] == (('D', 0), (0, 2.0))\nastropy\/io\/fits\/tests\/test_diff.py:                ' Column D data differs in row 0:') in report\nastropy\/io\/fits\/tests\/test_diff.py:        hdu = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = FITSDiff(self.temp('testa.fits'), self.temp('testb.fits'))\nastropy\/io\/fits\/tests\/test_diff.py:        # Primary HDUs should contain no differences\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Primary HDU' not in report\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Extension HDU' not in report\nastropy\/io\/fits\/tests\/test_diff.py:        ehdu = ImageHDU(data=a)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HDUDiff(ehdu, ehdu)\nastropy\/io\/fits\/tests\/test_diff.py:        Test files that have some identical HDUs but a different extension\nastropy\/io\/fits\/tests\/test_diff.py:        phdu = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_diff.py:        ehdu = ImageHDU(data=a)\nastropy\/io\/fits\/tests\/test_diff.py:        hdula = HDUList([phdu, ehdu])\nastropy\/io\/fits\/tests\/test_diff.py:        hdulb = HDUList([phdu, ehdu, ehdu])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = FITSDiff(hdula, hdulb)\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Files contain different numbers of HDUs' in report\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'No differences found between common HDUs' in report\nastropy\/io\/fits\/tests\/test_diff.py:        Test files that have some identical HDUs but one different HDU.\nastropy\/io\/fits\/tests\/test_diff.py:        phdu = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_diff.py:        ehdu = ImageHDU(data=a)\nastropy\/io\/fits\/tests\/test_diff.py:        ehdu2 = ImageHDU(data=(a + 1))\nastropy\/io\/fits\/tests\/test_diff.py:        hdula = HDUList([phdu, ehdu, ehdu])\nastropy\/io\/fits\/tests\/test_diff.py:        hdulb = HDUList([phdu, ehdu2, ehdu])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = FITSDiff(hdula, hdulb)\nastropy\/io\/fits\/tests\/test_diff.py:        assert isinstance(datadiff, ImageDataDiff)\nastropy\/io\/fits\/tests\/test_diff.py:        # Primary HDU and 2nd extension HDU should have no differences\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Primary HDU' not in report\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Extension HDU 2' not in report\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Extension HDU 1' in report\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Data contains differences' in report\nastropy\/io\/fits\/tests\/test_diff.py:            assert 'Data differs at [{}, 1]'.format(y + 1) in report\nastropy\/io\/fits\/tests\/test_diff.py:        Test files that have some identical HDUs but a different extension\nastropy\/io\/fits\/tests\/test_diff.py:        phdu = PrimaryHDU()\nastropy\/io\/fits\/tests\/test_diff.py:        ehdu = ImageHDU(name='FOO')\nastropy\/io\/fits\/tests\/test_diff.py:        hdula = HDUList([phdu, ehdu])\nastropy\/io\/fits\/tests\/test_diff.py:        ehdu = BinTableHDU(name='BAR')\nastropy\/io\/fits\/tests\/test_diff.py:        hdulb = HDUList([phdu, ehdu])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = FITSDiff(hdula, hdulb)\nastropy\/io\/fits\/tests\/test_diff.py:        assert ImageDataDiff(arr, arr2).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert TableDataDiff(table, table2).identical\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(arr, arr2)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = TableDataDiff(table, table2)\nastropy\/io\/fits\/tests\/test_diff.py:        diffobj = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diffobj = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diffobj = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diffobj = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        with catch_warnings(AstropyDeprecationWarning) as warning_lines:\nastropy\/io\/fits\/tests\/test_diff.py:            assert warning_lines[0].category == AstropyDeprecationWarning\nastropy\/io\/fits\/scripts\/fitsheader.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/scripts\/fitsheader.py:1. Print the header of all the HDUs of a .fits file::\nastropy\/io\/fits\/scripts\/fitsheader.py:2. Print the header of the third and fifth HDU extension::\nastropy\/io\/fits\/scripts\/fitsheader.py:3. Print the header of a named extension, e.g. select the HDU containing\nastropy\/io\/fits\/scripts\/fitsheader.py:6. Dump the header keywords of all the files in the current directory into a\nastropy\/io\/fits\/scripts\/fitsheader.py:Note that compressed images (HDUs of type\nastropy\/io\/fits\/scripts\/fitsheader.py::class:`~astropy.io.fits.CompImageHDU`) really have two headers: a real\nastropy\/io\/fits\/scripts\/fitsheader.py:    \"\"\"Raised if an HDU extension requested by the user does not exist.\"\"\"\nastropy\/io\/fits\/scripts\/fitsheader.py:    `fitsheader` tool; essentially a wrapper around a `HDUList` object.\nastropy\/io\/fits\/scripts\/fitsheader.py:            Format only specific HDU(s), identified by number or name.\nastropy\/io\/fits\/scripts\/fitsheader.py:            containing `CompImageHDU` extensions only.)\nastropy\/io\/fits\/scripts\/fitsheader.py:        # `hdukeys` will hold the keys of the HDUList items to display\nastropy\/io\/fits\/scripts\/fitsheader.py:            hdukeys = range(len(self._hdulist))  # Display all by default\nastropy\/io\/fits\/scripts\/fitsheader.py:                    # HDU may be specified by number\nastropy\/io\/fits\/scripts\/fitsheader.py:        # Having established which HDUs the user wants, we now format these:\nastropy\/io\/fits\/scripts\/fitsheader.py:            if idx > 0:  # Separate HDUs by a blank line\nastropy\/io\/fits\/scripts\/fitsheader.py:            result.append('# HDU {} in {}:\\n'.format(hdu, self.filename))\nastropy\/io\/fits\/scripts\/fitsheader.py:            Key of a single HDU in the HDUList.\nastropy\/io\/fits\/scripts\/fitsheader.py:                    log.warning('{filename} (HDU {hdukey}): '\nastropy\/io\/fits\/scripts\/fitsheader.py:    parser.add_argument('-e', '--extension', metavar='HDU',\nastropy\/io\/fits\/scripts\/fitsheader.py:    parser.add_argument('-k', '--keyword', metavar='KEYWORD',\nastropy\/io\/fits\/scripts\/fitsinfo.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/scripts\/fitsinfo.py:printing a summary of the HDUs in one or more FITS files(s) to the\nastropy\/io\/fits\/scripts\/fitsinfo.py:1. Print a summary of the HDUs in a FITS file::\nastropy\/io\/fits\/scripts\/fitsinfo.py:    No.    Name         Type      Cards   Dimensions   Format\nastropy\/io\/fits\/scripts\/fitsinfo.py:    0    PRIMARY     PrimaryHDU     138   ()\nastropy\/io\/fits\/scripts\/fitsinfo.py:    1    SCI         ImageHDU        61   (800, 800)   int16\nastropy\/io\/fits\/scripts\/fitsinfo.py:    2    SCI         ImageHDU        61   (800, 800)   int16\nastropy\/io\/fits\/scripts\/fitsinfo.py:    3    SCI         ImageHDU        61   (800, 800)   int16\nastropy\/io\/fits\/scripts\/fitsinfo.py:    4    SCI         ImageHDU        61   (800, 800)   int16\nastropy\/io\/fits\/scripts\/fitsinfo.py:2. Print a summary of HDUs of all the FITS files in the current directory::\nastropy\/io\/fits\/scripts\/fitsinfo.py:    Print a summary of the HDUs in a FITS file.\nastropy\/io\/fits\/scripts\/fitsinfo.py:        description=('Print a summary of the HDUs in a FITS file(s).'))\nastropy\/io\/fits\/tests\/test_hdulist.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_hdulist.py:from ....utils.exceptions import AstropyUserWarning, AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_hdulist.py:class TestHDUListFunctions(FitsTestCase):\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.ImageHDU(data=hdul[0].data)\nastropy\/io\/fits\/tests\/test_hdulist.py:        Ensure that a validation error occurs when saving an HDUList containing\nastropy\/io\/fits\/tests\/test_hdulist.py:        multiple PrimaryHDUs.\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList([fits.PrimaryHDU(), fits.PrimaryHDU()])\nastropy\/io\/fits\/tests\/test_hdulist.py:        # Tests appending a Simple PrimaryHDU to an empty HDUList.\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 5, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests appending a Simple ImageHDU to an empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.ImageHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 4, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests appending a Simple Table ExtensionHDU to a empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 4, (), '', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests appending a Simple GroupsHDU to an empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.GroupsHDU()\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'GroupsHDU', 8, (), '',\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests appending a Simple PrimaryHDU to a non-empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 7, (11, 10, 7), 'int32', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'ImageHDU', 6, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests appending a Simple ExtensionHDU to a non-empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 11, (), '', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (2, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests appending a Simple GroupsHDU to an empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.GroupsHDU()\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests inserting a Simple PrimaryHDU to an empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 5, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests inserting a Simple ImageHDU to an empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.ImageHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 4, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests inserting a Simple Table ExtensionHDU to a empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 4, (), '', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests inserting a Simple GroupsHDU to an empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.GroupsHDU()\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'GroupsHDU', 8, (), '',\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests inserting a Simple PrimaryHDU to a non-empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 7, (11, 10, 7), 'int32', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'ImageHDU', 6, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests inserting a Simple ExtensionHDU to a non-empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 11, (), '', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (2, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests inserting a Simple GroupsHDU to an empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.GroupsHDU()\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'GroupsHDU', 8, (), '',\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'ImageHDU', 6, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        Tests inserting a Simple GroupsHDU to the beginning of an HDUList\nastropy\/io\/fits\/tests\/test_hdulist.py:        that that already contains a GroupsHDU.\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.GroupsHDU()\nastropy\/io\/fits\/tests\/test_hdulist.py:        # Tests inserting a Simple ExtensionHDU to a non-empty HDUList.\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 4, (), '', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (2, '', 1, 'ImageHDU', 12, (), '', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (3, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        Tests inserting a Simple Image ExtensionHDU to a non-empty HDUList\nastropy\/io\/fits\/tests\/test_hdulist.py:        as the primary HDU.\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.ImageHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 5, (100,), 'int32', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'ImageHDU', 12, (), '', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (2, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests the HDUList filename method.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        in HDUList.writeto(), HDULIST.flush() or astropy.io.fits.writeto()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 5, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 5, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 5, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        Tests that new extension HDUs that are added to an HDUList can be\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul.append(fits.ImageHDU(header=f[1].header))\nastropy\/io\/fits\/tests\/test_hdulist.py:        HDU.\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(data=arr)\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul.append(fits.PrimaryHDU())\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul.append(fits.ImageHDU())\nastropy\/io\/fits\/tests\/test_hdulist.py:        del hdul[0].header['EXTEND']\nastropy\/io\/fits\/tests\/test_hdulist.py:        assert 'EXTEND' in hdul[0].header\nastropy\/io\/fits\/tests\/test_hdulist.py:        assert hdul[0].header['EXTEND'] is True\nastropy\/io\/fits\/tests\/test_hdulist.py:        Tests that adding a PrimaryHDU to a new HDUList object updates the\nastropy\/io\/fits\/tests\/test_hdulist.py:        EXTEND keyword on that HDU.\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(header=h0)\nastropy\/io\/fits\/tests\/test_hdulist.py:        sci = fits.ImageHDU(data=np.array(10))\nastropy\/io\/fits\/tests\/test_hdulist.py:        image = fits.HDUList([hdu, sci])\nastropy\/io\/fits\/tests\/test_hdulist.py:        assert 'EXTEND' in hdu.header\nastropy\/io\/fits\/tests\/test_hdulist.py:        assert hdu.header['EXTEND'] is True\nastropy\/io\/fits\/tests\/test_hdulist.py:            f.seek(0, os.SEEK_END)\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_hdulist.py:        end_card_pos = str(hdu.header).index('END' + ' ' * 77)\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(data=data)\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(data=data)\nastropy\/io\/fits\/tests\/test_hdulist.py:        case of multiple consecutive flush() calls on the same HDUList object,\nastropy\/io\/fits\/tests\/test_hdulist.py:        phdu = fits.PrimaryHDU(data=data1)\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.ImageHDU(data=data2)\nastropy\/io\/fits\/tests\/test_hdulist.py:        Test creating the HDUList structure in memory from a string containing\nastropy\/io\/fits\/tests\/test_hdulist.py:        # Tests HDUList.fromstring for all of Astropy's built in test files\nastropy\/io\/fits\/tests\/test_hdulist.py:                hdul2 = fits.HDUList.fromstring(dat)\nastropy\/io\/fits\/tests\/test_hdulist.py:                # TODO: That's probably possible, so one could make it work.\nastropy\/io\/fits\/tests\/test_hdulist.py:        # Test that creating an HDUList from something silly raises a TypeError\nastropy\/io\/fits\/tests\/test_hdulist.py:        pytest.raises(TypeError, fits.HDUList.fromstring, ['a', 'b', 'c'])\nastropy\/io\/fits\/tests\/test_hdulist.py:            hdu_a = fits.PrimaryHDU(data=arr_a)\nastropy\/io\/fits\/tests\/test_hdulist.py:            hdu_b = fits.PrimaryHDU(data=arr_b)\nastropy\/io\/fits\/tests\/test_hdulist.py:            hdu_a = fits.BinTableHDU.from_columns([col_a])\nastropy\/io\/fits\/tests\/test_hdulist.py:            hdu_b = fits.BinTableHDU.from_columns([col_b])\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist.append(fits.ImageHDU(name='a'))\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist = fits.HDUList([fits.PrimaryHDU()])\nastropy\/io\/fits\/tests\/test_hdulist.py:        with catch_warnings(AstropyDeprecationWarning) as warning_lines:\nastropy\/io\/fits\/tests\/test_hdulist.py:            assert warning_lines[0].category == AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist = fits.HDUList(fits.PrimaryHDU())\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist.append(fits.ImageHDU())\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist.append(fits.ImageHDU())\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist = fits.HDUList(fits.PrimaryHDU())\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist.append(fits.ImageHDU(name='SCI'))\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist.append(fits.ImageHDU(name='SCI'))\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist.append(fits.ImageHDU(name='nada'))\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist.append(fits.ImageHDU(name='SCI'))\nastropy\/io\/fits\/tests\/test_util.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/scripts\/fitsdiff.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/scripts\/fitsdiff.py:from ....utils.exceptions import AstropyDeprecationWarning\nastropy\/io\/fits\/scripts\/fitsdiff.py:FITSDIFF_SETTINGS.  If the FITSDIFF_SETTINGS environment variable is present,\nastropy\/io\/fits\/scripts\/fitsdiff.py:command-line unless the --exact option is specified.  The FITSDIFF_SETTINGS\nastropy\/io\/fits\/scripts\/fitsdiff.py:        help='DEPRECATED. Alias for \"--relative-tolerance\". '\nastropy\/io\/fits\/scripts\/fitsdiff.py:             'Deprecated, provided for backward compatibility (default %default).')\nastropy\/io\/fits\/scripts\/fitsdiff.py:        help=\"Don't ignore trailing blanks (whitespace) in string values.  \"\nastropy\/io\/fits\/scripts\/fitsdiff.py:             \"without this option 'ABCDEF   ' and 'ABCDEF' are considered \"\nastropy\/io\/fits\/scripts\/fitsdiff.py:        help=\"Don't ignore entirely blank cards in headers.  Normally fitsdiff \"\nastropy\/io\/fits\/scripts\/fitsdiff.py:             \"overriding command-line options and FITSDIFF_SETTINGS. \")\nastropy\/io\/fits\/scripts\/fitsdiff.py:        metavar='KEYWORDS',\nastropy\/io\/fits\/scripts\/fitsdiff.py:        metavar='KEYWORDS',\nastropy\/io\/fits\/scripts\/fitsdiff.py:    # Determine which filenames to compare\nastropy\/io\/fits\/scripts\/fitsdiff.py:    if 'FITSDIFF_SETTINGS' in os.environ:\nastropy\/io\/fits\/scripts\/fitsdiff.py:        args = os.environ['FITSDIFF_SETTINGS'].split() + args\nastropy\/io\/fits\/scripts\/fitsdiff.py:            AstropyDeprecationWarning)\nastropy\/io\/fits\/scripts\/fitsdiff.py:            # TODO: pass in any additional arguments here too\nastropy\/io\/fits\/scripts\/fitsdiff.py:            diff = fits.diff.FITSDiff(\nastropy\/io\/fits\/scripts\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_groups.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_groups.py:            assert isinstance(hdul[0], fits.GroupsHDU)\nastropy\/io\/fits\/tests\/test_groups.py:            parameters = ['UU', 'VV', 'WW', 'BASELINE', 'DATE']\nastropy\/io\/fits\/tests\/test_groups.py:            info = [(0, 'PRIMARY', 1, 'GroupsHDU', 147, naxes, 'float32',\nastropy\/io\/fits\/tests\/test_groups.py:            assert list(ghdu.data.dtype.names) == parameters + ['DATA']\nastropy\/io\/fits\/tests\/test_groups.py:            assert isinstance(ghdu.data, fits.GroupData)\nastropy\/io\/fits\/tests\/test_groups.py:        Test that opening a file containing a groups HDU in update mode and\nastropy\/io\/fits\/tests\/test_groups.py:        parameters = ['UU', 'VV', 'WW', 'BASELINE', 'DATE']\nastropy\/io\/fits\/tests\/test_groups.py:        A simple test to ensure that slicing GroupData returns a new, smaller\nastropy\/io\/fits\/tests\/test_groups.py:        GroupData object, as is the case with a normal FITS_rec.  This is a\nastropy\/io\/fits\/tests\/test_groups.py:        GroupData returned a single Group record.\nastropy\/io\/fits\/tests\/test_groups.py:            assert isinstance(s, fits.GroupData)\nastropy\/io\/fits\/tests\/test_groups.py:        Basic test for creating GroupData from scratch.\nastropy\/io\/fits\/tests\/test_groups.py:        x = fits.hdu.groups.GroupData(imdata, parnames=['abc', 'xyz'],\nastropy\/io\/fits\/tests\/test_groups.py:        # Test putting the data into a GroupsHDU and round-tripping it\nastropy\/io\/fits\/tests\/test_groups.py:        ghdu = fits.GroupsHDU(data=x)\nastropy\/io\/fits\/tests\/test_groups.py:        x = fits.hdu.groups.GroupData(imdata, parnames=['abc', 'xyz', 'abc'],\nastropy\/io\/fits\/tests\/test_groups.py:        ghdu = fits.GroupsHDU(data=x)\nastropy\/io\/fits\/tests\/test_groups.py:            assert x.dtype.names == ('abc', 'xyz', '_abc', 'DATA')\nastropy\/io\/fits\/tests\/test_fitsinfo.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_fitsinfo.py:            'No.    Name      Ver    Type      Cards   Dimensions   Format')\nastropy\/io\/fits\/tests\/test_fitsinfo.py:            '  0  PRIMARY       1 PrimaryHDU       7   (11, 10, 7)   int32')\nastropy\/io\/fits\/tests\/test_fitsinfo.py:            'No.    Name      Ver    Type      Cards   Dimensions   Format')\nastropy\/io\/fits\/tests\/test_fitsinfo.py:            '  0  PRIMARY       1 PrimaryHDU       7   (11, 10, 7)   int32')\nastropy\/io\/fits\/tests\/test_fitsinfo.py:            '  1                1 TableHDU        20   5R x 2C   [E10.4, I5]')\nastropy\/io\/fits\/column.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/column.py:from collections import OrderedDict\nastropy\/io\/fits\/column.py:from .card import Card, CARD_LENGTH\nastropy\/io\/fits\/column.py:__all__ = ['Column', 'ColDefs', 'Delayed']\nastropy\/io\/fits\/column.py:# D: Double-precision Floating Point\nastropy\/io\/fits\/column.py:# M: Double-precision Complex\nastropy\/io\/fits\/column.py:              'D': 'f8', 'C': 'c8', 'M': 'c16', 'A': 'a'}\nastropy\/io\/fits\/column.py:FORMATORDER = ['L', 'B', 'I', 'J', 'K', 'D', 'M', 'A']\nastropy\/io\/fits\/column.py:FITSUPCONVERTERS = {'E': 'D', 'C': 'M'}\nastropy\/io\/fits\/column.py:# D: Float (64-bit; exponential notation, always 64-bit by convention)\nastropy\/io\/fits\/column.py:ASCII2NUMPY = {'A': 'a', 'I': 'i4', 'J': 'i8', 'F': 'f8', 'E': 'f8', 'D': 'f8'}\nastropy\/io\/fits\/column.py:ASCII2STR = {'A': '', 'I': 'd', 'J': 'd', 'F': 'f', 'E': 'E', 'D': 'E'}\nastropy\/io\/fits\/column.py:ASCII_DEFAULT_WIDTHS = {'A': (1, 0), 'I': (10, 0), 'J': (15, 0),\nastropy\/io\/fits\/column.py:                        'E': (15, 7), 'F': (16, 7), 'D': (25, 17)}\nastropy\/io\/fits\/column.py:KEYWORD_NAMES = ('TTYPE', 'TFORM', 'TUNIT', 'TNULL', 'TSCAL', 'TZERO',\nastropy\/io\/fits\/column.py:                 'TDISP', 'TBCOL', 'TDIM', 'TCTYP', 'TCUNI', 'TCRPX',\nastropy\/io\/fits\/column.py:                 'TCRVL', 'TCDLT', 'TRPOS')\nastropy\/io\/fits\/column.py:KEYWORD_ATTRIBUTES = ('name', 'format', 'unit', 'null', 'bscale', 'bzero',\nastropy\/io\/fits\/column.py:KEYWORD_TO_ATTRIBUTE = OrderedDict(zip(KEYWORD_NAMES, KEYWORD_ATTRIBUTES))\nastropy\/io\/fits\/column.py:ATTRIBUTE_TO_KEYWORD = OrderedDict(zip(KEYWORD_ATTRIBUTES, KEYWORD_NAMES))\nastropy\/io\/fits\/column.py:# TODO: Define a list of default comments to associate with each table keyword\nastropy\/io\/fits\/column.py:TFORMAT_RE = re.compile(r'(?P<repeat>^[0-9]*)(?P<format>[LXBIJKAEDCMPQ])'\nastropy\/io\/fits\/column.py:                              r'(?:(?P<formatf>[FED])'\nastropy\/io\/fits\/column.py:TDEF_RE = re.compile(r'(?P<label>^T[A-Z]*)(?P<num>[1-9][0-9 ]*$)')\nastropy\/io\/fits\/column.py:TDIM_RE = re.compile(r'\\(\\s*(?P<dims>(?:\\d+,\\s*)+\\s*\\d+)\\s*\\)\\s*')\nastropy\/io\/fits\/column.py:DEFAULT_ASCII_TNULL = '---'\nastropy\/io\/fits\/column.py:class Delayed:\nastropy\/io\/fits\/column.py:    \"\"\"Delayed file-reading data.\"\"\"\nastropy\/io\/fits\/column.py:        # This forces the data for the HDU to be read, which will replace\nastropy\/io\/fits\/column.py:        # the corresponding Delayed objects in the Tables Columns to be\nastropy\/io\/fits\/column.py:            # TODO: There should be a generic factory that returns either\nastropy\/io\/fits\/column.py:        and 'D' only).\nastropy\/io\/fits\/column.py:        if self.format in ('E', 'F', 'D'):\nastropy\/io\/fits\/column.py:# TODO: Table column formats need to be verified upon first reading the file;\nastropy\/io\/fits\/column.py:    _format_re_template = (r'(?P<repeat>\\d+)?{}(?P<dtype>[LXBIJKAEDCM])'\nastropy\/io\/fits\/column.py:    Descriptor for attributes of `Column` that are associated with keywords\nastropy\/io\/fits\/column.py:    HDU this column is attached to in order to reflect the change.  The\nastropy\/io\/fits\/column.py:        # determined from the KEYWORD_NAMES\/ATTRIBUTES lists.  This could be\nastropy\/io\/fits\/column.py:        self._attr = '_' + KEYWORD_TO_ATTRIBUTE[self._keyword]\nastropy\/io\/fits\/column.py:            display format, corresponding to ``TDISP`` keyword\nastropy\/io\/fits\/column.py:            column dimension corresponding to ``TDIM`` keyword\nastropy\/io\/fits\/column.py:            coordinate increment at reference point corresponding to ``TCDLT``\nastropy\/io\/fits\/column.py:        for attr in KEYWORD_ATTRIBUTES:\nastropy\/io\/fits\/column.py:        for attr in KEYWORD_ATTRIBUTES:\nastropy\/io\/fits\/column.py:        # TODO: Try to eliminate the following two special cases\nastropy\/io\/fits\/column.py:                          (np.ndarray, chararray.chararray, Delayed)):\nastropy\/io\/fits\/column.py:                        raise ValueError('Data is inconsistent with the '\nastropy\/io\/fits\/column.py:        for attr in KEYWORD_ATTRIBUTES:\nastropy\/io\/fits\/column.py:        later added to a table, such as via `BinTableHDU.from_columns` as\nastropy\/io\/fits\/column.py:        # reference cycle was created.  This is because the code in BinTableHDU\nastropy\/io\/fits\/column.py:        # data._coldefs = columns  # The ColDefs object holding this Column\nastropy\/io\/fits\/column.py:                    isinstance(base._coldefs, ColDefs)):\nastropy\/io\/fits\/column.py:                or len(str(Card('TTYPE', name))) != CARD_LENGTH):\nastropy\/io\/fits\/column.py:    @ColumnAttribute('TCDLT')\nastropy\/io\/fits\/column.py:    disp = ColumnAttribute('TDISP')\nastropy\/io\/fits\/column.py:    dim = ColumnAttribute('TDIM')\nastropy\/io\/fits\/column.py:        TODO: There should be an abc base class for column format classes\nastropy\/io\/fits\/column.py:        # TODO: Add validation for these keywords, obviously\nastropy\/io\/fits\/column.py:                    # TODO: We should also check that TNULLn's integer value\nastropy\/io\/fits\/column.py:        # TODO: Add full parsing and validation of TDISPn keywords\nastropy\/io\/fits\/column.py:                    'Column disp option (TDISPn) must be a string (got {!r}).'\nastropy\/io\/fits\/column.py:                    \"Column disp option (TDISPn) may not use the 'L' format \"\nastropy\/io\/fits\/column.py:        # Process TDIMn options\nastropy\/io\/fits\/column.py:        # ASCII table columns can't have a TDIMn keyword associated with it;\nastropy\/io\/fits\/column.py:        # TODO: This should be checked by the FITS verification code\nastropy\/io\/fits\/column.py:                    'Column dim option (TDIMn) is not allowed for ASCII table '\nastropy\/io\/fits\/column.py:                    \"for the TDIMn header keyword associated with this column, \"\nastropy\/io\/fits\/column.py:                        \"is fewer than the number of elements per the TDIM \"\nastropy\/io\/fits\/column.py:                        \"argument {!r}.  The invalid TDIMn value will be ignored \"\nastropy\/io\/fits\/column.py:                        \"the data in this column.\".format(k, ATTRIBUTE_TO_KEYWORD[k], v))\nastropy\/io\/fits\/column.py:                '(TDIMn) option, since the former is only applies to '\nastropy\/io\/fits\/column.py:        if isinstance(array, Delayed):\nastropy\/io\/fits\/column.py:                        # in the TDIMn keyword itself) is the number of\nastropy\/io\/fits\/column.py:class ColDefs(NotifierMixin):\nastropy\/io\/fits\/column.py:    (e.g. `ColDefs` has the attribute ``names`` while `Column`\nastropy\/io\/fits\/column.py:    has ``name``). Each attribute in `ColDefs` is a list of\nastropy\/io\/fits\/column.py:                issubclass(input._columns_type, ColDefs)):\nastropy\/io\/fits\/column.py:            klass = _AsciiColDefs\nastropy\/io\/fits\/column.py:            klass = _AsciiColDefs\nastropy\/io\/fits\/column.py:        input : sequence of `Column`, `ColDefs`, other\nastropy\/io\/fits\/column.py:            An existing table HDU, an existing `ColDefs`, or any multi-field\nastropy\/io\/fits\/column.py:        from .hdu.table import _TableBaseHDU\nastropy\/io\/fits\/column.py:        if isinstance(input, ColDefs):\nastropy\/io\/fits\/column.py:        elif isinstance(input, _TableBaseHDU):\nastropy\/io\/fits\/column.py:            # Construct columns from fields in an HDU header\nastropy\/io\/fits\/column.py:            raise TypeError('Input to ColDefs must be a table HDU, a list '\nastropy\/io\/fits\/column.py:        \"\"\"Initialize from an existing ColDefs object (just copy the\nastropy\/io\/fits\/column.py:                raise TypeError('Element {} in the ColDefs input is not a '\nastropy\/io\/fits\/column.py:            # Determine the appropriate dimensions for items in the column\nastropy\/io\/fits\/column.py:            # (typically just 1D)\nastropy\/io\/fits\/column.py:        nfields = hdr['TFIELDS']\nastropy\/io\/fits\/column.py:            key = TDEF_RE.match(keyword)\nastropy\/io\/fits\/column.py:            if keyword in KEYWORD_NAMES:\nastropy\/io\/fits\/column.py:                    attr = KEYWORD_TO_ATTRIBUTE[keyword]\nastropy\/io\/fits\/column.py:            # TODO: Try to eliminate the need for these special cases\nastropy\/io\/fits\/column.py:            col_keywords[col]['array'] = Delayed(table, col)\nastropy\/io\/fits\/column.py:        # Add the table HDU is a listener to changes to the columns\nastropy\/io\/fits\/column.py:        # TODO: Catch exceptions here and raise an explicit error about\nastropy\/io\/fits\/column.py:        # TODO: This is sort of hacked in right now; we really need\nastropy\/io\/fits\/column.py:                new_column.null = DEFAULT_ASCII_TNULL\nastropy\/io\/fits\/column.py:                # for now just drop the TDISPn option for this column as we\nastropy\/io\/fits\/column.py:        if cname in KEYWORD_ATTRIBUTES and name[-1] == 's':\nastropy\/io\/fits\/column.py:        # field *shapes* as provided by TDIMn keywords.\nastropy\/io\/fits\/column.py:        # Now this incorporates TDIMn from the start, which makes *this* method\nastropy\/io\/fits\/column.py:        \"\"\"Returns the values of the TDIMn keywords parsed into tuples.\"\"\"\nastropy\/io\/fits\/column.py:            return ColDefs(x)\nastropy\/io\/fits\/column.py:        rep = 'ColDefs('\nastropy\/io\/fits\/column.py:        elif isinstance(other, ColDefs):\nastropy\/io\/fits\/column.py:        return ColDefs(tmp)\nastropy\/io\/fits\/column.py:        return ColDefs(tmp)\nastropy\/io\/fits\/column.py:        members of this `ColDefs`.\nastropy\/io\/fits\/column.py:        `ColDefs` itself does not currently do anything with this, and just\nastropy\/io\/fits\/column.py:        bubbles the notification up to any listening table HDUs that may need\nastropy\/io\/fits\/column.py:        # If this ColDefs is being tracked by a Table, inform the\nastropy\/io\/fits\/column.py:        Delete (the definition of) one `Column`.\nastropy\/io\/fits\/column.py:        # If this ColDefs is being tracked by a table HDU, inform the HDU (or\nastropy\/io\/fits\/column.py:        Change an attribute (in the ``KEYWORD_ATTRIBUTES`` list) of a `Column`.\nastropy\/io\/fits\/column.py:            ``astropy.io.fits.column.KEYWORD_ATTRIBUTES``.  The default is\nastropy\/io\/fits\/column.py:            lst = KEYWORD_ATTRIBUTES\nastropy\/io\/fits\/column.py:                if attr not in KEYWORD_ATTRIBUTES:\nastropy\/io\/fits\/column.py:class _AsciiColDefs(ColDefs):\nastropy\/io\/fits\/column.py:    \"\"\"ColDefs implementation for ASCII tables.\"\"\"\nastropy\/io\/fits\/column.py:        if not isinstance(input, _AsciiColDefs):\nastropy\/io\/fits\/column.py:    # TODO: A great deal of this is redundant with FITS_rec._convert_p; see if\nastropy\/io\/fits\/column.py:        # TODO: Maybe catch this error use a default type (bytes, maybe?) for\nastropy\/io\/fits\/column.py:    'F', or 'D').\nastropy\/io\/fits\/column.py:        width, precision = ASCII_DEFAULT_WIDTHS[format]\nastropy\/io\/fits\/column.py:    \"\"\"Parse the ``TDIM`` value into a tuple (may return an empty tuple if\nastropy\/io\/fits\/column.py:    the value ``TDIM`` value is empty or invalid).\nastropy\/io\/fits\/column.py:    m = tdim and TDIM_RE.match(tdim)\nastropy\/io\/fits\/column.py:    FORMATORDER.\nastropy\/io\/fits\/column.py:    Compares two numpy recformats using the ordering given by FORMATORDER.\nastropy\/io\/fits\/column.py:        return cmp(FORMATORDER.index(f1), FORMATORDER.index(f2))\nastropy\/io\/fits\/column.py:        # use a TDIM keyword to fix this, declaring as (slength,\nastropy\/io\/fits\/column.py:    Convert FITS format spec to record format spec.  Do the opposite if\nastropy\/io\/fits\/column.py:            width = max(width, ASCII_DEFAULT_WIDTHS['I'][0])\nastropy\/io\/fits\/column.py:            # This is tricky, but go ahead and use D if float-64, and E\nastropy\/io\/fits\/column.py:                format = 'D'\nastropy\/io\/fits\/column.py:            width = '.'.join(str(w) for w in ASCII_DEFAULT_WIDTHS[format])\nastropy\/io\/fits\/column.py:        # TODO: There may be reasonable ways to represent other Numpy types so\nastropy\/io\/fits\/scripts\/fitscheck.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/scripts\/fitscheck.py:and updating the CHECKSUM and DATASUM keywords of .fits files.  ``fitscheck``\nastropy\/io\/fits\/scripts\/fitscheck.py:6. Delete checksum keywords::\nastropy\/io\/fits\/scripts\/fitscheck.py:        Verifies and optionally re-writes the CHECKSUM and DATASUM keywords\nastropy\/io\/fits\/scripts\/fitscheck.py:        help='Choose FITS checksum mode or none.  Defaults standard.',\nastropy\/io\/fits\/scripts\/fitscheck.py:        help='Do file update even if original checksum was bad.',\nastropy\/io\/fits\/scripts\/fitscheck.py:        help='Do FITS compliance checking; fix if possible.',\nastropy\/io\/fits\/scripts\/fitscheck.py:    Prints a message if any HDU in `filename` has a bad checksum or datasum.\nastropy\/io\/fits\/scripts\/fitscheck.py:                # looping on HDUs is needed to read them and verify the\nastropy\/io\/fits\/scripts\/fitscheck.py:                                    'in HDU #{}'.format(filename, i))\nastropy\/io\/fits\/scripts\/fitscheck.py:                        log.warning('MISSING {!r} .. Datasum not found '\nastropy\/io\/fits\/scripts\/fitscheck.py:                                    'in HDU #{}'.format(filename, i))\nastropy\/io\/fits\/scripts\/fitscheck.py:                                      'Datasum verification failed')):\nastropy\/io\/fits\/scripts\/fitscheck.py:            log.warning('BAD %r %s', filename, str(w.message))\nastropy\/io\/fits\/scripts\/fitscheck.py:    Sets the ``CHECKSUM`` and ``DATASUM`` keywords for each HDU of `filename`.\nastropy\/io\/fits\/scripts\/fitscheck.py:    or update FITS DATASUM and CHECKSUM keywords for the specified files.\nastropy\/io\/fits\/tests\/test_header.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_header.py:    dict1 = collections.OrderedDict(list1)\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B', 'C'), ('D', 'E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card(\"undef\", fits.card.UNDEFINED)\nastropy\/io\/fits\/tests\/test_header.py:        assert str(c) == _pad(\"UNDEF   =\")\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:                          'ENC=OFFSET+RESOL*acos((WID-(MAX+MIN))\/(MAX-MIN)')\nastropy\/io\/fits\/tests\/test_header.py:                \"'ENC=OFFSET+RESOL*acos((WID-(MAX+MIN))\/(MAX-MIN)'\")\nastropy\/io\/fits\/tests\/test_header.py:                        'ENC=OFFSET+RESOL*acos((WID-(MAX+MIN))\/(MAX-MIN)')\nastropy\/io\/fits\/tests\/test_header.py:                \"'ENC=OFFSET+RESOL*acos((WID-(MAX+MIN))\/(MAX-MIN)'\")\nastropy\/io\/fits\/tests\/test_header.py:            ('EXTEND', True, 'May contain datasets'),\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU(header=header)\nastropy\/io\/fits\/tests\/test_header.py:        assert 'ABCDEFGHI' in header\nastropy\/io\/fits\/tests\/test_header.py:            header.update({'HIERARCH blah blah': 'TESTD'})\nastropy\/io\/fits\/tests\/test_header.py:            assert header['blah blah'], 'TESTD'\nastropy\/io\/fits\/tests\/test_header.py:            header.update({'HIERARCH blah blah blah': 'TESTD'})\nastropy\/io\/fits\/tests\/test_header.py:            assert header['blah blah blah'], 'TESTD'\nastropy\/io\/fits\/tests\/test_header.py:            header.update({'HIERARCH bla bla': 'TESTD'})\nastropy\/io\/fits\/tests\/test_header.py:            assert header['bla bla'], 'TESTD'\nastropy\/io\/fits\/tests\/test_header.py:            header.update({'HIERARCH bla bla': 'TESTD'})\nastropy\/io\/fits\/tests\/test_header.py:            assert header['bla bla'], 'TESTD'\nastropy\/io\/fits\/tests\/test_header.py:        header.set('A', comment='D')\nastropy\/io\/fits\/tests\/test_header.py:        assert header.comments['A'] == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        assert newheader[1] == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('ABC', 0), ('DEF', 1), ('ABD', 2)])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('DATE', 1), ('DATE-OBS', 2), ('DATE-FOO', 3)])\nastropy\/io\/fits\/tests\/test_header.py:        assert len(header['DATE*']) == 3\nastropy\/io\/fits\/tests\/test_header.py:        assert len(header['DATE?*']) == 2\nastropy\/io\/fits\/tests\/test_header.py:        assert len(header['DATE-*']) == 2\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('ABC', 0), ('DEF', 1), ('ABD', 2)])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('ABC', 0), ('DEF', 1), ('ABD', 2)])\nastropy\/io\/fits\/tests\/test_header.py:                              ('DEF', 3), ('HISTORY', 4), ('HISTORY', 5)])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        assert list(header.items()) == [('A', 'B'), ('C', 'D')]\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        for a, b in zip(header.values(), ['B', 'D']):\nastropy\/io\/fits\/tests\/test_header.py:                 'EXTEND'])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F'),\nastropy\/io\/fits\/tests\/test_header.py:        assert mid == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F'),\nastropy\/io\/fits\/tests\/test_header.py:        assert mid == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        assert header.setdefault('C') == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu2 = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:        # Directly append the other header in full--not usually a desirable\nastropy\/io\/fits\/tests\/test_header.py:        # operation when the header is coming from another HDU\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu2 = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu2 = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:                hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:                hdu2 = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu2 = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:                hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:                hdu2 = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        assert header[-2] == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('A', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        assert header[0] == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B', 'C'), ('DEF', 'G', 'H')])\nastropy\/io\/fits\/tests\/test_header.py:                '     DEF  H')\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('AB', 'C', 'D'), ('EF', 'G', 'H'),\nastropy\/io\/fits\/tests\/test_header.py:        assert list(s) == ['K', 'H', 'D']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(s) == ['D', 'K']\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('AB', 'C', 'D'), ('EF', 'G', 'H'),\nastropy\/io\/fits\/tests\/test_header.py:        assert list(header.comments) == ['D', 'L', 'L']\nastropy\/io\/fits\/tests\/test_header.py:        assert header.cards[header.index('AB')].comment == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        assert list(header.comments) == ['L', 'L', 'D']\nastropy\/io\/fits\/tests\/test_header.py:        header.append(('D', 'E', 'F'), end=True)\nastropy\/io\/fits\/tests\/test_header.py:        header['FRED'] = 'BARNEY'\nastropy\/io\/fits\/tests\/test_header.py:        header['HISTORY'] = 'DEF'\nastropy\/io\/fits\/tests\/test_header.py:        assert header['HISTORY'] == ['ABC', 'DEF', 'GHI']\nastropy\/io\/fits\/tests\/test_header.py:        assert header['HISTORY'] == ['FOO', 'DEF', 'GHI']\nastropy\/io\/fits\/tests\/test_header.py:        header['FRED'] = 'BARNEY'\nastropy\/io\/fits\/tests\/test_header.py:        assert list(header)[2] == 'FRED'\nastropy\/io\/fits\/tests\/test_header.py:        header.update({'FRED': 'BARNEY'})\nastropy\/io\/fits\/tests\/test_header.py:        assert header.cards[2].keyword == 'FRED'\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:        # as a PrimaryHDU\nastropy\/io\/fits\/tests\/test_header.py:                          fits.PrimaryHDU)\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:        header['B'] = ('C', 'D')\nastropy\/io\/fits\/tests\/test_header.py:        header['C'] = ('D', 'E')\nastropy\/io\/fits\/tests\/test_header.py:        Make sure that when a Header is read from a text file that the END card\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B', 'C'), ('D', 'E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:            f.write('\\nEND')\nastropy\/io\/fits\/tests\/test_header.py:        assert 'END' not in new_header\nastropy\/io\/fits\/tests\/test_header.py:        Manually adding an END card to a header should simply result in a\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B', 'C'), ('D', 'E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        pytest.raises(ValueError, setitem, 'END', '')\nastropy\/io\/fits\/tests\/test_header.py:        pytest.raises(ValueError, header.append, 'END')\nastropy\/io\/fits\/tests\/test_header.py:        pytest.raises(ValueError, header.append, 'END', end=True)\nastropy\/io\/fits\/tests\/test_header.py:        pytest.raises(ValueError, header.insert, len(header), 'END')\nastropy\/io\/fits\/tests\/test_header.py:        pytest.raises(ValueError, header.set, 'END')\nastropy\/io\/fits\/tests\/test_header.py:        This tests the case where the END card looks like a normal card like\nastropy\/io\/fits\/tests\/test_header.py:        'END = ' and other similar oddities.  As long as a card starts with END\nastropy\/io\/fits\/tests\/test_header.py:        and looks like it was intended to be the END card we allow it, but with\nastropy\/io\/fits\/tests\/test_header.py:        horig = fits.PrimaryHDU(data=np.arange(100)).header\nastropy\/io\/fits\/tests\/test_header.py:        # Basic case motivated by the original issue; it's as if the END card\nastropy\/io\/fits\/tests\/test_header.py:        s = invalid_header('END =', True)\nastropy\/io\/fits\/tests\/test_header.py:                \"Unexpected bytes trailing END keyword: ' ='\")\nastropy\/io\/fits\/tests\/test_header.py:        # A case similar to the last but with more spaces between END and the\nastropy\/io\/fits\/tests\/test_header.py:        s = invalid_header('END     = ', True)\nastropy\/io\/fits\/tests\/test_header.py:                \"Unexpected bytes trailing END keyword: '     ='\")\nastropy\/io\/fits\/tests\/test_header.py:        # END card with trailing gibberish\nastropy\/io\/fits\/tests\/test_header.py:        s = invalid_header('END$%&%^*%*', True)\nastropy\/io\/fits\/tests\/test_header.py:                \"Unexpected bytes trailing END keyword: '$%&%^*%*'\")\nastropy\/io\/fits\/tests\/test_header.py:        # 'END' at the very end of a truncated file without padding; the way\nastropy\/io\/fits\/tests\/test_header.py:        # the block reader works currently this can only happen if the 'END'\nastropy\/io\/fits\/tests\/test_header.py:        s = invalid_header('END', False)\nastropy\/io\/fits\/tests\/test_header.py:            # Don't raise an exception on missing padding, but still produce a\nastropy\/io\/fits\/tests\/test_header.py:            # warning that the END card is incomplete\nastropy\/io\/fits\/tests\/test_header.py:        hdul = fits.PrimaryHDU(header=h, data=np.arange(5))\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('B', 'C'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:        # message (HDU 0, Card 4).  I'm still not sure things like that\nastropy\/io\/fits\/tests\/test_header.py:        h = fits.Header([('abC', 1), ('Def', 2), ('GeH', 3)])\nastropy\/io\/fits\/tests\/test_header.py:        assert list(h) == ['ABC', 'DEF', 'GEH']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(h) == ['ABC', 'DEF']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(h) == ['GEH', 'ABC', 'DEF']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(h) == ['GEH', 'DEF', 'ABC']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(h) == ['GEH', 'DEF', 'ABC', 'IJK']\nastropy\/io\/fits\/tests\/test_header.py:        h.remove('Def')\nastropy\/io\/fits\/tests\/test_header.py:        Tests a case where the comment of a card ends with END, and is followed\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU(data=data)\nastropy\/io\/fits\/tests\/test_header.py:        hdu.header['TESTKW'] = ('Test val', 'This is the END')\nastropy\/io\/fits\/tests\/test_header.py:        # Add a couple blanks after the END string\nastropy\/io\/fits\/tests\/test_header.py:        When creating a new HDU from an existing Header read from an existing\nastropy\/io\/fits\/tests\/test_header.py:        history = ['CCD parameters table ...',\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:        new_hdu = fits.PrimaryHDU(header=hdu.header)\nastropy\/io\/fits\/tests\/test_header.py:        # Create a header containing a few different types of BAD headers.\nastropy\/io\/fits\/tests\/test_header.py:        c1 = fits.Card.fromstring('CLFIND2D: contour = 0.30')\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:                assert 'CLFIND2D' in header\nastropy\/io\/fits\/tests\/test_header.py:                assert header['CLFIND2D'] == ': contour = 0.30'\nastropy\/io\/fits\/tests\/test_header.py:                pytest.raises(ValueError, header.set, 'CLFIND2D', 'foo')\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card.fromstring('HIERARCH ESO DET CHIP PXSPACE = 5e6')\nastropy\/io\/fits\/tests\/test_header.py:        assert str(c) == _pad('HIERARCH ESO DET CHIP PXSPACE = 5E6')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'NAXIS: 2')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'AXIS.1: 1')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'AXIS.2: 2')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'NAUX: 2')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'AUX.1.COEFF.0: 0')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'AUX.1.POWER.0: 1')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'AUX.1.COEFF.1: 0.00048828125')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'AUX.1.POWER.1: 1')\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card.fromstring(\"DP1     = 'NAXIS: 2' \/ A comment\")\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card.fromstring(\"DP1     = 'NAXIS: 2.1'\")\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card.fromstring(\"DP1     = 'NAXIS: a'\")\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card('DP1', 'NAXIS: 2')\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card('DP1', 'NAXIS: 2.0')\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card('DP1', 'NAXIS: a')\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card('DP1.NAXIS', 2)\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card('DP1.NAXIS', 2.0)\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:            c = fits.Card('DP1.NAXIS', 'a')\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card.fromstring(\"DP1     = 'NAXIS: 2' \/ A comment\")\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card.fromstring(\"DP1     = 'NAXIS: 2' \/ A comment\")\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS1'\nastropy\/io\/fits\/tests\/test_header.py:        assert str(c).rstrip() == \"DP1     = 'NAXIS1: 2' \/ A comment\"\nastropy\/io\/fits\/tests\/test_header.py:        header.set('abc.DEF', 2)\nastropy\/io\/fits\/tests\/test_header.py:        assert header['ABC.DEF'] == 2\nastropy\/io\/fits\/tests\/test_header.py:        _test_header['DP1'] to return the parsed float value.\nastropy\/io\/fits\/tests\/test_header.py:        assert self._test_header['DP1'] == 'NAXIS: 2'\nastropy\/io\/fits\/tests\/test_header.py:        assert self._test_header['DP1.NAXIS'] == 2.0\nastropy\/io\/fits\/tests\/test_header.py:        assert isinstance(self._test_header['DP1.NAXIS'], float)\nastropy\/io\/fits\/tests\/test_header.py:        assert self._test_header['DP1.AUX.1.COEFF.1'] == 0.00048828125\nastropy\/io\/fits\/tests\/test_header.py:        pytest.raises(KeyError, lambda k: self._test_header[k], 'DP1.AXIS.3')\nastropy\/io\/fits\/tests\/test_header.py:            self._test_header['DP1.AXIS.3']\nastropy\/io\/fits\/tests\/test_header.py:            assert e.args[0] == \"Keyword 'DP1.AXIS.3' not found.\"\nastropy\/io\/fits\/tests\/test_header.py:        assert self._test_header['DP1.NAXIS'] == 3.0\nastropy\/io\/fits\/tests\/test_header.py:        assert isinstance(self._test_header['DP1.NAXIS'], float)\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header['DP1.AXIS.1'] = 1.1\nastropy\/io\/fits\/tests\/test_header.py:        assert self._test_header['DP1.AXIS.1'] == 1.1\nastropy\/io\/fits\/tests\/test_header.py:        h['D2IM1.EXTVER'] = 1\nastropy\/io\/fits\/tests\/test_header.py:        assert h['D2IM1.EXTVER'] == 1.0\nastropy\/io\/fits\/tests\/test_header.py:        h['D2IM1.EXTVER'] = 2\nastropy\/io\/fits\/tests\/test_header.py:        assert h['D2IM1.EXTVER'] == 2.0\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card.fromstring(\"DP1     = 'NAXIS: 2' \/ A comment\")\nastropy\/io\/fits\/tests\/test_header.py:        assert c.rawkeyword == 'DP1'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card('DP1.NAXIS', 2)\nastropy\/io\/fits\/tests\/test_header.py:        assert c.rawkeyword == 'DP1'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card('DP1.NAXIS', 2.0)\nastropy\/io\/fits\/tests\/test_header.py:        assert c.rawkeyword == 'DP1'\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'AXIS.3: 1', 'a comment',\nastropy\/io\/fits\/tests\/test_header.py:                              after='DP1.AXIS.2')\nastropy\/io\/fits\/tests\/test_header.py:        assert self._test_header['DP1.AXIS.3'] == 1\nastropy\/io\/fits\/tests\/test_header.py:        Deleting a RVKC should work as with a normal card by using the full\nastropy\/io\/fits\/tests\/test_header.py:        del self._test_header['DP1.AXIS.1']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(self._test_header)[0] == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        assert list(self._test_header)[1] == 'DP1.AXIS.2'\nastropy\/io\/fits\/tests\/test_header.py:        del self._test_header['DP1.AXIS.2']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(self._test_header)[0] == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        assert list(self._test_header)[1] == 'DP1.NAUX'\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.AXIS.*']\nastropy\/io\/fits\/tests\/test_header.py:                [\"DP1     = 'AXIS.1: 1'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AXIS.2: 2'\"])\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.N*']\nastropy\/io\/fits\/tests\/test_header.py:                [\"DP1     = 'NAXIS: 2'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'NAUX: 2'\"])\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.AUX...']\nastropy\/io\/fits\/tests\/test_header.py:                [\"DP1     = 'AUX.1.COEFF.0: 0'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.POWER.0: 1'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.COEFF.1: 0.00048828125'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.POWER.1: 1'\"])\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP?.NAXIS']\nastropy\/io\/fits\/tests\/test_header.py:                [\"DP1     = 'NAXIS: 2'\"])\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.A*S.*']\nastropy\/io\/fits\/tests\/test_header.py:                [\"DP1     = 'AXIS.1: 1'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AXIS.2: 2'\"])\nastropy\/io\/fits\/tests\/test_header.py:        \"\"\"Deletion by filter strings should work.\"\"\"\nastropy\/io\/fits\/tests\/test_header.py:        del self._test_header['DP1.A*...']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(self._test_header)[0] == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        assert list(self._test_header)[1] == 'DP1.NAUX'\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.A*...']\nastropy\/io\/fits\/tests\/test_header.py:                [\"DP1     = 'AXIS.1: 1'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AXIS.2: 2'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.COEFF.0: 0'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.POWER.0: 1'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.COEFF.1: 0.00048828125'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.POWER.1: 1'\"])\nastropy\/io\/fits\/tests\/test_header.py:                [\"DP1     = 'AUX.1.COEFF.0: 0'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.POWER.0: 1'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.COEFF.1: 0.00048828125'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.POWER.1: 1'\"])\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.AXIS.*']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(cl) == ['DP1.AXIS.1', 'DP1.AXIS.2']\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.AXIS.*']\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.AXIS.*']\nastropy\/io\/fits\/tests\/test_header.py:        h['HISTORY'] = 'Date: 2012-09-19T13:58:53.756061'\nastropy\/io\/fits\/tests\/test_header.py:        assert 'HISTORY.Date' not in h\nastropy\/io\/fits\/tests\/test_header.py:        assert str(h.cards[0]) == _pad('HISTORY Date: 2012-09-19T13:58:53.756061')\nastropy\/io\/fits\/tests\/test_header.py:            \"        'Date: 2012-09-19T13:58:53.756061'\")\nastropy\/io\/fits\/tests\/test_header.py:        assert c.value == \"'Date: 2012-09-19T13:58:53.756061'\"\nastropy\/io\/fits\/tests\/test_header.py:        h['FOO'] = 'Date: 2012-09-19T13:58:53.756061'\nastropy\/io\/fits\/tests\/test_header.py:        assert 'FOO.Date' not in h\nastropy\/io\/fits\/tests\/test_header.py:                _pad(\"FOO     = 'Date: 2012-09-19T13:58:53.756061'\"))\nastropy\/io\/fits\/tests\/test_header.py:        # Does the table contain the expected number of rows?\nastropy\/io\/fits\/tests\/test_header.py:        # Repeat the above test when multiple HDUs are requested\nastropy\/io\/fits\/tests\/test_header.py:        mytable = formatter.parse(extensions=['DOES_NOT_EXIST'])\nastropy\/io\/fits\/tests\/test_header.py:                                  keywords=['DOES_NOT_EXIST'])\nastropy\/io\/fits\/hdu\/image.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/image.py:from .base import DELAYED, _ValidHDU, ExtensionHDU, BITPIX2DTYPE, DTYPE2BITPIX\nastropy\/io\/fits\/hdu\/image.py:class _ImageBaseHDU(_ValidHDU):\nastropy\/io\/fits\/hdu\/image.py:    \"\"\"FITS image HDU base class.\nastropy\/io\/fits\/hdu\/image.py:        from .groups import GroupsHDU\nastropy\/io\/fits\/hdu\/image.py:                # TODO: Instead maybe try initializing a new Header object from\nastropy\/io\/fits\/hdu\/image.py:        if data is DELAYED:\nastropy\/io\/fits\/hdu\/image.py:            # Presumably if data is DELAYED then this HDU is coming from an\nastropy\/io\/fits\/hdu\/image.py:                raise ValueError('No header to setup HDU.')\nastropy\/io\/fits\/hdu\/image.py:            # TODO: Some of this card manipulation should go into the\nastropy\/io\/fits\/hdu\/image.py:            # PrimaryHDU and GroupsHDU subclasses\nastropy\/io\/fits\/hdu\/image.py:            if isinstance(self, ExtensionHDU):\nastropy\/io\/fits\/hdu\/image.py:            if isinstance(self, GroupsHDU):\nastropy\/io\/fits\/hdu\/image.py:            if isinstance(self, (ExtensionHDU, GroupsHDU)):\nastropy\/io\/fits\/hdu\/image.py:        # Set the name attribute if it was provided (if this is an ImageHDU\nastropy\/io\/fits\/hdu\/image.py:        if data is DELAYED:\nastropy\/io\/fits\/hdu\/image.py:            # Do not provide default values for BZERO and BSCALE here because\nastropy\/io\/fits\/hdu\/image.py:        _ImageBaseHDU is sort of an abstract class for HDUs containing image\nastropy\/io\/fits\/hdu\/image.py:        # Determine from the values read from the header\nastropy\/io\/fits\/hdu\/image.py:        of the order specified in the FITS file.  For example for a 2D image\nastropy\/io\/fits\/hdu\/image.py:            self._bitpix = DTYPE2BITPIX[data.dtype.name]\nastropy\/io\/fits\/hdu\/image.py:        # unsigned. Does not change the values of self._bitpix,\nastropy\/io\/fits\/hdu\/image.py:        # TODO: This routine is repeated in several different classes--it\nastropy\/io\/fits\/hdu\/image.py:        # should probably be made available as a method on all standard HDU\nastropy\/io\/fits\/hdu\/image.py:        Delete BSCALE\/BZERO from header if necessary.\nastropy\/io\/fits\/hdu\/image.py:            # Data is pseudo-unsigned integers, and the scale_back option\nastropy\/io\/fits\/hdu\/image.py:            self._header['BITPIX'] = DTYPE2BITPIX[dtype.name]\nastropy\/io\/fits\/hdu\/image.py:        ``BSCALE`` and ``BZERO`` in the HDU's header.  This method should only\nastropy\/io\/fits\/hdu\/image.py:        # Disable blank support for now\nastropy\/io\/fits\/hdu\/image.py:        TODO: This is only needed for fixing #3865 without introducing any\nastropy\/io\/fits\/hdu\/image.py:        # Determine the destination (numpy) data type\nastropy\/io\/fits\/hdu\/image.py:            type = BITPIX2DTYPE[self._bitpix]\nastropy\/io\/fits\/hdu\/image.py:        # Determine how to scale the data\nastropy\/io\/fits\/hdu\/image.py:        # Do the scaling\nastropy\/io\/fits\/hdu\/image.py:            # TODO: Perhaps check that the requested BLANK value fits in the\nastropy\/io\/fits\/hdu\/image.py:        self._bitpix = DTYPE2BITPIX[self.data.dtype.name]\nastropy\/io\/fits\/hdu\/image.py:        # both when the HDU is created and when written\nastropy\/io\/fits\/hdu\/image.py:        # TODO: Once the FITSSchema framewhere is merged these warnings\nastropy\/io\/fits\/hdu\/image.py:                \"in this HDU.\")\nastropy\/io\/fits\/hdu\/image.py:            self._scale_internal(BITPIX2DTYPE[self._orig_bitpix],\nastropy\/io\/fits\/hdu\/image.py:        Determine the dtype that the data should be converted to depending on\nastropy\/io\/fits\/hdu\/image.py:        code = BITPIX2DTYPE[self._orig_bitpix]\nastropy\/io\/fits\/hdu\/image.py:        Summarize the HDU: name, dimensions, and formats.\nastropy\/io\/fits\/hdu\/image.py:                format = BITPIX2DTYPE[self._bitpix]\nastropy\/io\/fits\/hdu\/image.py:        # Display shape in FITS-order\nastropy\/io\/fits\/hdu\/image.py:        Calculate the value for the ``DATASUM`` card in the HDU.\nastropy\/io\/fits\/hdu\/image.py:            # Only singleton dimensions remain; concatenate in a 1D array.\nastropy\/io\/fits\/hdu\/image.py:class PrimaryHDU(_ImageBaseHDU):\nastropy\/io\/fits\/hdu\/image.py:    FITS primary HDU class.\nastropy\/io\/fits\/hdu\/image.py:        Construct a primary HDU.\nastropy\/io\/fits\/hdu\/image.py:        data : array or DELAYED, optional\nastropy\/io\/fits\/hdu\/image.py:            The data in the HDU.\nastropy\/io\/fits\/hdu\/image.py:        # insert the keywords EXTEND\nastropy\/io\/fits\/hdu\/image.py:            self._header.set('EXTEND', True, after='NAXIS' + str(dim))\nastropy\/io\/fits\/hdu\/image.py:        # Due to problems discussed in #5808, we cannot assume the 'GROUPS'\nastropy\/io\/fits\/hdu\/image.py:        # Update the position of the EXTEND keyword if it already exists\nastropy\/io\/fits\/hdu\/image.py:        if 'EXTEND' in self._header:\nastropy\/io\/fits\/hdu\/image.py:            self._header.set('EXTEND', after=after)\nastropy\/io\/fits\/hdu\/image.py:        # The EXTEND keyword is only mandatory if the HDU has extensions; this\nastropy\/io\/fits\/hdu\/image.py:        # condition is checked by the HDUList object.  However, if we already\nastropy\/io\/fits\/hdu\/image.py:        # have an EXTEND keyword check that its position is correct\nastropy\/io\/fits\/hdu\/image.py:        if 'EXTEND' in self._header:\nastropy\/io\/fits\/hdu\/image.py:            self.req_cards('EXTEND', naxis + 3, lambda v: isinstance(v, bool),\nastropy\/io\/fits\/hdu\/image.py:class ImageHDU(_ImageBaseHDU, ExtensionHDU):\nastropy\/io\/fits\/hdu\/image.py:    FITS image extension HDU class.\nastropy\/io\/fits\/hdu\/image.py:        Construct an image HDU.\nastropy\/io\/fits\/hdu\/image.py:            The data in the HDU.\nastropy\/io\/fits\/hdu\/image.py:            The name of the HDU, will be the value of the keyword\nastropy\/io\/fits\/hdu\/image.py:            The ver of the HDU, will be the value of the keyword ``EXTVER``.\nastropy\/io\/fits\/hdu\/image.py:        ImageHDU verify method.\nastropy\/io\/fits\/hdu\/image.py:        # ExtensionHDU._verify, however ExtensionHDU._verify allows PCOUNT\nastropy\/io\/fits\/hdu\/__init__.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/__init__.py:from .base import (register_hdu, unregister_hdu, DELAYED, BITPIX2DTYPE,\nastropy\/io\/fits\/hdu\/__init__.py:                   DTYPE2BITPIX)\nastropy\/io\/fits\/hdu\/__init__.py:from .compressed import CompImageHDU\nastropy\/io\/fits\/hdu\/__init__.py:from .groups import GroupsHDU, GroupData, Group\nastropy\/io\/fits\/hdu\/__init__.py:from .hdulist import HDUList\nastropy\/io\/fits\/hdu\/__init__.py:from .image import PrimaryHDU, ImageHDU\nastropy\/io\/fits\/hdu\/__init__.py:from .nonstandard import FitsHDU\nastropy\/io\/fits\/hdu\/__init__.py:from .streaming import StreamingHDU\nastropy\/io\/fits\/hdu\/__init__.py:from .table import TableHDU, BinTableHDU\nastropy\/io\/fits\/hdu\/__init__.py:__all__ = ['HDUList', 'PrimaryHDU', 'ImageHDU', 'TableHDU', 'BinTableHDU',\nastropy\/io\/fits\/hdu\/__init__.py:           'GroupsHDU', 'GroupData', 'Group', 'CompImageHDU', 'FitsHDU',\nastropy\/io\/fits\/hdu\/__init__.py:           'StreamingHDU', 'register_hdu', 'unregister_hdu', 'DELAYED',\nastropy\/io\/fits\/hdu\/__init__.py:           'BITPIX2DTYPE', 'DTYPE2BITPIX']\nastropy\/io\/fits\/fitstime.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/fitstime.py:from collections import defaultdict, OrderedDict\nastropy\/io\/fits\/fitstime.py:from ...time import Time, TimeDelta\nastropy\/io\/fits\/fitstime.py:from ...time.formats import FITS_DEPRECATED_SCALES\nastropy\/io\/fits\/fitstime.py:TIME_KEYWORDS = ('TIMESYS', 'MJDREF', 'JDREF', 'DATEREF',\nastropy\/io\/fits\/fitstime.py:                 'TREFPOS', 'TREFDIR', 'TIMEUNIT', 'TIMEOFFS',\nastropy\/io\/fits\/fitstime.py:                 'OBSGEO-L', 'OBSGEO-B', 'OBSGEO-H', 'DATE',\nastropy\/io\/fits\/fitstime.py:                 'DATE-OBS', 'DATE-AVG', 'DATE-BEG', 'DATE-END',\nastropy\/io\/fits\/fitstime.py:                 'MJD-OBS', 'MJD-AVG', 'MJD-BEG', 'MJD-END')\nastropy\/io\/fits\/fitstime.py:COLUMN_TIME_KEYWORDS = ('TCTYP', 'TCUNI', 'TRPOS')\nastropy\/io\/fits\/fitstime.py:COLUMN_TIME_KEYWORD_REGEXP = '({0})[0-9]+'.format(\nastropy\/io\/fits\/fitstime.py:    '|'.join(COLUMN_TIME_KEYWORDS))\nastropy\/io\/fits\/fitstime.py:    return re.match(COLUMN_TIME_KEYWORD_REGEXP, keyword) is not None\nastropy\/io\/fits\/fitstime.py:GLOBAL_TIME_INFO = {'TIMESYS': ('UTC', 'Default time scale'),\nastropy\/io\/fits\/fitstime.py:                    'JDREF': (0.0, 'Time columns are jd = jd1 + jd2'),\nastropy\/io\/fits\/fitstime.py:    global_info['scale'] = FITS_DEPRECATED_SCALES.get(global_info['TIMESYS'],\nastropy\/io\/fits\/fitstime.py:            # Default scale 'UTC'\nastropy\/io\/fits\/fitstime.py:    for key, format_ in (('MJDREF', 'mjd'), ('JDREF', 'jd'), ('DATEREF', 'fits')):\nastropy\/io\/fits\/fitstime.py:        # If none of the three keywords is present, MJDREF = 0.0 must be assumed\nastropy\/io\/fits\/fitstime.py:        elif scale in FITS_DEPRECATED_SCALES.keys():\nastropy\/io\/fits\/fitstime.py:            column_info['scale'] = FITS_DEPRECATED_SCALES[scale]\nastropy\/io\/fits\/fitstime.py:        # FITS uses a subset of ISO-8601 for DATE-xxx\nastropy\/io\/fits\/fitstime.py:        if key.startswith('DATE'):\nastropy\/io\/fits\/fitstime.py:                scale = 'utc' if key == 'DATE' else global_info['scale']\nastropy\/io\/fits\/fitstime.py:        # MJD-xxx in MJD according to TIMESYS\nastropy\/io\/fits\/fitstime.py:        elif key.startswith('MJD-'):\nastropy\/io\/fits\/fitstime.py:            # [+\/-C]CCYY-MM-DD[Thh:mm:ss[.s...]] where the number of characters\nastropy\/io\/fits\/fitstime.py:        # If reference value is 0 for JD or MJD, the column values can be\nastropy\/io\/fits\/fitstime.py:            delta_time = TimeDelta(col[..., 0], col[..., 1])\nastropy\/io\/fits\/fitstime.py:            delta_time = TimeDelta(col)\nastropy\/io\/fits\/fitstime.py:    time_columns = defaultdict(OrderedDict)\nastropy\/io\/fits\/fitstime.py:        if key in TIME_KEYWORDS:\nastropy\/io\/fits\/fitstime.py:    jd = jd1 + jd2 represents time in the Julian Date format with\nastropy\/io\/fits\/fitstime.py:    newtable.meta['__coordinate_columns__'] = defaultdict(OrderedDict)\nastropy\/io\/fits\/hdu\/nonstandard.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/nonstandard.py:from .base import NonstandardExtHDU\nastropy\/io\/fits\/hdu\/nonstandard.py:from .hdulist import HDUList\nastropy\/io\/fits\/hdu\/nonstandard.py:class FitsHDU(NonstandardExtHDU):\nastropy\/io\/fits\/hdu\/nonstandard.py:    A non-standard extension HDU for encapsulating entire FITS files within a\nastropy\/io\/fits\/hdu\/nonstandard.py:    single HDU of a container FITS file.  These HDUs have an extension (that is\nastropy\/io\/fits\/hdu\/nonstandard.py:    The FITS file contained in the HDU's data can be accessed by the `hdulist`\nastropy\/io\/fits\/hdu\/nonstandard.py:    attribute which returns the contained FITS file as an `HDUList` object.\nastropy\/io\/fits\/hdu\/nonstandard.py:        return HDUList.fromfile(fileobj, mode='readonly')\nastropy\/io\/fits\/hdu\/nonstandard.py:        Like `FitsHDU.fromhdulist()`, but creates a FitsHDU from a file on\nastropy\/io\/fits\/hdu\/nonstandard.py:            The path to the file to read into a FitsHDU\nastropy\/io\/fits\/hdu\/nonstandard.py:        return cls.fromhdulist(HDUList.fromfile(filename), compress=compress)\nastropy\/io\/fits\/hdu\/nonstandard.py:        Creates a new FitsHDU from a given HDUList object.\nastropy\/io\/fits\/hdu\/nonstandard.py:        hdulist : HDUList\nastropy\/io\/fits\/hdu\/nonstandard.py:        # A proper HDUList should still be padded out to a multiple of 2880\nastropy\/io\/fits\/hdu\/nonstandard.py:        # Add the XINDn keywords proposed by Perry, though nothing is done with\nastropy\/io\/fits\/hdu\/nonstandard.py:                cards.append(('XIND' + str(idx + 1), hdu._header_offset,\nastropy\/io\/fits\/hdu\/nonstandard.py:    # TODO: Add header verification\nastropy\/io\/fits\/hdu\/nonstandard.py:        # TODO: Perhaps make this more descriptive...\nastropy\/io\/fits\/hdu\/streaming.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/streaming.py:from .base import _BaseHDU, BITPIX2DTYPE\nastropy\/io\/fits\/hdu\/streaming.py:from .hdulist import HDUList\nastropy\/io\/fits\/hdu\/streaming.py:from .image import PrimaryHDU\nastropy\/io\/fits\/hdu\/streaming.py:class StreamingHDU:\nastropy\/io\/fits\/hdu\/streaming.py:        shdu = astropy.io.fits.StreamingHDU('filename.fits', header)\nastropy\/io\/fits\/hdu\/streaming.py:        Construct a `StreamingHDU` object given a file name and a header.\nastropy\/io\/fits\/hdu\/streaming.py:        header, a default Primary HDU will be inserted at the\nastropy\/io\/fits\/hdu\/streaming.py:            raise TypeError('StreamingHDU not supported for GzipFile objects.')\nastropy\/io\/fits\/hdu\/streaming.py:        # to prepend a default PrimaryHDU to the file before writing the\nastropy\/io\/fits\/hdu\/streaming.py:                hdulist = HDUList([PrimaryHDU()])\nastropy\/io\/fits\/hdu\/streaming.py:        # TODO : Fix this once the HDU writing API is cleaned up\nastropy\/io\/fits\/hdu\/streaming.py:        tmp_hdu = _BaseHDU()\nastropy\/io\/fits\/hdu\/streaming.py:        # Passing self._header as an argument to _BaseHDU() will cause its\nastropy\/io\/fits\/hdu\/streaming.py:            Data to stream to the file.\nastropy\/io\/fits\/hdu\/streaming.py:        if BITPIX2DTYPE[self._header['BITPIX']] != data.dtype.name:\nastropy\/io\/fits\/hdu\/streaming.py:        Return the size (in bytes) of the data portion of the HDU.\nastropy\/io\/votable\/volint.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_table.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_table.py:from ....utils.exceptions import AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_table.py:from ..column import Delayed, NUMPY2FITS\nastropy\/io\/fits\/tests\/test_table.py:    Does this field by field, using approximation testing for float columns\nastropy\/io\/fits\/tests\/test_table.py:        Ensure that a header from one HDU is copied when used to initialize new\nastropy\/io\/fits\/tests\/test_table.py:        HDU.\nastropy\/io\/fits\/tests\/test_table.py:        ifd = fits.HDUList([fits.PrimaryHDU(), fits.BinTableHDU()])\nastropy\/io\/fits\/tests\/test_table.py:        thdu = fits.BinTableHDU(header=thdr)\nastropy\/io\/fits\/tests\/test_table.py:        ofd = fits.HDUList(thdu)\nastropy\/io\/fits\/tests\/test_table.py:        # Note that X format must be two-D array\nastropy\/io\/fits\/tests\/test_table.py:        x = fits.ColDefs([c1, c2, c3, c4, c5, c6, c7, c8])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(x)\nastropy\/io\/fits\/tests\/test_table.py:        x2 = fits.ColDefs(tt[1])\nastropy\/io\/fits\/tests\/test_table.py:        t2 = fits.BinTableHDU.from_columns(x2, nrows=2)\nastropy\/io\/fits\/tests\/test_table.py:        # the table HDU's data is a subclass of a record array, so we can\nastropy\/io\/fits\/tests\/test_table.py:        xx = fits.ColDefs(tt[1])\nastropy\/io\/fits\/tests\/test_table.py:        # now we write out the newly created table HDU to a FITS file:\nastropy\/io\/fits\/tests\/test_table.py:        fout = fits.HDUList(fits.PrimaryHDU())\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.TableHDU.from_columns([c2, c1, c3])\nastropy\/io\/fits\/tests\/test_table.py:        cols = fits.ColDefs([col])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(cols)\nastropy\/io\/fits\/tests\/test_table.py:        rfiHDU = hduL['RFI']\nastropy\/io\/fits\/tests\/test_table.py:        data = rfiHDU.data\nastropy\/io\/fits\/tests\/test_table.py:        col1 = fits.Column(name='a', format='D', array=a1)\nastropy\/io\/fits\/tests\/test_table.py:        col2 = fits.Column(name='b', format='D', array=a2)\nastropy\/io\/fits\/tests\/test_table.py:        cols = fits.ColDefs([col1, col2])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(cols)\nastropy\/io\/fits\/tests\/test_table.py:        # Double check that the array is converted to the correct byte-order\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(bright)\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(a)\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(a)\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.TableHDU.from_columns(bright, nrows=2)\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that all ndarray objects within the HDU reference the\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU.from_columns(bright, nrows=2)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU.from_columns(t1[1].columns, nrows=nrows)\nastropy\/io\/fits\/tests\/test_table.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 4, (), '', ''),\nastropy\/io\/fits\/tests\/test_table.py:                (1, '', 1, 'BinTableHDU', 19, '8R x 5C', '[10A, J, 10A, 5E, L]',\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu1 = fits.BinTableHDU.from_columns(coldefs1)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts1', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU.from_columns(t1[1].columns + t2[1].columns)\nastropy\/io\/fits\/tests\/test_table.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 4, (), '', ''),\nastropy\/io\/fits\/tests\/test_table.py:                (1, '', 1, 'BinTableHDU', 30, '4R x 10C',\nastropy\/io\/fits\/tests\/test_table.py:        b = fits.BinTableHDU(data=data)\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(newtbdata)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu1 = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN')\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs, nrows=5)\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that all ndarray objects within the HDU reference the\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu1 = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu2 = fits.BinTableHDU.from_columns(tbhdu1.data, nrows=9)\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that all ndarray objects within the HDU reference the\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that original ColDefs object has independent Column\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that original ColDefs object has independent ndarray\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that original ColDefs object references the same data\nastropy\/io\/fits\/tests\/test_table.py:        # Verify new HDU has an independent ColDefs object.\nastropy\/io\/fits\/tests\/test_table.py:        # Verify new HDU has independent Column objects.\nastropy\/io\/fits\/tests\/test_table.py:        # Verify new HDU has independent ndarray objects.\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that both ColDefs objects in the HDU reference the same\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that all ndarray objects within the HDU reference the\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu1 = fits.BinTableHDU.from_columns(tbhdu.data.view(np.ndarray))\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that all ndarray objects within the HDU reference the\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu1 = fits.BinTableHDU.from_columns(fr)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu1 = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(tbhdu1.data)\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that all ndarray objects within the HDU reference the\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that the references in the original HDU are the same as the\nastropy\/io\/fits\/tests\/test_table.py:        # references in the new HDU.\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that a change in the new HDU is reflected in both the new\nastropy\/io\/fits\/tests\/test_table.py:        # and original HDU.\nastropy\/io\/fits\/tests\/test_table.py:        Passing name='...' to the BinTableHDU and TableHDU constructors\nastropy\/io\/fits\/tests\/test_table.py:        for hducls in [fits.BinTableHDU, fits.TableHDU]:\nastropy\/io\/fits\/tests\/test_table.py:        for hducls in [fits.BinTableHDU, fits.TableHDU]:\nastropy\/io\/fits\/tests\/test_table.py:        fits.BinTableHDU.from_columns([col])\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu1 = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(tbhdu1.data)\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = hdul[2]  # This HDU contains a zero-width column 'ORBPARM'\nastropy\/io\/fits\/tests\/test_table.py:        ahdu = fits.BinTableHDU.from_columns([acol])\nastropy\/io\/fits\/tests\/test_table.py:        ahdu = fits.TableHDU.from_columns([acol])\nastropy\/io\/fits\/tests\/test_table.py:            ahdu = fits.BinTableHDU.from_columns(hdul[1].data.copy())\nastropy\/io\/fits\/tests\/test_table.py:        thdu = fits.BinTableHDU.from_columns(data)\nastropy\/io\/fits\/tests\/test_table.py:        # Modify the TDIM fields to my own specification\nastropy\/io\/fits\/tests\/test_table.py:        thdu.header['TDIM1'] = '(2,3)'\nastropy\/io\/fits\/tests\/test_table.py:        thdu.header['TDIM2'] = '(4,2)'\nastropy\/io\/fits\/tests\/test_table.py:        # Test setting the TDIMn header based on the column data\nastropy\/io\/fits\/tests\/test_table.py:        Tests two ways of creating a new `BinTableHDU` from a column of\nastropy\/io\/fits\/tests\/test_table.py:        both BinTableHDU(data=arr) and BinTableHDU.from_columns(arr) work\nastropy\/io\/fits\/tests\/test_table.py:            tbhdu1 = fits.BinTableHDU(data=arr)\nastropy\/io\/fits\/tests\/test_table.py:                assert tbhdu2.header['TDIM1'] == '(4,2,3)'\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu2 = fits.BinTableHDU.from_columns(arr)\nastropy\/io\/fits\/tests\/test_table.py:            If the number of elements in the array implied by the TDIMn is less\nastropy\/io\/fits\/tests\/test_table.py:        than the number of elements indicated by its TDIM (ex: TDIM1 = '(2,2)',\nastropy\/io\/fits\/tests\/test_table.py:        to take the first 4 elements as implied by the TDIM and ignore the\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU(data=arr)\nastropy\/io\/fits\/tests\/test_table.py:        # Artificially truncate TDIM in the header; this seems to be the\nastropy\/io\/fits\/tests\/test_table.py:            assert tbhdu2.header['TDIM1'] == '(2,2,2)'\nastropy\/io\/fits\/tests\/test_table.py:        t = fits.BinTableHDU(data=recarr)\nastropy\/io\/fits\/tests\/test_table.py:            assert 'TDIM1' in h[1].header\nastropy\/io\/fits\/tests\/test_table.py:            assert h[1].header['TDIM1'] == '(3,3,3)'\nastropy\/io\/fits\/tests\/test_table.py:            assert 'TDIM1' in h[1].header\nastropy\/io\/fits\/tests\/test_table.py:            assert h[1].header['TDIM1'] == '(3,3,3)'\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU.from_columns(fits.ColDefs(cols))\nastropy\/io\/fits\/tests\/test_table.py:        \"\"\"Normally the product of the dimensions listed in a TDIMn keyword\nastropy\/io\/fits\/tests\/test_table.py:        dimensions specified by TDIMn are greater than the repeat count.\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU.from_columns(fits.ColDefs(cols))\nastropy\/io\/fits\/tests\/test_table.py:            assert h[1].header['TDIM1'] == h[1].header['TDIM2'] == '(2,2)'\nastropy\/io\/fits\/tests\/test_table.py:        new_tbhdu = fits.BinTableHDU.load(datafile, cdfile, hfile)\nastropy\/io\/fits\/tests\/test_table.py:        # Double check that the headers are equivalent\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(data)\nastropy\/io\/fits\/tests\/test_table.py:        new_tbhdu = fits.BinTableHDU.load(datafile, cdfile, hfile)\nastropy\/io\/fits\/tests\/test_table.py:        c6 = fits.Column(name='c6', format='D', array=a6)\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns([c0, c2, c3, c4, c5, c6, c7, c8])\nastropy\/io\/fits\/tests\/test_table.py:        new_tbhdu = fits.BinTableHDU.load(datafile)\nastropy\/io\/fits\/tests\/test_table.py:        t = fits.BinTableHDU.from_columns([c1, c2, c3])\nastropy\/io\/fits\/tests\/test_table.py:        thdu = fits.BinTableHDU.from_columns(array)\nastropy\/io\/fits\/tests\/test_table.py:        a bool field is used to initialize a `BinTableHDU`.\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(data=arr)\nastropy\/io\/fits\/tests\/test_table.py:        thdu = fits.BinTableHDU.from_columns(fits.ColDefs([c1, c2]))\nastropy\/io\/fits\/tests\/test_table.py:        table = fits.TableHDU.from_columns([c])\nastropy\/io\/fits\/tests\/test_table.py:        table = fits.TableHDU.from_columns([c1])\nastropy\/io\/fits\/tests\/test_table.py:        table = fits.TableHDU.from_columns([c2])\nastropy\/io\/fits\/tests\/test_table.py:            # (Currently it should evaluate to 0.0, but if a TODO in fitsrec is\nastropy\/io\/fits\/tests\/test_table.py:        yet, so new_table has to get at it through the Delayed proxy.\nastropy\/io\/fits\/tests\/test_table.py:        BinTableHDU.from_columns directly, around which new_table is a mere\nastropy\/io\/fits\/tests\/test_table.py:        assert isinstance(hdul[1].columns._arrays[0], Delayed)\nastropy\/io\/fits\/tests\/test_table.py:        t = fits.BinTableHDU.from_columns(hdul[1].columns)\nastropy\/io\/fits\/tests\/test_table.py:        assert not isinstance(hdul[1].columns._arrays[0], Delayed)\nastropy\/io\/fits\/tests\/test_table.py:        \"\"\"Tests initializing a TableHDU with the data from a BinTableHDU.\"\"\"\nastropy\/io\/fits\/tests\/test_table.py:            tbhdu = fits.TableHDU(data=tbdata)\nastropy\/io\/fits\/tests\/test_table.py:            assert isinstance(btb[1].columns._arrays[0], Delayed)\nastropy\/io\/fits\/tests\/test_table.py:            assert not isinstance(btb[1].columns._arrays[0], Delayed)\nastropy\/io\/fits\/tests\/test_table.py:            # Doesn't pickle zero-width (_phanotm) column 'ORBPARM'\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(array)\nastropy\/io\/fits\/tests\/test_table.py:        assert hdu.header['TDIM3'] == '(2,3)'\nastropy\/io\/fits\/tests\/test_table.py:        When creating a table column with non-trivial TDIMn, and\nastropy\/io\/fits\/tests\/test_table.py:        data = fits.getdata(self.data('random_groups.fits'))['DATA']\nastropy\/io\/fits\/tests\/test_table.py:        thdu = fits.BinTableHDU.from_columns([col])\nastropy\/io\/fits\/tests\/test_table.py:        # Double check that the original data1 table hasn't been affected by\nastropy\/io\/fits\/tests\/test_table.py:        # Test update but with a non-trivial TDIMn\nastropy\/io\/fits\/tests\/test_table.py:            assert hdul[1].header['TDIM1'] == '(3,3,2)'\nastropy\/io\/fits\/tests\/test_table.py:            assert hdul[1].header['TDIM1'] == '(3,3,2)'\nastropy\/io\/fits\/tests\/test_table.py:        from .test_connect import TestMultipleHDU\nastropy\/io\/fits\/tests\/test_table.py:        t3 = TestMultipleHDU()\nastropy\/io\/fits\/tests\/test_table.py:            with catch_warnings(AstropyDeprecationWarning) as warning_lines:\nastropy\/io\/fits\/tests\/test_table.py:                assert warning_lines[0].category == AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_table.py:            tb_hdu = fits.BinTableHDU.from_columns([col])\nastropy\/io\/fits\/tests\/test_table.py:            pri_hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_table.py:            hdu_list = fits.HDUList([pri_hdu, tb_hdu])\nastropy\/io\/fits\/tests\/test_table.py:            tb_hdu = fits.BinTableHDU.from_columns([col1, col2], nrows=15)\nastropy\/io\/fits\/tests\/test_table.py:            tbhdu = fits.BinTableHDU.from_columns([acol])\nastropy\/io\/fits\/tests\/test_table.py:                assert tbhdu1[1].columns[0].format.endswith('D(2)')\nastropy\/io\/fits\/tests\/test_table.py:        for code in ('PD()', 'QD()'):\nastropy\/io\/fits\/tests\/test_table.py:            tbhdu = fits.BinTableHDU.from_columns([acol])\nastropy\/io\/fits\/tests\/test_table.py:                assert tbhdu1[1].columns[0].format.endswith('D(2)')\nastropy\/io\/fits\/tests\/test_table.py:        for code in ('PD()', 'QD()'):\nastropy\/io\/fits\/tests\/test_table.py:            tbhdu = fits.BinTableHDU.from_columns([acol])\nastropy\/io\/fits\/tests\/test_table.py:            tbhdu = fits.BinTableHDU.from_columns([acol])\nastropy\/io\/fits\/tests\/test_table.py:            tb_hdu = fits.BinTableHDU.from_columns([col])\nastropy\/io\/fits\/tests\/test_table.py:            pri_hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_table.py:            hdu_list = fits.HDUList([pri_hdu, tb_hdu])\nastropy\/io\/fits\/tests\/test_table.py:        t1 = fits.BinTableHDU.from_columns([c, c1])\nastropy\/io\/fits\/tests\/test_table.py:        t2 = fits.BinTableHDU.from_columns([c, c2])\nastropy\/io\/fits\/tests\/test_table.py:        hdul = fits.HDUList([fits.PrimaryHDU(), t1, t2])\nastropy\/io\/fits\/tests\/test_table.py:            new_hdu = fits.BinTableHDU(data=h[2].data, header=h[2].header)\nastropy\/io\/fits\/tests\/test_table.py:        new_hdul = fits.HDUList([fits.PrimaryHDU()])\nastropy\/io\/fits\/tests\/test_table.py:# These are tests that solely test the Column and ColDefs interfaces and\nastropy\/io\/fits\/tests\/test_table.py:        c = fits.Column('TEST', 'D15.8')\nastropy\/io\/fits\/tests\/test_table.py:        assert c.format.format == 'D'\nastropy\/io\/fits\/tests\/test_table.py:        c = fits.Column('TEST', 'D10.0')\nastropy\/io\/fits\/tests\/test_table.py:        assert c.format.format == 'D'\nastropy\/io\/fits\/tests\/test_table.py:        c = fits.Column('TEST', 'D')\nastropy\/io\/fits\/tests\/test_table.py:        assert c.format == 'D'\nastropy\/io\/fits\/tests\/test_table.py:        c = fits.Column('TEST', 'D', ascii=True)\nastropy\/io\/fits\/tests\/test_table.py:        assert c.format == 'D25.17'\nastropy\/io\/fits\/tests\/test_table.py:        t = fits.TableHDU.from_columns([c])\nastropy\/io\/fits\/tests\/test_table.py:        \"\"\"Test that a TypeError is raised when a ColDefs is instantiated with\nastropy\/io\/fits\/tests\/test_table.py:        pytest.raises(TypeError, fits.ColDefs, [1, 2, 3])\nastropy\/io\/fits\/tests\/test_table.py:            assert isinstance(btb[1].columns._arrays[0], Delayed)\nastropy\/io\/fits\/tests\/test_table.py:            assert not isinstance(btb[1].columns._arrays[0], Delayed)\nastropy\/io\/fits\/tests\/test_table.py:            # Doesn't pickle zero-width (_phanotm) column 'ORBPARM'\nastropy\/io\/fits\/tests\/test_table.py:        \"\"\"Tests that a `ColDefs` can be indexed by column name.\"\"\"\nastropy\/io\/fits\/tests\/test_table.py:        a = fits.Column(name='a', format='D')\nastropy\/io\/fits\/tests\/test_table.py:        b = fits.Column(name='b', format='D')\nastropy\/io\/fits\/tests\/test_table.py:        cols = fits.ColDefs([a, b])\nastropy\/io\/fits\/tests\/test_table.py:        table = fits.BinTableHDU.from_columns([\nastropy\/io\/fits\/tests\/test_table.py:            fits.Column('a', format='D'),\nastropy\/io\/fits\/tests\/test_table.py:            fits.Column('b', format='D')])\nastropy\/io\/fits\/tests\/test_table.py:        table.columns.change_name('a', 'GOODBYE')\nastropy\/io\/fits\/tests\/test_table.py:        assert table.columns['GOODBYE'].name == 'GOODBYE'\nastropy\/io\/fits\/tests\/test_table.py:        assert table.data.dtype.names == ('GOODBYE',)\nastropy\/io\/fits\/tests\/test_table.py:        assert table.columns.names == ['GOODBYE']\nastropy\/io\/fits\/tests\/test_table.py:        assert table.data.columns.names == ['GOODBYE']\nastropy\/io\/fits\/tests\/test_table.py:        table.columns['GOODBYE'].name = 'foo'\nastropy\/io\/fits\/tests\/test_table.py:            table.columns['GOODBYE']\nastropy\/io\/fits\/tests\/test_table.py:        err_msgs = ['keyword arguments to Column were invalid', 'TNULL', 'TDISP',\nastropy\/io\/fits\/tests\/test_table.py:                    'TCTYP', 'TCUNI', 'TCRPX', 'TCRVL', 'TCDLT', 'TRPOS']\nastropy\/io\/fits\/tests\/test_table.py:    hdu = fits.BinTableHDU.from_columns([col])\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(table, header=fits.Header({'TEST': 1}))\nastropy\/io\/votable\/converters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/converters.py:to\/from TABLEDATA_ and BINARY_ formats.\nastropy\/io\/votable\/converters.py:# STDLIB\nastropy\/io\/votable\/converters.py:# THIRD-PARTY\nastropy\/io\/votable\/converters.py:    converting a specific VOTABLE data type to\/from the TABLEDATA_ and\nastropy\/io\/votable\/converters.py:        The position in the XML file where the FIELD object was\nastropy\/io\/votable\/converters.py:        Convert the string *value* from the TABLEDATA_ format into an\nastropy\/io\/votable\/converters.py:            value in TABLEDATA format\nastropy\/io\/votable\/converters.py:            value in TABLEDATA format\nastropy\/io\/votable\/converters.py:        to a unicode string suitable for serializing in the TABLEDATA_\nastropy\/io\/votable\/converters.py:                vo_raise(E01, (field.arraysize, 'char', field.ID), config)\nastropy\/io\/votable\/converters.py:                vo_raise(E01, (field.arraysize, 'unicode', field.ID), config)\nastropy\/io\/votable\/converters.py:class Double(FloatingPoint):\nastropy\/io\/votable\/converters.py:    Handles the double datatype.  Double-precision IEEE\nastropy\/io\/votable\/converters.py:class DoubleComplex(Complex):\nastropy\/io\/votable\/converters.py:    'double': Double,\nastropy\/io\/votable\/converters.py:    'doubleComplex': DoubleComplex,\nastropy\/io\/votable\/converters.py:        vo_raise(E06, (field.datatype, field.ID), config)\nastropy\/io\/votable\/converters.py:    a VOTable FIELD element and correspond to that type.\nastropy\/io\/votable\/converters.py:       set on a VOTable FIELD element.\nastropy\/io\/votable\/converters.py:    necessary to create a VOTable FIELD element that corresponds to\nastropy\/io\/votable\/converters.py:       set on a VOTable FIELD element.\nastropy\/io\/fits\/file.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/file.py:IO_FITS_MODES = {\nastropy\/io\/fits\/file.py:# IO_FITS_MODES there are overlaps; for example 'readonly' and 'denywrite'\nastropy\/io\/fits\/file.py:FILE_MODES = {\nastropy\/io\/fits\/file.py:MEMMAP_MODES = {'readonly': 'c', 'copyonwrite': 'c', 'update': 'r+',\nastropy\/io\/fits\/file.py:# TODO: Eventually raise a warning, and maybe even later disable the use of\nastropy\/io\/fits\/file.py:    if mode is not None and mode not in IO_FITS_MODES:\nastropy\/io\/fits\/file.py:        new_mode = FILE_MODES.get(mode)\nastropy\/io\/fits\/file.py:        if new_mode not in IO_FITS_MODES:\nastropy\/io\/fits\/file.py:                # TODO: This could be revised when Python 3.5 support is dropped\nastropy\/io\/fits\/file.py:        if mode is not None and mode not in IO_FITS_MODES:\nastropy\/io\/fits\/file.py:                    memmap = Memmap(self._file, mode=MEMMAP_MODES[self.mode],\nastropy\/io\/fits\/file.py:        file (so there is only one, shared by all HDUs that reference this\nastropy\/io\/fits\/file.py:            kwargs = dict(mode=IO_FITS_MODES[mode])\nastropy\/io\/fits\/file.py:        fmode = fileobj_mode(fileobj) or IO_FITS_MODES[mode]\nastropy\/io\/fits\/file.py:            self._file = fileobj_open(self.name, IO_FITS_MODES[mode])\nastropy\/io\/fits\/file.py:            self._file = fileobj_open(self.name, IO_FITS_MODES[mode])\nastropy\/io\/fits\/hdu\/hdulist.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/hdulist.py:from .base import _BaseHDU, _ValidHDU, _NonstandardHDU, ExtensionHDU\nastropy\/io\/fits\/hdu\/hdulist.py:from .groups import GroupsHDU\nastropy\/io\/fits\/hdu\/hdulist.py:from .image import PrimaryHDU, ImageHDU\nastropy\/io\/fits\/hdu\/hdulist.py:    \"\"\"Factory function to open a FITS file and return an `HDUList` object.\nastropy\/io\/fits\/hdu\/hdulist.py:        By default `~astropy.io.fits.open` will not read all the HDUs and\nastropy\/io\/fits\/hdu\/hdulist.py:        of determining the number and offsets of all the HDUs in a file\nastropy\/io\/fits\/hdu\/hdulist.py:        To disable lazy loading and read all HDUs immediately (the old\nastropy\/io\/fits\/hdu\/hdulist.py:        order to determine the number of HDUs.  ``lazy_load_hdus=False``\nastropy\/io\/fits\/hdu\/hdulist.py:        ensures that all HDUs have already been loaded after the file has\nastropy\/io\/fits\/hdu\/hdulist.py:            Do not issue an exception when opening a file that is\nastropy\/io\/fits\/hdu\/hdulist.py:            missing an ``END`` card in the last header.\nastropy\/io\/fits\/hdu\/hdulist.py:            If `True`, verifies that both ``DATASUM`` and\nastropy\/io\/fits\/hdu\/hdulist.py:            ``CHECKSUM`` card values (when present in the HDU header)\nastropy\/io\/fits\/hdu\/hdulist.py:            match the header and data of all HDU's in the file.  Updates to a\nastropy\/io\/fits\/hdu\/hdulist.py:            'remove', in which case the CHECKSUM and DATASUM values are not\nastropy\/io\/fits\/hdu\/hdulist.py:            If `True`, treats compressed image HDU's like normal\nastropy\/io\/fits\/hdu\/hdulist.py:            binary table HDU's.\nastropy\/io\/fits\/hdu\/hdulist.py:        hdulist : an `HDUList` object\nastropy\/io\/fits\/hdu\/hdulist.py:            `HDUList` containing all of the header data units in the\nastropy\/io\/fits\/hdu\/hdulist.py:    return HDUList.fromfile(name, mode, memmap, save_backup, cache,\nastropy\/io\/fits\/hdu\/hdulist.py:class HDUList(list, _Verify):\nastropy\/io\/fits\/hdu\/hdulist.py:    HDU list class.  This is the top-level FITS object.  When a FITS\nastropy\/io\/fits\/hdu\/hdulist.py:    file is opened, a `HDUList` object is returned.\nastropy\/io\/fits\/hdu\/hdulist.py:        Construct a `HDUList` object.\nastropy\/io\/fits\/hdu\/hdulist.py:        hdus : sequence of HDU objects or single HDU, optional\nastropy\/io\/fits\/hdu\/hdulist.py:            The HDU object(s) to comprise the `HDUList`.  Should be\nastropy\/io\/fits\/hdu\/hdulist.py:            instances of HDU classes like `ImageHDU` or `BinTableHDU`.\nastropy\/io\/fits\/hdu\/hdulist.py:            The opened physical file associated with the `HDUList`\nastropy\/io\/fits\/hdu\/hdulist.py:        # HDUList.fromfile\/string when opening the file\nastropy\/io\/fits\/hdu\/hdulist.py:        # If we have read all the HDUs from the file or not\nastropy\/io\/fits\/hdu\/hdulist.py:        # The assumes that all HDUs have been written when we first opened the\nastropy\/io\/fits\/hdu\/hdulist.py:        # file; we do not currently support loading additional HDUs from a file\nastropy\/io\/fits\/hdu\/hdulist.py:        # existing HDUs.\nastropy\/io\/fits\/hdu\/hdulist.py:            # Should never attempt to read HDUs in ostream mode\nastropy\/io\/fits\/hdu\/hdulist.py:        # can take one HDU, as well as a list of HDU's as input\nastropy\/io\/fits\/hdu\/hdulist.py:        if isinstance(hdus, _ValidHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:        elif not isinstance(hdus, (HDUList, list)):\nastropy\/io\/fits\/hdu\/hdulist.py:            raise TypeError(\"Invalid input for HDUList.\")\nastropy\/io\/fits\/hdu\/hdulist.py:            if not isinstance(hdu, _BaseHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                raise TypeError(\"Element {} in the HDUList input is \"\nastropy\/io\/fits\/hdu\/hdulist.py:                                \"not an HDU.\".format(idx))\nastropy\/io\/fits\/hdu\/hdulist.py:            # Only do this when initializing from an existing list of HDUs\nastropy\/io\/fits\/hdu\/hdulist.py:            # append method after the first HDU is read\nastropy\/io\/fits\/hdu\/hdulist.py:        # In order to correctly repr an HDUList we need to load all the\nastropy\/io\/fits\/hdu\/hdulist.py:        # HDUs as well\nastropy\/io\/fits\/hdu\/hdulist.py:        Get an HDU from the `HDUList`, indexed by number or name.\nastropy\/io\/fits\/hdu\/hdulist.py:        # If the key is a slice we need to make sure the necessary HDUs\nastropy\/io\/fits\/hdu\/hdulist.py:                # We need all of the HDUs, so load them\nastropy\/io\/fits\/hdu\/hdulist.py:                # max_idx. Note we do not try to be clever about skipping HDUs\nastropy\/io\/fits\/hdu\/hdulist.py:                    raise IndexError('HDU not found, possibly because the index '\nastropy\/io\/fits\/hdu\/hdulist.py:                                     'closed before all HDUs were read')\nastropy\/io\/fits\/hdu\/hdulist.py:                return HDUList(hdus)\nastropy\/io\/fits\/hdu\/hdulist.py:        # Originally this used recursion, but hypothetically an HDU with\nastropy\/io\/fits\/hdu\/hdulist.py:        # a very large number of HDUs could blow the stack, so use a loop\nastropy\/io\/fits\/hdu\/hdulist.py:                raise IndexError('HDU not found, possibly because the index '\nastropy\/io\/fits\/hdu\/hdulist.py:                                 'closed before all HDUs were read')\nastropy\/io\/fits\/hdu\/hdulist.py:        Returns `True` if ``HDUList.index_of(item)`` succeeds.\nastropy\/io\/fits\/hdu\/hdulist.py:        Set an HDU to the `HDUList`, indexed by number or name.\nastropy\/io\/fits\/hdu\/hdulist.py:                raise ValueError('An element in the HDUList must be an HDU.')\nastropy\/io\/fits\/hdu\/hdulist.py:                if not isinstance(item, _BaseHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                    raise ValueError('{} is not an HDU.'.format(item))\nastropy\/io\/fits\/hdu\/hdulist.py:            if not isinstance(hdu, _BaseHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                raise ValueError('{} is not an HDU.'.format(hdu))\nastropy\/io\/fits\/hdu\/hdulist.py:        Delete an HDU from the `HDUList`, indexed by number or name.\nastropy\/io\/fits\/hdu\/hdulist.py:        Creates an `HDUList` instance from a file-like object.\nastropy\/io\/fits\/hdu\/hdulist.py:        Creates an `HDUList` instance from a string or other in-memory data\nastropy\/io\/fits\/hdu\/hdulist.py:        :meth:`HDUList.fromfile`, but does not accept the mode or memmap\nastropy\/io\/fits\/hdu\/hdulist.py:            string) the returned :class:`HDUList`'s data portions will also be\nastropy\/io\/fits\/hdu\/hdulist.py:        hdul : HDUList\nastropy\/io\/fits\/hdu\/hdulist.py:            An :class:`HDUList` object representing the in-memory FITS file.\nastropy\/io\/fits\/hdu\/hdulist.py:        of the indexed HDU within any associated file.  The values are\nastropy\/io\/fits\/hdu\/hdulist.py:        no intervening changes to the `HDUList`.\nastropy\/io\/fits\/hdu\/hdulist.py:            Index of HDU for which info is to be returned.\nastropy\/io\/fits\/hdu\/hdulist.py:            the indexed HDU within an associated file.  Returns `None`\nastropy\/io\/fits\/hdu\/hdulist.py:            when the HDU is not associated with a file.\nastropy\/io\/fits\/hdu\/hdulist.py:            Dictionary contents:\nastropy\/io\/fits\/hdu\/hdulist.py:            file       File object associated with the HDU\nastropy\/io\/fits\/hdu\/hdulist.py:            datSpan    Data size including padding\nastropy\/io\/fits\/hdu\/hdulist.py:                # OK, the HDU associated with this index is not yet\nastropy\/io\/fits\/hdu\/hdulist.py:                # tied to the file associated with the HDUList.  The only way\nastropy\/io\/fits\/hdu\/hdulist.py:                # to get the file object is to check each of the HDU's in the\nastropy\/io\/fits\/hdu\/hdulist.py:        Insert an HDU into the `HDUList` at the given ``index``.\nastropy\/io\/fits\/hdu\/hdulist.py:            Index before which to insert the new HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:        hdu : HDU object\nastropy\/io\/fits\/hdu\/hdulist.py:            The HDU object to insert\nastropy\/io\/fits\/hdu\/hdulist.py:        if not isinstance(hdu, _BaseHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:            raise ValueError('{} is not an HDU.'.format(hdu))\nastropy\/io\/fits\/hdu\/hdulist.py:                # We are inserting a new Primary HDU so we need to\nastropy\/io\/fits\/hdu\/hdulist.py:                # make the current Primary HDU into an extension HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:                if isinstance(self[0], GroupsHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                        \"The current Primary HDU is a GroupsHDU.  \"\nastropy\/io\/fits\/hdu\/hdulist.py:                        \"It can't be made into an extension HDU, \"\nastropy\/io\/fits\/hdu\/hdulist.py:                        \"so another HDU cannot be inserted before it.\")\nastropy\/io\/fits\/hdu\/hdulist.py:                hdu1 = ImageHDU(self[0].data, self[0].header)\nastropy\/io\/fits\/hdu\/hdulist.py:                # Insert it into position 1, then delete HDU at position 0.\nastropy\/io\/fits\/hdu\/hdulist.py:            if not isinstance(hdu, (PrimaryHDU, _NonstandardHDU)):\nastropy\/io\/fits\/hdu\/hdulist.py:                # You passed in an Extension HDU but we need a Primary HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:                # If you provided an ImageHDU then we can convert it to\nastropy\/io\/fits\/hdu\/hdulist.py:                # a primary HDU and use that.\nastropy\/io\/fits\/hdu\/hdulist.py:                if isinstance(hdu, ImageHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                    hdu = PrimaryHDU(hdu.data, hdu.header)\nastropy\/io\/fits\/hdu\/hdulist.py:                    # You didn't provide an ImageHDU so we create a\nastropy\/io\/fits\/hdu\/hdulist.py:                    # simple Primary HDU and append that first before\nastropy\/io\/fits\/hdu\/hdulist.py:                    # we append the new Extension HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:                    phdu = PrimaryHDU()\nastropy\/io\/fits\/hdu\/hdulist.py:            if isinstance(hdu, GroupsHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                raise ValueError('A GroupsHDU must be inserted as a '\nastropy\/io\/fits\/hdu\/hdulist.py:                                 'Primary HDU.')\nastropy\/io\/fits\/hdu\/hdulist.py:            if isinstance(hdu, PrimaryHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                # You passed a Primary HDU but we need an Extension HDU\nastropy\/io\/fits\/hdu\/hdulist.py:                # so create an Extension HDU from the input Primary HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:                hdu = ImageHDU(hdu.data, hdu.header)\nastropy\/io\/fits\/hdu\/hdulist.py:        # make sure the EXTEND keyword is in primary HDU if there is extension\nastropy\/io\/fits\/hdu\/hdulist.py:        Append a new HDU to the `HDUList`.\nastropy\/io\/fits\/hdu\/hdulist.py:        hdu : HDU object\nastropy\/io\/fits\/hdu\/hdulist.py:            HDU to add to the `HDUList`.\nastropy\/io\/fits\/hdu\/hdulist.py:        if not isinstance(hdu, _BaseHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:            raise ValueError('HDUList can only append an HDU.')\nastropy\/io\/fits\/hdu\/hdulist.py:            if isinstance(hdu, GroupsHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                    \"Can't append a GroupsHDU to a non-empty HDUList\")\nastropy\/io\/fits\/hdu\/hdulist.py:            if isinstance(hdu, PrimaryHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                # You passed a Primary HDU but we need an Extension HDU\nastropy\/io\/fits\/hdu\/hdulist.py:                # so create an Extension HDU from the input Primary HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:                # TODO: This isn't necessarily sufficient to copy the HDU;\nastropy\/io\/fits\/hdu\/hdulist.py:                hdu = ImageHDU(hdu.data, hdu.header)\nastropy\/io\/fits\/hdu\/hdulist.py:            if not isinstance(hdu, (PrimaryHDU, _NonstandardHDU)):\nastropy\/io\/fits\/hdu\/hdulist.py:                # You passed in an Extension HDU but we need a Primary\nastropy\/io\/fits\/hdu\/hdulist.py:                # HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:                # If you provided an ImageHDU then we can convert it to\nastropy\/io\/fits\/hdu\/hdulist.py:                # a primary HDU and use that.\nastropy\/io\/fits\/hdu\/hdulist.py:                if isinstance(hdu, ImageHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                    hdu = PrimaryHDU(hdu.data, hdu.header)\nastropy\/io\/fits\/hdu\/hdulist.py:                    # You didn't provide an ImageHDU so we create a\nastropy\/io\/fits\/hdu\/hdulist.py:                    # simple Primary HDU and append that first before\nastropy\/io\/fits\/hdu\/hdulist.py:                    # we append the new Extension HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:                    phdu = PrimaryHDU()\nastropy\/io\/fits\/hdu\/hdulist.py:        # make sure the EXTEND keyword is in primary HDU if there is extension\nastropy\/io\/fits\/hdu\/hdulist.py:        Get the index of an HDU from the `HDUList`.\nastropy\/io\/fits\/hdu\/hdulist.py:           The key identifying the HDU.  If ``key`` is a tuple, it is of the\nastropy\/io\/fits\/hdu\/hdulist.py:           match the HDU being searched for.\nastropy\/io\/fits\/hdu\/hdulist.py:           the duplicate HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:           The index of the HDU in the `HDUList`.\nastropy\/io\/fits\/hdu\/hdulist.py:            # 'PRIMARY' should always work as a reference to the first HDU\nastropy\/io\/fits\/hdu\/hdulist.py:        knowing the length of the HDUList, which in turn means loading\nastropy\/io\/fits\/hdu\/hdulist.py:        all HDUs.  Therefore using negative indices on HDULists is inherently\nastropy\/io\/fits\/hdu\/hdulist.py:        Read data of all HDUs into memory.\nastropy\/io\/fits\/hdu\/hdulist.py:        Force a write of the `HDUList` back to the file (for append and\nastropy\/io\/fits\/hdu\/hdulist.py:                # only append HDU's which are \"new\"\nastropy\/io\/fits\/hdu\/hdulist.py:                            print('append HDU', hdu.name, extver)\nastropy\/io\/fits\/hdu\/hdulist.py:        Make sure that if the primary header needs the keyword ``EXTEND`` that\nastropy\/io\/fits\/hdu\/hdulist.py:        if not isinstance(self[0], PrimaryHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:            # A PrimaryHDU will be automatically inserted at some point, but it\nastropy\/io\/fits\/hdu\/hdulist.py:        if 'EXTEND' in hdr:\nastropy\/io\/fits\/hdu\/hdulist.py:            if not hdr['EXTEND'] and get_first_ext() is not None:\nastropy\/io\/fits\/hdu\/hdulist.py:                hdr['EXTEND'] = True\nastropy\/io\/fits\/hdu\/hdulist.py:                hdr.set('EXTEND', True, after='NAXIS')\nastropy\/io\/fits\/hdu\/hdulist.py:                hdr.set('EXTEND', True, after='NAXIS' + str(n))\nastropy\/io\/fits\/hdu\/hdulist.py:        Write the `HDUList` to a new file.\nastropy\/io\/fits\/hdu\/hdulist.py:            ``OSError`` if ``False`` and the output file exists. Default is\nastropy\/io\/fits\/hdu\/hdulist.py:            When `True` adds both ``DATASUM`` and ``CHECKSUM`` cards\nastropy\/io\/fits\/hdu\/hdulist.py:            to the headers of all HDU's written to the file.\nastropy\/io\/fits\/hdu\/hdulist.py:        # make sure the EXTEND keyword is there if there is extension\nastropy\/io\/fits\/hdu\/hdulist.py:            # Give individual HDUs an opportunity to do on-close cleanup\nastropy\/io\/fits\/hdu\/hdulist.py:        Summarize the info of the HDUs in this `HDUList`.\nastropy\/io\/fits\/hdu\/hdulist.py:            the HDU info.  Writes to ``sys.stdout`` by default.\nastropy\/io\/fits\/hdu\/hdulist.py:            name = '(No file associated with this HDUList)'\nastropy\/io\/fits\/hdu\/hdulist.py:                   'No.    Name      Ver    Type      Cards   Dimensions   Format']\nastropy\/io\/fits\/hdu\/hdulist.py:        Return the file name associated with the HDUList object if one exists.\nastropy\/io\/fits\/hdu\/hdulist.py:                   HDUList object if an association exists.  Otherwise returns\nastropy\/io\/fits\/hdu\/hdulist.py:        Provides the implementations from HDUList.fromfile and\nastropy\/io\/fits\/hdu\/hdulist.py:        HDUList.fromstring, both of which wrap this method, as their\nastropy\/io\/fits\/hdu\/hdulist.py:            # This method is currently only called from HDUList.fromstring and\nastropy\/io\/fits\/hdu\/hdulist.py:            # HDUList.fromfile.  If fileobj is None then this must be the\nastropy\/io\/fits\/hdu\/hdulist.py:            # _BaseHDU.fromstring call.\nastropy\/io\/fits\/hdu\/hdulist.py:            # the HDUs--just writing to the output file\nastropy\/io\/fits\/hdu\/hdulist.py:        # Make sure at least the PRIMARY HDU can be read\nastropy\/io\/fits\/hdu\/hdulist.py:            # Go ahead and load all HDUs\nastropy\/io\/fits\/hdu\/hdulist.py:        Attempt an operation that accesses an HDU by index\/name\nastropy\/io\/fits\/hdu\/hdulist.py:        that can fail if not all HDUs have been read yet.  Keep\nastropy\/io\/fits\/hdu\/hdulist.py:        reading HDUs until the operation succeeds or there are no\nastropy\/io\/fits\/hdu\/hdulist.py:        more HDUs to read.\nastropy\/io\/fits\/hdu\/hdulist.py:        Lazily load a single HDU from the fileobj or data string the `HDUList`\nastropy\/io\/fits\/hdu\/hdulist.py:        was opened from, unless no further HDUs are found.\nastropy\/io\/fits\/hdu\/hdulist.py:        Returns True if a new HDU was loaded, or False otherwise.\nastropy\/io\/fits\/hdu\/hdulist.py:        saved_compression_enabled = compressed.COMPRESSION_ENABLED\nastropy\/io\/fits\/hdu\/hdulist.py:                compressed.COMPRESSION_ENABLED = False\nastropy\/io\/fits\/hdu\/hdulist.py:            # read all HDUs\nastropy\/io\/fits\/hdu\/hdulist.py:                        # HDU\nastropy\/io\/fits\/hdu\/hdulist.py:                        hdu = _BaseHDU.readfrom(fileobj, **kwargs)\nastropy\/io\/fits\/hdu\/hdulist.py:                    hdu = _BaseHDU.fromstring(data, **kwargs)\nastropy\/io\/fits\/hdu\/hdulist.py:                    # Check for an extension HDU and update the EXTEND\nastropy\/io\/fits\/hdu\/hdulist.py:                    # keyword of the primary HDU accordingly\nastropy\/io\/fits\/hdu\/hdulist.py:            # check in the case there is extra space after the last HDU or\nastropy\/io\/fits\/hdu\/hdulist.py:            # corrupted HDU\nastropy\/io\/fits\/hdu\/hdulist.py:                    'Error validating header for HDU #{} (note: Astropy '\nastropy\/io\/fits\/hdu\/hdulist.py:                    'There may be extra bytes after the last HDU or the '\nastropy\/io\/fits\/hdu\/hdulist.py:            compressed.COMPRESSION_ENABLED = saved_compression_enabled\nastropy\/io\/fits\/hdu\/hdulist.py:        errs = _ErrList([], unit='HDU')\nastropy\/io\/fits\/hdu\/hdulist.py:        # the first (0th) element must be a primary HDU\nastropy\/io\/fits\/hdu\/hdulist.py:        if len(self) > 0 and (not isinstance(self[0], PrimaryHDU)) and \\\nastropy\/io\/fits\/hdu\/hdulist.py:                             (not isinstance(self[0], _NonstandardHDU)):\nastropy\/io\/fits\/hdu\/hdulist.py:            err_text = \"HDUList's 0th element is not a primary HDU.\"\nastropy\/io\/fits\/hdu\/hdulist.py:            fix_text = 'Fixed by inserting one as 0th HDU.'\nastropy\/io\/fits\/hdu\/hdulist.py:                self.insert(0, PrimaryHDU())\nastropy\/io\/fits\/hdu\/hdulist.py:        if len(self) > 1 and ('EXTEND' not in self[0].header or\nastropy\/io\/fits\/hdu\/hdulist.py:                              self[0].header['EXTEND'] is not True):\nastropy\/io\/fits\/hdu\/hdulist.py:            err_text = ('Primary HDU does not contain an EXTEND keyword '\nastropy\/io\/fits\/hdu\/hdulist.py:                        'equal to T even though there are extension HDUs.')\nastropy\/io\/fits\/hdu\/hdulist.py:            fix_text = 'Fixed by inserting or updating the EXTEND keyword.'\nastropy\/io\/fits\/hdu\/hdulist.py:                header.set('EXTEND', value=True, after=after)\nastropy\/io\/fits\/hdu\/hdulist.py:            if idx > 0 and (not isinstance(hdu, ExtensionHDU)):\nastropy\/io\/fits\/hdu\/hdulist.py:                err_text = (\"HDUList's element {} is not an \"\nastropy\/io\/fits\/hdu\/hdulist.py:                            \"extension HDU.\".format(str(idx)))\nastropy\/io\/fits\/hdu\/hdulist.py:            # Need to all _prewriteto() for each HDU first to determine if\nastropy\/io\/fits\/hdu\/hdulist.py:            # if the HDUList is resized, need to write out the entire contents of\nastropy\/io\/fits\/hdu\/hdulist.py:        Implements flushing changes in update mode when parts of one or more HDU\nastropy\/io\/fits\/hdu\/hdulist.py:            # The underlying file is an actual file object.  The HDUList is\nastropy\/io\/fits\/hdu\/hdulist.py:                # on each HDU\nastropy\/io\/fits\/hdu\/hdulist.py:        Determine if any changes to the HDUList will require a file resize\nastropy\/io\/fits\/hdu\/hdulist.py:            # determine if any of the HDU is resized\nastropy\/io\/fits\/hdu\/hdulist.py:                # Data:\nastropy\/io\/ascii\/fixedwidth.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/fixedwidth.py:from .core import InconsistentTableError, DefaultSplitter\nastropy\/io\/ascii\/fixedwidth.py:class FixedWidthHeaderSplitter(DefaultSplitter):\nastropy\/io\/ascii\/fixedwidth.py:                # Define self.col_starts and self.col_ends so that the call to\nastropy\/io\/ascii\/fixedwidth.py:class FixedWidthData(basic.BasicData):\nastropy\/io\/ascii\/fixedwidth.py:    data_class = FixedWidthData\nastropy\/io\/ascii\/fixedwidth.py:class FixedWidthNoHeaderData(FixedWidthData):\nastropy\/io\/ascii\/fixedwidth.py:    '''Data reader for fixed width tables with no header line'''\nastropy\/io\/ascii\/fixedwidth.py:    data_class = FixedWidthNoHeaderData\nastropy\/io\/ascii\/fixedwidth.py:    splitter_class = DefaultSplitter\nastropy\/io\/ascii\/fixedwidth.py:class FixedWidthTwoLineDataSplitter(FixedWidthSplitter):\nastropy\/io\/ascii\/fixedwidth.py:class FixedWidthTwoLineData(FixedWidthData):\nastropy\/io\/ascii\/fixedwidth.py:    '''Data reader for fixed with tables with two header lines.'''\nastropy\/io\/ascii\/fixedwidth.py:    splitter_class = FixedWidthTwoLineDataSplitter\nastropy\/io\/ascii\/fixedwidth.py:    data_class = FixedWidthTwoLineData\nastropy\/io\/fits\/hdu\/base.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/base.py:class _Delayed:\nastropy\/io\/fits\/hdu\/base.py:DELAYED = _Delayed()\nastropy\/io\/fits\/hdu\/base.py:BITPIX2DTYPE = {8: 'uint8', 16: 'int16', 32: 'int32', 64: 'int64',\nastropy\/io\/fits\/hdu\/base.py:DTYPE2BITPIX = {'uint8': 8, 'int16': 16, 'uint16': 16, 'int32': 32,\nastropy\/io\/fits\/hdu\/base.py:class InvalidHDUException(Exception):\nastropy\/io\/fits\/hdu\/base.py:    A custom exception class used mainly to signal to _BaseHDU.__new__ that\nastropy\/io\/fits\/hdu\/base.py:    an HDU cannot possibly be considered valid, and must be assumed to be\nastropy\/io\/fits\/hdu\/base.py:    Used primarily by _BaseHDU.__new__ to find an appropriate HDU class to use\nastropy\/io\/fits\/hdu\/base.py:    based on values in the header.  See the _BaseHDU.__new__ docstring.\nastropy\/io\/fits\/hdu\/base.py:                # HDU classes built into astropy.io.fits are always considered,\nastropy\/io\/fits\/hdu\/base.py:                # but extension HDUs must be explicitly registered\nastropy\/io\/fits\/hdu\/base.py:                    'An exception occurred matching an HDU header to the '\nastropy\/io\/fits\/hdu\/base.py:                    'appropriate HDU type: {0}'.format(exc),\nastropy\/io\/fits\/hdu\/base.py:                warnings.warn('The HDU will be treated as corrupted.',\nastropy\/io\/fits\/hdu\/base.py:                klass = _CorruptedHDU\nastropy\/io\/fits\/hdu\/base.py:class _BaseHDUMeta(type):\nastropy\/io\/fits\/hdu\/base.py:        # data.deleter to all HDUs with a data property.\nastropy\/io\/fits\/hdu\/base.py:                # Don't do anything if the class has already explicitly\nastropy\/io\/fits\/hdu\/base.py:                        # Don't even do this unless the *only* reference to the\nastropy\/io\/fits\/hdu\/base.py:# TODO: Come up with a better __repr__ for HDUs (and for HDULists, for that\nastropy\/io\/fits\/hdu\/base.py:class _BaseHDU(metaclass=_BaseHDUMeta):\nastropy\/io\/fits\/hdu\/base.py:    \"\"\"Base class for all HDU (header data unit) classes.\"\"\"\nastropy\/io\/fits\/hdu\/base.py:    # This HDU type is part of the FITS standard\nastropy\/io\/fits\/hdu\/base.py:        Iterates through the subclasses of _BaseHDU and uses that class's\nastropy\/io\/fits\/hdu\/base.py:        depth-last order.  Each match_header() should identify an HDU type as\nastropy\/io\/fits\/hdu\/base.py:        match_header(), the type is taken to be _CorruptedHDU.\nastropy\/io\/fits\/hdu\/base.py:        # still points to the same data array as when the HDU was originally\nastropy\/io\/fits\/hdu\/base.py:        if 'DATASUM' in self._header and 'CHECKSUM' not in self._header:\nastropy\/io\/fits\/hdu\/base.py:        return ('data' in self.__dict__ and self.data is not DELAYED)\nastropy\/io\/fits\/hdu\/base.py:        Creates a new HDU object of the appropriate type from a string\nastropy\/io\/fits\/hdu\/base.py:        containing the HDU's entire header and, optionally, its data.\nastropy\/io\/fits\/hdu\/base.py:        Note: When creating a new HDU from a string without a backing file\nastropy\/io\/fits\/hdu\/base.py:        object, the data of that HDU may be read-only.  It depends on whether\nastropy\/io\/fits\/hdu\/base.py:           A byte string containing the HDU's header and data.\nastropy\/io\/fits\/hdu\/base.py:           Check the HDU's checksum and\/or datasum.\nastropy\/io\/fits\/hdu\/base.py:           corrupt HDU.  In this case the assumption is that the first 2880\nastropy\/io\/fits\/hdu\/base.py:           May consist of additional keyword arguments specific to an HDU\nastropy\/io\/fits\/hdu\/base.py:           different HDU classes such as `PrimaryHDU`, `ImageHDU`, or\nastropy\/io\/fits\/hdu\/base.py:           `BinTableHDU`.  Any unrecognized keyword arguments are simply\nastropy\/io\/fits\/hdu\/base.py:        Read the HDU from a file.  Normally an HDU should be opened with\nastropy\/io\/fits\/hdu\/base.py:        :func:`open` which reads the entire HDU list in a FITS file.  But this\nastropy\/io\/fits\/hdu\/base.py:            beginning of the HDU.\nastropy\/io\/fits\/hdu\/base.py:            If `True`, verifies that both ``DATASUM`` and ``CHECKSUM`` card\nastropy\/io\/fits\/hdu\/base.py:            values (when present in the HDU header) match the header and data\nastropy\/io\/fits\/hdu\/base.py:            of all HDU's in the file.\nastropy\/io\/fits\/hdu\/base.py:            Do not issue an exception when opening a file that is missing an\nastropy\/io\/fits\/hdu\/base.py:            ``END`` card in the last header.\nastropy\/io\/fits\/hdu\/base.py:        # TODO: Figure out a way to make it possible for the _File\nastropy\/io\/fits\/hdu\/base.py:        Write the HDU to a new file. This is a convenience method to\nastropy\/io\/fits\/hdu\/base.py:        provide a user easier output interface if only one HDU needs\nastropy\/io\/fits\/hdu\/base.py:            ``OSError`` if ``False`` and the output file exists. Default is\nastropy\/io\/fits\/hdu\/base.py:            When `True` adds both ``DATASUM`` and ``CHECKSUM`` cards\nastropy\/io\/fits\/hdu\/base.py:            to the header of the HDU when written to the file.\nastropy\/io\/fits\/hdu\/base.py:        from .hdulist import HDUList\nastropy\/io\/fits\/hdu\/base.py:        hdulist = HDUList([self])\nastropy\/io\/fits\/hdu\/base.py:        # Determine the appropriate arguments to pass to the constructor from\nastropy\/io\/fits\/hdu\/base.py:        # that may or may not be valid depending on the HDU type\nastropy\/io\/fits\/hdu\/base.py:        if Parameter.VAR_KEYWORD not in (x.kind for x in sig.parameters.values()):\nastropy\/io\/fits\/hdu\/base.py:        hdu = cls(data=DELAYED, header=header, **new_kwargs)\nastropy\/io\/fits\/hdu\/base.py:        # Checksums are not checked on invalid HDU types\nastropy\/io\/fits\/hdu\/base.py:        if checksum and checksum != 'remove' and isinstance(hdu, _ValidHDU):\nastropy\/io\/fits\/hdu\/base.py:        Return raw array from either the HDU's memory buffer or underlying\nastropy\/io\/fits\/hdu\/base.py:    # TODO: Rework checksum handling so that it's not necessary to add a\nastropy\/io\/fits\/hdu\/base.py:    # TODO: The BaseHDU class shouldn't even handle checksums since they're\nastropy\/io\/fits\/hdu\/base.py:    # only implemented on _ValidHDU...\nastropy\/io\/fits\/hdu\/base.py:            # CompImageHDUs need TFIELDS immediately after GCOUNT,\nastropy\/io\/fits\/hdu\/base.py:            # so BSCALE has to go after TFIELDS if it exists.\nastropy\/io\/fits\/hdu\/base.py:            if 'TFIELDS' in self._header:\nastropy\/io\/fits\/hdu\/base.py:                self._header.set('BSCALE', 1, after='TFIELDS')\nastropy\/io\/fits\/hdu\/base.py:                         datasum_keyword='DATASUM'):\nastropy\/io\/fits\/hdu\/base.py:        \"\"\"Update the 'CHECKSUM' and 'DATASUM' keywords in the header (or\nastropy\/io\/fits\/hdu\/base.py:        and ``datasum_keyword`` arguments--see for example ``CompImageHDU``\nastropy\/io\/fits\/hdu\/base.py:                               'DATASUM' not in self._header or\nastropy\/io\/fits\/hdu\/base.py:        # TODO: A lot of the simulateonly stuff should be moved back into the\nastropy\/io\/fits\/hdu\/base.py:                # TODO: Not that this is ever likely, but if for some odd\nastropy\/io\/fits\/hdu\/base.py:        HDU types, so that should be implemented in this method.\nastropy\/io\/fits\/hdu\/base.py:    # TODO: This is the start of moving HDU writing out of the _File class;\nastropy\/io\/fits\/hdu\/base.py:    # HDUList, eventually the plan is to have this be moved into writeto()\nastropy\/io\/fits\/hdu\/base.py:            # Set the various data location attributes on newly-written HDUs\nastropy\/io\/fits\/hdu\/base.py:            # different from before depending on if previous HDUs were resized\nastropy\/io\/fits\/hdu\/base.py:_AllHDU = _BaseHDU\nastropy\/io\/fits\/hdu\/base.py:# TODO: register_hdu could be made into a class decorator which would be pretty\nastropy\/io\/fits\/hdu\/base.py:register_hdu = _BaseHDU.register_hdu\nastropy\/io\/fits\/hdu\/base.py:unregister_hdu = _BaseHDU.unregister_hdu\nastropy\/io\/fits\/hdu\/base.py:class _CorruptedHDU(_BaseHDU):\nastropy\/io\/fits\/hdu\/base.py:    A Corrupted HDU class.\nastropy\/io\/fits\/hdu\/base.py:    ``END`` cards.  A corrupted HDU usually means that the data size\nastropy\/io\/fits\/hdu\/base.py:    cannot be calculated or the ``END`` card is not found.  In the case\nastropy\/io\/fits\/hdu\/base.py:    of a missing ``END`` card, the `Header` may also contain the binary\nastropy\/io\/fits\/hdu\/base.py:       extension is a `TableHDU` containing ASCII data.\nastropy\/io\/fits\/hdu\/base.py:        Returns the size (in bytes) of the HDU's data part.\nastropy\/io\/fits\/hdu\/base.py:        return (self.name, self.ver, 'CorruptedHDU')\nastropy\/io\/fits\/hdu\/base.py:class _NonstandardHDU(_BaseHDU, _Verify):\nastropy\/io\/fits\/hdu\/base.py:    A Non-standard HDU class.\nastropy\/io\/fits\/hdu\/base.py:    This class is used for a Primary HDU when the ``SIMPLE`` Card has\nastropy\/io\/fits\/hdu\/base.py:    a value of `False`.  A non-standard HDU comes from a file that\nastropy\/io\/fits\/hdu\/base.py:    in the DEC VAX internal storage format rather than the standard\nastropy\/io\/fits\/hdu\/base.py:    FITS most significant byte first.  The header for this HDU should\nastropy\/io\/fits\/hdu\/base.py:    be valid.  The data for this HDU is read from the file as a byte\nastropy\/io\/fits\/hdu\/base.py:    stream that begins at the first byte after the header ``END`` card\nastropy\/io\/fits\/hdu\/base.py:        Matches any HDU that has the 'SIMPLE' keyword but is not a standard\nastropy\/io\/fits\/hdu\/base.py:        Primary or Groups HDU.\nastropy\/io\/fits\/hdu\/base.py:        # match_header for GroupsHDU will always be called before this one.\nastropy\/io\/fits\/hdu\/base.py:                raise InvalidHDUException\nastropy\/io\/fits\/hdu\/base.py:        Returns the size (in bytes) of the HDU's data part.\nastropy\/io\/fits\/hdu\/base.py:        Differs from the base class :class:`_writedata` in that it doesn't\nastropy\/io\/fits\/hdu\/base.py:        return (self.name, self.ver, 'NonstandardHDU', len(self._header))\nastropy\/io\/fits\/hdu\/base.py:class _ValidHDU(_BaseHDU, _Verify):\nastropy\/io\/fits\/hdu\/base.py:    Base class for all HDUs which are not corrupted.\nastropy\/io\/fits\/hdu\/base.py:        Matches any HDU that is not recognized as having either the SIMPLE or\nastropy\/io\/fits\/hdu\/base.py:        TODO: Maybe it would make more sense to use _NonstandardHDU in this\nastropy\/io\/fits\/hdu\/base.py:        Size (in bytes) of the data portion of the HDU.\nastropy\/io\/fits\/hdu\/base.py:        Calculates and returns the number of bytes that this HDU will write to\nastropy\/io\/fits\/hdu\/base.py:        # TODO: Fix this once new HDU writing API is settled on\nastropy\/io\/fits\/hdu\/base.py:        of this HDU within any associated file.  The values are only\nastropy\/io\/fits\/hdu\/base.py:        intervening changes to the `HDUList`.\nastropy\/io\/fits\/hdu\/base.py:           this HDU within an associated file.  Returns `None` when\nastropy\/io\/fits\/hdu\/base.py:           the HDU is not associated with a file.\nastropy\/io\/fits\/hdu\/base.py:           Dictionary contents:\nastropy\/io\/fits\/hdu\/base.py:           file       File object associated with the HDU\nastropy\/io\/fits\/hdu\/base.py:           datSpan    Data size including padding\nastropy\/io\/fits\/hdu\/base.py:        Make a copy of the HDU, both header and data are copied.\nastropy\/io\/fits\/hdu\/base.py:        is_valid = BITPIX2DTYPE.__contains__\nastropy\/io\/fits\/hdu\/base.py:        # Do the first card here, instead of in the respective HDU classes, so\nastropy\/io\/fits\/hdu\/base.py:        if isinstance(self, ExtensionHDU):\nastropy\/io\/fits\/hdu\/base.py:                                            fix=fix, fix_text=\"Deleted.\"))\nastropy\/io\/fits\/hdu\/base.py:    # TODO: Improve this API a little bit--for one, most of these arguments\nastropy\/io\/fits\/hdu\/base.py:            multiple HDUs and multiple calls to `req_cards`.\nastropy\/io\/fits\/hdu\/base.py:    def add_datasum(self, when=None, datasum_keyword='DATASUM'):\nastropy\/io\/fits\/hdu\/base.py:        Add the ``DATASUM`` card to this HDU with the value set to the\nastropy\/io\/fits\/hdu\/base.py:            this is typically 'DATASUM' per convention, but there exist\nastropy\/io\/fits\/hdu\/base.py:                     checksum_keyword='CHECKSUM', datasum_keyword='DATASUM'):\nastropy\/io\/fits\/hdu\/base.py:        Add the ``CHECKSUM`` and ``DATASUM`` cards to this HDU with\nastropy\/io\/fits\/hdu\/base.py:        the values set to the checksum calculated for the HDU and the\nastropy\/io\/fits\/hdu\/base.py:        data respectively.  The addition of the ``DATASUM`` card may\nastropy\/io\/fits\/hdu\/base.py:            when = 'HDU checksum updated {}'.format(self._get_timestamp())\nastropy\/io\/fits\/hdu\/base.py:        Verify that the value in the ``DATASUM`` keyword matches the value\nastropy\/io\/fits\/hdu\/base.py:        calculated for the ``DATASUM`` of the current HDU data.\nastropy\/io\/fits\/hdu\/base.py:           - 2 - no ``DATASUM`` keyword present\nastropy\/io\/fits\/hdu\/base.py:        if 'DATASUM' in self._header:\nastropy\/io\/fits\/hdu\/base.py:            if datasum == int(self._header['DATASUM']):\nastropy\/io\/fits\/hdu\/base.py:        value calculated for the current HDU CHECKSUM.\nastropy\/io\/fits\/hdu\/base.py:            if 'DATASUM' in self._header:\nastropy\/io\/fits\/hdu\/base.py:                    'Checksum verification failed for HDU {0}.\\n'.format(\nastropy\/io\/fits\/hdu\/base.py:        if 'DATASUM' in self._header:\nastropy\/io\/fits\/hdu\/base.py:            self._datasum = self._header['DATASUM']\nastropy\/io\/fits\/hdu\/base.py:                    'Datasum verification failed for HDU {0}.\\n'.format(\nastropy\/io\/fits\/hdu\/base.py:        Calculate the value for the ``DATASUM`` card in the HDU.\nastropy\/io\/fits\/hdu\/base.py:        Calculate the value of the ``CHECKSUM`` card in the HDU.\nastropy\/io\/fits\/hdu\/base.py:    # _MASK and _EXCLUDE used for encoding the checksum value into a character\nastropy\/io\/fits\/hdu\/base.py:    _EXCLUDE = [0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,\nastropy\/io\/fits\/hdu\/base.py:            for x in self._EXCLUDE:\nastropy\/io\/fits\/hdu\/base.py:class ExtensionHDU(_ValidHDU):\nastropy\/io\/fits\/hdu\/base.py:    An extension HDU class.\nastropy\/io\/fits\/hdu\/base.py:    This class is the base class for the `TableHDU`, `ImageHDU`, and\nastropy\/io\/fits\/hdu\/base.py:    `BinTableHDU` classes.\nastropy\/io\/fits\/hdu\/base.py:        extension HDU type should be used for a specific extension, or\nastropy\/io\/fits\/hdu\/base.py:        NonstandardExtHDU should be used.\nastropy\/io\/fits\/hdu\/base.py:        `PrimaryHDU` are required by extension HDUs (which cannot stand on\nastropy\/io\/fits\/hdu\/base.py:        from .hdulist import HDUList\nastropy\/io\/fits\/hdu\/base.py:        from .image import PrimaryHDU\nastropy\/io\/fits\/hdu\/base.py:        hdulist = HDUList([PrimaryHDU(), self])\nastropy\/io\/fits\/hdu\/base.py:# TODO: Mark this as deprecated\nastropy\/io\/fits\/hdu\/base.py:_ExtensionHDU = ExtensionHDU\nastropy\/io\/fits\/hdu\/base.py:class NonstandardExtHDU(ExtensionHDU):\nastropy\/io\/fits\/hdu\/base.py:    A Non-standard Extension HDU class.\nastropy\/io\/fits\/hdu\/base.py:    This class is used for an Extension HDU when the ``XTENSION``\nastropy\/io\/fits\/hdu\/base.py:    out how big the data is but not what it is.  The data for this HDU\nastropy\/io\/fits\/hdu\/base.py:    byte after the header ``END`` card and continues until the\nastropy\/io\/fits\/hdu\/base.py:        Matches any extension HDU that is not one of the standard extension HDU\nastropy\/io\/fits\/hdu\/base.py:        # A3DTABLE is not really considered a 'standard' extension, as it was\nastropy\/io\/fits\/hdu\/base.py:        # implementation handles A3DTABLE HDUs it is listed here.\nastropy\/io\/fits\/hdu\/base.py:        standard_xtensions = ('IMAGE', 'TABLE', 'BINTABLE', 'A3DTABLE')\nastropy\/io\/fits\/hdu\/base.py:        return (self.name, self.ver, 'NonstandardExtHDU', len(self._header))\nastropy\/io\/fits\/hdu\/base.py:# TODO: Mark this as deprecated\nastropy\/io\/fits\/hdu\/base.py:_NonstandardExtHDU = NonstandardExtHDU\nastropy\/io\/votable\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/unit\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/unit\/unit.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_fitsheader.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_fitsheader.py:        fitsheader.main(['-k', 'RANDOMKEY', self.data('arange.fits')])\nastropy\/io\/fits\/tests\/test_fitsheader.py:        assert err.startswith('WARNING') and 'RANDOMKEY' in err\nastropy\/io\/fits\/tests\/test_fitsheader.py:        fitsheader.main(['-e', '3', '-k', 'BACKGRND', self.data('test0.fits')])\nastropy\/io\/fits\/tests\/test_fitsheader.py:        assert out.splitlines()[1].startswith('BACKGRND=                 312.')\nastropy\/io\/fits\/tests\/test_fitsheader.py:        fitsheader.main(['-e', '0', '-k', 'BACKGRND', self.data('test0.fits')])\nastropy\/io\/fits\/tests\/test_fitsheader.py:        fitsheader.main(['-t', '-k', 'BACKGRND', self.data('test0.fits')])\nastropy\/io\/fits\/tests\/test_fitsheader.py:        assert out[1].endswith('|   1 | BACKGRND | 316.0 |')\nastropy\/io\/fits\/tests\/test_fitsheader.py:        assert out[2].endswith('|   2 | BACKGRND | 351.0 |')\nastropy\/io\/fits\/tests\/test_fitsheader.py:        assert out[3].endswith('|   3 | BACKGRND | 312.0 |')\nastropy\/io\/fits\/tests\/test_fitsheader.py:        assert out[4].endswith('|   4 | BACKGRND | 323.0 |')\nastropy\/io\/misc\/asdf\/tags\/unit\/quantity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/unit\/quantity.py:from asdf.tags.core import NDArrayType\nastropy\/io\/misc\/asdf\/tags\/unit\/quantity.py:        if isinstance(value, NDArrayType):\nastropy\/io\/votable\/exceptions.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/exceptions.py:# STDLIB\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#toc-header-35>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:TABLEDATA>`__\nastropy\/io\/votable\/exceptions.py:        According to the XML standard, the attribute ``ID`` is a\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:name>`__,\nastropy\/io\/votable\/exceptions.py:    The VOTable 1.1 spec says the following about ``name`` vs. ``ID``\nastropy\/io\/votable\/exceptions.py:    on ``FIELD`` and ``VALUE`` elements:\nastropy\/io\/votable\/exceptions.py:        ``ID`` and ``name`` attributes have a different role in\nastropy\/io\/votable\/exceptions.py:        VOTable: the ``ID`` is meant as a *unique identifier* of an\nastropy\/io\/votable\/exceptions.py:        throughout the VOTable document. The ``ID`` attribute is\nastropy\/io\/votable\/exceptions.py:        referenced, but in principle any element may have an ``ID``\nastropy\/io\/votable\/exceptions.py:        attribute. ... In summary, the ``ID`` is different from the\nastropy\/io\/votable\/exceptions.py:        ``name`` attribute in that (a) the ``ID`` attribute is made\nastropy\/io\/votable\/exceptions.py:        relevant element with matching ``ID``.\nastropy\/io\/votable\/exceptions.py:        While the ``ID`` attribute has to be unique in a VOTable\nastropy\/io\/votable\/exceptions.py:        ``name`` attributes of ``FIELD``, ``PARAM`` and optional\nastropy\/io\/votable\/exceptions.py:    columns, ``ID`` is used for the column name when present.\nastropy\/io\/votable\/exceptions.py:    However, when ``ID`` is not present, (since it is not required by\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:name>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:name>`__\nastropy\/io\/votable\/exceptions.py:    message_template = \"Implicitly generating an ID from a name '{}' -> '{}'\"\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:link>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:link>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/vizier.u-strasbg.fr\/doc\/UCD.htx>`__.\nastropy\/io\/votable\/exceptions.py:    If the VOTable version is 1.2 or later, the UCD will also be\nastropy\/io\/votable\/exceptions.py:    by UCD1+.\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:ucd>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:ucd>`__\nastropy\/io\/votable\/exceptions.py:    message_template = \"Invalid UCD '{}': {}\"\nastropy\/io\/votable\/exceptions.py:    Defined in this XML Schema snippet::\nastropy\/io\/votable\/exceptions.py:    The VOTable specification uses the attribute name ``ID`` (with\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:name>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:name>`__\nastropy\/io\/votable\/exceptions.py:    message_template = \"ID attribute not capitalized\"\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC54>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC58>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:link>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:link>`__\nastropy\/io\/votable\/exceptions.py:    ``FIELD`` element must have either an ``ID`` or ``name`` attribute\nastropy\/io\/votable\/exceptions.py:    ``name`` is not present by ``ID`` is, and *pedantic mode* is off,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:name>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:name>`__\nastropy\/io\/votable\/exceptions.py:        \"'{}' element must have at least one of 'ID' or 'name' attributes\")\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:# W14: Deprecated\nastropy\/io\/votable\/exceptions.py:    The ``name`` attribute is required on every ``FIELD`` element.\nastropy\/io\/votable\/exceptions.py:    an ``ID`` instead.  In this case, when *pedantic mode* is off,\nastropy\/io\/votable\/exceptions.py:    ``vo.table`` will copy the ``name`` attribute to a new ``ID``\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:name>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:name>`__\nastropy\/io\/votable\/exceptions.py:# W16: Deprecated\nastropy\/io\/votable\/exceptions.py:    A ``DESCRIPTION`` element can only appear once within its parent\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC54>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC58>`__)\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:addesc>`__\nastropy\/io\/votable\/exceptions.py:    message_template = \"{} element contains more than one DESCRIPTION element\"\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC10>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC10>`__\nastropy\/io\/votable\/exceptions.py:    The column fields as defined using ``FIELD`` elements do not match\nastropy\/io\/votable\/exceptions.py:    Version 1.0 of the VOTable specification used the ``DEFINITIONS``\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:definitions>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:definitions>`__\nastropy\/io\/votable\/exceptions.py:    message_template = 'The DEFINITIONS element is deprecated in VOTable 1.1.  Ignoring'\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:utype>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/ivoa.net\/Documents\/latest\/VOTableSTC.html>`__.\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC54>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC58>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:    value must be specified in the FIELD descriptor to support reading\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:    Each field in a table must have a unique ID.  If two or more fields\nastropy\/io\/votable\/exceptions.py:    have the same ID, some will be renamed to ensure that all IDs are\nastropy\/io\/votable\/exceptions.py:        The ``ID`` and ``ref`` attributes are defined as XML types\nastropy\/io\/votable\/exceptions.py:        ``ID`` and ``IDREF`` respectively. This means that the\nastropy\/io\/votable\/exceptions.py:        contents of ``ID`` is an identifier which must be unique\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:name>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:name>`__\nastropy\/io\/votable\/exceptions.py:    message_template = \"Duplicate ID '{}' renamed to '{}' to ensure uniqueness\"\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:name>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:name>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.w3.org\/TR\/2000\/WD-xml-2e-20000814#NT-Nmtoken>`__.\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC54>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC32>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:values>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:values>`__\nastropy\/io\/votable\/exceptions.py:    vo.table are ``TABLEDATA``, ``BINARY`` and ``FITS``.\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:data>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:data>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:       In VOTable1.2, it is further recommended to place the ID\nastropy\/io\/votable\/exceptions.py:        ``ID`` attribute. When specified, the ``ref`` attribute\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC54>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC58>`__\nastropy\/io\/votable\/exceptions.py:        <FIELD name=\"unboundedString\" datatype=\"char\" arraysize=\"*\"\/>\nastropy\/io\/votable\/exceptions.py:    A 1D array of strings can be represented as a 2D array of\nastropy\/io\/votable\/exceptions.py:    in the FIELD specifier.\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:    insensitive) in the ``TABLEDATA`` format::\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:# E07: Deprecated\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:values>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:values>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:values>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:values>`__\nastropy\/io\/votable\/exceptions.py:    From VOTable 1.1 and later, ``FIELD`` and ``PARAM`` elements must have\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#elem:FIELD>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#elem:FIELD>`__\nastropy\/io\/votable\/exceptions.py:    default_args = ('FIELD',)\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:form>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:form>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:form>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:form>`__\nastropy\/io\/votable\/exceptions.py:        point in a 3D space can be defined by the following::\nastropy\/io\/votable\/exceptions.py:            <FIELD ID=\"point_3D\" datatype=\"double\" arraysize=\"3\"\/>\nastropy\/io\/votable\/exceptions.py:            <FIELD ID=\"values\" datatype=\"int\" arraysize=\"100*\"\/>\nastropy\/io\/votable\/exceptions.py:            <FIELD ID=\"thumbs\" datatype=\"unsignedByte\" arraysize=\"64\u00d764\u00d710*\"\/>\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:dim>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:dim>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#elem:FIELD>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#elem:FIELD>`__\nastropy\/io\/votable\/exceptions.py:    All ``COOSYS`` elements must have an ``ID`` attribute.\nastropy\/io\/votable\/exceptions.py:    message_template = \"ID attribute is required for all COOSYS elements\"\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#elem:COOSYS>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC54>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC58>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC54>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC58>`__\nastropy\/io\/votable\/exceptions.py:    message_template = \"Data has more columns than are defined in the header ({})\"\nastropy\/io\/votable\/exceptions.py:    message_template = \"Data has fewer columns ({}) than are defined in the header ({})\"\nastropy\/io\/misc\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/hdu\/compressed.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/compressed.py:from .base import DELAYED, ExtensionHDU, BITPIX2DTYPE, DTYPE2BITPIX\nastropy\/io\/fits\/hdu\/compressed.py:from .image import ImageHDU\nastropy\/io\/fits\/hdu\/compressed.py:from .table import BinTableHDU\nastropy\/io\/fits\/hdu\/compressed.py:from ..column import Column, ColDefs, TDEF_RE\nastropy\/io\/fits\/hdu\/compressed.py:from ..column import KEYWORD_NAMES as TABLE_KEYWORD_NAMES\nastropy\/io\/fits\/hdu\/compressed.py:from ....utils.exceptions import (AstropyPendingDeprecationWarning,\nastropy\/io\/fits\/hdu\/compressed.py:    COMPRESSION_SUPPORTED = COMPRESSION_ENABLED = True\nastropy\/io\/fits\/hdu\/compressed.py:    COMPRESSION_SUPPORTED = COMPRESSION_ENABLED = False\nastropy\/io\/fits\/hdu\/compressed.py:NO_DITHER = -1\nastropy\/io\/fits\/hdu\/compressed.py:SUBTRACTIVE_DITHER_1 = 1\nastropy\/io\/fits\/hdu\/compressed.py:SUBTRACTIVE_DITHER_2 = 2\nastropy\/io\/fits\/hdu\/compressed.py:QUANTIZE_METHOD_NAMES = {\nastropy\/io\/fits\/hdu\/compressed.py:    NO_DITHER: 'NO_DITHER',\nastropy\/io\/fits\/hdu\/compressed.py:    SUBTRACTIVE_DITHER_1: 'SUBTRACTIVE_DITHER_1',\nastropy\/io\/fits\/hdu\/compressed.py:    SUBTRACTIVE_DITHER_2: 'SUBTRACTIVE_DITHER_2'\nastropy\/io\/fits\/hdu\/compressed.py:DITHER_SEED_CLOCK = 0\nastropy\/io\/fits\/hdu\/compressed.py:DITHER_SEED_CHECKSUM = -1\nastropy\/io\/fits\/hdu\/compressed.py:# Default compression parameter values\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_COMPRESSION_TYPE = 'RICE_1'\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_QUANTIZE_LEVEL = 16.\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_QUANTIZE_METHOD = NO_DITHER\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_DITHER_SEED = DITHER_SEED_CLOCK\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_HCOMP_SCALE = 0\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_HCOMP_SMOOTH = 0\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_BLOCK_SIZE = 32\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_BYTE_PIX = 4\nastropy\/io\/fits\/hdu\/compressed.py:if COMPRESSION_SUPPORTED:\nastropy\/io\/fits\/hdu\/compressed.py:        CFITSIO_SUPPORTS_GZIPDATA = compression.CFITSIO_VERSION >= 3.28\nastropy\/io\/fits\/hdu\/compressed.py:        CFITSIO_SUPPORTS_GZIPDATA = True\nastropy\/io\/fits\/hdu\/compressed.py:COMPRESSION_KEYWORDS = {'ZIMAGE', 'ZCMPTYPE', 'ZBITPIX', 'ZNAXIS', 'ZMASKCMP',\nastropy\/io\/fits\/hdu\/compressed.py:                        'ZSIMPLE', 'ZTENSION', 'ZEXTEND'}\nastropy\/io\/fits\/hdu\/compressed.py:    Header object for compressed image HDUs designed to keep the compression\nastropy\/io\/fits\/hdu\/compressed.py:    # TODO: The difficulty of implementing this screams a need to rewrite this\nastropy\/io\/fits\/hdu\/compressed.py:        'NAXIS': 'ZNAXIS', 'EXTEND': 'ZEXTEND', 'BLOCKED': 'ZBLOCKED',\nastropy\/io\/fits\/hdu\/compressed.py:        'DATASUM': 'ZDATASUM'\nastropy\/io\/fits\/hdu\/compressed.py:        ['ZIMAGE', 'ZCMPTYPE', 'ZMASKCMP', 'ZQUANTIZ', 'ZDITHER0'])\nastropy\/io\/fits\/hdu\/compressed.py:    # TODO: Once it place it should be possible to manage some of this through\nastropy\/io\/fits\/hdu\/compressed.py:    # makes more sense to change CompImageHDU to subclass ImageHDU :\/\nastropy\/io\/fits\/hdu\/compressed.py:            # Determine condition to pass through to append\nastropy\/io\/fits\/hdu\/compressed.py:        if keyword == 'TFIELDS':\nastropy\/io\/fits\/hdu\/compressed.py:        m = TDEF_RE.match(keyword)\nastropy\/io\/fits\/hdu\/compressed.py:        if m and m.group('label').upper() in TABLE_KEYWORD_NAMES:\nastropy\/io\/fits\/hdu\/compressed.py:        # the name used for it in the COMPRESSED HDU header\nastropy\/io\/fits\/hdu\/compressed.py:# TODO: Fix this class so that it doesn't actually inherit from BinTableHDU,\nastropy\/io\/fits\/hdu\/compressed.py:# but instead has an internal BinTableHDU reference\nastropy\/io\/fits\/hdu\/compressed.py:class CompImageHDU(BinTableHDU):\nastropy\/io\/fits\/hdu\/compressed.py:    Compressed Image HDU class.\nastropy\/io\/fits\/hdu\/compressed.py:    DEPRECATED_KWARGS = {\nastropy\/io\/fits\/hdu\/compressed.py:                 compression_type=DEFAULT_COMPRESSION_TYPE,\nastropy\/io\/fits\/hdu\/compressed.py:                 hcomp_scale=DEFAULT_HCOMP_SCALE,\nastropy\/io\/fits\/hdu\/compressed.py:                 hcomp_smooth=DEFAULT_HCOMP_SMOOTH,\nastropy\/io\/fits\/hdu\/compressed.py:                 quantize_level=DEFAULT_QUANTIZE_LEVEL,\nastropy\/io\/fits\/hdu\/compressed.py:                 quantize_method=DEFAULT_QUANTIZE_METHOD,\nastropy\/io\/fits\/hdu\/compressed.py:                 dither_seed=DEFAULT_DITHER_SEED,\nastropy\/io\/fits\/hdu\/compressed.py:            Header to be associated with the image; when reading the HDU from a\nastropy\/io\/fits\/hdu\/compressed.py:            file (data=DELAYED), the header read from the file\nastropy\/io\/fits\/hdu\/compressed.py:            input image header then the default name ``COMPRESSED_IMAGE`` is\nastropy\/io\/fits\/hdu\/compressed.py:            Compression tile sizes.  Default treats each row of image as a\nastropy\/io\/fits\/hdu\/compressed.py:            ``NO_DITHER`` (-1), ``SUBTRACTIVE_DITHER_1`` (1; default), or\nastropy\/io\/fits\/hdu\/compressed.py:            ``SUBTRACTIVE_DITHER_2`` (2); see note below\nastropy\/io\/fits\/hdu\/compressed.py:            range 1 to 1000 (inclusive), ``DITHER_SEED_CLOCK`` (0; default), or\nastropy\/io\/fits\/hdu\/compressed.py:            ``DITHER_SEED_CHECKSUM`` (-1); see note below\nastropy\/io\/fits\/hdu\/compressed.py:               the ``_File`` class, not in the `CompImageHDU` class.  The file\nastropy\/io\/fits\/hdu\/compressed.py:            2) The `CompImageHDU` class supports the FITS tiled image\nastropy\/io\/fits\/hdu\/compressed.py:        ``SUBTRACTIVE_DITHER_1`` adds dithering to the zero-point of the\nastropy\/io\/fits\/hdu\/compressed.py:        pixel (see below).  The other method, ``SUBTRACTIVE_DITHER_2``, is\nastropy\/io\/fits\/hdu\/compressed.py:        ``NO_DITHER`` disables dithering entirely.\nastropy\/io\/fits\/hdu\/compressed.py:        ``ZDITHER0`` keyword in the header of the compressed HDU.  In order to\nastropy\/io\/fits\/hdu\/compressed.py:        (``DITHER_SEED_CLOCK``) or based on a checksum of the pixels in the\nastropy\/io\/fits\/hdu\/compressed.py:        image's first tile (``DITHER_SEED_CHECKSUM``).  The clock-based method\nastropy\/io\/fits\/hdu\/compressed.py:        if not COMPRESSION_SUPPORTED:\nastropy\/io\/fits\/hdu\/compressed.py:            # TODO: Raise a more specific Exception type\nastropy\/io\/fits\/hdu\/compressed.py:                            'available.  Creation of compressed image HDUs is '\nastropy\/io\/fits\/hdu\/compressed.py:        for oldarg, newarg in self.DEPRECATED_KWARGS.items():\nastropy\/io\/fits\/hdu\/compressed.py:                              AstropyPendingDeprecationWarning)\nastropy\/io\/fits\/hdu\/compressed.py:        if data is DELAYED:\nastropy\/io\/fits\/hdu\/compressed.py:            # Reading the HDU from a file\nastropy\/io\/fits\/hdu\/compressed.py:            # Create at least a skeleton HDU that matches the input\nastropy\/io\/fits\/hdu\/compressed.py:        # TODO: A lot of this should be passed on to an internal image HDU o\nastropy\/io\/fits\/hdu\/compressed.py:        if xtension not in ('BINTABLE', 'A3DTABLE'):\nastropy\/io\/fits\/hdu\/compressed.py:        if COMPRESSION_SUPPORTED and COMPRESSION_ENABLED:\nastropy\/io\/fits\/hdu\/compressed.py:        elif not COMPRESSION_SUPPORTED:\nastropy\/io\/fits\/hdu\/compressed.py:                          'HDU: The compression module is not available.\\n'\nastropy\/io\/fits\/hdu\/compressed.py:                          'The HDU will be treated as a Binary Table HDU.',\nastropy\/io\/fits\/hdu\/compressed.py:        call this method after assigning new data to the `CompImageHDU`\nastropy\/io\/fits\/hdu\/compressed.py:            input image header then the default name 'COMPRESSED_IMAGE' is used\nastropy\/io\/fits\/hdu\/compressed.py:            NO_DITHER (-1), SUBTRACTIVE_DITHER_1 (1; default), or\nastropy\/io\/fits\/hdu\/compressed.py:            SUBTRACTIVE_DITHER_2 (2)\nastropy\/io\/fits\/hdu\/compressed.py:            range 1 to 1000 (inclusive), DITHER_SEED_CLOCK (0; default), or\nastropy\/io\/fits\/hdu\/compressed.py:            DITHER_SEED_CHECKSUM (-1)\nastropy\/io\/fits\/hdu\/compressed.py:        image_hdu = ImageHDU(data=self.data, header=self._header)\nastropy\/io\/fits\/hdu\/compressed.py:        # Determine based on the size of the input data whether to use the Q\nastropy\/io\/fits\/hdu\/compressed.py:            name = 'COMPRESSED_IMAGE'\nastropy\/io\/fits\/hdu\/compressed.py:                             after='TFIELDS')\nastropy\/io\/fits\/hdu\/compressed.py:                    'Default ({}) compression will be used.'\nastropy\/io\/fits\/hdu\/compressed.py:                            DEFAULT_COMPRESSION_TYPE),\nastropy\/io\/fits\/hdu\/compressed.py:                compression_type = DEFAULT_COMPRESSION_TYPE\nastropy\/io\/fits\/hdu\/compressed.py:                             'compression algorithm', after='TFIELDS')\nastropy\/io\/fits\/hdu\/compressed.py:                                                DEFAULT_COMPRESSION_TYPE)\nastropy\/io\/fits\/hdu\/compressed.py:        self._header.set('TTYPE1', 'COMPRESSED_DATA', 'label for field 1',\nastropy\/io\/fits\/hdu\/compressed.py:                         after='TFIELDS')\nastropy\/io\/fits\/hdu\/compressed.py:            # floating point image has 'COMPRESSED_DATA',\nastropy\/io\/fits\/hdu\/compressed.py:            # 'UNCOMPRESSED_DATA', 'ZSCALE', and 'ZZERO' columns (unless using\nastropy\/io\/fits\/hdu\/compressed.py:            # CFITSIO 3.28 and up automatically use the GZIP_COMPRESSED_DATA\nastropy\/io\/fits\/hdu\/compressed.py:            # of the UNCOMPRESSED_DATA column.  There's no way to control\nastropy\/io\/fits\/hdu\/compressed.py:            if CFITSIO_SUPPORTS_GZIPDATA:\nastropy\/io\/fits\/hdu\/compressed.py:                ttype2 = 'GZIP_COMPRESSED_DATA'\nastropy\/io\/fits\/hdu\/compressed.py:                # The required format for the GZIP_COMPRESSED_DATA is actually\nastropy\/io\/fits\/hdu\/compressed.py:                # Q format is not supported for UNCOMPRESSED_DATA columns.\nastropy\/io\/fits\/hdu\/compressed.py:                ttype2 = 'UNCOMPRESSED_DATA'\nastropy\/io\/fits\/hdu\/compressed.py:                    tform2 = '1QD' if huge_hdu else '1PD'\nastropy\/io\/fits\/hdu\/compressed.py:            self._header.set('TFORM3', '1D',\nastropy\/io\/fits\/hdu\/compressed.py:                             'data format of field: 8-byte DOUBLE',\nastropy\/io\/fits\/hdu\/compressed.py:            self._header.set('TFORM4', '1D',\nastropy\/io\/fits\/hdu\/compressed.py:                             'data format of field: 8-byte DOUBLE',\nastropy\/io\/fits\/hdu\/compressed.py:            # Create the ColDefs object for the table\nastropy\/io\/fits\/hdu\/compressed.py:            cols = ColDefs([col1, col2, col3, col4])\nastropy\/io\/fits\/hdu\/compressed.py:            # default table has just one 'COMPRESSED_DATA' column\nastropy\/io\/fits\/hdu\/compressed.py:            # Create the ColDefs object for the table\nastropy\/io\/fits\/hdu\/compressed.py:            cols = ColDefs([col1])\nastropy\/io\/fits\/hdu\/compressed.py:        # image HDU, the data type of the image data and the number of\nastropy\/io\/fits\/hdu\/compressed.py:        self._header.set('TFIELDS', ncols, 'number of fields in each row',\nastropy\/io\/fits\/hdu\/compressed.py:        # size to match the HDU's data.\nastropy\/io\/fits\/hdu\/compressed.py:                          'Default tile size will be used.', AstropyUserWarning)\nastropy\/io\/fits\/hdu\/compressed.py:                # The Hcompress algorithm is inherently 2D in nature, so the\nastropy\/io\/fits\/hdu\/compressed.py:                    # Default tile size\nastropy\/io\/fits\/hdu\/compressed.py:            quantize_level = DEFAULT_QUANTIZE_LEVEL\nastropy\/io\/fits\/hdu\/compressed.py:            hcomp_scale = DEFAULT_HCOMP_SCALE\nastropy\/io\/fits\/hdu\/compressed.py:            hcomp_smooth = DEFAULT_HCOMP_SCALE\nastropy\/io\/fits\/hdu\/compressed.py:            self._header.set('ZVAL1', DEFAULT_BLOCK_SIZE, 'pixels per block',\nastropy\/io\/fits\/hdu\/compressed.py:                bytepix = DEFAULT_BYTE_PIX\nastropy\/io\/fits\/hdu\/compressed.py:                if quantize_method not in [NO_DITHER, SUBTRACTIVE_DITHER_1,\nastropy\/io\/fits\/hdu\/compressed.py:                                           SUBTRACTIVE_DITHER_2]:\nastropy\/io\/fits\/hdu\/compressed.py:                    name = QUANTIZE_METHOD_NAMES[DEFAULT_QUANTIZE_METHOD]\nastropy\/io\/fits\/hdu\/compressed.py:                                  'Default method ({}) used.'.format(name))\nastropy\/io\/fits\/hdu\/compressed.py:                    quantize_method = DEFAULT_QUANTIZE_METHOD\nastropy\/io\/fits\/hdu\/compressed.py:                if quantize_method == NO_DITHER:\nastropy\/io\/fits\/hdu\/compressed.py:                                 QUANTIZE_METHOD_NAMES[quantize_method],\nastropy\/io\/fits\/hdu\/compressed.py:                # no dithering, rather than whatever DEFAULT_QUANTIZE_METHOD\nastropy\/io\/fits\/hdu\/compressed.py:                quantize_method = self._header.get('ZQUANTIZ', NO_DITHER)\nastropy\/io\/fits\/hdu\/compressed.py:                    for k, v in QUANTIZE_METHOD_NAMES.items():\nastropy\/io\/fits\/hdu\/compressed.py:                        quantize_method = NO_DITHER\nastropy\/io\/fits\/hdu\/compressed.py:            if quantize_method == NO_DITHER:\nastropy\/io\/fits\/hdu\/compressed.py:                if 'ZDITHER0' in self._header:\nastropy\/io\/fits\/hdu\/compressed.py:                    # keep the ZDITHER0 keyword\nastropy\/io\/fits\/hdu\/compressed.py:                    del self._header['ZDITHER0']\nastropy\/io\/fits\/hdu\/compressed.py:                elif 'ZDITHER0' in self._header:\nastropy\/io\/fits\/hdu\/compressed.py:                    dither_seed = self._header['ZDITHER0']\nastropy\/io\/fits\/hdu\/compressed.py:                            DEFAULT_DITHER_SEED)\nastropy\/io\/fits\/hdu\/compressed.py:                self._header.set('ZDITHER0', dither_seed,\nastropy\/io\/fits\/hdu\/compressed.py:            # Move EXTEND card from the image header to the\nastropy\/io\/fits\/hdu\/compressed.py:            # table header as ZEXTEND card.\nastropy\/io\/fits\/hdu\/compressed.py:            if 'EXTEND' in image_header:\nastropy\/io\/fits\/hdu\/compressed.py:                self._header.set('ZEXTEND', image_header['EXTEND'],\nastropy\/io\/fits\/hdu\/compressed.py:                                 image_header.comments['EXTEND'])\nastropy\/io\/fits\/hdu\/compressed.py:            # Move BLOCKED card from the image header to the\nastropy\/io\/fits\/hdu\/compressed.py:            # table header as ZBLOCKED card.\nastropy\/io\/fits\/hdu\/compressed.py:            if 'BLOCKED' in image_header:\nastropy\/io\/fits\/hdu\/compressed.py:                self._header.set('ZBLOCKED', image_header['BLOCKED'],\nastropy\/io\/fits\/hdu\/compressed.py:                                 image_header.comments['BLOCKED'])\nastropy\/io\/fits\/hdu\/compressed.py:            # Move CHECKSUM and DATASUM cards from the image header to the\nastropy\/io\/fits\/hdu\/compressed.py:            # table header as XHECKSUM and XDATASUM cards.\nastropy\/io\/fits\/hdu\/compressed.py:            if 'DATASUM' in image_header:\nastropy\/io\/fits\/hdu\/compressed.py:                self._header.set('ZDATASUM', image_header['DATASUM'],\nastropy\/io\/fits\/hdu\/compressed.py:                                 image_header.comments['DATASUM'])\nastropy\/io\/fits\/hdu\/compressed.py:        # Right out of _ImageBaseHDU.data\nastropy\/io\/fits\/hdu\/compressed.py:            raise TypeError('CompImageHDU data has incorrect type:{}; '\nastropy\/io\/fits\/hdu\/compressed.py:        # Deleting the compressed_data attribute has to be handled\nastropy\/io\/fits\/hdu\/compressed.py:        # Determine from the values read from the header\nastropy\/io\/fits\/hdu\/compressed.py:        # Delete cards that are related to the table.  And move\nastropy\/io\/fits\/hdu\/compressed.py:        # Delete any other spurious NAXISn keywords:\nastropy\/io\/fits\/hdu\/compressed.py:        # Although PCOUNT and GCOUNT are considered mandatory for IMAGE HDUs,\nastropy\/io\/fits\/hdu\/compressed.py:        # ZPCOUNT and ZGCOUNT are optional, probably because for IMAGE HDUs\nastropy\/io\/fits\/hdu\/compressed.py:        if 'ZEXTEND' in self._header:\nastropy\/io\/fits\/hdu\/compressed.py:            image_header.set('EXTEND', self._header['ZEXTEND'],\nastropy\/io\/fits\/hdu\/compressed.py:                             self._header.comments['ZEXTEND'])\nastropy\/io\/fits\/hdu\/compressed.py:        if 'ZBLOCKED' in self._header:\nastropy\/io\/fits\/hdu\/compressed.py:            image_header.set('BLOCKED', self._header['ZBLOCKED'],\nastropy\/io\/fits\/hdu\/compressed.py:                             self._header.comments['ZBLOCKED'])\nastropy\/io\/fits\/hdu\/compressed.py:        # Move the ZHECKSUM and ZDATASUM cards to the image header\nastropy\/io\/fits\/hdu\/compressed.py:        # as CHECKSUM and DATASUM\nastropy\/io\/fits\/hdu\/compressed.py:        if 'ZDATASUM' in self._header:\nastropy\/io\/fits\/hdu\/compressed.py:            image_header.set('DATASUM', self._header['ZDATASUM'],\nastropy\/io\/fits\/hdu\/compressed.py:                             self._header.comments['ZDATASUM'])\nastropy\/io\/fits\/hdu\/compressed.py:        # is the default value of COMPRESSED_IMAGE.\nastropy\/io\/fits\/hdu\/compressed.py:                self._header['EXTNAME'] == 'COMPRESSED_IMAGE'):\nastropy\/io\/fits\/hdu\/compressed.py:        Summarize the HDU: name, dimensions, and formats.\nastropy\/io\/fits\/hdu\/compressed.py:            _format = BITPIX2DTYPE[self.header['BITPIX']]\nastropy\/io\/fits\/hdu\/compressed.py:        image_bitpix = DTYPE2BITPIX[self.data.dtype.name]\nastropy\/io\/fits\/hdu\/compressed.py:        # TODO: This is copied right out of _ImageBaseHDU._writedata_internal;\nastropy\/io\/fits\/hdu\/compressed.py:        # it would be cool if we could use an internal ImageHDU and use that to\nastropy\/io\/fits\/hdu\/compressed.py:        # Determine the destination (numpy) data type\nastropy\/io\/fits\/hdu\/compressed.py:            type = BITPIX2DTYPE[self._bitpix]\nastropy\/io\/fits\/hdu\/compressed.py:        # Determine how to scale the data\nastropy\/io\/fits\/hdu\/compressed.py:        # Do the scaling\nastropy\/io\/fits\/hdu\/compressed.py:            # Delete from both headers\nastropy\/io\/fits\/hdu\/compressed.py:        self._bitpix = DTYPE2BITPIX[self.data.dtype.name]\nastropy\/io\/fits\/hdu\/compressed.py:        # TODO: Make this more clear by using self._image_header, but only once\nastropy\/io\/fits\/hdu\/compressed.py:            self.scale(BITPIX2DTYPE[self._orig_bitpix])\nastropy\/io\/fits\/hdu\/compressed.py:            # Shove the image header and data into a new ImageHDU and use that\nastropy\/io\/fits\/hdu\/compressed.py:            image_hdu = ImageHDU(data=self.data, header=self.header)\nastropy\/io\/fits\/hdu\/compressed.py:                # ZDATASUM keyword\nastropy\/io\/fits\/hdu\/compressed.py:            if 'DATASUM' in image_hdu.header:\nastropy\/io\/fits\/hdu\/compressed.py:                self._image_header.set('DATASUM', image_hdu.header['DATASUM'],\nastropy\/io\/fits\/hdu\/compressed.py:                                       image_hdu.header.comments['DATASUM'])\nastropy\/io\/fits\/hdu\/compressed.py:            # the .data attribute on the HDU so that the call to _writedata\nastropy\/io\/fits\/hdu\/compressed.py:        Bypasses `BinTableHDU._writeheader()` which updates the header with\nastropy\/io\/fits\/hdu\/compressed.py:        why this class maybe shouldn't inherit directly from BinTableHDU...\nastropy\/io\/fits\/hdu\/compressed.py:        return ExtensionHDU._writeheader(self, fileobj)\nastropy\/io\/fits\/hdu\/compressed.py:    # TODO: This was copied right out of _ImageBaseHDU; get rid of it once we\nastropy\/io\/fits\/hdu\/compressed.py:    # ImageHDU\nastropy\/io\/fits\/hdu\/compressed.py:        Determine the dtype that the data should be converted to depending on\nastropy\/io\/fits\/hdu\/compressed.py:                self.header['BITPIX'] = DTYPE2BITPIX[dtype.name]\nastropy\/io\/fits\/hdu\/compressed.py:        if seed == DITHER_SEED_CHECKSUM:\nastropy\/io\/fits\/hdu\/compressed.py:            # Determine the tile dimensions from the ZTILEn keywords\nastropy\/io\/fits\/hdu\/compressed.py:        elif seed == DITHER_SEED_CLOCK:\nastropy\/io\/fits\/hdu\/compressed.py:            # is that CFITSIO incorporates the HDU number into the result in\nastropy\/io\/fits\/hdu\/compressed.py:            # generated for two HDUs at the same time.  Here instead we just\nastropy\/io\/fits\/hdu\/compressed.py:            # add in the HDU object's id\nastropy\/io\/fits\/hdu\/table.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/table.py:from .base import DELAYED, _ValidHDU, ExtensionHDU\nastropy\/io\/fits\/hdu\/table.py:from ..column import (FITS2NUMPY, KEYWORD_NAMES, KEYWORD_TO_ATTRIBUTE,\nastropy\/io\/fits\/hdu\/table.py:                      ATTRIBUTE_TO_KEYWORD, TDEF_RE, Column, ColDefs,\nastropy\/io\/fits\/hdu\/table.py:                      _AsciiColDefs, _FormatP, _FormatQ, _makep,\nastropy\/io\/fits\/hdu\/table.py:class FITSTableDumpDialect(csv.excel):\nastropy\/io\/fits\/hdu\/table.py:class _TableLikeHDU(_ValidHDU):\nastropy\/io\/fits\/hdu\/table.py:    A class for HDUs that have table-like data.  This is used for both\nastropy\/io\/fits\/hdu\/table.py:    Binary\/ASCII tables as well as Random Access Group HDUs (which are\nastropy\/io\/fits\/hdu\/table.py:    otherwise too dissimilar for tables to use _TableBaseHDU directly).\nastropy\/io\/fits\/hdu\/table.py:    _columns_type = ColDefs\nastropy\/io\/fits\/hdu\/table.py:    # TODO: Temporary flag representing whether uints are enabled; remove this\nastropy\/io\/fits\/hdu\/table.py:        This is an abstract HDU type for HDUs that contain table-like data.\nastropy\/io\/fits\/hdu\/table.py:        This is even more abstract than _TableBaseHDU which is specifically for\nastropy\/io\/fits\/hdu\/table.py:        Given either a `ColDefs` object, a sequence of `Column` objects,\nastropy\/io\/fits\/hdu\/table.py:        or another table HDU or table data (a `FITS_rec` or multi-field\nastropy\/io\/fits\/hdu\/table.py:        `numpy.ndarray` or `numpy.recarray` object, return a new table HDU of\nastropy\/io\/fits\/hdu\/table.py:        columns : sequence of `Column`, `ColDefs`, or other\nastropy\/io\/fits\/hdu\/table.py:            a column-like structure from which a `ColDefs` can be instantiated.\nastropy\/io\/fits\/hdu\/table.py:            This includes an existing `BinTableHDU` or `TableHDU`, or a\nastropy\/io\/fits\/hdu\/table.py:            An optional `Header` object to instantiate the new HDU yet.  Header\nastropy\/io\/fits\/hdu\/table.py:            HDU. By default this is `False` and (unicode) strings are returned,\nastropy\/io\/fits\/hdu\/table.py:        Any additional keyword arguments accepted by the HDU class's\nastropy\/io\/fits\/hdu\/table.py:        The :class:`ColDefs` objects describing the columns in this table.\nastropy\/io\/fits\/hdu\/table.py:        # definitions come from, so just return an empty ColDefs\nastropy\/io\/fits\/hdu\/table.py:        return ColDefs([])\nastropy\/io\/fits\/hdu\/table.py:        Table-like HDUs must provide an attribute that specifies the number of\nastropy\/io\/fits\/hdu\/table.py:        rows in the HDU's table.\nastropy\/io\/fits\/hdu\/table.py:        \"\"\"Get the table data from an input HDU object.\"\"\"\nastropy\/io\/fits\/hdu\/table.py:        # TODO: Details related to variable length arrays need to be dealt with\nastropy\/io\/fits\/hdu\/table.py:        # specifically in the BinTableHDU class, since they're a detail\nastropy\/io\/fits\/hdu\/table.py:                # This can happen when a brand new table HDU is being created\nastropy\/io\/fits\/hdu\/table.py:        Update the data upon addition of a new column through the `ColDefs`\nastropy\/io\/fits\/hdu\/table.py:        # TODO: It's not clear that this actually works--it probably does not.\nastropy\/io\/fits\/hdu\/table.py:        Update the data upon removal of a column through the `ColDefs`\nastropy\/io\/fits\/hdu\/table.py:class _TableBaseHDU(ExtensionHDU, _TableLikeHDU):\nastropy\/io\/fits\/hdu\/table.py:    FITS table extension base HDU class.\nastropy\/io\/fits\/hdu\/table.py:        Data to be used.\nastropy\/io\/fits\/hdu\/table.py:        The ver of the HDU, will be the value of the keyword ``EXTVER``.\nastropy\/io\/fits\/hdu\/table.py:    This is included primarily as an optimization for compressed image HDUs\nastropy\/io\/fits\/hdu\/table.py:        if data is DELAYED:\nastropy\/io\/fits\/hdu\/table.py:                raise ValueError('No header to setup HDU.')\nastropy\/io\/fits\/hdu\/table.py:                ('TFIELDS', 0, 'number of table fields')]\nastropy\/io\/fits\/hdu\/table.py:                    # TODO: I need to read this code a little more closely\nastropy\/io\/fits\/hdu\/table.py:                # TODO: Too much of the code in this class uses header keywords\nastropy\/io\/fits\/hdu\/table.py:                self._header['TFIELDS'] = len(self.data._coldefs)\nastropy\/io\/fits\/hdu\/table.py:                    # Make the ndarrays in the Column objects of the ColDefs\nastropy\/io\/fits\/hdu\/table.py:                    # object of the HDU reference the same ndarray as the HDU's\nastropy\/io\/fits\/hdu\/table.py:                    # Delete the _arrays attribute so that it is recreated to\nastropy\/io\/fits\/hdu\/table.py:        the ASCII and Binary Table HDU types, which should be used instead of\nastropy\/io\/fits\/hdu\/table.py:        The :class:`ColDefs` objects describing the columns in this table.\nastropy\/io\/fits\/hdu\/table.py:                # Make the ndarrays in the Column objects of the ColDefs\nastropy\/io\/fits\/hdu\/table.py:                # object of the HDU reference the same ndarray as the HDU's\nastropy\/io\/fits\/hdu\/table.py:                # Delete the _arrays attribute so that it is recreated to\nastropy\/io\/fits\/hdu\/table.py:    # TODO: Need to either rename this to update_header, for symmetry with the\nastropy\/io\/fits\/hdu\/table.py:    # Image HDUs, or just at some point deprecate it and remove it altogether,\nastropy\/io\/fits\/hdu\/table.py:        self._header.set('TFIELDS', len(self.columns), after='GCOUNT')\nastropy\/io\/fits\/hdu\/table.py:        Make a copy of the table HDU, both header and data are copied.\nastropy\/io\/fits\/hdu\/table.py:            # check TFIELDS and NAXIS2\nastropy\/io\/fits\/hdu\/table.py:            self._header['TFIELDS'] = len(self.data._coldefs)\nastropy\/io\/fits\/hdu\/table.py:        _TableBaseHDU verify method.\nastropy\/io\/fits\/hdu\/table.py:        self.req_cards('TFIELDS', 7,\nastropy\/io\/fits\/hdu\/table.py:        tfields = self._header['TFIELDS']\nastropy\/io\/fits\/hdu\/table.py:        Summarize the HDU: name, dimensions, and formats.\nastropy\/io\/fits\/hdu\/table.py:            ncols = self._header['TFIELDS']\nastropy\/io\/fits\/hdu\/table.py:        # base_keyword is the keyword without the index such as TDIM\nastropy\/io\/fits\/hdu\/table.py:        # while keyword is like TDIM1\nastropy\/io\/fits\/hdu\/table.py:        base_keyword = ATTRIBUTE_TO_KEYWORD[attr]\nastropy\/io\/fits\/hdu\/table.py:            keyword_idx = KEYWORD_NAMES.index(base_keyword)\nastropy\/io\/fits\/hdu\/table.py:            # Determine the appropriate keyword to insert this one before\/after\nastropy\/io\/fits\/hdu\/table.py:            for before_keyword in reversed(KEYWORD_NAMES[:keyword_idx]):\nastropy\/io\/fits\/hdu\/table.py:                for after_keyword in KEYWORD_NAMES[keyword_idx + 1:]:\nastropy\/io\/fits\/hdu\/table.py:            match = TDEF_RE.match(keyword)\nastropy\/io\/fits\/hdu\/table.py:            if base_keyword in KEYWORD_TO_ATTRIBUTE:\nastropy\/io\/fits\/hdu\/table.py:            # Also decrement TFIELDS\nastropy\/io\/fits\/hdu\/table.py:            if 'TFIELDS' in self._header:\nastropy\/io\/fits\/hdu\/table.py:                self._header['TFIELDS'] -= 1\nastropy\/io\/fits\/hdu\/table.py:            for keyword, attr in KEYWORD_TO_ATTRIBUTE.items():\nastropy\/io\/fits\/hdu\/table.py:class TableHDU(_TableBaseHDU):\nastropy\/io\/fits\/hdu\/table.py:    FITS ASCII table extension HDU class.\nastropy\/io\/fits\/hdu\/table.py:        Data to be used.\nastropy\/io\/fits\/hdu\/table.py:        The ver of the HDU, will be the value of the keyword ``EXTVER``.\nastropy\/io\/fits\/hdu\/table.py:    _columns_type = _AsciiColDefs\nastropy\/io\/fits\/hdu\/table.py:        r'(?P<code>[ADEFIJ])(?P<width>\\d+)(?:\\.(?P<prec>\\d+))?')\nastropy\/io\/fits\/hdu\/table.py:            raise ValueError(\"Duplicate field names: {}\".format(dup))\nastropy\/io\/fits\/hdu\/table.py:        # TODO: Determine if this extra logic is necessary--I feel like the\nastropy\/io\/fits\/hdu\/table.py:        # _AsciiColDefs class should be responsible for telling the table what\nastropy\/io\/fits\/hdu\/table.py:        Calculate the value for the ``DATASUM`` card in the HDU.\nastropy\/io\/fits\/hdu\/table.py:        `TableHDU` verify method.\nastropy\/io\/fits\/hdu\/table.py:        tfields = self._header['TFIELDS']\nastropy\/io\/fits\/hdu\/table.py:class BinTableHDU(_TableBaseHDU):\nastropy\/io\/fits\/hdu\/table.py:    Binary table HDU class.\nastropy\/io\/fits\/hdu\/table.py:        Data to be used.\nastropy\/io\/fits\/hdu\/table.py:        The ver of the HDU, will be the value of the keyword ``EXTVER``.\nastropy\/io\/fits\/hdu\/table.py:                xtension in (cls._extension, 'A3DTABLE'))\nastropy\/io\/fits\/hdu\/table.py:        Calculate the value for the ``DATASUM`` card given the input data\nastropy\/io\/fits\/hdu\/table.py:            # TODO: The following code may no longer be necessary since it is\nastropy\/io\/fits\/hdu\/table.py:        Calculate the value for the ``DATASUM`` card in the HDU.\nastropy\/io\/fits\/hdu\/table.py:          (``TDISPn``).  The fourth field provides the physical units\nastropy\/io\/fits\/hdu\/table.py:          multidimensional array (``TDIMn``).  The sixth field provides the\nastropy\/io\/fits\/hdu\/table.py:          definition of a single HDU header card as represented by the card\nastropy\/io\/fits\/hdu\/table.py:        Dump the table HDU to a file in ASCII format.  The table may be dumped\nastropy\/io\/fits\/hdu\/table.py:            fits file associated with this HDU appended with the\nastropy\/io\/fits\/hdu\/table.py:            ``OSError`` if ``False`` and the output file exists. Default is\nastropy\/io\/fits\/hdu\/table.py:            the creation of the new table and HDU.  Otherwise this Header\nastropy\/io\/fits\/hdu\/table.py:            coldefs = ColDefs(data)\nastropy\/io\/fits\/hdu\/table.py:        # Create a new HDU using the supplied header and data\nastropy\/io\/fits\/hdu\/table.py:        Write the table data in the ASCII format read by BinTableHDU.load()\nastropy\/io\/fits\/hdu\/table.py:        linewriter = csv.writer(fileobj, dialect=FITSTableDumpDialect)\nastropy\/io\/fits\/hdu\/table.py:        BinTableHDU.load() to fileobj.\nastropy\/io\/fits\/hdu\/table.py:        Read the table data from the ASCII file output by BinTableHDU.dump().\nastropy\/io\/fits\/hdu\/table.py:        linereader = csv.reader(fileobj, dialect=FITSTableDumpDialect)\nastropy\/io\/fits\/hdu\/table.py:        # TODO: The handling of VLAs could probably be simplified a bit\nastropy\/io\/fits\/hdu\/table.py:        # TODO: In the future maybe enable loading a bit at a time so that we\nastropy\/io\/fits\/hdu\/table.py:        hdu = BinTableHDU.from_columns(np.recarray(shape=1, dtype=dtype),\nastropy\/io\/fits\/hdu\/table.py:        # TODO: It seems to me a lot of this could\/should be handled from\nastropy\/io\/fits\/hdu\/table.py:        linereader = csv.reader(fileobj, dialect=FITSTableDumpDialect)\nastropy\/io\/fits\/hdu\/table.py:        BinTableHDU.dump().\nastropy\/io\/fits\/hdu\/table.py:        return ColDefs(columns)\nastropy\/io\/misc\/asdf\/tags\/fits\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coords\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/hdu\/groups.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/groups.py:from .base import DTYPE2BITPIX\nastropy\/io\/fits\/hdu\/groups.py:from .image import PrimaryHDU\nastropy\/io\/fits\/hdu\/groups.py:from .table import _TableLikeHDU\nastropy\/io\/fits\/hdu\/groups.py:from ..column import Column, ColDefs, FITS2NUMPY\nastropy\/io\/fits\/hdu\/groups.py:        # TODO: It would be nice if, instead of requiring a multi-part value to\nastropy\/io\/fits\/hdu\/groups.py:class GroupData(FITS_rec):\nastropy\/io\/fits\/hdu\/groups.py:            unique_parnames = _unique_parnames(parnames + ['DATA'])\nastropy\/io\/fits\/hdu\/groups.py:                bitpix = DTYPE2BITPIX[input.dtype.name]\nastropy\/io\/fits\/hdu\/groups.py:            fits_fmt = GroupsHDU._bitpix2tform[bitpix]  # -32 -> 'E'\nastropy\/io\/fits\/hdu\/groups.py:            coldefs = ColDefs(cols)\nastropy\/io\/fits\/hdu\/groups.py:            # By default the data field will just be 'DATA', but it may be\nastropy\/io\/fits\/hdu\/groups.py:            # uniquified if 'DATA' is already used by one of the group names\nastropy\/io\/fits\/hdu\/groups.py:                # TODO: Find a better way to do this than using this interface\nastropy\/io\/fits\/hdu\/groups.py:        if isinstance(obj, GroupData):\nastropy\/io\/fits\/hdu\/groups.py:        if isinstance(out, GroupData):\nastropy\/io\/fits\/hdu\/groups.py:class GroupsHDU(PrimaryHDU, _TableLikeHDU):\nastropy\/io\/fits\/hdu\/groups.py:    FITS Random Groups HDU class.\nastropy\/io\/fits\/hdu\/groups.py:    details on working with this type of HDU.\nastropy\/io\/fits\/hdu\/groups.py:    _bitpix2tform = {8: 'B', 16: 'I', 32: 'J', 64: 'K', -32: 'E', -64: 'D'}\nastropy\/io\/fits\/hdu\/groups.py:    _data_type = GroupData\nastropy\/io\/fits\/hdu\/groups.py:    _data_field = 'DATA'\nastropy\/io\/fits\/hdu\/groups.py:    for each group; 'DATA' by default, but may be preceded by any number of\nastropy\/io\/fits\/hdu\/groups.py:    underscores if 'DATA' is already a parameter name\nastropy\/io\/fits\/hdu\/groups.py:        # Update the axes; GROUPS HDUs should always have at least one axis\nastropy\/io\/fits\/hdu\/groups.py:        # Now create columns from collected parameters, but first add the DATA\nastropy\/io\/fits\/hdu\/groups.py:        parnames.append('DATA')\nastropy\/io\/fits\/hdu\/groups.py:        coldefs = ColDefs(cols)\nastropy\/io\/fits\/hdu\/groups.py:        # Only really a lazyproperty for symmetry with _TableBaseHDU\nastropy\/io\/fits\/hdu\/groups.py:        Returns the size (in bytes) of the HDU's data part.\nastropy\/io\/fits\/hdu\/groups.py:            if isinstance(self.data, GroupData):\nastropy\/io\/fits\/hdu\/groups.py:            self._header['BITPIX'] = DTYPE2BITPIX[field0_code]\nastropy\/io\/fits\/hdu\/groups.py:        if self._has_data and isinstance(self.data, GroupData):\nastropy\/io\/fits\/hdu\/groups.py:        # Update the position of the EXTEND keyword if it already exists\nastropy\/io\/fits\/hdu\/groups.py:        if 'EXTEND' in self._header:\nastropy\/io\/fits\/hdu\/groups.py:            self._header.set('EXTEND', after=after)\nastropy\/io\/fits\/hdu\/groups.py:        Basically copy\/pasted from `_ImageBaseHDU._writedata_internal()`, but\nastropy\/io\/fits\/hdu\/groups.py:        TODO: Might be nice to store some indication of the data's byte order\nastropy\/io\/fits\/hdu\/groups.py:        Calculate the value for the ``DATASUM`` card in the HDU.\nastropy\/io\/fits\/hdu\/groups.py:            # TODO: Maybe check this on a per-field basis instead of assuming\nastropy\/io\/fits\/hdu\/groups.py:        # Drop the first axis from the shape\nastropy\/io\/misc\/asdf\/tags\/unit\/tests\/test_quantity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/compound.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/compound.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/__init__.py:so that they can be represented and stored using the Advanced Scientific Data\nastropy\/io\/misc\/asdf\/__init__.py:Format (ASDF). This subpackage defines classes, referred to as **tags**, that\nastropy\/io\/misc\/asdf\/__init__.py:ASDF makes use of abstract data type definitons called **schemas**. The tags\nastropy\/io\/misc\/asdf\/__init__.py:externally by the ASDF Standard. However, it is likely that astropy will\nastropy\/io\/misc\/asdf\/__init__.py:Astropy currently has no ability to read or write ASDF files itself. In order\nastropy\/io\/misc\/asdf\/__init__.py:to process ASDF files it is necessary to make use of the standalone **asdf**\nastropy\/io\/misc\/asdf\/__init__.py:Their presence should be entirely transparent when processing ASDF files.\nastropy\/io\/misc\/asdf\/__init__.py:required in order to process ASDF files. The **asdf** package has been designed\nastropy\/io\/misc\/asdf\/__init__.py:Documentation on the ASDF Standard can be found `here\nastropy\/io\/misc\/asdf\/__init__.py:<https:\/\/asdf-standard.readthedocs.io>`__. Documentation on the ASDF Python\nastropy\/io\/misc\/asdf\/tags\/unit\/tests\/test_unit.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/unit\/tests\/test_unit.py:# TODO: Implement defunit\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:__all__ = ['TransformType', 'IdentityType', 'ConstantType', 'DomainType']\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:        # TODO: Remove domain in a later version.\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:        # TODO: Assert inverses are the same\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:    types = ['astropy.modeling.functional_models.Const1D']\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:        return functional_models.Const1D(node['value'])\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:class DomainType(AstropyAsdfType):\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:    # TODO: Is this used anywhere? Can it be removed?\nastropy\/io\/misc\/asdf\/tags\/table\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:    types = ['astropy.modeling.models.Polynomial1D',\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:             'astropy.modeling.models.Polynomial2D']\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:            model = modeling.models.Polynomial1D(coefficients.size - 1)\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:            model = modeling.models.Polynomial2D(degree, **coeffs)\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:                \"Asdf currently only supports 1D or 2D polynomial transform.\")\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:        if isinstance(model, modeling.models.Polynomial1D):\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:        elif isinstance(model, modeling.models.Polynomial2D):\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:        assert (isinstance(a, (modeling.models.Polynomial1D, modeling.models.Polynomial2D)) and\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:                isinstance(b, (modeling.models.Polynomial1D, modeling.models.Polynomial2D)))\nastropy\/io\/ascii\/latex.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/latex.py:    '''Split LaTeX table date. Default delimiter is `&`.\nastropy\/io\/ascii\/latex.py:class LatexData(core.BaseData):\nastropy\/io\/ascii\/latex.py:        core.BaseData.write(self, lines)\nastropy\/io\/ascii\/latex.py:    **latexdict** : Dictionary of extra parameters for the LaTeX output\nastropy\/io\/ascii\/latex.py:    data_class = LatexData\nastropy\/io\/ascii\/latex.py:class AASTexData(LatexData):\nastropy\/io\/ascii\/latex.py:        core.BaseData.write(self, lines)\nastropy\/io\/ascii\/latex.py:    data_class = AASTexData\nastropy\/io\/misc\/asdf\/tags\/transform\/tabular.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/tabular.py:        modeling.models.Tabular2D, modeling.models.Tabular1D\nastropy\/io\/misc\/asdf\/tags\/transform\/tabular.py:            model = modeling.models.Tabular1D(points=points, lookup_table=lookup_table,\nastropy\/io\/misc\/asdf\/tags\/transform\/tabular.py:            model = modeling.models.Tabular2D(points=points, lookup_table=lookup_table,\nastropy\/io\/misc\/asdf\/tags\/time\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/time\/time.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/fits\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/table\/table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/table\/table.py:from asdf.tags.core.ndarray import NDArrayType\nastropy\/io\/misc\/asdf\/tags\/table\/table.py:        NDArrayType.assert_equal(np.array(old), np.array(new))\nastropy\/io\/misc\/asdf\/tags\/table\/table.py:        NDArrayType.assert_equal(np.array(old), np.array(new))\nastropy\/io\/misc\/asdf\/tags\/fits\/tests\/test_fits.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/fits\/tests\/test_fits.py:    h = fits.HDUList()\nastropy\/io\/misc\/asdf\/tags\/fits\/tests\/test_fits.py:    h.append(fits.BinTableHDU.from_columns(a))\nastropy\/io\/misc\/asdf\/tags\/table\/tests\/test_table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    astmodels.Identity(2), astmodels.Polynomial1D(2, c0=1, c1=2, c2=3),\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    astmodels.Polynomial2D(1, c0_0=1, c0_1=2, c1_0=3), astmodels.Shift(2.),\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:            astmodels.Rotation2D() |\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:            astmodels.AffineTransformation2D([[2, 0], [0, 2]], [42, 32]) +\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:            astmodels.Rotation2D(32)\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    rotation = astmodels.Rotation2D(32)\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    rotation.inverse = astmodels.Rotation2D(45)\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    real_rotation = astmodels.Rotation2D(32)\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    tree = {'rot': astmodels.Rotation2D(23, name='foo')}\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    model = astmodels.Tabular1D(points=points, lookup_table=values)\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    model2 = astmodels.Tabular2D(points, lookup_table=table, bounds_error=False,\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:from collections import OrderedDict\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:    newschema = OrderedDict()\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:        # TODO: Simplify?\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:                cursor = cursor.setdefault('items', OrderedDict())\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:                cursor = cursor.setdefault('properties', OrderedDict())\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:                    cursor = cursor.setdefault(part, OrderedDict())\nastropy\/io\/misc\/asdf\/extension.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/extension.py:from asdf.resolver import Resolver, DEFAULT_URL_MAPPING\nastropy\/io\/misc\/asdf\/extension.py:# by ASDF, but have tag implementations defined in astropy.\nastropy\/io\/misc\/asdf\/types.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/types.py:    be stored automatically by astropy extensions for ASDF.\nastropy\/io\/misc\/asdf\/types.py:    schemas that are defined by the ASDF standard.\nastropy\/io\/misc\/asdf\/types.py:    This class represents types that have schemas that are defined in the ASDF\nastropy\/io\/misc\/asdf\/tags\/coords\/coords.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/setup_package.py:# Licensed under a 3-clause BSD style license\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:__all__ = ['AffineType', 'Rotate2DType', 'Rotate3DType']\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:    types = ['astropy.modeling.projections.AffineTransformation2D']\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:                \"asdf currently only supports 2x2 (2D) rotation transformation \"\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:                \"asdf currently only supports 2D translation transformations.\")\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:        return modeling.projections.AffineTransformation2D(\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:class Rotate2DType(TransformType):\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:    types = ['astropy.modeling.rotations.Rotation2D']\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:        return modeling.rotations.Rotation2D(node['angle'])\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:        assert (isinstance(a, modeling.rotations.Rotation2D) and\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:                isinstance(b, modeling.rotations.Rotation2D))\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:class Rotate3DType(TransformType):\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:    types = ['astropy.io.fits.HDUList']\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:                hdu = fits.PrimaryHDU(data=data, header=header)\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:                hdu = fits.BinTableHDU(data=data, header=header)\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:                hdu = fits.ImageHDU(data=data, header=header)\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:        hdulist = fits.HDUList(hdus)\nastropy\/io\/ascii\/html.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/html.py:class HTMLData(core.BaseData):\nastropy\/io\/ascii\/html.py:    **htmldict** : Dictionary of parameters for HTML input\/output.\nastropy\/io\/ascii\/html.py:        * table_id : ID for the input table\nastropy\/io\/ascii\/html.py:    data_class = HTMLData\nastropy\/io\/ascii\/html.py:                # Declare encoding and set CSS style for table\nastropy\/io\/misc\/yaml.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/yaml.py:`~astropy.io.misc.yaml.AstropyDumper` and `~astropy.io.misc.yaml.AstropyLoader`\nastropy\/io\/misc\/yaml.py:- `astropy.time.TimeDelta`\nastropy\/io\/misc\/yaml.py:from ...time import Time, TimeDelta\nastropy\/io\/misc\/yaml.py:__all__ = ['AstropyLoader', 'AstropyDumper', 'load', 'load_all', 'dump']\nastropy\/io\/misc\/yaml.py:    return dumper.represent_mapping('!astropy.time.TimeDelta', out)\nastropy\/io\/misc\/yaml.py:    out = TimeDelta.info._construct_from_dict(map)\nastropy\/io\/misc\/yaml.py:    <http:\/\/pyyaml.org\/wiki\/PyYAMLDocumentation>`_ for details of the\nastropy\/io\/misc\/yaml.py:class AstropyDumper(yaml.SafeDumper):\nastropy\/io\/misc\/yaml.py:    Custom SafeDumper that represents astropy core objects as well\nastropy\/io\/misc\/yaml.py:    `PyYaml documentation <http:\/\/pyyaml.org\/wiki\/PyYAMLDocumentation>`_\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(u.IrreducibleUnit, _unit_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(u.CompositeUnit, _unit_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_multi_representer(u.Unit, _unit_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(tuple, AstropyDumper._represent_tuple)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(np.ndarray, _ndarray_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(Time, _time_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(TimeDelta, _timedelta_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(coords.SkyCoord, _skycoord_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(SerializedColumn, _serialized_column_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(np.bool_,\nastropy\/io\/misc\/yaml.py:    AstropyDumper.add_representer(np_type,\nastropy\/io\/misc\/yaml.py:    AstropyDumper.add_representer(np_type,\nastropy\/io\/misc\/yaml.py:    AstropyDumper.add_representer(np_type,\nastropy\/io\/misc\/yaml.py:AstropyLoader.add_constructor('!astropy.time.TimeDelta', _timedelta_constructor)\nastropy\/io\/misc\/yaml.py:    AstropyDumper.add_multi_representer(cls, _quantity_representer(tag))\nastropy\/io\/misc\/yaml.py:    \"\"\"Serialize a Python object into a YAML stream using the AstropyDumper class.\nastropy\/io\/misc\/yaml.py:    kwargs['Dumper'] = AstropyDumper\nastropy\/io\/ascii\/sextractor.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/sextractor.py:    comment = r'^\\s*#\\s*\\S\\D.*'  # Find lines that don't have \"# digit\"\nastropy\/io\/ascii\/sextractor.py:        # header comment string of the format: \"# 1 ID short description [unit]\"\nastropy\/io\/ascii\/sextractor.py:        # E.g. '# 1 ID identification number' (without units) or '# 2 MAGERR magnitude of error [mag]'\nastropy\/io\/ascii\/sextractor.py:class SExtractorData(core.BaseData):\nastropy\/io\/ascii\/sextractor.py:      # 3 DELTA_J2000\nastropy\/io\/ascii\/sextractor.py:      # 4 FLUX_RADIUS\nastropy\/io\/ascii\/sextractor.py:    Note the skipped numbers since flux_radius has 3 columns.  The three FLUX_RADIUS\nastropy\/io\/ascii\/sextractor.py:    columns will be named FLUX_RADIUS, FLUX_RADIUS_1, FLUX_RADIUS_2\nastropy\/io\/ascii\/sextractor.py:    Also note that a post-ID description (e.g. \"Variance along x\") is\nastropy\/io\/ascii\/sextractor.py:    data_class = SExtractorData\nastropy\/io\/misc\/asdf\/tags\/coords\/tests\/test_coords.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coords\/tests\/test_coords.py:    reason=\"Compound ICRS coordinates have not been implemented for ASDF yet\")\nastropy\/io\/votable\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/setup_package.py:    VO_DIR = 'astropy\/io\/votable\/src'\nastropy\/io\/votable\/setup_package.py:        [join(VO_DIR, \"tablewriter.c\")],\nastropy\/io\/votable\/setup_package.py:        include_dirs=[VO_DIR])]\nastropy\/io\/votable\/table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/table.py:# STDLIB\nastropy\/io\/votable\/table.py:          chunk_size=tree.DEFAULT_CHUNK_SIZE, table_number=None,\nastropy\/io\/votable\/table.py:        The ID of the table in the file to read in.  Should not be\nastropy\/io\/votable\/table.py:        Where to output the report.  Defaults to ``sys.stdout``.\nastropy\/io\/votable\/table.py:        DTD validation.  Requires that ``xmllint`` is installed.  The\nastropy\/io\/fits\/setup_package.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/setup_package.py:    cfg = setup_helpers.DistutilsExtensionArgs()\nastropy\/io\/fits\/setup_package.py:                ['\/D', '\"WIN32\"',\nastropy\/io\/fits\/setup_package.py:                 '\/D', '\"_WINDOWS\"',\nastropy\/io\/fits\/setup_package.py:                 '\/D', '\"_MBCS\"',\nastropy\/io\/fits\/setup_package.py:                 '\/D', '\"_USRDLL\"',\nastropy\/io\/fits\/setup_package.py:                 '\/D', '\"_CRT_SECURE_NO_DEPRECATE\"',\nastropy\/io\/fits\/setup_package.py:                 '\/D', '\"FF_NO_UNISTD_H\"'])\nastropy\/io\/ascii\/daophot.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/daophot.py:Classes to read DAOphot table format\nastropy\/io\/ascii\/daophot.py:from collections import defaultdict, OrderedDict\nastropy\/io\/ascii\/daophot.py:class DaophotHeader(core.BaseHeader):\nastropy\/io\/ascii\/daophot.py:    Read the header from a file produced by the IRAF DAOphot routine.\nastropy\/io\/ascii\/daophot.py:        #N ID    XCENTER   YCENTER   MAG         MERR          MSKY           NITER\nastropy\/io\/ascii\/daophot.py:            # Database contains multi-aperture data.\nastropy\/io\/ascii\/daophot.py:        row_short = Daophot.table_width - row_widths\nastropy\/io\/ascii\/daophot.py:        Extract table-level keywords for DAOphot table.  These are indicated by\nastropy\/io\/ascii\/daophot.py:            # Dict of line groups keyed by line identifiers\nastropy\/io\/ascii\/daophot.py:                keywords = OrderedDict(map(self.extract_keyword_line, grouped_lines_dict['#K']))\nastropy\/io\/ascii\/daophot.py:        Initialize the header Column objects from the table ``lines`` for a DAOphot\nastropy\/io\/ascii\/daophot.py:        header.  The DAOphot header is specialized so that we just copy the entire BaseHeader\nastropy\/io\/ascii\/daophot.py:            raise core.InconsistentTableError('No column names found in DAOphot header')\nastropy\/io\/ascii\/daophot.py:        # INDEF is the missing value marker\nastropy\/io\/ascii\/daophot.py:        self.data.fill_values.append(('INDEF', '0'))\nastropy\/io\/ascii\/daophot.py:class DaophotData(core.BaseData):\nastropy\/io\/ascii\/daophot.py:        core.BaseData.__init__(self)\nastropy\/io\/ascii\/daophot.py:        core.BaseData.get_data_lines(self, lines)\nastropy\/io\/ascii\/daophot.py:class DaophotInputter(core.ContinuationLinesInputter):\nastropy\/io\/ascii\/daophot.py:class Daophot(core.BaseReader):\nastropy\/io\/ascii\/daophot.py:    Read a DAOphot file.\nastropy\/io\/ascii\/daophot.py:      #K MERGERAD   = INDEF                   scaleunit  %-23.7g\nastropy\/io\/ascii\/daophot.py:      #N ID    XCENTER   YCENTER   MAG         MERR          MSKY           NITER    \\\\\nastropy\/io\/ascii\/daophot.py:      14       138.538     INDEF   15.461      0.003         34.85955       4        \\\\\nastropy\/io\/ascii\/daophot.py:      MERGERAD INDEF scaleunit %-23.7g\nastropy\/io\/ascii\/daophot.py:      ID None %-9d\nastropy\/io\/ascii\/daophot.py:    Any column values of INDEF are interpreted as a missing value and will be\nastropy\/io\/ascii\/daophot.py:    _description = 'IRAF DAOphot format table'\nastropy\/io\/ascii\/daophot.py:    header_class = DaophotHeader\nastropy\/io\/ascii\/daophot.py:    data_class = DaophotData\nastropy\/io\/ascii\/daophot.py:    inputter_class = DaophotInputter\nastropy\/io\/ascii\/daophot.py:        # The inputter needs to know about the data (see DaophotInputter.process_lines)\nastropy\/io\/tests\/test_registry.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/tests\/test_registry.py:_READERS_ORIGINAL = copy(_readers)\nastropy\/io\/tests\/test_registry.py:_IDENTIFIERS_ORIGINAL = copy(_identifiers)\nastropy\/io\/tests\/test_registry.py:class TestData:\nastropy\/io\/tests\/test_registry.py:    return TestData()\nastropy\/io\/tests\/test_registry.py:        io_registry.get_reader('test', TestData)\nastropy\/io\/tests\/test_registry.py:        \"No reader defined for format 'test' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:        io_registry.get_writer('test', TestData)\nastropy\/io\/tests\/test_registry.py:        \"No writer defined for format 'test' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test1', TestData, empty_reader)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test2', TestData, empty_reader)\nastropy\/io\/tests\/test_registry.py:    assert io_registry.get_reader('test1', TestData) == empty_reader\nastropy\/io\/tests\/test_registry.py:    assert io_registry.get_reader('test2', TestData) == empty_reader\nastropy\/io\/tests\/test_registry.py:    io_registry.unregister_reader('test1', TestData)\nastropy\/io\/tests\/test_registry.py:        io_registry.get_reader('test1', TestData)\nastropy\/io\/tests\/test_registry.py:    assert io_registry.get_reader('test2', TestData) == empty_reader\nastropy\/io\/tests\/test_registry.py:    io_registry.unregister_reader('test2', TestData)\nastropy\/io\/tests\/test_registry.py:        io_registry.get_reader('test2', TestData)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_writer('test1', TestData, empty_writer)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_writer('test2', TestData, empty_writer)\nastropy\/io\/tests\/test_registry.py:    assert io_registry.get_writer('test1', TestData) == empty_writer\nastropy\/io\/tests\/test_registry.py:    assert io_registry.get_writer('test2', TestData) == empty_writer\nastropy\/io\/tests\/test_registry.py:    io_registry.unregister_writer('test1', TestData)\nastropy\/io\/tests\/test_registry.py:        io_registry.get_writer('test1', TestData)\nastropy\/io\/tests\/test_registry.py:    assert io_registry.get_writer('test2', TestData) == empty_writer\nastropy\/io\/tests\/test_registry.py:    io_registry.unregister_writer('test2', TestData)\nastropy\/io\/tests\/test_registry.py:        io_registry.get_writer('test2', TestData)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test1', TestData, empty_identifier)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test2', TestData, empty_identifier)\nastropy\/io\/tests\/test_registry.py:    io_registry.unregister_identifier('test1', TestData)\nastropy\/io\/tests\/test_registry.py:    io_registry.unregister_identifier('test2', TestData)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test', TestData, empty_reader)\nastropy\/io\/tests\/test_registry.py:        io_registry.register_reader('test', TestData, empty_reader)\nastropy\/io\/tests\/test_registry.py:    assert (str(exc.value) == \"Reader for format 'test' and class 'TestData' \"\nastropy\/io\/tests\/test_registry.py:    io_registry.register_writer('test', TestData, empty_writer)\nastropy\/io\/tests\/test_registry.py:        io_registry.register_writer('test', TestData, empty_writer)\nastropy\/io\/tests\/test_registry.py:    assert (str(exc.value) == \"Writer for format 'test' and class 'TestData' \"\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test', TestData, empty_identifier)\nastropy\/io\/tests\/test_registry.py:        io_registry.register_identifier('test', TestData, empty_identifier)\nastropy\/io\/tests\/test_registry.py:                              \"'TestData' is already defined\")\nastropy\/io\/tests\/test_registry.py:        io_registry.unregister_reader('test', TestData)\nastropy\/io\/tests\/test_registry.py:    assert str(exc.value) == \"No reader defined for format 'test' and class 'TestData'\"\nastropy\/io\/tests\/test_registry.py:        io_registry.unregister_writer('test', TestData)\nastropy\/io\/tests\/test_registry.py:    assert str(exc.value) == \"No writer defined for format 'test' and class 'TestData'\"\nastropy\/io\/tests\/test_registry.py:        io_registry.unregister_identifier('test', TestData)\nastropy\/io\/tests\/test_registry.py:    assert str(exc.value) == \"No identifier defined for format 'test' and class 'TestData'\"\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test', TestData, empty_reader)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test', TestData, empty_reader, force=True)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_writer('test', TestData, empty_writer)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_writer('test', TestData, empty_writer, force=True)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test', TestData, empty_identifier)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test', TestData, empty_identifier, force=True)\nastropy\/io\/tests\/test_registry.py:        TestData.read()\nastropy\/io\/tests\/test_registry.py:        TestData().write()\nastropy\/io\/tests\/test_registry.py:    _identifiers.update(_IDENTIFIERS_ORIGINAL)\nastropy\/io\/tests\/test_registry.py:        TestData.read(object())\nastropy\/io\/tests\/test_registry.py:    _readers.update(_READERS_ORIGINAL)\nastropy\/io\/tests\/test_registry.py:    _identifiers.update(_IDENTIFIERS_ORIGINAL)\nastropy\/io\/tests\/test_registry.py:        TestData().write(object())\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test1', TestData, lambda o, *x, **y: True)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test2', TestData, lambda o, *x, **y: True)\nastropy\/io\/tests\/test_registry.py:        TestData.read()\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test1', TestData, lambda o, *x, **y: True)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test2', TestData, lambda o, *x, **y: True)\nastropy\/io\/tests\/test_registry.py:        TestData().write()\nastropy\/io\/tests\/test_registry.py:        TestData.read(format='test')\nastropy\/io\/tests\/test_registry.py:        \"No reader defined for format 'test' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:        TestData().write(format='test')\nastropy\/io\/tests\/test_registry.py:        \"No writer defined for format 'test' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:        'test1', TestData,\nastropy\/io\/tests\/test_registry.py:        'test2', TestData,\nastropy\/io\/tests\/test_registry.py:        TestData.read(filename)\nastropy\/io\/tests\/test_registry.py:        \"No reader defined for format 'test1' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:        TestData.read(filename)\nastropy\/io\/tests\/test_registry.py:        \"No reader defined for format 'test2' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test1', TestData, lambda o, *x, **y: x[0].startswith('a'))\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test2', TestData, lambda o, *x, **y: x[0].startswith('b'))\nastropy\/io\/tests\/test_registry.py:        TestData().write('abc')\nastropy\/io\/tests\/test_registry.py:        \"No writer defined for format 'test1' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:        TestData().write('bac')\nastropy\/io\/tests\/test_registry.py:        \"No writer defined for format 'test2' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test1', TestData, lambda o, *x, **y: o == 'read')\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test2', TestData, lambda o, *x, **y: o == 'write')\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test1', TestData, empty_reader)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_writer('test2', TestData, empty_writer)\nastropy\/io\/tests\/test_registry.py:    TestData.read()\nastropy\/io\/tests\/test_registry.py:    TestData().write()\nastropy\/io\/tests\/test_registry.py:        TestData.read(format='test2')\nastropy\/io\/tests\/test_registry.py:        \"No reader defined for format 'test2' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:        TestData().write(format='test1')\nastropy\/io\/tests\/test_registry.py:        \"No writer defined for format 'test1' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test', TestData, lambda: TestData())\nastropy\/io\/tests\/test_registry.py:    t = TestData.read(format='test')\nastropy\/io\/tests\/test_registry.py:    assert isinstance(t, TestData)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test', TestData, lambda: 'spam')\nastropy\/io\/tests\/test_registry.py:        TestData.read(format='test')\nastropy\/io\/tests\/test_registry.py:    assert str(exc.value) == \"reader should return a TestData instance\"\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test', TestData, lambda: TestData())\nastropy\/io\/tests\/test_registry.py:    t = TestData.read(format='test')\nastropy\/io\/tests\/test_registry.py:    assert isinstance(t, TestData)\nastropy\/io\/tests\/test_registry.py:    _readers.update(_READERS_ORIGINAL)\nastropy\/io\/tests\/test_registry.py:    _identifiers.update(_IDENTIFIERS_ORIGINAL)\nastropy\/io\/ascii\/setup_package.py:# Licensed under a 3-clause BSD style license\nastropy\/io\/fits\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/connect.py:from collections import OrderedDict\nastropy\/io\/fits\/connect.py:from . import HDUList, TableHDU, BinTableHDU, GroupsHDU\nastropy\/io\/fits\/connect.py:from .column import KEYWORD_NAMES\nastropy\/io\/fits\/connect.py:REMOVE_KEYWORDS = ['XTENSION', 'BITPIX', 'NAXIS', 'NAXIS1', 'NAXIS2',\nastropy\/io\/fits\/connect.py:                   'PCOUNT', 'GCOUNT', 'TFIELDS', 'THEAP']\nastropy\/io\/fits\/connect.py:COLUMN_KEYWORD_REGEXP = '(' + '|'.join(KEYWORD_NAMES) + ')[0-9]+'\nastropy\/io\/fits\/connect.py:    return re.match(COLUMN_KEYWORD_REGEXP, keyword) is not None\nastropy\/io\/fits\/connect.py:    Determine whether `origin` is a FITS file.\nastropy\/io\/fits\/connect.py:    elif isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU)):\nastropy\/io\/fits\/connect.py:    \"\"\"Decode a Table ``tbl`` that has astropy Columns + appropriate meta-data into\nastropy\/io\/fits\/connect.py:        i0 = tbl.meta['comments'].index('--BEGIN-ASTROPY-SERIALIZED-COLUMNS--')\nastropy\/io\/fits\/connect.py:        i1 = tbl.meta['comments'].index('--END-ASTROPY-SERIALIZED-COLUMNS--')\nastropy\/io\/fits\/connect.py:    input : str or file-like object or compatible `astropy.io.fits` HDU object\nastropy\/io\/fits\/connect.py:        a compatible HDU object, the object to extract the table from. The\nastropy\/io\/fits\/connect.py:        following `astropy.io.fits` HDU objects can be used as input:\nastropy\/io\/fits\/connect.py:        - :class:`~astropy.io.fits.hdu.table.TableHDU`\nastropy\/io\/fits\/connect.py:        - :class:`~astropy.io.fits.hdu.table.BinTableHDU`\nastropy\/io\/fits\/connect.py:        - :class:`~astropy.io.fits.hdu.table.GroupsHDU`\nastropy\/io\/fits\/connect.py:        - :class:`~astropy.io.fits.hdu.hdulist.HDUList`\nastropy\/io\/fits\/connect.py:        The HDU to read the table from.\nastropy\/io\/fits\/connect.py:        of standard Table Column objects. Default is False.\nastropy\/io\/fits\/connect.py:    if isinstance(input, HDUList):\nastropy\/io\/fits\/connect.py:        tables = OrderedDict()\nastropy\/io\/fits\/connect.py:            if isinstance(hdu_item, (TableHDU, BinTableHDU, GroupsHDU)):\nastropy\/io\/fits\/connect.py:            # to the correct HDU index\nastropy\/io\/fits\/connect.py:    elif isinstance(input, (TableHDU, BinTableHDU, GroupsHDU)):\nastropy\/io\/fits\/connect.py:    # TODO: in future, it may make more sense to do this column-by-column,\nastropy\/io\/fits\/connect.py:    # TODO: deal properly with unsigned integers\nastropy\/io\/fits\/connect.py:        elif is_column_keyword(key) or key in REMOVE_KEYWORDS:\nastropy\/io\/fits\/connect.py:    # TODO: implement masking\nastropy\/io\/fits\/connect.py:    # Decode any mixin columns that have been stored as standard Columns.\nastropy\/io\/fits\/connect.py:    encode_tbl.meta['comments'].append('--BEGIN-ASTROPY-SERIALIZED-COLUMNS--')\nastropy\/io\/fits\/connect.py:    encode_tbl.meta['comments'].append('--END-ASTROPY-SERIALIZED-COLUMNS--')\nastropy\/io\/ascii\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/core.py:from collections import OrderedDict\nastropy\/io\/ascii\/core.py:    Describes floating-point data.\nastropy\/io\/ascii\/core.py:    Describes boolean data.\nastropy\/io\/ascii\/core.py:    Describes integer data.\nastropy\/io\/ascii\/core.py:class DefaultSplitter(BaseSplitter):\nastropy\/io\/ascii\/core.py:    \"\"\"Default class to split strings into columns using python csv.  The class\nastropy\/io\/ascii\/core.py:    attributes are taken from the csv Dialect class.\nastropy\/io\/ascii\/core.py:      splitter = ascii.DefaultSplitter()\nastropy\/io\/ascii\/core.py:    splitter_class = DefaultSplitter\nastropy\/io\/ascii\/core.py:        the table ``lines`` and update the OrderedDict ``meta`` in place.  This base\nastropy\/io\/ascii\/core.py:class BaseData:\nastropy\/io\/ascii\/core.py:    splitter_class = DefaultSplitter\nastropy\/io\/ascii\/core.py:        else:  # Don't copy entire data lines unless necessary\nastropy\/io\/ascii\/core.py:        \"\"\"Set the fill values of the individual cols based on fill_values of BaseData\nastropy\/io\/ascii\/core.py:    # Derived classes must define default_converters and __call__\nastropy\/io\/ascii\/core.py:    data_class = BaseData\nastropy\/io\/ascii\/core.py:        # Data and Header instances benefit from a little cross-coupling.  Header may need to\nastropy\/io\/ascii\/core.py:        # know about number of data columns for auto-column name generation and Data may\nastropy\/io\/ascii\/core.py:        self.meta = OrderedDict(table=OrderedDict(),\nastropy\/io\/ascii\/core.py:                                cols=OrderedDict())\nastropy\/io\/ascii\/core.py:                              'Data values: {}'.format(\nastropy\/io\/ascii\/core.py:    # to line continuation.  The initial use case here is Daophot.  In this\nastropy\/io\/ascii\/core.py:class WhitespaceSplitter(DefaultSplitter):\nastropy\/io\/fits\/convenience.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/convenience.py::class:`astropy.io.fits.HDUList` object and underlying HDU objects.\nastropy\/io\/fits\/convenience.py:special arguments for selecting which extension HDU to use when working with a\nastropy\/io\/fits\/convenience.py:    *not* for selecting the extension HDU should be passed in as keyword\nastropy\/io\/fits\/convenience.py:    extension arguments.  For example, to set NAXIS=1 on the Primary HDU:\nastropy\/io\/fits\/convenience.py:    HDU to blank.  That is, the argument '1' is assumed to specify an extension\nastropy\/io\/fits\/convenience.py:    HDU.\nastropy\/io\/fits\/convenience.py:    This will set the NAXIS keyword to 1 on the primary HDU (the default).  To\nastropy\/io\/fits\/convenience.py:    specify the first extension HDU use::\nastropy\/io\/fits\/convenience.py:from .diff import FITSDiff, HDUDiff\nastropy\/io\/fits\/convenience.py:from .file import FILE_MODES, _File\nastropy\/io\/fits\/convenience.py:from .hdu.base import _BaseHDU, _ValidHDU\nastropy\/io\/fits\/convenience.py:from .hdu.hdulist import fitsopen, HDUList\nastropy\/io\/fits\/convenience.py:from .hdu.image import PrimaryHDU, ImageHDU\nastropy\/io\/fits\/convenience.py:from .hdu.table import BinTableHDU\nastropy\/io\/fits\/convenience.py:        If `True`, return the data and the header of the specified HDU as a\nastropy\/io\/fits\/convenience.py:                raise IndexError('No data in this HDU.')\nastropy\/io\/fits\/convenience.py:            raise IndexError('No data in this HDU.')\nastropy\/io\/fits\/convenience.py:    Delete all instances of keyword from a header in a FITS file.\nastropy\/io\/fits\/convenience.py:        ``OSError`` if ``False`` and the output file exists. Default is\nastropy\/io\/fits\/convenience.py:        If `True`, adds both ``DATASUM`` and ``CHECKSUM`` cards to the\nastropy\/io\/fits\/convenience.py:        headers of all HDU's written to the file.\nastropy\/io\/fits\/convenience.py:    if hdu.is_image and not isinstance(hdu, PrimaryHDU):\nastropy\/io\/fits\/convenience.py:        hdu = PrimaryHDU(data, header=header)\nastropy\/io\/fits\/convenience.py:    `~astropy.io.fits.BinTableHDU`.\nastropy\/io\/fits\/convenience.py:        Whether to return bytes for string columns when accessed from the HDU.\nastropy\/io\/fits\/convenience.py:    table_hdu : `~astropy.io.fits.BinTableHDU`\nastropy\/io\/fits\/convenience.py:        The FITS binary table HDU.\nastropy\/io\/fits\/convenience.py:    from .connect import is_column_keyword, REMOVE_KEYWORDS\nastropy\/io\/fits\/convenience.py:    # Create a new HDU object\nastropy\/io\/fits\/convenience.py:        # TODO: it might be better to construct the FITS table directly from\nastropy\/io\/fits\/convenience.py:        table_hdu = BinTableHDU.from_columns(np.array(table.filled()), header=hdr, character_as_bytes=True)\nastropy\/io\/fits\/convenience.py:            # TODO: Determine a schema for handling non-integer masked columns\nastropy\/io\/fits\/convenience.py:        table_hdu = BinTableHDU.from_columns(np.array(table.filled()), header=hdr, character_as_bytes=character_as_bytes)\nastropy\/io\/fits\/convenience.py:    # Set units for output HDU\nastropy\/io\/fits\/convenience.py:        if is_column_keyword(key.upper()) or key.upper() in REMOVE_KEYWORDS:\nastropy\/io\/fits\/convenience.py:        When `True` adds both ``DATASUM`` and ``CHECKSUM`` cards to the header\nastropy\/io\/fits\/convenience.py:        of the HDU when written to the file.\nastropy\/io\/fits\/convenience.py:        if isinstance(hdu, PrimaryHDU):\nastropy\/io\/fits\/convenience.py:            hdu = ImageHDU(data, header)\nastropy\/io\/fits\/convenience.py:                # Set a flag in the HDU so that only this HDU gets a checksum\nastropy\/io\/fits\/convenience.py:        HDU info.  Writes to ``sys.stdout`` by default.\nastropy\/io\/fits\/convenience.py:    FITS `HDUList` objects and FITS ``HDU`` objects.\nastropy\/io\/fits\/convenience.py:    inputa : str, `HDUList` object, or ``HDU`` object\nastropy\/io\/fits\/convenience.py:        The filename of a FITS file, `HDUList`, or ``HDU``\nastropy\/io\/fits\/convenience.py:    inputb : str, `HDUList` object, or ``HDU`` object\nastropy\/io\/fits\/convenience.py:        The filename of a FITS file, `HDUList`, or ``HDU``\nastropy\/io\/fits\/convenience.py:        ``inputa`` and ``inputb`` are ``HDU`` objects or `HDUList` objects).\nastropy\/io\/fits\/convenience.py:            printdiff('inA.fits', 'inB.fits', 0)      # the primary HDU\nastropy\/io\/fits\/convenience.py:        `~astropy.io.fits.FITSDiff`.\nastropy\/io\/fits\/convenience.py:    To save the diff report to a file please use `~astropy.io.fits.FITSDiff`\nastropy\/io\/fits\/convenience.py:            print(HDUDiff(hdua, hdub, **kwargs).report())\nastropy\/io\/fits\/convenience.py:    # If input is not a string, can feed HDU objects or HDUList directly,\nastropy\/io\/fits\/convenience.py:    elif isinstance(inputa, _ValidHDU) and has_extensions:\nastropy\/io\/fits\/convenience.py:                         \"HDU object.\")\nastropy\/io\/fits\/convenience.py:    elif isinstance(inputa, _ValidHDU) and not has_extensions:\nastropy\/io\/fits\/convenience.py:        print(HDUDiff(inputa, inputb, **kwargs).report())\nastropy\/io\/fits\/convenience.py:    elif isinstance(inputa, HDUList) and has_extensions:\nastropy\/io\/fits\/convenience.py:        raise NotImplementedError(\"Extension specification with HDUList \"\nastropy\/io\/fits\/convenience.py:        print(FITSDiff(inputa, inputb, **kwargs).report())\nastropy\/io\/fits\/convenience.py:    Dump a table HDU to a file in ASCII format.  The table may be\nastropy\/io\/fits\/convenience.py:        The number of the extension containing the table HDU to be\nastropy\/io\/fits\/convenience.py:        ``OSError`` if ``False`` and the output file exists. Default is\nastropy\/io\/fits\/convenience.py:        # Dump the data from the HDU to the files\nastropy\/io\/fits\/convenience.py:    tabledump.__doc__ += BinTableHDU._tdump_file_format.replace('\\n', '\\n    ')\nastropy\/io\/fits\/convenience.py:    return BinTableHDU.load(datafile, cdfile, hfile, replace=True)\nastropy\/io\/fits\/convenience.py:    tableload.__doc__ += BinTableHDU._tdump_file_format.replace('\\n', '\\n    ')\nastropy\/io\/fits\/convenience.py:    Open the input file, return the `HDUList` and the extension.\nastropy\/io\/fits\/convenience.py:    hdu = _BaseHDU(data, header)\nastropy\/io\/fits\/convenience.py:    if hdu.__class__ in (_BaseHDU, _ValidHDU):\nastropy\/io\/fits\/convenience.py:        # The HDU type was unrecognized, possibly due to a\nastropy\/io\/fits\/convenience.py:            hdu = BinTableHDU(data, header=header)\nastropy\/io\/fits\/convenience.py:            hdu = ImageHDU(data, header=header)\nastropy\/io\/fits\/convenience.py:            raise KeyError('Data must be a numpy array.')\nastropy\/io\/fits\/convenience.py:        mode = FILE_MODES.get(fmode)\nastropy\/io\/votable\/tests\/table_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/table_test.py:        assert field.ID == name\nastropy\/io\/votable\/tests\/table_test.py:        'Name', 'GLON', 'GLAT', 'RAdeg', 'DEdeg', 'Jmag', 'Hmag', 'Kmag',\nastropy\/io\/votable\/tests\/table_test.py:    assert b'TABLEDATA' not in obuff\nastropy\/io\/votable\/tests\/table_test.py:    assert b'TABLEDATA' not in obuff\nastropy\/io\/ascii\/ecsv.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/ecsv.py:Define the Enhanced Character-Separated-Values (ECSV) which allows for reading and\nastropy\/io\/ascii\/ecsv.py:from collections import OrderedDict\nastropy\/io\/ascii\/ecsv.py:DELIMITERS = (' ', ',')\nastropy\/io\/ascii\/ecsv.py:        if self.splitter.delimiter not in DELIMITERS:\nastropy\/io\/ascii\/ecsv.py:            if delimiter not in DELIMITERS:\nastropy\/io\/ascii\/ecsv.py:        header_cols = OrderedDict((x['name'], x) for x in header['datatype'])\nastropy\/io\/ascii\/tests\/test_ecsv.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_ecsv.py:from ....time import Time, TimeDelta\nastropy\/io\/ascii\/tests\/test_ecsv.py:from ..ecsv import DELIMITERS\nastropy\/io\/ascii\/tests\/test_ecsv.py:DTYPES = ['bool', 'int8', 'int16', 'int32', 'int64', 'uint8', 'uint16', 'uint32',\nastropy\/io\/ascii\/tests\/test_ecsv.py:    DTYPES.remove('float128')\nastropy\/io\/ascii\/tests\/test_ecsv.py:T_DTYPES = Table()\nastropy\/io\/ascii\/tests\/test_ecsv.py:for dtype in DTYPES:\nastropy\/io\/ascii\/tests\/test_ecsv.py:    T_DTYPES[dtype] = c\nastropy\/io\/ascii\/tests\/test_ecsv.py:T_DTYPES.meta['comments'] = ['comment1', 'comment2']\nastropy\/io\/ascii\/tests\/test_ecsv.py:    t = T_DTYPES['bool', 'int64', 'float64', 'str']\nastropy\/io\/ascii\/tests\/test_ecsv.py:    t = T_DTYPES\nastropy\/io\/ascii\/tests\/test_ecsv.py:    for delimiter in DELIMITERS:\nastropy\/io\/ascii\/tests\/test_ecsv.py:        T_DTYPES.write(out, format='ascii.ecsv', delimiter='|')\nastropy\/io\/ascii\/tests\/test_ecsv.py:    'dt': TimeDelta([1, 2] * u.day),\nastropy\/io\/ascii\/tests\/test_ecsv.py:            # Downgrade Quantity to Column + unit\nastropy\/io\/misc\/pickle_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/pickle_helpers.py:from ...utils.exceptions import AstropyDeprecationWarning, NoValue\nastropy\/io\/misc\/pickle_helpers.py:                      AstropyDeprecationWarning)\nastropy\/io\/misc\/pickle_helpers.py:                      AstropyDeprecationWarning)\nastropy\/io\/ascii\/tests\/common.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/common.py:CWD = os.getcwd()\nastropy\/io\/ascii\/tests\/common.py:TEST_DIR = os.path.dirname(__file__)\nastropy\/io\/ascii\/tests\/common.py:    os.chdir(TEST_DIR)\nastropy\/io\/ascii\/tests\/common.py:    os.chdir(CWD)\nastropy\/io\/votable\/tests\/converter_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/converter_test.py:# THIRD-PARTY\nastropy\/io\/ascii\/tests\/test_c_reader.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_c_reader.py:    # TODO: also read from file\nastropy\/io\/ascii\/tests\/test_c_reader.py:A B C D E\nastropy\/io\/ascii\/tests\/test_c_reader.py:    assert_equal(table['D'].dtype.kind, 'f')\nastropy\/io\/ascii\/tests\/test_c_reader.py:    table = read_basic(\"A B C D\\n1 2 3 4\\n5 6 7 8\", include_names=['A', 'D'], parallel=parallel)\nastropy\/io\/ascii\/tests\/test_c_reader.py:    expected = Table([[1, 5], [4, 8]], names=('A', 'D'))\nastropy\/io\/ascii\/tests\/test_c_reader.py:    table = read_basic(\"A B C D\\n1 2 3 4\\n5 6 7 8\", exclude_names=['A', 'D'], parallel=parallel)\nastropy\/io\/ascii\/tests\/test_c_reader.py:A B C D E F G H\nastropy\/io\/ascii\/tests\/test_c_reader.py:    table = read_basic(text, include_names=['A', 'B', 'D', 'F', 'H'],\nastropy\/io\/ascii\/tests\/test_c_reader.py:    expected = Table([[1, 9], [4, 12], [8, 16]], names=('A', 'D', 'H'))\nastropy\/io\/ascii\/tests\/test_c_reader.py:\"A B\" C D\nastropy\/io\/ascii\/tests\/test_c_reader.py:    expected = Table([['1.5', 'a'], ['2.1', 'b'], ['-37.1', 'cd']], names=('A B', 'C', 'D'))\nastropy\/io\/ascii\/tests\/test_c_reader.py:    ('header_Splitter', ascii.DefaultSplitter),  # passing Splitter\nastropy\/io\/ascii\/tests\/test_c_reader.py:    ('data_Splitter', ascii.DefaultSplitter)])\nastropy\/io\/ascii\/tests\/test_c_reader.py:    # make sure data_end works with RDB\nastropy\/io\/ascii\/tests\/test_c_reader.py:    is large (so that each header string is longer than INITIAL_HEADER_SIZE).\nastropy\/io\/ascii\/tests\/test_c_reader.py:    Readers that don't strip whitespace from data (Tab, RDB)\nastropy\/io\/ascii\/tests\/test_c_reader.py:\\tdecDeg\\tRate_pn_offAxis\\tRate_mos2_offAxis\\tObsID\\tSourceID\\tRADeg\\tversion\\tCounts_pn\\tRate_pn\\trun\\tRate_mos1\\tRate_mos2\\tInserted_pn\\tInserted_mos2\\tbeta\\tRate_mos1_offAxis\\trcArcsec\\tname\\tInserted\\tCounts_mos1\\tInserted_mos1\\tCounts_mos2\\ty\\tx\\tCounts\\toffAxis\\tRot\nastropy\/io\/ascii\/tests\/test_c_reader.py:@pytest.mark.skipif(not os.getenv('TEST_READ_HUGE_FILE'),\nastropy\/io\/ascii\/tests\/test_c_reader.py:                    reason='Environment variable TEST_READ_HUGE_FILE must be '\nastropy\/io\/ascii\/tests\/test_c_reader.py:    environment variable ``TEST_READ_HUGE_FILE`` is defined. Note that running\nastropy\/io\/ascii\/tests\/test_c_reader.py:    fields = ['.0101D202', '0.000000314d+314', '1777+305', '-1799E+305', '0.2e-323',\nastropy\/io\/ascii\/tests\/test_c_reader.py:    expstyles = {'e': 4*('E'), 'D': ('D', 'd', 'd', 'D'), 'Q': 2*('q', 'Q'),\nastropy\/io\/ascii\/tests\/test_c_reader.py:                  'fortran': ('D', 'E', 'Q', 'd')}\nastropy\/io\/ascii\/tests\/test_c_reader.py:        ascii.read(text.format(*(4*('D'))), format='basic', guess=False,\nastropy\/io\/ascii\/tests\/test_c_reader.py:                                'parallel': parallel, 'exponent_style': 'D'})\nastropy\/io\/votable\/tests\/exception_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/vo_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/vo_test.py:# STDLIB\nastropy\/io\/votable\/tests\/vo_test.py:# THIRD-PARTY\nastropy\/io\/votable\/tests\/vo_test.py:# Determine the kind of float formatting in this build of Python\nastropy\/io\/votable\/tests\/vo_test.py:            '<PARAM ID=\"awesome\" arraysize=\"*\" datatype=\"float\" name=\"INPUT\" unit=\"deg\" value=\"[0.0 0.0]\"\/>'  # noqa\nastropy\/io\/votable\/tests\/vo_test.py:class TestThroughTableData(TestParse):\nastropy\/io\/votable\/tests\/vo_test.py:    # Define some fields\nastropy\/io\/votable\/tests\/vo_test.py:            Field(votable, ID=\"filename\", datatype=\"char\"),\nastropy\/io\/votable\/tests\/vo_test.py:            Field(votable, ID=\"matrix\", datatype=\"double\", arraysize=\"2x2\")])\nastropy\/io\/votable\/tests\/vo_test.py:    # Define some fields\nastropy\/io\/votable\/tests\/vo_test.py:        tree.Field(votable, ID=\"filename\", datatype=\"char\"),\nastropy\/io\/votable\/tests\/vo_test.py:        tree.Field(votable, ID=\"matrix\", datatype=\"double\", arraysize=\"2x2\")])\nastropy\/io\/votable\/tests\/vo_test.py:    # Define some fields\nastropy\/io\/ascii\/tests\/test_cds_header_from_readme.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_cds_header_from_readme.py:        assert_equal(table['Q'].description, 'DAOSPEC quality parameter Q(large values are bad)')\nastropy\/io\/ascii\/tests\/test_connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_html.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_html.py:    assert html.identify_table(soup, {}, 1) is True  # Default index of 1\nastropy\/io\/ascii\/tests\/test_html.py:    # Test identification by string ID\nastropy\/io\/ascii\/tests\/test_html.py:    # Identification by string ID\nastropy\/io\/ascii\/tests\/test_html.py:            html.SoupString(BeautifulSoup('<table><tr><td>Data 1<\/td><td>Data 2<\/td><\/tr><\/table>').tr)]\nastropy\/io\/ascii\/tests\/test_html.py:    expected_data = [['Col 1', 'Col 2'], ['Data 1', 'Data 2']]\nastropy\/io\/ascii\/tests\/test_html.py:    lines.append('<tr><td>Data 3<\/td><td>Data 4<\/td><\/tr>')\nastropy\/io\/ascii\/tests\/test_html.py:    lines = [html.SoupString(BeautifulSoup('<table><tr><td>Data<\/td><\/tr><\/table>').tr),\nastropy\/io\/ascii\/tests\/test_html.py:    of HTMLData returns the first line of table data. Uses\nastropy\/io\/ascii\/tests\/test_html.py:    data = html.HTMLData()\nastropy\/io\/ascii\/tests\/test_html.py:    lines.append('<tr><td>Data<\/td><\/tr>')\nastropy\/io\/ascii\/tests\/test_html.py:                      'raw_html_clean_kwargs': {'tags': bleach.ALLOWED_TAGS + ['p']}})\nastropy\/io\/ascii\/tests\/test_html.py:    ascii.write(t, buffer_output, fill_values=[(ascii.masked, 'MASKED')],\nastropy\/io\/ascii\/tests\/test_html.py:    t_expected = Table([['MASKED', 'MASKED', 3, 4], ['MASKED', 'MASKED', '--', 'b']], names=('a', 'b'))\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:from ..ipac import Ipac, IpacFormatError, IpacFormatErrorDBMS\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:DATA = '''\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    table = read(DATA, Reader=Ipac)\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    table = read(DATA, Reader=Ipac, definition='ignore')\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    table = read(DATA, Reader=Ipac, definition='left')\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    table = read(DATA, Reader=Ipac, definition='right')\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    with pytest.raises(IpacFormatErrorDBMS):\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:        ascii.write(table, out, Writer=Ipac, DBMS=True)\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:        ascii.write(table, out, Writer=Ipac, DBMS=False)\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:@pytest.mark.parametrize((\"strict_\", \"Err\"), [(True, IpacFormatErrorDBMS), (False, IpacFormatError)])\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:        ascii.write(table, out, Writer=Ipac, DBMS=strict_)\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    with pytest.raises(IpacFormatErrorDBMS):\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:        ascii.write(table, out, Writer=Ipac, DBMS=True)\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    table = Table([[3], [1]], names=['DEC', 'dec'])\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    with pytest.raises(IpacFormatErrorDBMS):\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:        ascii.write(table, out, Writer=Ipac, DBMS=True)\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    with pytest.raises(IpacFormatErrorDBMS):\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:        ascii.write(table, out, Writer=Ipac, DBMS=True)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_types.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_write.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_write.py:from ....utils.exceptions import AstropyWarning, AstropyDeprecationWarning\nastropy\/io\/ascii\/tests\/test_write.py:ID XCENTER YCENTER MAG MERR MSKY NITER SHARPNESS CHI PIER PERROR\nastropy\/io\/ascii\/tests\/test_write.py:ID XCENTER YCENTER MAG MERR MSKY NITER SHARPNESS CHI PIER PERROR\nastropy\/io\/ascii\/tests\/test_write.py:ID\\tXCENTER\\tYCENTER\\tMAG\\tMERR\\tMSKY\\tNITER\\tSHARPNESS\\tPIER\\tPERROR\nastropy\/io\/ascii\/tests\/test_write.py:ID\\tXCENTER\\tYCENTER\\tMAG\\tMERR\\tMSKY\\tNITER\\tSHARPNESS\\tCHI\\tPIER\\tPERROR\nastropy\/io\/ascii\/tests\/test_write.py:ID,XCENTER,YCENTER,MAG,MERR,MSKY,NITER,SHARPNESS,CHI,PIER,PERROR\nastropy\/io\/ascii\/tests\/test_write.py:# ID XCENTER YCENTER MAG MERR MSKY NITER SHARPNESS CHI PIER PERROR\nastropy\/io\/ascii\/tests\/test_write.py:&ID XCENTER YCENTER MAG MERR MSKY NITER SHARPNESS CHI PIER PERROR\nastropy\/io\/ascii\/tests\/test_write.py:ID & XCENTER & YCENTER & MAG & MERR & MSKY & NITER & SHARPNESS & CHI & PIER & PERROR \\\\\\\\\nastropy\/io\/ascii\/tests\/test_write.py:\\\\tablehead{\\\\colhead{ID} & \\\\colhead{XCENTER} & \\\\colhead{YCENTER} & \\\\colhead{MAG} & \\\\colhead{MERR} & \\\\colhead{MSKY} & \\\\colhead{NITER} & \\\\colhead{SHARPNESS} & \\\\colhead{CHI} & \\\\colhead{PIER} & \\\\colhead{PERROR}\\\\\\\\ \\\\colhead{ } & \\\\colhead{pixels} & \\\\colhead{pixels} & \\\\colhead{magnitudes} & \\\\colhead{magnitudes} & \\\\colhead{counts} & \\\\colhead{ } & \\\\colhead{ } & \\\\colhead{ } & \\\\colhead{ } & \\\\colhead{perrors}}\nastropy\/io\/ascii\/tests\/test_write.py:\\\\tablehead{\\\\colhead{ID} & \\\\colhead{XCENTER} & \\\\colhead{YCENTER} & \\\\colhead{MAG} & \\\\colhead{MERR} & \\\\colhead{MSKY} & \\\\colhead{NITER} & \\\\colhead{SHARPNESS} & \\\\colhead{CHI} & \\\\colhead{PIER} & \\\\colhead{PERROR}\\\\\\\\ \\\\colhead{ } & \\\\colhead{[pixel]} & \\\\colhead{pixels} & \\\\colhead{[mag]} & \\\\colhead{magnitudes} & \\\\colhead{counts} & \\\\colhead{ } & \\\\colhead{ } & \\\\colhead{ } & \\\\colhead{ } & \\\\colhead{perrors}}\nastropy\/io\/ascii\/tests\/test_write.py:ID & XCENTER & YCENTER & MAG & MERR & MSKY & NITER & SHARPNESS & CHI & PIER & PERROR \\\\\\\\\nastropy\/io\/ascii\/tests\/test_write.py:ID & XCENTER & YCENTER & MAG & MERR & MSKY & NITER & SHARPNESS & CHI & PIER & PERROR \\\\\\\\\nastropy\/io\/ascii\/tests\/test_write.py:ID & XCENTER & YCENTER & MAG & MERR & MSKY & NITER & SHARPNESS & CHI & PIER & PERROR \\\\\\\\\nastropy\/io\/ascii\/tests\/test_write.py:     <th>ID<\/th>\nastropy\/io\/ascii\/tests\/test_write.py:\\\\MERGERAD='INDEF'\nastropy\/io\/ascii\/tests\/test_write.py:\\\\DATE='05-28-93'\nastropy\/io\/ascii\/tests\/test_write.py:\\\\DATAMIN='50.'\nastropy\/io\/ascii\/tests\/test_write.py:\\\\DATAMAX='24500.'\nastropy\/io\/ascii\/tests\/test_write.py:\\\\READNOISE='0.'\nastropy\/io\/ascii\/tests\/test_write.py:\\\\PSFRAD='5.'\nastropy\/io\/ascii\/tests\/test_write.py:\\\\FITRAD='3.'\nastropy\/io\/ascii\/tests\/test_write.py:|       ID|   XCENTER|   YCENTER|         MAG|          MERR|           MSKY| NITER|              SHARPNESS|         CHI|  PIER|       PERROR|\nastropy\/io\/ascii\/tests\/test_write.py:    table = ascii.get_reader(Reader=ascii.Daophot)\nastropy\/io\/ascii\/tests\/test_write.py:    with catch_warnings(AstropyDeprecationWarning) as warning:\nastropy\/io\/ascii\/tests\/test_rst.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_read.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_read.py:from collections import OrderedDict\nastropy\/io\/ascii\/tests\/test_read.py:        print('\\n\\n******** READING {}'.format(testfile['name']))\nastropy\/io\/ascii\/tests\/test_read.py:        print('\\n\\n******** READING {}'.format(testfile['name']))\nastropy\/io\/ascii\/tests\/test_read.py:        print('\\n\\n******** READING {}'.format(testfile['name']))\nastropy\/io\/ascii\/tests\/test_read.py:    \"\"\"Test that INDEF is correctly interpreted as a missing value\"\"\"\nastropy\/io\/ascii\/tests\/test_read.py:    table = ascii.read('t\/daophot2.dat', Reader=ascii.Daophot)\nastropy\/io\/ascii\/tests\/test_read.py:        # Three columns have all INDEF values and are masked\nastropy\/io\/ascii\/tests\/test_read.py:    inferred automatically based only data values.  DAOphot reader uses\nastropy\/io\/ascii\/tests\/test_read.py:    table = ascii.read('t\/daophot2.dat', Reader=ascii.Daophot)\nastropy\/io\/ascii\/tests\/test_read.py:    assert table['LID'].dtype.char in 'fd'  # float or double\nastropy\/io\/ascii\/tests\/test_read.py:    assert table['ID'].dtype.char in 'il'  # int or long\nastropy\/io\/ascii\/tests\/test_read.py:    table = ascii.read('t\/daophot.dat', Reader=ascii.Daophot)\nastropy\/io\/ascii\/tests\/test_read.py:    table = ascii.read('t\/daophot3.dat', Reader=ascii.Daophot)\nastropy\/io\/ascii\/tests\/test_read.py:    table = ascii.read('t\/daophot4.dat', Reader=ascii.Daophot)\nastropy\/io\/ascii\/tests\/test_read.py:    include_names = ('ID', 'MAG', 'PIER')\nastropy\/io\/ascii\/tests\/test_read.py:    exclude_names = ('ID', 'YCENTER', 'MERR', 'NITER', 'CHI', 'PERROR')\nastropy\/io\/ascii\/tests\/test_read.py:    keywords = OrderedDict((('intval', 1),\nastropy\/io\/ascii\/tests\/test_read.py:    \"\"\"Read RDB data with inconstent data type (except failure)\"\"\"\nastropy\/io\/ascii\/tests\/test_read.py:                  'DE-',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEd',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEm',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEs',\nastropy\/io\/ascii\/tests\/test_read.py:        # Test malformed CDS file (issues #2241 #467)\nastropy\/io\/ascii\/tests\/test_read.py:                  'DE-',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEd',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEm',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEs',\nastropy\/io\/ascii\/tests\/test_read.py:        {'cols': ('ID',\nastropy\/io\/ascii\/tests\/test_read.py:         'opts': {'Reader': ascii.Daophot}},\nastropy\/io\/ascii\/tests\/test_read.py:                  'objID',\nastropy\/io\/ascii\/tests\/test_read.py:                  'SpecObjID',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DE-',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEd',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEm',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEs',\nastropy\/io\/ascii\/tests\/test_read.py:        {'cols': ('ID',\nastropy\/io\/ascii\/tests\/test_read.py:         'opts': {'Reader': ascii.Daophot}},\nastropy\/io\/ascii\/tests\/test_read.py:                   ascii.BaseReader, ascii.FixedWidthNoHeader, ascii.Cds, ascii.Daophot]:\nastropy\/io\/ascii\/tests\/test_read.py:    expected_columns = ['X_IMAGE', 'Y_IMAGE', 'ALPHA_J2000', 'DELTA_J2000',\nastropy\/io\/ascii\/tests\/test_read.py:                       'Declination of barycenter (J2000)',\nastropy\/io\/ascii\/tests\/test_read.py:             '| r  | rE | rea  | real | D | do | dou | f  | i | l | da| c |',\nastropy\/io\/ascii\/tests\/test_read.py:        if platform.system() == 'Darwin':\nastropy\/io\/ascii\/tests\/test_read.py:            locale.setlocale(locale.LC_ALL, str('de_DE'))\nastropy\/io\/ascii\/tests\/test_read.py:            locale.setlocale(locale.LC_ALL, str('de_DE.utf8'))\nastropy\/io\/ascii\/tests\/test_read.py:# Default delimiter is the space character.\nastropy\/io\/ascii\/tests\/test_read.py:# Data starts after the header column definition, blank lines ignored\nastropy\/io\/ascii\/tests\/test_read.py:    # TO DO commented_header does not currently work due to the special-cased\nastropy\/io\/votable\/tests\/tree_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/util_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/ucd_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_compressed.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/console.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/console.py:_DEFAULT_ENCODING = 'utf-8'\nastropy\/utils\/console.py:    \"\"\"Decode the supplied byte string using the preferred encoding\nastropy\/utils\/console.py:            enc = _DEFAULT_ENCODING\nastropy\/utils\/console.py:    except UnicodeDecodeError:\nastropy\/utils\/console.py:        Writer = codecs.getwriter(_DEFAULT_ENCODING)\nastropy\/utils\/console.py:        Where to write to.  Defaults to `sys.stdout`.  If file is not\nastropy\/utils\/console.py:        The ending of the message.  Defaults to ``\\\\n``.  The end will\nastropy\/utils\/console.py:    Depending on the number of seconds given, can be one of::\nastropy\/utils\/console.py:            The file to write the progress bar to.  Defaults to\nastropy\/utils\/console.py:                signal.signal(signal.SIGWINCH, signal.SIG_DFL)\nastropy\/utils\/console.py:        Does a `map` operation while displaying a progress bar with\nastropy\/utils\/console.py:            The file to write the progress bar to.  Defaults to\nastropy\/utils\/console.py:            The file to write the spinner to.  Defaults to\nastropy\/utils\/console.py:            color_print(' [Done]', 'green', file=file)\nastropy\/utils\/console.py:            The file to write the to.  Defaults to `sys.stdout`.  If\nastropy\/utils\/console.py:        Where to write to.  Defaults to `sys.stdout`.\nastropy\/utils\/console.py:        The number of spaces per tab (``'\\\\t'``) character.  Default\nastropy\/utils\/console.py:        truncated.  Defaults to 70 (this matches the default in the\nastropy\/utils\/console.py:            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\nastropy\/utils\/console.py:        if Carbon.Evt.EventAvail(0x0008)[0] == 0:  # 0x0008 is the keyDownMask\nastropy\/coordinates\/sites.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/__init__.py:.. _SIP: http:\/\/irsa.ipac.caltech.edu\/data\/SPITZER\/docs\/files\/spitzer\/shupeADASS.pdf\nastropy\/wcs\/__init__.py:  `~astropy.wcs.DistortionLookupTable`.\nastropy\/io\/votable\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/utils.py:    if radesys == '' and xcoord == 'RA--' and ycoord == 'DEC-':\nastropy\/wcs\/utils.py:    from ..coordinates import BaseRADecFrame, FK4, FK4NoETerms, FK5, ICRS, Galactic\nastropy\/wcs\/utils.py:    if isinstance(frame, BaseRADecFrame):\nastropy\/wcs\/utils.py:        ycoord = 'DEC-'\nastropy\/wcs\/utils.py:        CDELT1  =                  1.0 \/ [deg] Coordinate increment at reference point\nastropy\/wcs\/utils.py:        CDELT2  =                  1.0 \/ [deg] Coordinate increment at reference point\nastropy\/wcs\/utils.py:        CTYPE2  = 'DEC--TAN'           \/ Declination, gnomonic projection\nastropy\/wcs\/utils.py:        RADESYS = 'FK5'                \/ Equatorial coordinate system\nastropy\/wcs\/utils.py:        Pixel area is defined only for 2D pixels. Most likely the\nastropy\/wcs\/utils.py:    Depending on the application, square root of the pixel area can be used to\nastropy\/wcs\/utils.py:        raise ValueError(\"Pixel area is defined only for 2D pixels.\")\nastropy\/wcs\/utils.py:    (from ``PC`` and ``CDELT``) CD matrix. `is_proj_plane_distorted`\nastropy\/wcs\/utils.py:        Accuracy to which the CD matrix, **normalized** such\nastropy\/wcs\/utils.py:        that :math:`|det(CD)|=1`, should be close to being an\nastropy\/wcs\/utils.py:        raise ValueError(\"CD (or PC) matrix must be a 2D square matrix.\")\nastropy\/wcs\/utils.py:        raise ValueError(\"CD (or PC) matrix is singular.\")\nastropy\/wcs\/utils.py:    # However, I am not aware of complex CD\/PC matrices...\nastropy\/wcs\/utils.py:# TODO: in future, we should think about how the following two functions can be\nastropy\/coordinates\/angle_lextab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angle_lextab.py:_lextokens    = set(('UINT', 'SIMPLE_UNIT', 'DEGREE', 'MINUTE', 'HOUR', 'COLON', 'UFLOAT', 'SIGN', 'SECOND'))\nastropy\/coordinates\/angle_lextab.py:_lexstatere   = {'INITIAL': [('(?P<t_UFLOAT>((\\\\d+\\\\.\\\\d*)|(\\\\.\\\\d+))([eE][+-\u2212]?\\\\d+)?)|(?P<t_UINT>\\\\d+)|(?P<t_SIGN>[+\u2212-])|(?P<t_SIMPLE_UNIT>(?:karcsec)|(?:uarcsec)|(?:Earcmin)|(?:Zdeg)|(?:crad)|(?:cycle)|(?:hectoradian)|(?:Yarcmin)|(?:kiloarcsecond)|(?:zeptoarcminute)|(?:adeg)|(?:darcmin)|(?:ddeg)|(?:exaradian)|(?:parcsec)|(?:yoctoradian)|(?:arcsecond)|(?:petadegree)|(?:petaarcminute)|(?:microarcsecond)|(?:mas)|(?:parcmin)|(?:hdeg)|(?:narcmin)|(?:attodegree)|(?:kilodegree)|(?:zettaradian)|(?:fdeg)|(?:zeptoradian)|(?:microradian)|(?:Gdeg)|(?:hectodegree)|(?:attoarcsecond)|(?:Marcmin)|(?:exadegree)|(?:femtodegree)|(?:yottaradian)|(?:pdeg)|(?:zarcmin)|(?:kiloarcminute)|(?:urad)|(?:teraarcsecond)|(?:nrad)|(?:carcsec)|(?:Pdeg)|(?:Yrad)|(?:yrad)|(?:picoarcsecond)|(?:aarcsec)|(?:dekaradian)|(?:Zrad)|(?:femtoradian)|(?:yarcsec)|(?:arcmin)|(?:arcsec)|(?:yottadegree)|(?:drad)|(?:dekadegree)|(?:zdeg)|(?:zeptoarcsecond)|(?:farcmin)|(?:Parcmin)|(?:decaarcminute)|(?:nanoarcminute)|(?:nanoarcsecond)|(?:Tdeg)|(?:decaarcsecond)|(?:nanodegree)|(?:farcsec)|(?:femtoarcminute)|(?:microdegree)|(?:deciarcsecond)|(?:deciarcminute)|(?:attoradian)|(?:dadeg)|(?:decidegree)|(?:hectoarcminute)|(?:milliarcsecond)|(?:femtoarcsecond)|(?:megaarcminute)|(?:yoctoarcminute)|(?:zrad)|(?:hectoarcsecond)|(?:frad)|(?:centiarcsecond)|(?:carcmin)|(?:Garcmin)|(?:decadegree)|(?:Grad)|(?:petaarcsecond)|(?:gigaarcsecond)|(?:megaradian)|(?:Tarcsec)|(?:Prad)|(?:zettadegree)|(?:yottaarcminute)|(?:mrad)|(?:yottaarcsecond)|(?:exaarcminute)|(?:harcmin)|(?:dekaarcsecond)|(?:cy)|(?:ndeg)|(?:teraradian)|(?:teradegree)|(?:Zarcsec)|(?:gigadegree)|(?:Mdeg)|(?:Mrad)|(?:centiarcminute)|(?:uarcmin)|(?:picoradian)|(?:radian)|(?:ydeg)|(?:milliarcminute)|(?:deciradian)|(?:narcsec)|(?:Trad)|(?:picodegree)|(?:yoctodegree)|(?:zettaarcminute)|(?:daarcmin)|(?:arcminute)|(?:yarcmin)|(?:kdeg)|(?:Earcsec)|(?:Edeg)|(?:harcsec)|(?:rad)|(?:centidegree)|(?:Garcsec)|(?:marcsec)|(?:megaarcsecond)|(?:attoarcminute)|(?:cdeg)|(?:Erad)|(?:kiloradian)|(?:daarcsec)|(?:Parcsec)|(?:megadegree)|(?:millidegree)|(?:centiradian)|(?:uas)|(?:teraarcminute)|(?:prad)|(?:yoctoarcsecond)|(?:hrad)|(?:picoarcminute)|(?:petaradian)|(?:Marcsec)|(?:marcmin)|(?:Tarcmin)|(?:zeptodegree)|(?:Yarcsec)|(?:gigaarcminute)|(?:Zarcmin)|(?:arad)|(?:karcmin)|(?:darcsec)|(?:exaarcsecond)|(?:nanoradian)|(?:udeg)|(?:zarcsec)|(?:Ydeg)|(?:decaradian)|(?:milliradian)|(?:aarcmin)|(?:zettaarcsecond)|(?:darad)|(?:microarcminute)|(?:mdeg)|(?:dekaarcminute)|(?:krad)|(?:gigaradian))|(?P<t_MINUTE>m(in(ute(s)?)?)?|\u2032|\\\\\\'|\u1d50)|(?P<t_SECOND>s(ec(ond(s)?)?)?|\u2033|\\\\\"|\u02e2)|(?P<t_DEGREE>d(eg(ree(s)?)?)?|\u00b0)|(?P<t_HOUR>hour(s)?|h(r)?|\u02b0)|(?P<t_COLON>:)', [None, ('t_UFLOAT', 'UFLOAT'), None, None, None, None, ('t_UINT', 'UINT'), ('t_SIGN', 'SIGN'), ('t_SIMPLE_UNIT', 'SIMPLE_UNIT'), (None, 'MINUTE'), None, None, None, (None, 'SECOND'), None, None, None, (None, 'DEGREE'), None, None, None, (None, 'HOUR'), None, None, (None, 'COLON')])]}\nastropy\/wcs\/docstrings.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/docstrings.py:``int`` (read-only) Order of the polynomial (``A_ORDER``).\nastropy\/wcs\/docstrings.py:Does the following:\nastropy\/wcs\/docstrings.py:    - Detector to image plane correction (if present)\nastropy\/wcs\/docstrings.py:``int`` (read-only) Order of the polynomial (``AP_ORDER``).\nastropy\/wcs\/docstrings.py:``int`` (read-only) Order of the polynomial (``B_ORDER``).\nastropy\/wcs\/docstrings.py:    transformations.  Default is `True`.\nastropy\/wcs\/docstrings.py:    transformations.  Default is `True`.\nastropy\/wcs\/docstrings.py:``int`` (read-only) Order of the polynomial (``BP_ORDER``).\nastropy\/wcs\/docstrings.py:``double array[naxis][naxis]`` The ``CDi_ja`` linear transformation\nastropy\/wcs\/docstrings.py:``PCi_ja`` with ``CDELTia``, ``CDi_ja``, and the deprecated\nastropy\/wcs\/docstrings.py:if ``CDi_ja`` is present (and no ``PCi_ja``).  If no ``CROTAia`` is\nastropy\/wcs\/docstrings.py:``double array[naxis]`` Coordinate increments (``CDELTia``) for each\nastropy\/wcs\/docstrings.py:If a ``CDi_ja`` linear transformation matrix is present, a warning is\nastropy\/wcs\/docstrings.py:raised and `~astropy.wcs.Wcsprm.cdelt` is ignored.  The ``CDi_ja``\nastropy\/wcs\/docstrings.py:Fix erroneously omitted ``CDi_ja`` keywords.\nastropy\/wcs\/docstrings.py:Sets the diagonal element of the ``CDi_ja`` matrix to unity if all\nastropy\/wcs\/docstrings.py:``CDi_ja`` keywords associated with a given axis were omitted.\nastropy\/wcs\/docstrings.py:According to Paper I, if any ``CDi_ja`` keywords at all are given in a\nastropy\/wcs\/docstrings.py:(0, 0)`` at the fiducial point, (phi_0, theta_0).  Default is `False`.\nastropy\/wcs\/docstrings.py:      change the WCS transformation, such as ``DATE-OBS`` or\nastropy\/wcs\/docstrings.py:`~astropy.wcs.DistortionLookupTable`\nastropy\/wcs\/docstrings.py:The pre-linear transformation distortion lookup table, ``CPDIS1``.\nastropy\/wcs\/docstrings.py:`~astropy.wcs.DistortionLookupTable`\nastropy\/wcs\/docstrings.py:The pre-linear transformation distortion lookup table, ``CPDIS2``.\nastropy\/wcs\/docstrings.py:``CRDERia``.\nastropy\/wcs\/docstrings.py:``PCi_ja`` with ``CDELTia``, ``CDi_ja``, and the deprecated\nastropy\/wcs\/docstrings.py:if ``CDi_ja`` is present (and no ``PCi_ja``).  If no ``CROTAia`` is\nastropy\/wcs\/docstrings.py:These define the units of measurement of the ``CRVALia``, ``CDELTia``\nastropy\/wcs\/docstrings.py:and ``CDi_ja`` keywords.\nastropy\/wcs\/docstrings.py:`~astropy.wcs.DistortionLookupTable`.\nastropy\/wcs\/docstrings.py:Translates the old ``DATE-OBS`` date format to year-2000 standard form\nastropy\/wcs\/docstrings.py:``(yyyy-mm-ddThh:mm:ss)`` and derives ``MJD-OBS`` from it if not\nastropy\/wcs\/docstrings.py:A `~astropy.wcs.DistortionLookupTable` object for detector to image plane\nastropy\/wcs\/docstrings.py:A `~astropy.wcs.DistortionLookupTable` object for detector to image plane\nastropy\/wcs\/docstrings.py:DistortionLookupTable = \"\"\"\nastropy\/wcs\/docstrings.py:DistortionLookupTable(*table*, *crpix*, *crval*, *cdelt*)\nastropy\/wcs\/docstrings.py:    Degree of permissiveness:\nastropy\/wcs\/docstrings.py:    - ``WCSHDR_IMGHEAD``: Image header keywords.\nastropy\/wcs\/docstrings.py:    - ``WCSHDR_BIMGARR``: Binary table image array.\nastropy\/wcs\/docstrings.py:    - ``WCSHDR_PIXLIST``: Pixel list keywords.\nastropy\/wcs\/docstrings.py:    used.  The same applies to ``\"H\"`` for hours (Henry), and ``\"D\"``\nastropy\/wcs\/docstrings.py:    for days (Debye).\nastropy\/wcs\/docstrings.py:    - If the string contains ``\"d\"``, translate ``\"D\"`` to ``\"d\"``.\nastropy\/wcs\/docstrings.py:Coordinate increments (``CDELTia``) for each coord axis.\nastropy\/wcs\/docstrings.py:Returns the ``CDELT`` offsets in read-only form.  Unlike the\nastropy\/wcs\/docstrings.py:``CDi_ja`` or ``CROTAia`` forms.  This is useful when you want access\nastropy\/wcs\/docstrings.py:``CDi_ja`` or ``CROTAia`` forms.  This is useful when you want access\nastropy\/wcs\/docstrings.py:Returns `True` if ``CDi_ja`` is present.\nastropy\/wcs\/docstrings.py:``CDi_ja`` is an alternate specification of the linear transformation\nastropy\/wcs\/docstrings.py:``CDi_ja = CDELTia * PCi_ja``, but the defaults differ from that of\nastropy\/wcs\/docstrings.py:the ``PCi_ja`` matrix.  If one or more ``CDi_ja`` keywords are present\nastropy\/wcs\/docstrings.py:then all unspecified ``CDi_ja`` default to zero.  If no ``CDi_ja`` (or\nastropy\/wcs\/docstrings.py:since this results in an interpretation of ``CDELTia`` consistent with\nastropy\/wcs\/docstrings.py:While ``CDi_ja`` may not formally co-exist with ``PCi_ja``, it may\nastropy\/wcs\/docstrings.py:co-exist with ``CDELTia`` and ``CROTAia`` which are to be ignored.\nastropy\/wcs\/docstrings.py:astropy.wcs.Wcsprm.cd : Get the raw ``CDi_ja`` values.\nastropy\/wcs\/docstrings.py:the image plane that is applied *after* the ``CDELTia``; any other\nastropy\/wcs\/docstrings.py:``CDELTia`` may formally co-exist with ``CDi_ja`` but if so are to be\nastropy\/wcs\/docstrings.py:``double array[2][2]`` (read-only) Inverse of the ``CDELT`` or ``PC``\nastropy\/wcs\/docstrings.py:Inverse containing the product of the ``CDELTia`` diagonal matrix and\nastropy\/wcs\/docstrings.py:For example, \"RA\", \"DEC\", \"GLON\", \"GLAT\", etc. extracted from \"RA--\",\nastropy\/wcs\/docstrings.py:\"DEC-\", \"GLON\", \"GLAT\", etc. in the first four characters of\nastropy\/wcs\/docstrings.py:For example, \"RA\", \"DEC\", \"GLON\", \"GLAT\", etc. extracted from \"RA--\",\nastropy\/wcs\/docstrings.py:\"DEC-\", \"GLON\", \"GLAT\", etc. in the first four characters of\nastropy\/wcs\/docstrings.py:``double`` Modified Julian Date corresponding to ``DATE-AVG``.\nastropy\/wcs\/docstrings.py:``(MJD = JD - 2400000.5)``.\nastropy\/wcs\/docstrings.py:``double`` Modified Julian Date corresponding to ``DATE-OBS``.\nastropy\/wcs\/docstrings.py:``(MJD = JD - 2400000.5)``.\nastropy\/wcs\/docstrings.py:    Definition of the latitude and longitude axes\nastropy\/wcs\/docstrings.py:``PCi_ja`` with ``CDELTia``, ``CDi_ja``, and the deprecated\nastropy\/wcs\/docstrings.py:if ``CDi_ja`` is present (and no ``PCi_ja``).  If no ``CROTAia`` is\nastropy\/wcs\/docstrings.py:the ``CDELTia`` diagonal matrix and the ``PCi_ja`` matrix.\nastropy\/wcs\/docstrings.py:``RADESYSa``.\nastropy\/wcs\/docstrings.py:    Definition of the latitude and longitude axes\nastropy\/wcs\/docstrings.py:    Its size must be (*m* + 1, *m* + 1) where *m* = ``A_ORDER``.\nastropy\/wcs\/docstrings.py:    Its size must be (*m* + 1, *m* + 1) where *m* = ``B_ORDER``.\nastropy\/wcs\/docstrings.py:    Its size must be (*m* + 1, *m* + 1) where *m* = ``AP_ORDER``.\nastropy\/wcs\/docstrings.py:    Its size must be (*m* + 1, *m* + 1) where *m* = ``BP_ORDER``.\nastropy\/wcs\/docstrings.py:Shupe, D. L., M. Moshir, J. Li, D. Makovoz and R. Narron.  2005.\nastropy\/wcs\/docstrings.py:\"The SIP Convention for Representing Distortion in FITS Image\nastropy\/wcs\/docstrings.py:Headers.\"  ADASS XIV.\nastropy\/wcs\/docstrings.py:    - ``'longitude'`` \/ ``WCSSUB_LONGITUDE``: Celestial longitude\nastropy\/wcs\/docstrings.py:    - ``'latitude'`` \/ ``WCSSUB_LATITUDE``: Celestial latitude\nastropy\/wcs\/docstrings.py:    wcs.sub([WCSSUB_LONGITUDE | WCSSUB_LATITUDE | WCSSUB_SPECTRAL])\nastropy\/wcs\/docstrings.py:``WCSSUB_LONGITUDE | WCSSUB_LATITUDE | WCSSUB_CUBEFACE``.\nastropy\/wcs\/docstrings.py:      WCSSUB_LONGITUDE,\nastropy\/wcs\/docstrings.py:      WCSSUB_LATITUDE,\nastropy\/wcs\/docstrings.py:       such as ``SIMPLE``, ``NAXIS``, ``BITPIX``, or ``END``.\nastropy\/wcs\/docstrings.py:    2. Deprecated (e.g. ``CROTAn``) or non-standard usage will be\nastropy\/wcs\/docstrings.py:    Degree of permissiveness:\nastropy\/wcs\/docstrings.py:For example, ``DEG`` -> ``deg``, also stripping off unnecessary\nastropy\/wcs\/docstrings.py:    Do potentially unsafe translations of non-standard unit strings.\nastropy\/wcs\/docstrings.py:    and ``\\\"D\\\"`` for days (Debye).\nastropy\/wcs\/docstrings.py:    - If the string contains ``\\\"d\\\"``, translate ``\\\"D\\\"`` to ``\\\"d\\\"``.\nastropy\/wcs\/docstrings.py:cpdis : A pair of `~astropy.wcs.DistortionLookupTable` objects, or\nastropy\/wcs\/docstrings.py:det2im : A pair of `~astropy.wcs.DistortionLookupTable` objects, or\nastropy\/wcs\/docstrings.py:    Degree of permissiveness:\nastropy\/wcs\/docstrings.py:        - ``WCSHDR_IMGHEAD``: Image header keywords.\nastropy\/wcs\/docstrings.py:        - ``WCSHDR_BIMGARR``: Binary table image array.\nastropy\/wcs\/docstrings.py:        - ``WCSHDR_PIXLIST``: Pixel list keywords.\nastropy\/io\/votable\/tests\/resource_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/resource_test.py:    assert groups[0].entries[0].name == \"ID\"\nastropy\/io\/votable\/tests\/resource_test.py:    assert params[0].name == \"standardID\"\nastropy\/wcs\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/_docutil.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/_docutil.py:__all__ = ['TWO_OR_THREE_ARGS', 'RETURNS', 'ORIGIN', 'RA_DEC_ORDER']\nastropy\/wcs\/_docutil.py:def RA_DEC_ORDER(indent=0):\nastropy\/wcs\/_docutil.py:    the axes specified by the in the ``CTYPE`` keywords.  Default is\nastropy\/wcs\/tests\/test_utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_utils.py:    # Default: numpy order\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN', 'VOPT-LSR', 'STOKES']\nastropy\/wcs\/tests\/test_utils.py:    assert mywcs.axis_type_names == ['RA', 'DEC', 'VOPT', 'STOKES']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.cname = ['RA', 'DEC', 'VOPT', 'STOKES']\nastropy\/wcs\/tests\/test_utils.py:    assert mywcs.axis_type_names == ['RA', 'DEC', 'VOPT', 'STOKES']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN', 'VOPT', 'STOKES']\nastropy\/wcs\/tests\/test_utils.py:    assert tuple(cel.wcs.ctype) == ('RA---TAN', 'DEC--TAN')\nastropy\/wcs\/tests\/test_utils.py:    assert cel.axis_type_names == ['RA', 'DEC']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['DEC--TAN', 'RA---TAN']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['DEC--TAN', 'VELOCITY', 'RA---TAN']\nastropy\/wcs\/tests\/test_utils.py:    assert tuple(mywcs.wcs.ctype) == ('RA---TAN', 'DEC--TAN')\nastropy\/wcs\/tests\/test_utils.py:    assert tuple(mywcs.wcs.ctype) == ('RA---TAN', 'DEC--TAN')\nastropy\/wcs\/tests\/test_utils.py:    assert tuple(mywcs.wcs.ctype) == ('RA---TAN', 'DEC--TAN')\nastropy\/wcs\/tests\/test_utils.py:    assert tuple(mywcs.wcs.ctype) == ('RA---TAN', 'DEC--TAN')\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN', 'VOPT']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_utils.py:                         ((['RA---TAN', 'DEC--TAN'], True),\nastropy\/wcs\/tests\/test_utils.py:                          (['RA---TAN', 'DEC--TAN', 'FREQ'], False),\nastropy\/wcs\/tests\/test_utils.py:                         ((['RA---TAN', 'DEC--TAN'], True),\nastropy\/wcs\/tests\/test_utils.py:                          (['RA---TAN', 'DEC--TAN', 'FREQ'], True),\nastropy\/wcs\/tests\/test_utils.py:    # non-orthogonal CD:\nastropy\/wcs\/tests\/test_utils.py:    wcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_utils.py:    # almost orthogonal CD:\nastropy\/table\/row.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/row.py:            raise ValueError('Datatype coercion is not allowed')\nastropy\/table\/row.py:        Display row as a single-line table but with appropriate header line.\nastropy\/wcs\/tests\/test_profiling.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_profiling.py:# OLD COMMENTS:\nastropy\/table\/info.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/info.py:from ..utils.data_info import DataInfo\nastropy\/table\/info.py:    column as its single argument.  The function must return an OrderedDict\nastropy\/table\/info.py:class TableInfo(DataInfo):\nastropy\/table\/groups.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/groups.py:        # 'mergesort' for all data types.  MacOSX (Darwin) doesn't have a stable\nastropy\/table\/groups.py:        stable_sort = platform.system() not in ('Darwin', 'Windows')\nastropy\/wcs\/tests\/test_pickle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/scripts\/showtable.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/scripts\/showtable.py:``astropy.table`` for printing ASCII, FITS, HDF5 or VOTable files(s) to the\nastropy\/table\/scripts\/showtable.py:            Print tables from ASCII, FITS, HDF5, VOTable file(s).  The tables\nastropy\/table\/scripts\/showtable.py:    addarg('--hdu', help='name of the HDU to show')\nastropy\/table\/scripts\/showtable.py:    # HDF5-specific arguments\nastropy\/table\/scripts\/showtable.py:    hdf5_args = parser.add_argument_group('HDF5 arguments')\nastropy\/table\/meta.py:from collections import OrderedDict\nastropy\/table\/meta.py:class ColumnDict(dict):\nastropy\/table\/meta.py:    Construct OrderedDict from !!omap in yaml safe load.\nastropy\/table\/meta.py:    except the data type is changed to OrderedDict() and setitem is\nastropy\/table\/meta.py:      OrderedDict([('foo', 'bar'), ('mumble', 'quux'), ('baz', 'gorp')])\nastropy\/table\/meta.py:      OrderedDict([('foo', 'bar'), ('mumble', 'quux'), ('baz', 'gorp')])\nastropy\/table\/meta.py:    omap = OrderedDict()\nastropy\/table\/meta.py:    Represent OrderedDict in yaml dump.\nastropy\/table\/meta.py:    >>> data = OrderedDict([('foo', 'bar'), ('mumble', 'quux'), ('baz', 'gorp')])\nastropy\/table\/meta.py:    Represent ColumnDict in yaml dump.\nastropy\/table\/meta.py:    attrs = ColumnDict()\nastropy\/table\/meta.py:    from ..io.misc.yaml import AstropyDumper\nastropy\/table\/meta.py:    class TableDumper(AstropyDumper):\nastropy\/table\/meta.py:        Custom Dumper that represents OrderedDict as an !!omap object.\nastropy\/table\/meta.py:    TableDumper.add_representer(OrderedDict, _repr_odict)\nastropy\/table\/meta.py:    TableDumper.add_representer(ColumnDict, _repr_column_dict)\nastropy\/table\/meta.py:    header = copy.copy(header)  # Don't overwrite original\nastropy\/table\/meta.py:    lines = yaml.dump(header, Dumper=TableDumper, width=130).splitlines()\nastropy\/table\/meta.py:        Dictionary describing table and column meta\nastropy\/table\/meta.py:        Custom Loader that constructs OrderedDict from an !!omap object.\nastropy\/table\/sorted_array.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/sorted_array.py:        Decrement all row numbers greater than the input row.\nastropy\/table\/operations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/operations.py:from collections import OrderedDict, Counter\nastropy\/table\/operations.py:        Default is to use all columns which are common to both tables.\nastropy\/table\/operations.py:    col_name_map = OrderedDict()\nastropy\/table\/operations.py:        Default is to use all columns in ``table1``.\nastropy\/table\/operations.py:    # Dummy column to recover rows after join\nastropy\/table\/operations.py:        # Define bool mask of table1 rows not in table2\nastropy\/table\/operations.py:    col_name_map = OrderedDict()\nastropy\/table\/operations.py:    col_name_map = OrderedDict()\nastropy\/table\/operations.py:        Default is to use all columns.\nastropy\/table\/operations.py:        Default is 'first'.\nastropy\/table\/operations.py:        Default is `False`.\nastropy\/table\/operations.py:    col_name_map = OrderedDict((name, col_name_map[name]) for name in col_name_list)\nastropy\/table\/operations.py:        Default is to use all columns which are common to both tables.\nastropy\/table\/operations.py:        col_name_map = OrderedDict((name, in_names) for name, in_names in col_name_map.items()\nastropy\/table\/index.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/extension\/test_extension.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/extension\/test_extension.py:    except UnicodeDecodeError:\nastropy\/wcs\/tests\/extension\/test_extension.py:        # Don't try to guess about encoding; just display the text\nastropy\/wcs\/tests\/extension\/setup.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/extension\/setup.py:            ('YY_NO_UNISTD_H', None),\nastropy\/wcs\/tests\/extension\/setup.py:            ('_NO_OLDNAMES', None),  # for mingw32\nastropy\/wcs\/tests\/extension\/setup.py:            ('NO_OLDNAMES', None),  # for mingw64\nastropy\/wcs\/tests\/extension\/setup.py:            ('__STDC__', None)  # for MSVC\nastropy\/table\/column.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/column.py:from ..utils.metadata import MetaData\nastropy\/table\/column.py:        Data shape\nastropy\/table\/column.py:    meta = MetaData()\nastropy\/table\/column.py:            arguments.)  Default is 'C'.\nastropy\/table\/column.py:            reference.  Default is True.\nastropy\/table\/column.py:        # Define Column-specific attrs and meta that gets added to state.\nastropy\/table\/column.py:            Include column name. Default is True.\nastropy\/table\/column.py:            Include a header row for unit. Default is False.\nastropy\/table\/column.py:            Include column dtype. Default is False.\nastropy\/table\/column.py:            Format the output as an HTML table. Default is False.\nastropy\/table\/column.py:            Include column name. Default is True.\nastropy\/table\/column.py:            Include a header row for unit. Default is False.\nastropy\/table\/column.py:            Include column dtype. Default is True.\nastropy\/table\/column.py:            Include a header row for column names. Default is True.\nastropy\/table\/column.py:            Include a header row for unit. Default is False.\nastropy\/table\/column.py:    \"\"\"Define a data column for use in a Table object.\nastropy\/table\/column.py:        Data type for column\nastropy\/table\/column.py:        Dimensions of a single row element in the column data\nastropy\/table\/column.py:            the column array is flattened before insertion.  Default is 0,\nastropy\/table\/column.py:    \"\"\"Define a masked data column for use in a Table object.\nastropy\/table\/column.py:        Data type for column\nastropy\/table\/column.py:        Dimensions of a single row element in the column data\nastropy\/table\/column.py:            the column array is flattened before insertion.  Default is 0,\nastropy\/table\/serialize.py:                             'astropy.time.core.TimeDelta',\nastropy\/table\/serialize.py:                             'astropy.coordinates.distances.Distance',\nastropy\/table\/serialize.py:    # - name: handled directly [DON'T store]\nastropy\/table\/serialize.py:    # - unit: DON'T store if this is a parent attribute\nastropy\/table\/serialize.py:    # - dtype: captured in plain Column if relevant [DON'T store]\nastropy\/table\/serialize.py:    # - format: possibly irrelevant but settable post-object creation [DO store]\nastropy\/table\/serialize.py:    # - description: DO store\nastropy\/table\/serialize.py:    # - meta: DO store\nastropy\/table\/serialize.py:            # TODO masking, MaskedColumn\nastropy\/table\/serialize.py:    # Don't know final output class but assume QTable so no columns get\nastropy\/table\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/bst.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/bst.py:        Decrement all rows larger than the given row.\nastropy\/table\/bst.py:                raise ValueError(\"Data does not belong to correct node\")\nastropy\/table\/bst.py:                raise ValueError(\"Data does not belong to correct node\")\nastropy\/table\/bst.py:        Decrement rows larger than the given row.\nastropy\/table\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/table.py:from collections import OrderedDict, Mapping\nastropy\/table\/table.py:from ..utils import isiterable, ShapedLikeNDArray\nastropy\/table\/table.py:from ..utils.metadata import MetaData\nastropy\/table\/table.py:from ..utils.data_info import BaseColumnInfo, MixinInfo, ParentDtypeInfo, DataInfo\nastropy\/table\/table.py:from ..utils.exceptions import AstropyDeprecationWarning, NoValue\nastropy\/table\/table.py:class TableColumns(OrderedDict):\nastropy\/table\/table.py:    \"\"\"OrderedDict subclass for a set of columns.\nastropy\/table\/table.py:            return OrderedDict.__getitem__(self, item)\nastropy\/table\/table.py:    # Define keys and values for Python 2 and 3 source compatibility\nastropy\/table\/table.py:        return list(OrderedDict.keys(self))\nastropy\/table\/table.py:        return list(OrderedDict.values(self))\nastropy\/table\/table.py:    `Table` differs from `~astropy.nddata.NDData` by the assumption that the\nastropy\/table\/table.py:        Data to initialize table.\nastropy\/table\/table.py:        Default is True.\nastropy\/table\/table.py:        Copy any indices in the input data. Default is True.\nastropy\/table\/table.py:    meta = MetaData()\nastropy\/table\/table.py:    # Define class attributes for core container objects to allow for subclass\nastropy\/table\/table.py:            # Data object implements the __astropy_table__ interface method.\nastropy\/table\/table.py:            raise ValueError('Data type {0} not allowed to init Table'\nastropy\/table\/table.py:        columns = OrderedDict((key, col if isinstance(col, BaseColumn) else col_copy(col))\nastropy\/table\/table.py:        # Dynamic view of available masks\nastropy\/table\/table.py:            Whether the values of the index must be unique. Default is False.\nastropy\/table\/table.py:            raise ValueError('Datatype coercion is not allowed')\nastropy\/table\/table.py:        # TODO: is this restriction still needed with no ndarray?\nastropy\/table\/table.py:        # Deduplicate indices.  It may happen that after pickling or when\nastropy\/table\/table.py:            raise ValueError('Duplicate column names')\nastropy\/table\/table.py:        Determine if ``col`` should be added to the table directly as\nastropy\/table\/table.py:            Include a header row for column names. Default is True.\nastropy\/table\/table.py:            Include a header row for unit.  Default is to show a row\nastropy\/table\/table.py:            Include a header row for column dtypes. Default is True.\nastropy\/table\/table.py:            Left\/right alignment of columns. Default is right (None) for all\nastropy\/table\/table.py:            An html ID tag for the table.  Default is ``table{id}-XXX``, where\nastropy\/table\/table.py:            A valid CSS string declaring the formatting for the table. Defaults\nastropy\/table\/table.py:            to ``astropy.table.jsviewer.DEFAULT_CSS_NB``.\nastropy\/table\/table.py:            Number or rows to show. Defaults to 50.\nastropy\/table\/table.py:            ignored. Defaults to \"idx\".\nastropy\/table\/table.py:            rendered as a `DataTables <https:\/\/datatables.net>`_ data table.\nastropy\/table\/table.py:            Passed to the `astropy.table.JSViewer` init. Defaults to\nastropy\/table\/table.py:            An html ID tag for the table.  Default is ``table{id}``, where id\nastropy\/table\/table.py:            Default is \"display compact\", and other possible values can be\nastropy\/table\/table.py:            A valid CSS string declaring the formatting for the table. Defaults\nastropy\/table\/table.py:            to ``astropy.table.jsviewer.DEFAULT_CSS``.\nastropy\/table\/table.py:            ignored. Defaults to \"idx\".\nastropy\/table\/table.py:        from .jsviewer import DEFAULT_CSS\nastropy\/table\/table.py:            css = DEFAULT_CSS\nastropy\/table\/table.py:            Include a header row for column names. Default is True.\nastropy\/table\/table.py:            Include a header row for unit.  Default is to show a row\nastropy\/table\/table.py:            Include a header row for column dtypes. Default is True.\nastropy\/table\/table.py:            Format the output as an HTML table. Default is False.\nastropy\/table\/table.py:            An ID tag for the table; only used if html is set.  Default is\nastropy\/table\/table.py:            Left\/right alignment of columns. Default is right (None) for all\nastropy\/table\/table.py:            CSS classes for the table; only used if html is set.  Default is\nastropy\/table\/table.py:            Include a header row for column names. Default is True.\nastropy\/table\/table.py:            Include a header row for unit.  Default is to show a row\nastropy\/table\/table.py:            Include a header row for column dtypes. Default is True.\nastropy\/table\/table.py:                    elif isinstance(value, ShapedLikeNDArray):\nastropy\/table\/table.py:            Uniquify column name if it already exist. Default is False.\nastropy\/table\/table.py:            Make a copy of the new column. Default is True.\nastropy\/table\/table.py:            Make a copy of the new columns. Default is True.\nastropy\/table\/table.py:            Default is False.\nastropy\/table\/table.py:            # Did reference count change?\nastropy\/table\/table.py:            # Check base DataInfo attributes that any column will have\nastropy\/table\/table.py:            for attr in DataInfo.attr_names:\nastropy\/table\/table.py:        cols = OrderedDict(self.columns)\nastropy\/table\/table.py:                          AstropyDeprecationWarning)\nastropy\/table\/table.py:                          AstropyDeprecationWarning)\nastropy\/table\/table.py:        TODO: this won't work for mixins\nastropy\/table\/table.py:        Return a :class:`pandas.DataFrame` instance\nastropy\/table\/table.py:        dataframe : :class:`pandas.DataFrame`\nastropy\/table\/table.py:            A pandas :class:`pandas.DataFrame` instance\nastropy\/table\/table.py:        from pandas import DataFrame\nastropy\/table\/table.py:            raise ValueError(\"Cannot convert a table with mixin columns to a pandas DataFrame\")\nastropy\/table\/table.py:            raise ValueError(\"Cannot convert a table with multi-dimensional columns to a pandas DataFrame\")\nastropy\/table\/table.py:        out = OrderedDict()\nastropy\/table\/table.py:        return DataFrame(out)\nastropy\/table\/table.py:        Create a `Table` from a :class:`pandas.DataFrame` instance\nastropy\/table\/table.py:        dataframe : :class:`pandas.DataFrame`\nastropy\/table\/table.py:            The pandas :class:`pandas.DataFrame` instance\nastropy\/table\/table.py:        out = OrderedDict()\nastropy\/table\/table.py:        Data to initialize table.\nastropy\/table\/table.py:        Copy the input data. Default is True.\nastropy\/table\/table.py:        Copy any indices in the input data. Default is True.\nastropy\/table\/table.py:        Determine if ``col`` should be added to the table directly as\nastropy\/table\/table.py:    info = ParentDtypeInfo()\nastropy\/wcs\/wcslint.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/table_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/table_helpers.py:from ..utils.data_info import ParentDtypeInfo\nastropy\/table\/table_helpers.py:        Number of table columns. Defaults to number of kinds.\nastropy\/table\/table_helpers.py:    info = ParentDtypeInfo()\nastropy\/wcs\/tests\/test_wcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_wcs.py:    # TODO: write this to test the expected output behavior of pix2world,\nastropy\/wcs\/tests\/test_wcs.py:    # Dictionary with no actual WCS, returns identity transform\nastropy\/wcs\/tests\/test_wcs.py:                 'CDELT1': -0.1,\nastropy\/wcs\/tests\/test_wcs.py:                 'CDELT2': 0.1})\nastropy\/wcs\/tests\/test_wcs.py:    WCSAXES =                    2 \/ Number of coordinate axes                      CRPIX1  =                  0.0 \/ Pixel coordinate of reference point            CRPIX2  =                  0.0 \/ Pixel coordinate of reference point            CDELT1  =                  1.0 \/ Coordinate increment at reference point        CDELT2  =                  1.0 \/ Coordinate increment at reference point        CRVAL1  =                  0.0 \/ Coordinate value at reference point            CRVAL2  =                  0.0 \/ Coordinate value at reference point            LATPOLE =                 90.0 \/ [deg] Native latitude of celestial pole        END\"\"\"\nastropy\/wcs\/tests\/test_wcs.py:    assert isinstance(wfits, fits.HDUList)\nastropy\/wcs\/tests\/test_wcs.py:    assert isinstance(wfits[0], fits.PrimaryHDU)\nastropy\/wcs\/tests\/test_wcs.py:    assert 'A_ORDER' in str(w[0])\nastropy\/wcs\/tests\/test_wcs.py:            print(\"Diverging solutions:\\n{}\\n\"\nastropy\/wcs\/tests\/test_wcs.py:                 'CTYPE2': 'DEC--ZPN', 'CRUNIT2': 'deg',\nastropy\/wcs\/tests\/test_wcs.py:    h['RADESYSA'] = 'ICRS'\nastropy\/wcs\/tests\/test_wcs.py:    hdu = fits.PrimaryHDU([[0]], header=h)\nastropy\/wcs\/tests\/test_wcs.py:    hdulist = fits.HDUList([hdu])\nastropy\/wcs\/tests\/test_wcs.py:CTYPE2  = 'DEC--TAN' \/ TAN (gnomic) projection\nastropy\/wcs\/tests\/test_wcs.py:CRVAL2  =        23.1148929108 \/ DEC of reference point\nastropy\/wcs\/tests\/test_wcs.py:CD1_1   =    -0.00912247310646 \/ Transformation matrix\nastropy\/wcs\/tests\/test_wcs.py:CD1_2   =    -0.00250608809647 \/ no comment\nastropy\/wcs\/tests\/test_wcs.py:CD2_1   =     0.00250608809647 \/ no comment\nastropy\/wcs\/tests\/test_wcs.py:CD2_2   =    -0.00912247310646 \/ no comment\nastropy\/wcs\/tests\/test_wcs.py:    w.wcs.ctype = ['RA---TAN', 'DEC--TAN', 'FREQ']\nastropy\/wcs\/tests\/test_wcs.py:        assert header['CDELT{0}'.format(ii + 1)] == w.wcs.cdelt[ii]\nastropy\/wcs\/tests\/test_wcs.py:    w.wcs.ctype = ['RA---SIN', 'DEC--SIN', 'FREQ']\nastropy\/wcs\/tests\/test_wcs.py:        assert header['CDELT{0}'.format(ii + 1)] == w.wcs.cdelt[ii]\nastropy\/wcs\/tests\/test_wcs.py:    w.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_wcs.py:    header = w.to_header(relax=wcs.WCSHDO_P17)\nastropy\/wcs\/tests\/test_wcs.py:    w.wcs.ctype = ['RA---TAN', 'DEC--TAN', 'FREQ']\nastropy\/wcs\/tests\/test_wcs.py:def test_passing_ImageHDU():\nastropy\/wcs\/tests\/test_wcs.py:    Passing ImageHDU or PrimaryHDU and comparing it with\nastropy\/wcs\/tests\/test_wcs.py:    w.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_wcs.py:    w.wcs.ctype = [\"RA---CAR\", \"DEC--CAR\"]\nastropy\/wcs\/tests\/test_wcs.py:    h1['CTYPE2A'] = \"DEC--SIN-SIP\"\nastropy\/wcs\/tests\/test_wcs.py:    assert (w.wcs.ctype == np.array(['RA---SIN-SIP', 'DEC--SIN-SIP'])).all()\nastropy\/wcs\/tests\/test_wcs.py:    assert isinstance(wfits, fits.HDUList)\nastropy\/wcs\/tests\/test_wcs.py:    assert isinstance(wfits[0], fits.PrimaryHDU)\nastropy\/wcs\/tests\/test_wcs.py:    assert isinstance(wfits[1], fits.ImageHDU)\nastropy\/table\/tests\/conftest.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/conftest.py:from collections import OrderedDict\nastropy\/table\/tests\/conftest.py:    class TableData:\nastropy\/table\/tests\/conftest.py:            self.DATA = self.Table(self.COLS)\nastropy\/table\/tests\/conftest.py:    return TableData(request)\nastropy\/table\/tests\/conftest.py:    cols = OrderedDict()\nastropy\/table\/tests\/test_item_access.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_item_access.py:        assert np.all(t2['a'] == table_data.DATA['a'][1:3])\nastropy\/table\/tests\/test_item_access.py:        assert np.all(t2['a'] == table_data.DATA['a'][slice])\nastropy\/table\/tests\/test_item_access.py:        assert np.all(self.t.as_array() == table_data.DATA)\nastropy\/table\/tests\/test_item_access.py:        assert np.any(t2['a'] != table_data.DATA['a'][slice])\nastropy\/table\/tests\/test_item_access.py:        assert np.all(t2['a'] == table_data.DATA['a'][slice])\nastropy\/table\/tests\/test_item_access.py:        assert np.all(self.t.as_array() == table_data.DATA)\nastropy\/table\/tests\/test_item_access.py:        assert np.any(t2['a'] != table_data.DATA['a'][slice])\nastropy\/table\/tests\/test_item_access.py:            assert np.all(t2['a'] == table_data.DATA['a'])\nastropy\/table\/tests\/test_item_access.py:            assert np.all(t2['c'] == table_data.DATA['c'])\nastropy\/table\/tests\/test_item_access.py:            assert np.all(self.t.as_array() == table_data.DATA)\nastropy\/table\/tests\/test_item_access.py:            assert np.any(t2['a'] != table_data.DATA['a'])\nastropy\/table\/tests\/test_row.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_wcsprm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: We need some data with -NCP or -GLS projections to test\nastropy\/wcs\/tests\/test_wcsprm.py:    w.ctype = [b'RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_wcsprm.py:    assert w.lattyp == 'DEC'\nastropy\/wcs\/tests\/test_wcsprm.py:    assert list(w.ctype) == ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_wcsprm.py:    assert w.lattyp == 'DEC'\nastropy\/wcs\/tests\/test_wcsprm.py:    w.ctype = [b'RA-\\t--TAN', 'DEC-\\n-TAN']\nastropy\/wcs\/tests\/test_wcsprm.py:    assert repr(w.ctype == '[\"RA-\\t--TAN\", \"DEC-\\n-TAN\"]')\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: We need some data with broken cylindrical projections to\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: When dateavg is verified, check that it works\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: When dateavg is verified, check that it works\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: We need some data with PSi_ma keywords\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: We need some data with PVi_ma keywords\nastropy\/wcs\/tests\/test_wcsprm.py:    w.ctype = [b'RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: We need some data with broken spectral headers here to\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: Write me\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: Inject some headers that have tables and test\nastropy\/wcs\/tests\/test_wcsprm.py:    w.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_wcsprm.py:    # coordinates\", for those systems the RADESYS keyword can be used to\nastropy\/wcs\/tests\/test_wcsprm.py:    # \"For RADESYSa values of FK4 and FK4-NO-E, any stated equinox is Besselian\nastropy\/wcs\/tests\/test_wcsprm.py:    # RADESYS a. However, if it should happen to ap- pear by itself then\nastropy\/wcs\/tests\/test_wcsprm.py:    # RADESYSa defaults to FK4 if EQUINOXa < 1984.0, or to FK5 if EQUINOXa\nastropy\/wcs\/tests\/test_wcsprm.py:    # By default RADESYS is empty\nastropy\/wcs\/tests\/test_wcsprm.py:    for ctype in [('RA---TAN', 'DEC--TAN'),\nastropy\/wcs\/tests\/test_wcsprm.py:                  ('DEC--TAN', 'RA---TAN'),\nastropy\/wcs\/tests\/test_wcsprm.py:        # Check defaults for RADESYS\nastropy\/table\/pprint.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/pprint.py:        Hashable object to identify column like id or name. Default is None.\nastropy\/table\/pprint.py:                    # Does this string format method work?\nastropy\/table\/pprint.py:            Include column name. Default is True.\nastropy\/table\/pprint.py:            Include a header row for unit.  Default is to show a row\nastropy\/table\/pprint.py:            Include column dtype. Default is False.\nastropy\/table\/pprint.py:            Include column length at end.  Default is to show this only\nastropy\/table\/pprint.py:            Left\/right alignment of columns. Default is '>' (right) for all\nastropy\/table\/pprint.py:            Dict which is used to pass back additional values\nastropy\/table\/pprint.py:            Include column name. Default is True.\nastropy\/table\/pprint.py:            Include a header row for unit.  Default is to show a row\nastropy\/table\/pprint.py:            Include column dtype. Default is False.\nastropy\/table\/pprint.py:            Include column length at end.  Default is to show this only\nastropy\/table\/pprint.py:            Include a header row for column names. Default is True.\nastropy\/table\/pprint.py:            Include a header row for unit.  Default is to show a row\nastropy\/table\/pprint.py:            Include a header row for column dtypes. Default is False.\nastropy\/table\/pprint.py:            Format the output as an HTML table. Default is False.\nastropy\/table\/pprint.py:            An ID tag for the table; only used if html is set.  Default is\nastropy\/table\/pprint.py:            CSS classes for the table; only used if html is set.  Default is\nastropy\/table\/pprint.py:            Left\/right alignment of columns. Default is '>' (right) for all\nastropy\/table\/pprint.py:            Dict which is used to pass back additional values\nastropy\/table\/pprint.py:            Include a header row for column names. Default is True.\nastropy\/table\/pprint.py:            Include a header row for unit.  Default is to show a row\nastropy\/table\/pprint.py:            Include a header row for column dtypes. Default is False.\nastropy\/table\/pprint.py:            if showlines:  # Don't always show the table (e.g. after help)\nastropy\/table\/tests\/test_jsviewer.py:EXTERN_DIR = abspath(dirname(extern.__file__))\nastropy\/table\/tests\/test_jsviewer.py:        columnDefs: [{targets: [0], type: \"optionalnum\"}]\nastropy\/table\/tests\/test_jsviewer.py:        datatables_css_url='file:\/\/' + join(EXTERN_DIR, 'css', 'jquery.dataTables.css'),\nastropy\/table\/tests\/test_jsviewer.py:        datatables_js_url='file:\/\/' + join(EXTERN_DIR, 'js', 'jquery.dataTables.min.js'),\nastropy\/table\/tests\/test_jsviewer.py:        jquery_url='file:\/\/' + join(EXTERN_DIR, 'js', 'jquery-3.1.1.min.js')\nastropy\/table\/tests\/test_groups.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/np_utils.py:from collections import OrderedDict, Counter\nastropy\/table\/np_utils.py:    col_name_map = OrderedDict((name, col_name_map[name]) for name in col_name_list)\nastropy\/table\/jsviewer.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/jsviewer.py:EXTERN_JS_DIR = abspath(join(dirname(extern.__file__), 'js'))\nastropy\/table\/jsviewer.py:EXTERN_CSS_DIR = abspath(join(dirname(extern.__file__), 'css'))\nastropy\/table\/jsviewer.py:        columnDefs: [{{targets: {sort_columns}, type: \"optionalnum\"}}]\nastropy\/table\/jsviewer.py:        columnDefs: [{{targets: {sort_columns}, type: \"optionalnum\"}}]\nastropy\/table\/jsviewer.py:# Default CSS for the JSViewer writer\nastropy\/table\/jsviewer.py:DEFAULT_CSS = \"\"\"\\\nastropy\/table\/jsviewer.py:# Default CSS used when rendering a table in the IPython notebook\nastropy\/table\/jsviewer.py:DEFAULT_CSS_NB = \"\"\"\\\nastropy\/table\/jsviewer.py:    This class provides an interface to the `DataTables\nastropy\/table\/jsviewer.py:        Use local files or a CDN for JavaScript libraries. Default False.\nastropy\/table\/jsviewer.py:        Number or rows to show. Default to 50.\nastropy\/table\/jsviewer.py:            return ['file:\/\/' + join(EXTERN_JS_DIR, 'jquery-3.1.1.min.js'),\nastropy\/table\/jsviewer.py:                    'file:\/\/' + join(EXTERN_JS_DIR, 'jquery.dataTables.min.js')]\nastropy\/table\/jsviewer.py:            return ['file:\/\/' + join(EXTERN_CSS_DIR,\nastropy\/table\/jsviewer.py:            return 'file:\/\/' + join(EXTERN_JS_DIR, 'jquery.dataTables.min')\nastropy\/table\/jsviewer.py:                                           else DEFAULT_CSS_NB)\nastropy\/table\/jsviewer.py:                         css=DEFAULT_CSS, htmldict=None):\nastropy\/wcs\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/setup_package.py:CONTACT = \"Michael Droettboom\"\nastropy\/wcs\/setup_package.py:    #ifndef YY_NO_UNISTD_H\nastropy\/wcs\/setup_package.py:    #define YY_NO_UNISTD_H\nastropy\/wcs\/setup_package.py:    #ifndef _NO_OLDNAMES\nastropy\/wcs\/setup_package.py:    #define _NO_OLDNAMES\nastropy\/wcs\/setup_package.py:    #ifndef NO_OLDNAMES\nastropy\/wcs\/setup_package.py:    #define NO_OLDNAMES\nastropy\/wcs\/setup_package.py:    #ifndef __STDC__\nastropy\/wcs\/setup_package.py:    #define __STDC__ 1\nastropy\/wcs\/setup_package.py:# GENERATE DOCSTRINGS IN C\nastropy\/wcs\/setup_package.py:DO NOT EDIT!\nastropy\/wcs\/setup_package.py:#ifndef __DOCSTRINGS_H__\nastropy\/wcs\/setup_package.py:#define __DOCSTRINGS_H__\nastropy\/wcs\/setup_package.py:DO NOT EDIT!\nastropy\/wcs\/setup_package.py:        ('ASTROPY_WCS_BUILD', None),\nastropy\/wcs\/setup_package.py:        cfg['define_macros'].append(('DEBUG', None))\nastropy\/wcs\/setup_package.py:        cfg['undef_macros'].append('NDEBUG')\nastropy\/wcs\/setup_package.py:        # Define ECHO as nothing to prevent spurious newlines from\nastropy\/wcs\/setup_package.py:        cfg['define_macros'].append(('NDEBUG', None))\nastropy\/wcs\/setup_package.py:        cfg['undef_macros'].append('DEBUG')\nastropy\/wcs\/setup_package.py:            ('YY_NO_UNISTD_H', None),\nastropy\/wcs\/setup_package.py:            ('_NO_OLDNAMES', None),  # for mingw32\nastropy\/wcs\/setup_package.py:            ('NO_OLDNAMES', None),  # for mingw64\nastropy\/wcs\/setup_package.py:            ('__STDC__', None)  # for MSVC\nastropy\/wcs\/setup_package.py:    # DISTUTILS SETUP\nastropy\/wcs\/setup_package.py:    cfg = setup_helpers.DistutilsExtensionArgs()\nastropy\/table\/tests\/test_masked.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_masked.py:class SetupData:\nastropy\/table\/tests\/test_masked.py:class TestPprint(SetupData):\nastropy\/table\/tests\/test_masked.py:class TestFillValue(SetupData):\nastropy\/table\/tests\/test_masked.py:        c.fill_value = 'ABCDEF'\nastropy\/table\/tests\/test_masked.py:        assert c.fill_value == 'ABCD'  # string truncated to dtype length\nastropy\/table\/tests\/test_masked.py:        assert np.all(c.filled() == ['ABCD', 'yyyy'])\nastropy\/table\/tests\/test_masked.py:class TestMaskedColumnInit(SetupData):\nastropy\/table\/tests\/test_masked.py:class TestTableInit(SetupData):\nastropy\/table\/tests\/test_masked.py:        # Do not convert to masked table, if new column has no masked value.\nastropy\/table\/tests\/test_info.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_info.py:from collections import OrderedDict\nastropy\/table\/tests\/test_info.py:        assert cinfo == OrderedDict([('name', 'name'),\nastropy\/table\/tests\/test_info.py:        assert cinfo == OrderedDict([('name', 'name'),\nastropy\/table\/tests\/test_info.py:        assert cinfo == OrderedDict([('dtype', 'int64'),\nastropy\/table\/tests\/test_subclass.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/wcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/wcs.py:     functionality in `wcslib`_.  (This includes TPV and TPD\nastropy\/wcs\/wcs.py:   - `~astropy.wcs.DistortionLookupTable`: Handles `distortion paper`_\nastropy\/wcs\/wcs.py:   - Detector to image plane correction (by a pair of\nastropy\/wcs\/wcs.py:     `~astropy.wcs.DistortionLookupTable` objects).\nastropy\/wcs\/wcs.py:     `~astropy.wcs.DistortionLookupTable` objects).\nastropy\/wcs\/wcs.py:# STDLIB\nastropy\/wcs\/wcs.py:# THIRD-PARTY\nastropy\/wcs\/wcs.py:from ..utils.exceptions import AstropyWarning, AstropyUserWarning, AstropyDeprecationWarning\nastropy\/wcs\/wcs.py:           'DistortionLookupTable', 'Sip', 'Tabprm', 'Wcsprm',\nastropy\/wcs\/wcs.py:    DistortionLookupTable = _wcs.DistortionLookupTable\nastropy\/wcs\/wcs.py:        if key.startswith(('WCSSUB', 'WCSHDR', 'WCSHDO')):\nastropy\/wcs\/wcs.py:    DistortionLookupTable = object\nastropy\/wcs\/wcs.py:WCSHDO_SIP = 0x80000\nastropy\/wcs\/wcs.py:                keysel_flags |= _wcs.WCSHDR_IMGHEAD\nastropy\/wcs\/wcs.py:                keysel_flags |= _wcs.WCSHDR_BIMGARR\nastropy\/wcs\/wcs.py:                keysel_flags |= _wcs.WCSHDR_PIXLIST\nastropy\/wcs\/wcs.py:                          AstropyDeprecationWarning)\nastropy\/wcs\/wcs.py:    header : astropy.io.fits header object, Primary HDU, Image HDU, string, dict-like, or None, optional\nastropy\/wcs\/wcs.py:        Degree of permissiveness:\nastropy\/wcs\/wcs.py:            elif isinstance(header, fits.hdu.image._ImageBaseHDU):\nastropy\/wcs\/wcs.py:                header, fobj, dist='CPDIS', err=minerr)\nastropy\/wcs\/wcs.py:            header_string = header_string.replace('END' + ' ' * 77, '')\nastropy\/wcs\/wcs.py:            hours (Henry), and ``\"D\"`` for days (Debye).\nastropy\/wcs\/wcs.py:            - If the string contains ``\"d\"``, translate ``\"D\"`` to\nastropy\/wcs\/wcs.py:        if not isinstance(fobj, fits.HDUList):\nastropy\/wcs\/wcs.py:        dist = 'D2IMDIS'\nastropy\/wcs\/wcs.py:        d_kw = 'D2IM'\nastropy\/wcs\/wcs.py:        err_kw = 'D2IMERR'\nastropy\/wcs\/wcs.py:                    assert isinstance(fobj, fits.HDUList), ('An astropy.io.fits.HDUList'\nastropy\/wcs\/wcs.py:                        d_data = fobj[str('D2IMARR'), d_extver].data\nastropy\/wcs\/wcs.py:                        d_data = (fobj[str('D2IMARR'), d_extver].data).transpose()\nastropy\/wcs\/wcs.py:                    d_header = fobj[str('D2IMARR'), d_extver].header\nastropy\/wcs\/wcs.py:                    d_cdelt = (d_header.get(str('CDELT1'), 1.0), d_header.get(str('CDELT2'), 1.0))\nastropy\/wcs\/wcs.py:                    d_lookup = DistortionLookupTable(d_data, d_crpix,\nastropy\/wcs\/wcs.py:        warnings.warn(\"The use of ``AXISCORR`` for D2IM correction has been deprecated.\"\nastropy\/wcs\/wcs.py:                      AstropyDeprecationWarning)\nastropy\/wcs\/wcs.py:            d2im_data = fobj[(str('D2IMARR'), 1)].data\nastropy\/wcs\/wcs.py:        d2im_hdr = fobj[(str('D2IMARR'), 1)].header\nastropy\/wcs\/wcs.py:            cdelt[i - 1] = d2im_hdr.get(str('CDELT') + str(i), 1.0)\nastropy\/wcs\/wcs.py:        cpdis = DistortionLookupTable(d2im_data, crpix, crval, cdelt)\nastropy\/wcs\/wcs.py:        `astropy.io.fits.HDUList`.\nastropy\/wcs\/wcs.py:        dist = 'D2IMDIS'\nastropy\/wcs\/wcs.py:        d_kw = 'D2IM'\nastropy\/wcs\/wcs.py:        err_kw = 'D2IMERR'\nastropy\/wcs\/wcs.py:                'LOOKUP', 'Detector to image correction type')\nastropy\/wcs\/wcs.py:                num, 'Version number of WCSDVARR extension')\nastropy\/wcs\/wcs.py:            image = fits.ImageHDU(det2im.data, name=str('D2IMARR'))\nastropy\/wcs\/wcs.py:            header[str('CDELT1')] = (det2im.cdelt[0],\nastropy\/wcs\/wcs.py:            header[str('CDELT2')] = (det2im.cdelt[1],\nastropy\/wcs\/wcs.py:    def _read_distortion_kw(self, header, fobj, dist='CPDIS', err=0.0):\nastropy\/wcs\/wcs.py:        returns a 2-tuple of `~astropy.wcs.DistortionLookupTable`\nastropy\/wcs\/wcs.py:        if dist == 'CPDIS':\nastropy\/wcs\/wcs.py:            d_kw = str('DP')\nastropy\/wcs\/wcs.py:            d_kw = str('DQ')\nastropy\/wcs\/wcs.py:                    if not isinstance(fobj, fits.HDUList):\nastropy\/wcs\/wcs.py:                        raise ValueError('an astropy.io.fits.HDUList is '\nastropy\/wcs\/wcs.py:                        d_data = fobj[str('WCSDVARR'), d_extver].data\nastropy\/wcs\/wcs.py:                        d_data = (fobj[str('WCSDVARR'), d_extver].data).transpose()\nastropy\/wcs\/wcs.py:                    d_header = fobj[str('WCSDVARR'), d_extver].header\nastropy\/wcs\/wcs.py:                    d_cdelt = (d_header.get(str('CDELT1'), 1.0),\nastropy\/wcs\/wcs.py:                               d_header.get(str('CDELT2'), 1.0))\nastropy\/wcs\/wcs.py:                    d_lookup = DistortionLookupTable(d_data, d_crpix, d_crval, d_cdelt)\nastropy\/wcs\/wcs.py:    def _write_distortion_kw(self, hdulist, dist='CPDIS'):\nastropy\/wcs\/wcs.py:        `fits.HDUList`.\nastropy\/wcs\/wcs.py:        if dist == 'CPDIS':\nastropy\/wcs\/wcs.py:            d_kw = str('DP')\nastropy\/wcs\/wcs.py:            d_kw = str('DQ')\nastropy\/wcs\/wcs.py:                num, 'Version number of WCSDVARR extension')\nastropy\/wcs\/wcs.py:            image = fits.ImageHDU(cpdis.data, name=str('WCSDVARR'))\nastropy\/wcs\/wcs.py:            header[str('CDELT1')] = (cpdis.cdelt[0], 'Coordinate increment along axis')\nastropy\/wcs\/wcs.py:            header[str('CDELT2')] = (cpdis.cdelt[1], 'Coordinate increment along axis')\nastropy\/wcs\/wcs.py:            # TODO: Parse SIP from a string without pyfits around\nastropy\/wcs\/wcs.py:        if str(\"A_ORDER\") in header and header[str('A_ORDER')] > 1:\nastropy\/wcs\/wcs.py:            if str(\"B_ORDER\") not in header:\nastropy\/wcs\/wcs.py:                    \"A_ORDER provided without corresponding B_ORDER \"\nastropy\/wcs\/wcs.py:            m = int(header[str(\"A_ORDER\")])\nastropy\/wcs\/wcs.py:            m = int(header[str(\"B_ORDER\")])\nastropy\/wcs\/wcs.py:            del header[str('A_ORDER')]\nastropy\/wcs\/wcs.py:            del header[str('B_ORDER')]\nastropy\/wcs\/wcs.py:        elif str(\"B_ORDER\") in header and header[str('B_ORDER')] > 1:\nastropy\/wcs\/wcs.py:                \"B_ORDER provided without corresponding A_ORDER \" +\nastropy\/wcs\/wcs.py:        if str(\"AP_ORDER\") in header and header[str('AP_ORDER')] > 1:\nastropy\/wcs\/wcs.py:            if str(\"BP_ORDER\") not in header:\nastropy\/wcs\/wcs.py:                    \"AP_ORDER provided without corresponding BP_ORDER \"\nastropy\/wcs\/wcs.py:            m = int(header[str(\"AP_ORDER\")])\nastropy\/wcs\/wcs.py:            m = int(header[str(\"BP_ORDER\")])\nastropy\/wcs\/wcs.py:            del header[str('AP_ORDER')]\nastropy\/wcs\/wcs.py:            del header[str('BP_ORDER')]\nastropy\/wcs\/wcs.py:        elif str(\"BP_ORDER\") in header and header[str('BP_ORDER')] > 1:\nastropy\/wcs\/wcs.py:                \"BP_ORDER provided without corresponding AP_ORDER \"\nastropy\/wcs\/wcs.py:            keywords[str('{0}_ORDER').format(name)] = size - 1\nastropy\/wcs\/wcs.py:        if self.wcs.lattyp != 'DEC':\nastropy\/wcs\/wcs.py:                \"WCS does not have longitude type of 'DEC', therefore \" +\nastropy\/wcs\/wcs.py:        if self.wcs.lattyp != 'DEC':\nastropy\/wcs\/wcs.py:                \"WCS does not have longitude type of 'DEC', therefore \" +\nastropy\/wcs\/wcs.py:                    \"a 1-D array for each axis, followed by an origin.\")\nastropy\/wcs\/wcs.py:            - Detector to image plane correction (if present in the\nastropy\/wcs\/wcs.py:                   __.RA_DEC_ORDER(8),\nastropy\/wcs\/wcs.py:                   __.RA_DEC_ORDER(8),\nastropy\/wcs\/wcs.py:        # #          DESCRIPTION OF THE NUMERICAL METHOD            ##\nastropy\/wcs\/wcs.py:        # (1)   x = CD*(u+f(u)),\nastropy\/wcs\/wcs.py:        # (CD matrix + projection onto celestial sphere) part of the\nastropy\/wcs\/wcs.py:        #      ### Direct Solving of Equation (2)  ###\nastropy\/wcs\/wcs.py:        #      ### Description of the Method Used here ###\nastropy\/wcs\/wcs.py:        # (when any of the non-CD-matrix-based corrections are\nastropy\/wcs\/wcs.py:        # #                NON-ADAPTIVE ITERATIONS:                 ##\nastropy\/wcs\/wcs.py:        # #                  ADAPTIVE ITERATIONS:                   ##\nastropy\/wcs\/wcs.py:                    # AND that do not diverge:\nastropy\/wcs\/wcs.py:        # #         FINAL DETECTION OF INVALID, DIVERGING,          ##\nastropy\/wcs\/wcs.py:        # #         AND FAILED-TO-CONVERGE POINTS                   ##\nastropy\/wcs\/wcs.py:        # #  RAISE EXCEPTION IF DIVERGING OR TOO SLOWLY CONVERGING  ##\nastropy\/wcs\/wcs.py:        # #  DATA POINTS HAVE BEEN DETECTED:                        ##\nastropy\/wcs\/wcs.py:        tolerance : float, optional (Default = 1.0e-4)\nastropy\/wcs\/wcs.py:        maxiter : int, optional (Default = 20)\nastropy\/wcs\/wcs.py:        quiet : bool, optional (Default = False)\nastropy\/wcs\/wcs.py:            Do not throw :py:class:`NoConvergence` exceptions when\nastropy\/wcs\/wcs.py:        adaptive : bool, optional (Default = False)\nastropy\/wcs\/wcs.py:            accuracy for the next iteration. Default is recommended\nastropy\/wcs\/wcs.py:        detect_divergence : bool, optional (Default = True)\nastropy\/wcs\/wcs.py:                   __.RA_DEC_ORDER(8),\nastropy\/wcs\/wcs.py:                   __.RA_DEC_ORDER(8),\nastropy\/wcs\/wcs.py:        Generate an `astropy.io.fits.HDUList` object with all of the\nastropy\/wcs\/wcs.py:            Degree of permissiveness:\nastropy\/wcs\/wcs.py:        hdulist : `astropy.io.fits.HDUList`\nastropy\/wcs\/wcs.py:        hdu = fits.PrimaryHDU(header=header)\nastropy\/wcs\/wcs.py:        hdulist = fits.HDUList(hdu)\nastropy\/wcs\/wcs.py:            Degree of permissiveness:\nastropy\/wcs\/wcs.py:             ``END``.\nastropy\/wcs\/wcs.py:          2. Deprecated (e.g. ``CROTAn``) or non-standard usage will\nastropy\/wcs\/wcs.py:        precision = WCSHDO_P14\nastropy\/wcs\/wcs.py:            do_sip = relax & WCSHDO_SIP\nastropy\/wcs\/wcs.py:            relax &= ~WCSHDO_SIP\nastropy\/wcs\/wcs.py:            relax = WCSHDO_all if relax is True else WCSHDO_safe\nastropy\/wcs\/wcs.py:            # This is called when relax is not False or WCSHDO_SIP\nastropy\/wcs\/wcs.py:        comments = ('# Region file format: DS9 version 4.0 \\n'\nastropy\/wcs\/wcs.py:                            'AMPLIFIER', 'DETECTOR'):\nastropy\/wcs\/wcs.py:            s = 'CDELT' + sfmt\nastropy\/wcs\/wcs.py:                    s += \"\".join(['CD', str(i+1), '_', str(j+1), ' '])\nastropy\/wcs\/wcs.py:        # if wcs.wcs.ctype == ['RA','DEC','VLSR'], you want\nastropy\/wcs\/wcs.py:        # wcs.sub([1,2]) to get 'RA','DEC' back\nastropy\/wcs\/wcs.py:        # We COULD allow wcs[1] to link to wcs.sub([2])\nastropy\/wcs\/wcs.py:        Degree of permissiveness:\nastropy\/wcs\/wcs.py:    source : str path, readable file-like object or `astropy.io.fits.HDUList` object\nastropy\/wcs\/wcs.py:        corresponds to the HDUs in the given file.  The next level has\nastropy\/wcs\/wcs.py:                result = ['HDU {0}{1}:'.format(self._hdu_index, hdu_name)]\nastropy\/wcs\/wcs.py:    if isinstance(source, fits.HDUList):\nastropy\/wcs\/wcs.py:                hdu.header, relax=_wcs.WCSHDR_reject,\nastropy\/wcs\/wcs.py:                        relax=_wcs.WCSHDR_reject,\nastropy\/table\/tests\/test_init_table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_init_table.py:from collections import OrderedDict, Mapping, UserDict\nastropy\/table\/tests\/test_init_table.py:class BaseInitFromDictLike(BaseInitFrom):\nastropy\/table\/tests\/test_init_table.py:class TestInitFromListOfDicts(BaseInitFromListLike):\nastropy\/table\/tests\/test_init_table.py:class TestInitFromNdarrayStruct(BaseInitFromDictLike):\nastropy\/table\/tests\/test_init_table.py:class TestInitFromDict(BaseInitFromDictLike):\nastropy\/table\/tests\/test_init_table.py:class TestInitFromMapping(BaseInitFromDictLike):\nastropy\/table\/tests\/test_init_table.py:        self.data = UserDict([('a', Column([1, 3], name='x')),\nastropy\/table\/tests\/test_init_table.py:class TestInitFromOrderedDict(BaseInitFromDictLike):\nastropy\/table\/tests\/test_init_table.py:        self.data = OrderedDict([('a', Column(name='x', data=[1, 3])),\nastropy\/table\/tests\/test_init_table.py:class TestInitFromRow(BaseInitFromDictLike):\nastropy\/table\/tests\/test_init_table.py:class TestInitFromTable(BaseInitFromDictLike):\nastropy\/table\/tests\/test_init_table.py:    # Note table_table.TestEmptyData tests initializing a completely empty\nastropy\/table\/tests\/test_mixin.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_mixin.py:    io.votable.  Note that FITS and HDF5 mixin support are tested (much more\nastropy\/table\/tests\/test_showtable.py:            '  TIME   SOURCE ID ANTENNA NO. SUBARRAY FREQ ID ANT FLAG STATUS 1\\n'\nastropy\/table\/tests\/test_showtable.py:            '  DAYS                                                           \\n'\nastropy\/table\/tests\/test_showtable.py:            '   TIME    SOURCE ID ANTENNA NO. SUBARRAY FREQ ID ANT FLAG STATUS 1\\n'\nastropy\/table\/tests\/test_showtable.py:            '   DAYS                                                            \\n'\nastropy\/table\/tests\/test_showtable.py:        'Index RAh RAm  RAs  DE- DEd  DEm    DEs   Match Class  AK Fit ',\nastropy\/table\/tests\/test_showtable.py:        'Index RAh RAm  RAs  DE- DEd DEm DEs Match Class  AK Fit ',\nastropy\/table\/tests\/test_operations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_operations.py:from collections import OrderedDict\nastropy\/table\/tests\/test_operations.py:        self.t1.meta.update(OrderedDict([('b', [1, 2]), ('c', {'a': 1}), ('d', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t2.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t3.meta.update(OrderedDict([('b', 3), ('c', [1, 2]), ('d', 2), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.meta_merge = OrderedDict([('b', [1, 2, 3, 4]),\nastropy\/table\/tests\/test_operations.py:        meta1 = OrderedDict([('b', [1, 2]), ('c', {'a': 1}), ('d', 1)])\nastropy\/table\/tests\/test_operations.py:        meta2 = OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)])\nastropy\/table\/tests\/test_operations.py:        self.t1.meta.update(OrderedDict([('b', [1, 2]), ('c', {'a': 1}), ('d', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t2.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t4.meta.update(OrderedDict([('b', [5, 6]), ('c', {'c': 1}), ('e', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t5.meta.update(OrderedDict([('b', 3), ('c', 'k'), ('d', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.meta_merge = OrderedDict([('b', [1, 2, 3, 4, 5, 6]),\nastropy\/table\/tests\/test_operations.py:        t1['a'].info.meta.update(OrderedDict([('b', [1, 2]), ('c', {'a': 1}), ('d', 1)]))\nastropy\/table\/tests\/test_operations.py:        t2['a'].info.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        t4['a'].info.meta.update(OrderedDict([('b', [5, 6]), ('c', {'c': 1}), ('e', 1)]))\nastropy\/table\/tests\/test_operations.py:        t2['b'].info.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        assert out['b'].info.meta == OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)])\nastropy\/table\/tests\/test_operations.py:        t1['a'].info.meta.update(OrderedDict([('b', [1, 2]), ('c', {'a': 1}), ('d', 1)]))\nastropy\/table\/tests\/test_operations.py:        t2['a'].info.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        t4['a'].info.meta.update(OrderedDict([('b', [5, 6]), ('c', {'c': 1}), ('e', 1)]))\nastropy\/table\/tests\/test_operations.py:        t2['b'].info.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        assert out['b'].info.meta == OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)])\nastropy\/table\/tests\/test_operations.py:        self.t1.meta.update(OrderedDict([('b', [1, 2]), ('c', {'a': 1}), ('d', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t2.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t4.meta.update(OrderedDict([('b', [5, 6]), ('c', {'c': 1}), ('e', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t5.meta.update(OrderedDict([('b', 3), ('c', 'k'), ('d', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.meta_merge = OrderedDict([('b', [1, 2, 3, 4, 5, 6]),\nastropy\/table\/tests\/test_operations.py:        meta1 = OrderedDict([('b', [1, 2]), ('c', {'a': 1}), ('d', 1)])\nastropy\/table\/tests\/test_operations.py:        t3['d'].info.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        t4['g'].info.meta.update(OrderedDict([('b', [5, 6]), ('c', {'c': 1}), ('e', 1)]))\nastropy\/table\/tests\/test_operations.py:        t3['e'].info.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_pprint.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_pprint.py:BIG_WIDE_ARR = np.arange(2000, dtype=np.float64).reshape(100, 20)\nastropy\/table\/tests\/test_pprint.py:class TestMultiD():\nastropy\/table\/tests\/test_pprint.py:        self.tb = table_type(BIG_WIDE_ARR)\nastropy\/table\/tests\/test_pprint.py:        \"\"\"Do not include the name header row\"\"\"\nastropy\/table\/tests\/test_pprint.py:    def test_column_format_func_multiD(self, table_type):\nastropy\/table\/tests\/test_pprint.py:    def test_column_format_func_multiD(self):\nastropy\/table\/tests\/test_pprint.py:    decoding to utf-8 and gets replaced by U+FFFD.  See\nastropy\/table\/tests\/test_index.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_index.py:from .test_table import SetupData\nastropy\/table\/tests\/test_index.py:class TestIndex(SetupData):\nastropy\/table\/tests\/test_column.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_column.py:    assert isinstance(qtab['f'], u.Dex)\nexamples\/io\/skip_create-large-fits.py:*License: BSD*\nexamples\/io\/skip_create-large-fits.py:hdu = fits.PrimaryHDU(data=data)\nexamples\/io\/skip_create-large-fits.py:# blocks, large enough for 36 keywords per block (including the END keyword in\nexamples\/io\/skip_create-large-fits.py:# use 4 blocks by default. Then, excluding the END card which Astropy will add\nexamples\/io\/skip_create-large-fits.py:# Create a stub array to initialize the HDU; its\nexamples\/io\/skip_create-large-fits.py:hdu = fits.PrimaryHDU(data=data)\nexamples\/io\/skip_create-large-fits.py:    # Data we want to write.\nastropy\/table\/tests\/test_bst.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_table.py:from collections import OrderedDict\nastropy\/table\/tests\/test_table.py:    with ignore_warnings(DeprecationWarning):\nastropy\/table\/tests\/test_table.py:        # Ignore DeprecationWarning on pandas import in Python 3.5--see\nastropy\/table\/tests\/test_table.py:    HAS_PANDAS = False\nastropy\/table\/tests\/test_table.py:    HAS_PANDAS = True\nastropy\/table\/tests\/test_table.py:class SetupData:\nastropy\/table\/tests\/test_table.py:class TestSetTableColumn(SetupData):\nastropy\/table\/tests\/test_table.py:class TestEmptyData():\nastropy\/table\/tests\/test_table.py:class TestAddLength(SetupData):\nastropy\/table\/tests\/test_table.py:class TestAddPosition(SetupData):\nastropy\/table\/tests\/test_table.py:class TestAddName(SetupData):\nastropy\/table\/tests\/test_table.py:class TestInitFromTable(SetupData):\nastropy\/table\/tests\/test_table.py:class TestAddColumns(SetupData):\nastropy\/table\/tests\/test_table.py:class TestAddRow(SetupData):\nastropy\/table\/tests\/test_table.py:class TestTableColumn(SetupData):\nastropy\/table\/tests\/test_table.py:class TestArrayColumns(SetupData):\nastropy\/table\/tests\/test_table.py:class TestRemove(SetupData):\nastropy\/table\/tests\/test_table.py:class TestKeep(SetupData):\nastropy\/table\/tests\/test_table.py:class TestRename(SetupData):\nastropy\/table\/tests\/test_table.py:    # Define unicode literals\nastropy\/table\/tests\/test_table.py:@pytest.mark.skipif('not HAS_PANDAS')\nastropy\/table\/tests\/test_table.py:        assert exc.value.args[0] == \"Cannot convert a table with multi-dimensional columns to a pandas DataFrame\"\nastropy\/table\/tests\/test_table.py:        assert exc.value.args[0] == \"Cannot convert a table with mixin columns to a pandas DataFrame\"\nastropy\/table\/tests\/test_table.py:class TestReplaceColumn(SetupData):\nastropy\/table\/tests\/test_table.py:            self.meta = OrderedDict([('a', 1), ('b', 2)])\nastropy\/table\/tests\/test_table.py:        t = table.Table(st, dtype=dtypes, names=names, meta=OrderedDict([('c', 3)]))\nastropy\/utils\/tests\/test_timer.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_timer.py:# STDLIB\nastropy\/utils\/tests\/test_timer.py:# THIRD-PARTY\nastropy\/utils\/tests\/test_timer.py:    p.time_func(2.2)  # Test OrderedDict\nastropy\/utils\/introspection.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/introspection.py:        Defaults to just ``'__version__'``, which should work for most Python\nastropy\/utils\/introspection.py:    Determines the module\/package from which this function is called.\nastropy\/logger.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/logger.py:# log.setLevel(log.DEBUG), for example\nastropy\/logger.py:logging_levels = ['NOTSET', 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL',\nastropy\/logger.py:        \"will be ignored. The levels are ``'DEBUG'``, \"\nastropy\/logger.py:            loggerDict = logging.Logger.manager.loggerDict\nastropy\/logger.py:            for key in loggerDict.keys():\nastropy\/logger.py:                    del loggerDict[key]\nastropy\/logger.py:        # Deliberately not using isinstance here: We want to display\nastropy\/logger.py:        Disable logging of warnings.warn() calls\nastropy\/logger.py:        Determine if the exception-logging mechanism is enabled.\nastropy\/logger.py:        Disable logging of exceptions\nastropy\/logger.py:        Disable colorized output\nastropy\/logger.py:            'INFO', then setting ``filter_level`` to ``INFO`` or ``DEBUG``\nastropy\/logger.py:            'INFO', then setting ``filter_level`` to ``INFO`` or ``DEBUG``\nastropy\/logger.py:    A specialized StreamHandler that logs INFO and DEBUG messages to\nastropy\/logger.py:        if record.levelno < logging.DEBUG or not _conf.use_color:\nastropy\/samp\/tests\/test_hub.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/collections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_array.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/tests\/web_profile_test_helpers.py:from ..hub import WebProfileDialog\nastropy\/samp\/tests\/web_profile_test_helpers.py:class AlwaysApproveWebProfileDialog(WebProfileDialog):\nastropy\/samp\/tests\/web_profile_test_helpers.py:        WebProfileDialog.__init__(self)\nastropy\/samp\/tests\/test_standard_profile.py:                          \"samp.description.text\": \"Client 1 Description\",\nastropy\/samp\/tests\/test_standard_profile.py:                          \"samp.description.text\": \"Client 2 Description\",\nastropy\/samp\/tests\/test_standard_profile.py:        # TODO: check that receive_response received the right data\nastropy\/samp\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/tests\/test_client.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/tests\/test_errors.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/tests\/test_web_profile.py:from .web_profile_test_helpers import (AlwaysApproveWebProfileDialog,\nastropy\/samp\/tests\/test_web_profile.py:from ..web_profile import CROSS_DOMAIN, CLIENT_ACCESS_POLICY\nastropy\/samp\/tests\/test_web_profile.py:        self.dialog = AlwaysApproveWebProfileDialog()\nastropy\/samp\/tests\/test_web_profile.py:            assert f.read() == CROSS_DOMAIN\nastropy\/config\/affiliated.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/data.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/data.py:        'Block size for computing MD5 file hashes.')\nastropy\/utils\/data.py:        from a remote server.  Default is `True`.\nastropy\/utils\/data.py:              file in ``astropy\/pkgname\/data\/file.dat``.  Double-dots\nastropy\/utils\/data.py:        ...                           encoding='binary') as fobj:  # doctest: +REMOTE_DATA\nastropy\/utils\/data.py:        Downloading http:\/\/data.astropy.org\/allsky\/allsky_rosat.fits [Done]\nastropy\/utils\/data.py:        ...                           encoding='binary', cache=False) as fobj:  # doctest: +REMOTE_DATA\nastropy\/utils\/data.py:        Downloading http:\/\/data.astropy.org\/allsky\/allsky_rosat.fits [Done]\nastropy\/utils\/data.py:              file in ``astropy\/pkgname\/data\/file.dat``.  Double-dots\nastropy\/utils\/data.py:        from a remote server.  Default is `True`.\nastropy\/utils\/data.py:              file in ``astropy\/pkgname\/data\/file.dat``.  Double-dots\nastropy\/utils\/data.py:    \"\"\" Computes the MD5 hash for a file.\nastropy\/utils\/data.py:        The hex digest of the MD5 hash for the contents of the ``localfn``\nastropy\/utils\/data.py:        retval = ctypes.windll.kernel32.GetDiskFreeSpaceExW(\nastropy\/utils\/data.py:    Determines if a given directory has enough space to hold a file of\nastropy\/utils\/data.py:    returning the filename, with a name determined by the file's MD5\nastropy\/utils\/data.py:            dlmsg = \"Downloading {0}\".format(remote_url)\nastropy\/utils\/data.py:    Downloads multiple files in parallel from the given URLs.  Blocks until\nastropy\/utils\/data.py:        warn(\"Disabling the cache does not work because of multiprocessing, it \"\nastropy\/utils\/data.py:        msg = 'Data cache directory {0} is not a directory'\nastropy\/utils\/data.py:        msg = 'Data cache shelve object location {0} is a directory'\nastropy\/constants\/cgs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/configuration.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/configuration.py:from ..utils.exceptions import AstropyWarning, AstropyDeprecationWarning\nastropy\/config\/configuration.py:from ..utils.misc import InheritDocstrings\nastropy\/config\/configuration.py:class ConfigurationDefaultMissingError(ValueError):\nastropy\/config\/configuration.py:class ConfigurationDefaultMissingWarning(AstropyWarning):\nastropy\/config\/configuration.py:class ConfigItem(metaclass=InheritDocstrings):\nastropy\/config\/configuration.py:                    AstropyDeprecationWarning)\nastropy\/config\/configuration.py:                AstropyDeprecationWarning)\nastropy\/config\/configuration.py:    Determines if a config file can be safely replaced because it doesn't\nastropy\/config\/configuration.py:    # Don't install template files for dev versions, or we'll end up\nastropy\/constants\/codata2010.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/codata2010.py:class CODATA2010(Constant):\nastropy\/constants\/codata2010.py:    default_reference = 'CODATA 2010'\nastropy\/constants\/codata2010.py:class EMCODATA2010(CODATA2010, EMConstant):\nastropy\/constants\/codata2010.py:    _registry = CODATA2010._registry\nastropy\/constants\/codata2010.py:h = CODATA2010('h', \"Planck constant\", 6.62606957e-34, 'J s',\nastropy\/constants\/codata2010.py:hbar = CODATA2010('hbar', \"Reduced Planck constant\",\nastropy\/constants\/codata2010.py:k_B = CODATA2010('k_B', \"Boltzmann constant\", 1.3806488e-23, 'J \/ (K)',\nastropy\/constants\/codata2010.py:c = CODATA2010('c', \"Speed of light in vacuum\", 2.99792458e8, 'm \/ (s)', 0.,\nastropy\/constants\/codata2010.py:G = CODATA2010('G', \"Gravitational constant\", 6.67384e-11, 'm3 \/ (kg s2)',\nastropy\/constants\/codata2010.py:g0 = CODATA2010('g0', \"Standard acceleration of gravity\", 9.80665, 'm \/ s2', 0.0,\nastropy\/constants\/codata2010.py:m_p = CODATA2010('m_p', \"Proton mass\", 1.672621777e-27, 'kg', 0.000000074e-27,\nastropy\/constants\/codata2010.py:m_n = CODATA2010('m_n', \"Neutron mass\", 1.674927351e-27, 'kg', 0.000000074e-27,\nastropy\/constants\/codata2010.py:m_e = CODATA2010('m_e', \"Electron mass\", 9.10938291e-31, 'kg', 0.00000040e-31,\nastropy\/constants\/codata2010.py:u = CODATA2010('u', \"Atomic mass\", 1.660538921e-27, 'kg', 0.000000073e-27,\nastropy\/constants\/codata2010.py:sigma_sb = CODATA2010('sigma_sb', \"Stefan-Boltzmann constant\", 5.670373e-8,\nastropy\/constants\/codata2010.py:e = EMCODATA2010('e', 'Electron charge', 1.602176565e-19, 'C', 0.000000035e-19,\nastropy\/constants\/codata2010.py:eps0 = EMCODATA2010('eps0', 'Electric constant', 8.854187817e-12, 'F\/m', 0.0,\nastropy\/constants\/codata2010.py:N_A = CODATA2010('N_A', \"Avogadro's number\", 6.02214129e23, '1 \/ (mol)',\nastropy\/constants\/codata2010.py:R = CODATA2010('R', \"Gas constant\", 8.3144621, 'J \/ (K mol)', 0.0000075,\nastropy\/constants\/codata2010.py:Ryd = CODATA2010('Ryd', 'Rydberg constant', 10973731.568539, '1 \/ (m)',\nastropy\/constants\/codata2010.py:a0 = CODATA2010('a0', \"Bohr radius\", 0.52917721092e-10, 'm', 0.00000000017e-10,\nastropy\/constants\/codata2010.py:muB = CODATA2010('muB', \"Bohr magneton\", 927.400968e-26, 'J\/T', 0.00002e-26,\nastropy\/constants\/codata2010.py:alpha = CODATA2010('alpha', \"Fine-structure constant\", 7.2973525698e-3,\nastropy\/constants\/codata2010.py:atm = CODATA2010('atm', \"Standard atmosphere\", 101325, 'Pa', 0.0,\nastropy\/constants\/codata2010.py:mu0 = CODATA2010('mu0', \"Magnetic constant\", 4.0e-7 * np.pi, 'N\/A2', 0.0,\nastropy\/constants\/codata2010.py:sigma_T = CODATA2010('sigma_T', \"Thomson scattering cross-section\",\nastropy\/constants\/codata2010.py:                  2.8977721e-3, 'm K', 0.0000026e-3, 'CODATA 2010', system='si')\nastropy\/constants\/codata2010.py:e_esu = EMCODATA2010(e.abbrev, e.name, e.value * c.value * 10.0,\nastropy\/constants\/codata2010.py:e_emu = EMCODATA2010(e.abbrev, e.name, e.value \/ 10, 'abC',\nastropy\/constants\/codata2010.py:e_gauss = EMCODATA2010(e.abbrev, e.name, e.value * c.value * 10.0,\nastropy\/units\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/core.py:from ..utils.misc import isiterable, InheritDocstrings\nastropy\/units\/core.py:class UnitBase(metaclass=InheritDocstrings):\nastropy\/units\/core.py:            # TODO: maybe better for other to have a `_back_converter` method?\nastropy\/units\/core.py:        # Don't presume decomposition is possible; e.g.,\nastropy\/units\/core.py:        # Do we have any minimal results?\nastropy\/units\/core.py:            Default is `False`.\nastropy\/units\/core.py:            Default is `False`.\nastropy\/units\/core.py:class _UnitMetaClass(InheritDocstrings):\nastropy\/units\/core.py:                    # Deliberately not issubclass here. Subclasses\nastropy\/units\/core.py:        # get string bases and powers from the ID tuple\nastropy\/units\/core.py:    Direct use of this class is not recommended. Instead use the\nastropy\/units\/core.py:        Default is `False`.  This function always returns the base\nastropy\/units\/core.py:# TODO: Is this still needed? Should there be a deprecation warning?\nastropy\/units\/quantity_helper.py:UNSUPPORTED_UFUNCS = set([np.bitwise_and, np.bitwise_or,\nastropy\/units\/quantity_helper.py:    UNSUPPORTED_UFUNCS |= {np.isnat}\nastropy\/units\/quantity_helper.py:    # TODO: find a better way to do this, currently need to signal that one\nastropy\/units\/quantity_helper.py:    \"\"\"Determine the required converters and the unit of the ufunc result.\nastropy\/units\/quantity_helper.py:    if function in UNSUPPORTED_UFUNCS:\nastropy\/units\/quantity_helper.py:        # TODO: find a better way to deal with this.\nastropy\/config\/tests\/test_configs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/tests\/test_configs.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/config\/tests\/test_configs.py:    ci = ConfigItem(34, 'this is a Description')\nastropy\/config\/tests\/test_configs.py:    assert ci.description == 'this is a Description'\nastropy\/config\/tests\/test_configs.py:    ci.description = 'updated Descr'\nastropy\/config\/tests\/test_configs.py:    ci.description = 'this is a Description'\nastropy\/config\/tests\/test_configs.py:    monkeypatch.setenv(str('XDG_CONFIG_HOME'), 'foo')\nastropy\/config\/tests\/test_configs.py:    monkeypatch.delenv(str('XDG_CONFIG_HOME'))\nastropy\/config\/tests\/test_configs.py:        tstnm12 = ConfigItem(42, 'this is another Description')\nastropy\/config\/tests\/test_configs.py:        with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/config\/tests\/test_configs.py:    # \"import astropy\" fails when neither $HOME or $XDG_CONFIG_HOME\nastropy\/config\/tests\/test_configs.py:    for val in ['HOME', 'XDG_CONFIG_HOME']:\nastropy\/config\/paths.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/paths.py:        elif 'HOMEDRIVE' in os.environ and 'HOMEPATH' in os.environ:\nastropy\/config\/paths.py:            homedir = os.path.join(os.environ['HOMEDRIVE'],\nastropy\/config\/paths.py:    Determines the Astropy configuration directory name and creates the\nastropy\/config\/paths.py:    XDG_CONFIG_HOME environment variable is set and the\nastropy\/config\/paths.py:    ``$XDG_CONFIG_HOME\/astropy`` directory exists, it will be that directory.\nastropy\/config\/paths.py:    # first look for XDG_CONFIG_HOME\nastropy\/config\/paths.py:    xch = os.environ.get('XDG_CONFIG_HOME')\nastropy\/config\/paths.py:    Determines the Astropy cache directory name and creates the directory if it\nastropy\/config\/paths.py:    XDG_CACHE_HOME environment variable is set and the\nastropy\/config\/paths.py:    ``$XDG_CACHE_HOME\/astropy`` directory exists, it will be that directory.\nastropy\/config\/paths.py:    # first look for XDG_CACHE_HOME\nastropy\/config\/paths.py:    xch = os.environ.get('XDG_CACHE_HOME')\nastropy\/tests\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/parameters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/parameters.py:    n           Density perturbation spectral index\nastropy\/cosmology\/parameters.py:    sigma8      Density perturbation amplitude\nastropy\/units\/quantity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/quantity.py:from ..utils.exceptions import AstropyDeprecationWarning\nastropy\/units\/quantity.py:from ..utils.misc import isiterable, InheritDocstrings\nastropy\/units\/quantity.py:from ..utils.data_info import ParentDtypeInfo\nastropy\/units\/quantity.py:_UNIT_NOT_INITIALISED = \"(Unit not initialised)\"\nastropy\/units\/quantity.py:    ``q``.  It allows iterating over the array as if it were a 1-D array,\nastropy\/units\/quantity.py:class QuantityInfoBase(ParentDtypeInfo):\nastropy\/units\/quantity.py:class Quantity(np.ndarray, metaclass=InheritDocstrings):\nastropy\/units\/quantity.py:        `~astropy.units.Dex` for ``u.dex(u.AA)``).\nastropy\/units\/quantity.py:    # Default unit for initialization; can be overridden by subclasses,\nastropy\/units\/quantity.py:                # Default to dimensionless for no (initialized) unit attribute.\nastropy\/units\/quantity.py:        # DataInfo works, `'info' in obj.__dict__` is False until the\nastropy\/units\/quantity.py:        # Determine required conversion functions -- to bring the unit of the\nastropy\/units\/quantity.py:        # Determine the unit and quantity subclass that we need for the view.\nastropy\/units\/quantity.py:            except DeprecationWarning:\nastropy\/units\/quantity.py:                # We treat the DeprecationWarning separately, since it may\nastropy\/units\/quantity.py:            except DeprecationWarning:\nastropy\/units\/quantity.py:        \"\"\" Division between `Quantity` objects and other objects.\"\"\"\nastropy\/units\/quantity.py:        \"\"\" Right Division between `Quantity` objects and other objects.\"\"\"\nastropy\/units\/quantity.py:        \"\"\" Division between `Quantity` objects. \"\"\"\nastropy\/units\/quantity.py:        \"\"\" Division between `Quantity` objects. \"\"\"\nastropy\/units\/quantity.py:        \"\"\" Division between `Quantity` objects. \"\"\"\nastropy\/units\/quantity.py:                      AstropyDeprecationWarning)\nastropy\/units\/quantity.py:            unitstr = _UNIT_NOT_INITIALISED\nastropy\/units\/quantity.py:    # Display\nastropy\/units\/quantity.py:    # TODO: we may want to add a hook for dimensionless quantities?\nastropy\/units\/quantity.py:                      else _UNIT_NOT_INITIALISED)\nastropy\/units\/quantity.py:        decomposed. Decomposed units have only irreducible units in\nastropy\/units\/quantity.py:        Generates a new `Quantity` with the units decomposed. Decomposed\nastropy\/units\/quantity.py:        \"\"\"A 1-D iterator over the Quantity array.\nastropy\/units\/quantity.py:    :class:`~astropy.coordinates.Distance`\nastropy\/units\/quantity.py:    # Default unit for initialization through the constructor.\nastropy\/units\/physical.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/physical.py:Defines physical unit names.\nastropy\/stats\/tests\/test_bayesian_blocks.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_bayesian_blocks.py:    # Event Data\nastropy\/cosmology\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/command.py:class FixRemoteDataOption(type):\nastropy\/tests\/command.py:        return super(FixRemoteDataOption, cls).__init__(name, bases, dct)\nastropy\/tests\/command.py:class AstropyTest(Command, metaclass=FixRemoteDataOption):\nastropy\/tests\/command.py:         \"Don't test the documentation .rst files.\"),\nastropy\/tests\/command.py:        # Don't use get_pkg_data_filename here, because it\nastropy\/tests\/test_logger.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/test_logger.py:@pytest.mark.parametrize(('level'), [None, 'DEBUG', 'INFO', 'WARN', 'ERROR'])\nastropy\/tests\/test_logger.py:            log.debug(\"Debug message\")\nastropy\/tests\/test_logger.py:    if level == 'DEBUG':\nastropy\/tests\/test_logger.py:        assert log_list[3].levelname == 'DEBUG'\nastropy\/tests\/test_logger.py:        assert log_list[3].message.startswith('Debug message')\nastropy\/tests\/test_logger.py:@pytest.mark.parametrize(('level'), [None, 'DEBUG', 'INFO', 'WARN', 'ERROR'])\nastropy\/tests\/test_logger.py:            log.debug(\"Debug message\")\nastropy\/tests\/test_logger.py:    if level == 'DEBUG':\nastropy\/tests\/test_logger.py:            'astropy.tests.test_logger', 'DEBUG', 'Debug message')\nastropy\/stats\/bayesian_blocks.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/bayesian_blocks.py:Dynamic programming algorithm for solving a piecewise-constant model for\nastropy\/stats\/bayesian_blocks.py:# TODO: implement other fitness functions from appendix B of Scargle 2012\nastropy\/stats\/bayesian_blocks.py:    FITNESS_DICT = {'events': Events,\nastropy\/stats\/bayesian_blocks.py:    fitness = FITNESS_DICT.get(fitness, fitness)\nastropy\/stats\/bayesian_blocks.py:    Derived classes should overload the following method:\nastropy\/stats\/bayesian_blocks.py:            # TODO: allow broadcasted x?\nastropy\/units\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/utils.py:     - Description\nastropy\/units\/utils.py:            # Denominators of 1 can just be integers.\nastropy\/stats\/lombscargle\/core.py:        Conference on Intelligent Data Understanding (2012)\nastropy\/stats\/lombscargle\/core.py:        \"\"\"Determine a suitable frequency grid for data.\nastropy\/stats\/lombscargle\/core.py:        - \"davies\" : the Davies upper bound from Baluev (2008) [1]_.\nastropy\/stats\/lombscargle\/core.py:        - \"davies\" : the Davies upper bound from Baluev (2008) [1]_.\nastropy\/tests\/helper.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/helper.py:from ..utils.exceptions import (AstropyDeprecationWarning,\nastropy\/tests\/helper.py:                                AstropyPendingDeprecationWarning)\nastropy\/tests\/helper.py:        @raises(ZeroDivisionError)\nastropy\/tests\/helper.py:        If set to `True`, ``AstropyDeprecationWarning`` and\nastropy\/tests\/helper.py:        ``AstropyPendingDeprecationWarning`` are also turned into exceptions.\nastropy\/tests\/helper.py:        is given, ``AstropyDeprecationWarning`` and\nastropy\/tests\/helper.py:        ``AstropyPendingDeprecationWarning`` are also ignored for the modules.\nastropy\/tests\/helper.py:        Dictionary mapping tuple of ``(major, minor)`` Python version to\nastropy\/tests\/helper.py:    Turn all DeprecationWarnings (which indicate deprecated uses of\nastropy\/tests\/helper.py:    # Hide the next couple of DeprecationWarnings\nastropy\/tests\/helper.py:    warnings.simplefilter('ignore', DeprecationWarning)\nastropy\/tests\/helper.py:    # Now, turn DeprecationWarnings into exceptions\nastropy\/tests\/helper.py:    _all_warns = [DeprecationWarning]\nastropy\/tests\/helper.py:        _all_warns += [AstropyDeprecationWarning,\nastropy\/tests\/helper.py:                       AstropyPendingDeprecationWarning]\nastropy\/tests\/helper.py:                warnings.filterwarnings(\"ignore\", s, DeprecationWarning)\nastropy\/tests\/helper.py:          \"Did not pickle {0}\".format(key)\nastropy\/stats\/lombscargle\/_statistics.py:        raise NotImplementedError(\"Degrees of freedom != 2\")\nastropy\/stats\/lombscargle\/_statistics.py:        raise NotImplementedError(\"Degrees of freedom != 2\")\nastropy\/stats\/lombscargle\/_statistics.py:        raise NotImplementedError(\"Degrees of freedom != 2\")\nastropy\/stats\/lombscargle\/_statistics.py:    \"\"\"tau factor for estimating Davies bound (Baluev 2008, Table 1)\"\"\"\nastropy\/stats\/lombscargle\/_statistics.py:    NH = N - dH  # DOF for null hypothesis\nastropy\/stats\/lombscargle\/_statistics.py:    NK = N - dK  # DOF for periodic hypothesis\nastropy\/stats\/lombscargle\/_statistics.py:    Dt = _weighted_var(t, dy)\nastropy\/stats\/lombscargle\/_statistics.py:    Teff = np.sqrt(4 * np.pi * Dt)  # Effective baseline\nastropy\/stats\/lombscargle\/_statistics.py:    \"\"\"Davies upper-bound to the false alarm probability\nastropy\/stats\/lombscargle\/_statistics.py:METHODS = {'single': fap_single,\nastropy\/stats\/lombscargle\/_statistics.py:    elif method not in METHODS:\nastropy\/stats\/lombscargle\/_statistics.py:    method = METHODS[method]\nastropy\/stats\/lombscargle\/_statistics.py:INV_METHODS = {'single': inv_fap_single,\nastropy\/stats\/lombscargle\/_statistics.py:    elif method not in INV_METHODS:\nastropy\/stats\/lombscargle\/_statistics.py:    method = INV_METHODS[method]\nastropy\/stats\/lombscargle\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_logarithmic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_logarithmic.py:lu_subclasses = [u.DexUnit, u.MagUnit, u.DecibelUnit]\nastropy\/units\/tests\/test_logarithmic.py:lq_subclasses = [u.Dex, u.Magnitude, u.Decibel]\nastropy\/units\/tests\/test_logarithmic.py:        \"\"\"Do some spot checks that str, repr, etc. work as expected.\"\"\"\nastropy\/units\/tests\/test_logarithmic.py:        dm0 = u.Unit('DM', 1.\/(4.*np.pi*(10.*u.pc)**2))\nastropy\/units\/tests\/test_logarithmic.py:            q.view(u.Dex)\nastropy\/units\/tests\/test_logarithmic.py:        lq = q.view(u.Dex)\nastropy\/units\/tests\/test_logarithmic.py:        assert isinstance(lq, u.Dex)\nastropy\/units\/tests\/test_logarithmic.py:        dm0 = u.Unit('DM', 1.\/(4.*np.pi*(10.*u.pc)**2))\nastropy\/units\/tests\/test_logarithmic.py:        DMmag = u.mag(dm0)\nastropy\/units\/tests\/test_logarithmic.py:        dm = 5. * DMmag\nastropy\/units\/tests\/test_logarithmic.py:        lq3 = u.Dex(2.*u.Jy)\nastropy\/stats\/tests\/test_histogram.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_sigma_clipping.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_physical.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/mixin.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_units.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_units.py:COMPOSE_ROUNDTRIP = set()\nastropy\/units\/tests\/test_units.py:        COMPOSE_ROUNDTRIP.add(val)\nastropy\/units\/tests\/test_units.py:@pytest.mark.parametrize('unit', sorted(COMPOSE_ROUNDTRIP, key=_unit_as_str), ids=_unit_as_str)\nastropy\/units\/tests\/test_units.py:            assert 'Did you mean {0}?'.format(matches) in str(e)\nastropy\/stats\/lombscargle\/implementations\/chi2_impl.py:    .. [3] Scargle, J.D. 1982, ApJ 263:835-853\nastropy\/stats\/tests\/test_biweight.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_biweight.py:    \"\"\"Test a 2D array with the axis keyword.\"\"\"\nastropy\/stats\/tests\/test_biweight.py:    \"\"\"Test a 3D array with the axis keyword.\"\"\"\nastropy\/stats\/tests\/test_biweight.py:    \"\"\"Test a 2D array with the axis keyword.\"\"\"\nastropy\/stats\/tests\/test_biweight.py:    \"\"\"Test a 3D array with the axis keyword.\"\"\"\nastropy\/stats\/tests\/test_biweight.py:    Test that biweight_midcovariance raises error with a 3D array.\nastropy\/stats\/tests\/test_biweight.py:    assert 'The input array must be 2D or 1D.' in str(e.value)\nastropy\/stats\/tests\/test_biweight.py:    or 1D array.\nastropy\/stats\/tests\/test_biweight.py:    assert 'M must be a scalar or 1D array.' in str(e.value)\nastropy\/stats\/tests\/test_biweight.py:        assert 'x must be a 1D array.' in str(e.value)\nastropy\/stats\/tests\/test_biweight.py:        assert 'y must be a 1D array.' in str(e.value)\nastropy\/stats\/lombscargle\/implementations\/fastchi2_impl.py:    .. [3] Scargle, J.D. ApJ 263:835-853 (1982)\nastropy\/stats\/histogram.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/histogram.py:        - 'freedman' : use the Freedman-Diaconis rule to determine bins\nastropy\/stats\/histogram.py:        # TODO: if weights is specified, we need to modify things.\nastropy\/stats\/histogram.py:        \\Delta_b = \\frac{3.5\\sigma}{n^{1\/3}}\nastropy\/stats\/histogram.py:    .. [1] Scott, David W. (1979). \"On optimal and data-based histograms\".\nastropy\/stats\/histogram.py:    r\"\"\"Return the optimal histogram bin width using the Freedman-Diaconis rule\nastropy\/stats\/histogram.py:    The Freedman-Diaconis rule is a normal reference rule like Scott's\nastropy\/stats\/histogram.py:        optimal bin width using the Freedman-Diaconis rule\nastropy\/stats\/histogram.py:        \\Delta_b = \\frac{2(q_{75} - q_{25})}{n^{1\/3}}\nastropy\/stats\/histogram.py:    .. [1] D. Freedman & P. Diaconis (1981)\nastropy\/stats\/histogram.py:    .. [1] Knuth, K.H. \"Optimal Data-Based Binning for Histograms\".\nastropy\/stats\/lombscargle\/implementations\/main.py:METHODS = {'slow': lombscargle_slow,\nastropy\/stats\/lombscargle\/implementations\/main.py:    if method not in METHODS:\nastropy\/stats\/lombscargle\/implementations\/main.py:    PLS = METHODS[method](*args, **kwds)\nastropy\/units\/tests\/test_equivalencies.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_equivalencies.py:# THIRD-PARTY\nastropy\/units\/tests\/test_equivalencies.py:    # Density\nastropy\/units\/tests\/test_equivalencies.py:    # Define F_nu in Jy\nastropy\/units\/tests\/test_equivalencies.py:    # Define F_lambda in ergs \/ cm^2 \/ s \/ micron\nastropy\/units\/tests\/test_equivalencies.py:        assert False, \"Didn't find speed in compose results\"\nastropy\/units\/function\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_deprecated.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/lombscargle\/implementations\/scipy_impl.py:    .. [3] Scargle, J.D. 1982, ApJ 263:835-853\nastropy\/units\/imperial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/imperial.py:# SPEED\nastropy\/units\/imperial.py:def_unit(['deg_F', 'Fahrenheit'], namespace=_ns, doc='Degrees Fahrenheit',\nastropy\/units\/imperial.py:# DOCSTRING\nastropy\/stats\/lombscargle\/implementations\/slow_impl.py:    .. [2] Scargle, J.D. 1982, ApJ 263:835-853\nastropy\/units\/tests\/test_quantity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_quantity.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/units\/tests\/test_quantity.py:from ...units.quantity import _UNIT_NOT_INITIALISED\nastropy\/units\/tests\/test_quantity.py:        numbers are converted to float (including decimal.Decimal, which\nastropy\/units\/tests\/test_quantity.py:        q4 = u.Quantity(decimal.Decimal('10.25'), u.m)\nastropy\/units\/tests\/test_quantity.py:        q5 = u.Quantity(decimal.Decimal('10.25'), u.m, dtype=object)\nastropy\/units\/tests\/test_quantity.py:            with catch_warnings(AstropyDeprecationWarning) as warning_lines:\nastropy\/units\/tests\/test_quantity.py:                assert warning_lines[0].category == AstropyDeprecationWarning\nastropy\/units\/tests\/test_quantity.py:class TestQuantityDisplay:\nastropy\/units\/tests\/test_quantity.py:        assert str(bad_quantity).endswith(_UNIT_NOT_INITIALISED)\nastropy\/units\/tests\/test_quantity.py:        assert repr(bad_quantity).endswith(_UNIT_NOT_INITIALISED + '>')\nastropy\/units\/tests\/test_quantity.py:    TODO: create PNG output and check against reference image\nastropy\/units\/tests\/test_quantity_decorator.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/magnitude_zero_points.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/magnitude_zero_points.py:# DOCSTRING\nastropy\/units\/function\/logarithmic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/logarithmic.py:__all__ = ['LogUnit', 'MagUnit', 'DexUnit', 'DecibelUnit',\nastropy\/units\/function\/logarithmic.py:           'LogQuantity', 'Magnitude', 'Decibel', 'Dex',\nastropy\/units\/function\/logarithmic.py:    such `MagUnit`, `DecibelUnit`, and `DexUnit`.\nastropy\/units\/function\/logarithmic.py:class DexUnit(LogUnit):\nastropy\/units\/function\/logarithmic.py:        return Dex\nastropy\/units\/function\/logarithmic.py:class DecibelUnit(LogUnit):\nastropy\/units\/function\/logarithmic.py:        return Decibel\nastropy\/units\/function\/logarithmic.py:        >>> u.Decibel(1.*u.W, u.DecibelUnit(u.mW))  # doctest: +FLOAT_CMP\nastropy\/units\/function\/logarithmic.py:        <Decibel 30. dB(mW)>\nastropy\/units\/function\/logarithmic.py:        # Do calculation in-place using _function_view of array.\nastropy\/units\/function\/logarithmic.py:        # Do calculation in-place using _function_view of array.\nastropy\/units\/function\/logarithmic.py:class Dex(LogQuantity):\nastropy\/units\/function\/logarithmic.py:    _unit_class = DexUnit\nastropy\/units\/function\/logarithmic.py:class Decibel(LogQuantity):\nastropy\/units\/function\/logarithmic.py:    _unit_class = DecibelUnit\nastropy\/units\/function\/logarithmic.py:dex._function_unit_class = DexUnit\nastropy\/units\/function\/logarithmic.py:dB._function_unit_class = DecibelUnit\nastropy\/tests\/disable_internet.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/disable_internet.py:TODO: This module should eventually be removed once backwards compatibility\nastropy\/tests\/disable_internet.py:from ..utils.exceptions import AstropyDeprecationWarning\nastropy\/tests\/disable_internet.py:     \"for more information.\", AstropyDeprecationWarning)\nastropy\/units\/tests\/test_format.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_format.py:    ([\"dB(mW)\", \"dB (mW)\"], u.DecibelUnit(u.mW)),\nastropy\/units\/tests\/test_format.py:    ([\"dex(cm s**-2)\", \"dex(cm\/s2)\"], u.DexUnit(u.cm \/ u.s**2))])\nastropy\/units\/tests\/test_format.py:        unit2 = u_format.CDS.parse(s)\nastropy\/units\/tests\/test_format.py:        u_format.CDS.parse(string)\nastropy\/units\/tests\/test_format.py:    val for key, val in u_format.CDS._units.items()\nastropy\/units\/tests\/test_format.py:    u_format.CDS._units\nastropy\/units\/tests\/test_format.py:    and CDS, but not in fits and vounit.\"\"\"\nastropy\/units\/tests\/test_format.py:        assert 'Did you mean Angstrom or angstrom?' in str(e)\nastropy\/stats\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/equivalencies.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/equivalencies.py:# THIRD-PARTY\nastropy\/units\/equivalencies.py:    Defines the conversion between Jy\/beam and \"brightness temperature\",\nastropy\/tests\/tests\/test_imports.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/cds.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/cds.py:This package defines units used in the CDS format, both the units\nastropy\/units\/cds.py:defined in `Centre de Donn\u00e9es astronomiques de Strasbourg\nastropy\/units\/cds.py:    # The CDS format also supports power-of-2 prefixes as defined here:\nastropy\/units\/cds.py:    # CDS only uses the short prefixes\nastropy\/units\/cds.py:        (['D'], u.D, \"Debye (dipole)\"),\nastropy\/units\/cds.py:        (['JD'], u.d, \"Julian day\", ['M']),\nastropy\/units\/cds.py:        (['MJD'], u.d, \"Julian day\"),\nastropy\/units\/cds.py:# DOCSTRING\nastropy\/units\/cds.py:    Enable CDS units so they appear in results of\nastropy\/units\/cds.py:    This may be used with the ``with`` statement to enable CDS\nastropy\/tests\/pytest_plugins.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/pytest_plugins.py:TODO: This entire module should eventually be removed once backwards\nastropy\/tests\/pytest_plugins.py:from ..utils.exceptions import AstropyDeprecationWarning\nastropy\/tests\/pytest_plugins.py:from .plugins.display import PYTEST_HEADER_MODULES, TESTED_VERSIONS\nastropy\/tests\/pytest_plugins.py:    \"deprecated. The variables `PYTEST_HEADER_MODULES` and `TESTED_VERSIONS`\" \\\nastropy\/tests\/pytest_plugins.py:warnings.warn(_warning_message, AstropyDeprecationWarning)\nastropy\/stats\/tests\/test_jackknife.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/units.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/units.py:                              doc=\"Dex: Base 10 logarithmic unit\")\nastropy\/units\/function\/units.py:                         doc=\"Decibel: ten per base 10 logarithmic unit\")\nastropy\/units\/function\/units.py:# DOCSTRING\nastropy\/units\/tests\/test_quantity_ufuncs.py:        all_q_ufuncs = (qh.UNSUPPORTED_UFUNCS |\nastropy\/tests\/tests\/test_run_tests.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/tests\/test_run_tests.py:# TODO: Temporarily disabled, as this seems to non-deterministically fail\nastropy\/tests\/tests\/test_run_tests.py:#     with pytest.raises(DeprecationWarning):\nastropy\/tests\/tests\/test_run_tests.py:#         warnings.warn('test warning', DeprecationWarning)\nastropy\/tests\/tests\/test_run_tests.py:    with pytest.raises(doctest.DocTestFailure):\nastropy\/stats\/jackknife.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/jackknife.py:        Original sample (1-D array) from which the jackknife resamples will be\nastropy\/stats\/jackknife.py:        Resampling Plans\". Technical Report No. 63, Division of Biostatistics,\nastropy\/stats\/jackknife.py:        Stanford University, December, 1980.\nastropy\/stats\/jackknife.py:        Original sample (1-D array).\nastropy\/stats\/jackknife.py:        Must be a real-valued number in (0,1). Default value is 0.95.\nastropy\/units\/si.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/si.py:# DIMENSIONLESS\nastropy\/units\/si.py:    ['deg_C', 'Celsius'], namespace=_ns, doc='Degrees Celsius',\nastropy\/units\/si.py:# RADIOACTIVITY\nastropy\/units\/si.py:# DOCSTRING\nastropy\/units\/tests\/py3_test_quantity_annotations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_funcs.py:        D, f = funcs.kuiper_two(np.random.random(500) * 0.5,\nastropy\/stats\/tests\/test_funcs.py:            D, f = funcs.kuiper_two(np.random.random(N), np.random.random(M))\nastropy\/stats\/spatial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/spatial.py:    .. [4] Cressie, N.A.C. (1991). Statistics for Spatial Data,\nastropy\/stats\/spatial.py:    .. [5] Stoyan, D., Stoyan, H. (1992). Fractals, Random Shapes and\nastropy\/stats\/spatial.py:        radii : 1D array\nastropy\/stats\/spatial.py:        output : 1D array\nastropy\/stats\/spatial.py:        data : 2D array\nastropy\/stats\/spatial.py:        radii : 1D array\nastropy\/stats\/spatial.py:        ripley : 1D array\nastropy\/tests\/image_tests.py:IMAGE_REFERENCE_DIR = (ROOT.format(server='data.astropy.org', mpl_version='1.5.x') + ',' +\nastropy\/units\/required_by_vounit.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/required_by_vounit.py:# DOCSTRING\nastropy\/units\/function\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/core.py:SUPPORTED_UFUNCS = set(getattr(np.core.umath, ufunc) for ufunc in (\nastropy\/units\/function\/core.py:# TODO: the following could work if helper changed relative to Quantity:\nastropy\/units\/function\/core.py:SUPPORTED_FUNCTIONS = set(getattr(np, function) for function in\nastropy\/units\/function\/core.py:        \"\"\"Default function unit corresponding to the function.\nastropy\/units\/function\/core.py:            # Don't know what to do with anything not like a unit.\nastropy\/units\/function\/core.py:    \"\"\"Default `~astropy.units.function.FunctionUnitBase` subclass.\nastropy\/units\/function\/core.py:    # Define functions that work on FunctionQuantity.\nastropy\/units\/function\/core.py:    _supported_ufuncs = SUPPORTED_UFUNCS\nastropy\/units\/function\/core.py:    _supported_functions = SUPPORTED_FUNCTIONS\nastropy\/units\/function\/core.py:        \"\"\"Do a comparison between self and other, raising UnitsError when\nastropy\/units\/decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/decorators.py:        # Define a new function to return in place of the wrapped one\nastropy\/units\/decorators.py:                if param.kind in (inspect.Parameter.VAR_KEYWORD,\nastropy\/stats\/info_theory.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/info_theory.py:    :math:`\\Delta \\mathrm{BIC} = \\mathrm{BIC}_h - \\mathrm{BIC}_l`, in which\nastropy\/stats\/info_theory.py:    the lower BIC. The higher is :math:`\\Delta \\mathrm{BIC}` the stronger is\nastropy\/stats\/info_theory.py:    :math:`0 < \\Delta\\mathrm{BIC} \\leq 2`: weak evidence that model low is\nastropy\/stats\/info_theory.py:    :math:`2 < \\Delta\\mathrm{BIC} \\leq 6`: moderate evidence that model low is\nastropy\/stats\/info_theory.py:    :math:`6 < \\Delta\\mathrm{BIC} \\leq 10`: strong evidence that model low is\nastropy\/stats\/info_theory.py:    :math:`\\Delta\\mathrm{BIC} > 10`: very strong evidence that model low is\nastropy\/stats\/info_theory.py:    .. [1] Richards, D. Maximum Likelihood Estimation and the Bayesian\nastropy\/stats\/info_theory.py:    Consider the simple 1-D fitting example presented in the Astropy\nastropy\/stats\/info_theory.py:    >>> t_init = models.Trapezoid1D(amplitude=1., x_0=0., width=1., slope=0.5)\nastropy\/stats\/info_theory.py:    >>> g_init = models.Gaussian1D(amplitude=1., mean=0, stddev=1.)\nastropy\/stats\/info_theory.py:    :math:`\\Delta\\mathrm{AIC}_i = \\mathrm{AIC}_i - \\mathrm{AIC}_{min}`\nastropy\/stats\/info_theory.py:    :math:`\\Delta\\mathrm{AIC}_i < 2`: substantial support for model i\nastropy\/stats\/info_theory.py:    :math:`3 < \\Delta\\mathrm{AIC}_i < 7`: considerably less support for model i\nastropy\/stats\/info_theory.py:    :math:`\\Delta\\mathrm{AIC}_i > 10`: essentially none support for model i\nastropy\/stats\/info_theory.py:    with five parameters (model 2). Despite of the fact that model 2 has a\nastropy\/stats\/info_theory.py:    >>> g1 = models.Gaussian1D(.1, 0, 0.2) # changed this to noise level\nastropy\/stats\/info_theory.py:    >>> g2 = models.Gaussian1D(.1, 0.3, 0.2) # and added another Gaussian\nastropy\/stats\/info_theory.py:    >>> g3 = models.Gaussian1D(2.5, 0.5, 0.1)\nastropy\/stats\/info_theory.py:    >>> g3_init = (models.Gaussian1D(.1, 0, 0.1)\nastropy\/stats\/info_theory.py:    ...            + models.Gaussian1D(.1, 0.2, 0.15)\nastropy\/stats\/info_theory.py:    ...            + models.Gaussian1D(2., .4, 0.1))\nastropy\/stats\/info_theory.py:    >>> g2_init = (models.Gaussian1D(.1, 0, 0.1) +\nastropy\/stats\/info_theory.py:    ...            models.Gaussian1D(2, 0.5, 0.1))\nastropy\/stats\/info_theory.py:    >>> g1_init = models.Gaussian1D(amplitude=2., mean=0.3, stddev=.5)\nastropy\/stats\/circstats.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/circstats.py:        If ``True``, central circular moments are computed. Default value is\nastropy\/stats\/circstats.py:    .. [3] M. Chirstman., C. Miller. \"Testing a Sample of Directions for\nastropy\/stats\/circstats.py:    .. [4] D. Wilkie. \"Rayleigh Test for Randomness of Circular Data\". Applied\nastropy\/stats\/circstats.py:    .. [3] M. Chirstman., C. Miller. \"Testing a Sample of Directions for\nastropy\/units\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/__init__.py:code under a BSD license.\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:ALL_METHODS = LombScargle.available_methods\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:ALL_METHODS_NO_AUTO = [method for method in ALL_METHODS if method != 'auto']\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:FAST_METHODS = [method for method in ALL_METHODS if 'fast' in method]\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:NTERMS_METHODS = [method for method in ALL_METHODS if 'chi2' in method]\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:@pytest.mark.parametrize('method', ALL_METHODS_NO_AUTO)\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:    if method in FAST_METHODS:\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:@pytest.mark.parametrize('method', ALL_METHODS_NO_AUTO)\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:@pytest.mark.parametrize('method', NTERMS_METHODS)\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:@pytest.mark.parametrize('method', FAST_METHODS)\nastropy\/tests\/plugins\/config.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/plugins\/config.py:from collections import OrderedDict\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:                           METHODS)\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:METHOD_KWDS = dict(bootstrap={'n_bootstraps': 20, 'random_seed': 42})\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:    method_kwds = METHOD_KWDS['bootstrap']\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:@pytest.mark.parametrize('method', sorted(set(METHODS) - {'bootstrap'}))\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:    method_kwds = METHOD_KWDS.get(method, None)\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:@pytest.mark.parametrize('method', sorted(METHODS))\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:    kwds = METHOD_KWDS.get(method, None)\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:@pytest.mark.parametrize('method', sorted(METHODS))\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:    # Note: the PSD normalization is not equivalent to the others, in that it\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:    kwds = METHOD_KWDS.get(method, None)\nastropy\/stats\/biweight.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/biweight.py:        u_{i} = \\frac{(x_i - M)}{c * MAD}\nastropy\/stats\/biweight.py:    where :math:`c` is the tuning constant and :math:`MAD` is the\nastropy\/stats\/biweight.py:        u_{i} = \\frac{(x_i - M)}{c * MAD}\nastropy\/stats\/biweight.py:    where :math:`c` is the tuning constant and :math:`MAD` is the\nastropy\/stats\/biweight.py:        u_{i} = \\frac{(x_i - M)}{c * MAD}\nastropy\/stats\/biweight.py:    where :math:`c` is the tuning constant and :math:`MAD` is the\nastropy\/stats\/biweight.py:        u_{i} = \\frac{(x_i - M_x)}{c * MAD_x}\nastropy\/stats\/biweight.py:        v_{i} = \\frac{(y_i - M_y)}{c * MAD_y}\nastropy\/stats\/biweight.py:    where :math:`c` is the biweight tuning constant and :math:`MAD_x`\nastropy\/stats\/biweight.py:    and :math:`MAD_y` are the `median absolute deviation\nastropy\/stats\/biweight.py:    data : 2D or 1D array-like\nastropy\/stats\/biweight.py:        Input data either as a 2D or 1D array.  For a 2D array, it\nastropy\/stats\/biweight.py:        should have a shape (N_variables, N_observations).  A 1D array\nastropy\/stats\/biweight.py:    M : float or 1D array-like, optional\nastropy\/stats\/biweight.py:        array.  If ``M`` is an array, then its must be a 1D array\nastropy\/stats\/biweight.py:        A 2D array representing the biweight midcovariances between each\nastropy\/stats\/biweight.py:    # ensure data is 2D\nastropy\/stats\/biweight.py:        raise ValueError('The input array must be 2D or 1D.')\nastropy\/stats\/biweight.py:        raise ValueError('M must be a scalar or 1D array.')\nastropy\/stats\/biweight.py:    x, y : 1D array-like\nastropy\/stats\/biweight.py:        Input arrays for the two variables.  ``x`` and ``y`` must be 1D\nastropy\/stats\/biweight.py:        raise ValueError('x must be a 1D array.')\nastropy\/stats\/biweight.py:        raise ValueError('y must be a 1D array.')\nastropy\/tests\/runner.py:from collections import OrderedDict\nastropy\/tests\/runner.py:from ..utils.exceptions import AstropyWarning, AstropyDeprecationWarning\nastropy\/tests\/runner.py:        The default value for the keyword argument. (Default: `None`)\nastropy\/tests\/runner.py:        cls.keywords = OrderedDict()\nastropy\/tests\/runner.py:        cls.run_tests.__doc__ = cls.RUN_TESTS_DOCSTRING.format(keywords=doc_keywords)\nastropy\/tests\/runner.py:    RUN_TESTS_DOCSTRING = \\\nastropy\/tests\/runner.py:        # Don't import pytest until it's actually needed to run the tests\nastropy\/tests\/runner.py:                          AstropyDeprecationWarning)\nastropy\/tests\/runner.py:            Turn on PDB post-mortem analysis for failing tests. Same as\nastropy\/units\/cgs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/cgs.py:# DYNAMIC VISCOSITY\nastropy\/units\/cgs.py:def_unit(['D', 'Debye', 'debye'], Fraction(1, 3) * 1e-29 * C * si.m,\nastropy\/units\/cgs.py:         doc=\"Debye: CGS unit of electric dipole moment\")\nastropy\/units\/cgs.py:# DOCSTRING\nastropy\/tests\/plugins\/display.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/plugins\/display.py:from collections import OrderedDict\nastropy\/tests\/plugins\/display.py:PYTEST_HEADER_MODULES = OrderedDict([('Numpy', 'numpy'),\nastropy\/tests\/plugins\/display.py:TESTED_VERSIONS = OrderedDict([('Astropy', __version__)])\nastropy\/tests\/plugins\/display.py:    # TESTED_VERSIONS can contain the affiliated package version, too\nastropy\/tests\/plugins\/display.py:    if len(TESTED_VERSIONS) > 1:\nastropy\/tests\/plugins\/display.py:        for pkg, version in TESTED_VERSIONS.items():\nastropy\/tests\/plugins\/display.py:            TESTED_VERSIONS['Astropy'])\nastropy\/tests\/plugins\/display.py:    s += \"Date: {0}\\n\\n\".format(datetime.datetime.now().isoformat()[:19])\nastropy\/tests\/plugins\/display.py:    for module_display, module_name in PYTEST_HEADER_MODULES.items():\nastropy\/tests\/plugins\/display.py:            with ignore_warnings(DeprecationWarning):\nastropy\/units\/deprecated.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/deprecated.py:# DOCSTRING\nastropy\/constants\/iau2015.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/iau2015.py:# DISTANCE\nastropy\/constants\/iau2015.py:              \"Derived from au\", system='si')\nastropy\/constants\/iau2015.py:               \"Derived from au\", system='si')\nastropy\/constants\/iau2015.py:                 \"IAU 2015 Resolution B 3 + CODATA 2014\", system='si')\nastropy\/constants\/iau2015.py:                 \"IAU 2015 Resolution B 3 + CODATA 2014\", system='si')\nastropy\/constants\/iau2015.py:                 \"IAU 2015 Resolution B 3 + CODATA 2014\", system='si')\nastropy\/stats\/funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/funcs.py:# TODO Note scipy dependency\nastropy\/stats\/funcs.py:        Desired probability content of interval. Default is 0.68269,\nastropy\/stats\/funcs.py:        recommended.  It is provided for comparison purposes.  Default is\nastropy\/stats\/funcs.py:    .. [1] Brown, Lawrence D.; Cai, T. Tony; DasGupta, Anirban (2001).\nastropy\/stats\/funcs.py:# TODO Note scipy dependency (needed in binom_conf_interval)\nastropy\/stats\/funcs.py:        Desired probability content in the confidence\nastropy\/stats\/funcs.py:        interval ``(p - perr[0], p + perr[1])`` in each bin. Default is\nastropy\/stats\/funcs.py:        It is provided for comparison purposes. Default is 'wilson'.\nastropy\/stats\/funcs.py:       plt.title('Detection efficiency vs magnitude')\nastropy\/stats\/funcs.py:       plt.ylabel('Detection efficiency')\nastropy\/stats\/funcs.py:       plt.ylabel('Detection efficiency')\nastropy\/stats\/funcs.py:        Default is ``'root-n'``.\nastropy\/stats\/funcs.py:    matter of debate. The CDF working group [recommends][pois_eb]\nastropy\/stats\/funcs.py:    the CDF working group). It also has the nice feature that\nastropy\/stats\/funcs.py:    Calculate the median absolute deviation (MAD).\nastropy\/stats\/funcs.py:    The MAD is defined as ``median(abs(a - median(a)))``.\nastropy\/stats\/funcs.py:        Axis along which the MADs are computed.  The default (`None`) is\nastropy\/stats\/funcs.py:        to compute the MAD of the flattened array.\nastropy\/stats\/funcs.py:        The function used to compute the median. Defaults to `numpy.ma.median`\nastropy\/stats\/funcs.py:    deviation (MAD)\nastropy\/stats\/funcs.py:        \\sigma \\approx \\frac{\\textrm{MAD}}{\\Phi^{-1}(3\/4)}\nastropy\/stats\/funcs.py:            \\approx 1.4826 \\ \\textrm{MAD}\nastropy\/stats\/funcs.py:        Data array or object that can be converted to an array.\nastropy\/stats\/funcs.py:        The function used to compute the median. Defaults to `numpy.ma.median`\nastropy\/stats\/funcs.py:    MAD = median_absolute_deviation(\nastropy\/stats\/funcs.py:    return MAD * 1.482602218505602\nastropy\/stats\/funcs.py:    optical\/IR using a CCD.\nastropy\/stats\/funcs.py:        CCD integration time in seconds\nastropy\/stats\/funcs.py:        Number of electrons (photons) or DN per second in the aperture from the\nastropy\/stats\/funcs.py:        transmission and the quantum efficiency of the CCD. If the input is in\nastropy\/stats\/funcs.py:        DN, then be sure to set the gain to the proper value for the CCD.\nastropy\/stats\/funcs.py:        Number of electrons (photons) or DN per second per pixel from the sky\nastropy\/stats\/funcs.py:        DN or ADU, then multiply by the gain to get the value in electrons.\nastropy\/stats\/funcs.py:        Read noise of the CCD in electrons. If this is given in\nastropy\/stats\/funcs.py:        DN or ADU, then multiply by the gain to get the value in electrons.\nastropy\/stats\/funcs.py:        Gain of the CCD. In units of electrons per DN.\nastropy\/stats\/funcs.py:        N-D array. The bootstrap resampling will be performed on the first\nastropy\/stats\/funcs.py:def kuiper_false_positive_probability(D, N):\nastropy\/stats\/funcs.py:    D : float\nastropy\/stats\/funcs.py:    if D < 0. or D > 2.:\nastropy\/stats\/funcs.py:        raise ValueError(\"Must have 0<=D<=2 by definition of the Kuiper test\")\nastropy\/stats\/funcs.py:    if D < 2. \/ N:\nastropy\/stats\/funcs.py:        return 1. - factorial(N) * (D - 1. \/ N)**(N - 1)\nastropy\/stats\/funcs.py:    elif D < 3. \/ N:\nastropy\/stats\/funcs.py:        k = -(N * D - 1.) \/ 2.\nastropy\/stats\/funcs.py:        r = np.sqrt(k**2 - (N * D - 2.) \/ 2.)\nastropy\/stats\/funcs.py:    elif (D > 0.5 and N % 2 == 0) or (D > (N - 1.) \/ (2. * N) and N % 2 == 1):\nastropy\/stats\/funcs.py:            y = D + t \/ float(N)\nastropy\/stats\/funcs.py:        for t in range(int(np.floor(N * (1 - D))) + 1):\nastropy\/stats\/funcs.py:            term = T(t) * comb(N, t) * (1 - D - t \/ float(N))**(N - t - 1)\nastropy\/stats\/funcs.py:        z = D * np.sqrt(N)\nastropy\/stats\/funcs.py:        return S1 - 8 * D \/ (3. * np.sqrt(N)) * S2\nastropy\/stats\/funcs.py:    distribution whose CDF is given as ``cdf``.\nastropy\/stats\/funcs.py:        A callable to evaluate the CDF of the distribution being tested\nastropy\/stats\/funcs.py:    D : float\nastropy\/stats\/funcs.py:        The probability of a D this large arising with a sample drawn from\nastropy\/stats\/funcs.py:        the distribution whose CDF is cdf.\nastropy\/stats\/funcs.py:    Returns (D, fpp), where D is the Kuiper D number and fpp is the\nastropy\/stats\/funcs.py:    probability that a value as large as D would occur if data was\nastropy\/stats\/funcs.py:    it will be necessary to do Monte Carlo simulations to interpret D.\nastropy\/stats\/funcs.py:    D should normally be independent of the shape of CDF.\nastropy\/stats\/funcs.py:    D = (np.amax(cdfv - np.arange(N) \/ float(N)) +\nastropy\/stats\/funcs.py:    return D, kuiper_false_positive_probability(D, N)\nastropy\/stats\/funcs.py:    D : float\nastropy\/stats\/funcs.py:    D = (np.amax(cdfv1 - np.arange(len(data1)) \/ float(len(data1))) +\nastropy\/stats\/funcs.py:    return D, kuiper_false_positive_probability(D, Ne)\nastropy\/stats\/funcs.py:    \"\"\"Construct a callable piecewise-linear CDF from a pair of arrays.\nastropy\/stats\/funcs.py:        Endpoints of the intervals in the PDF\nastropy\/constants\/constant.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/constant.py:from ..utils.misc import InheritDocstrings\nastropy\/constants\/constant.py:class ConstantMeta(InheritDocstrings):\nastropy\/stats\/sigma_clipping.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/sigma_clipping.py:        ``sigma_lower`` and ``sigma_upper``, if input. Defaults to 3.\nastropy\/stats\/sigma_clipping.py:        used. Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:        used. Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:        last iteration clips nothing). Defaults to 5.\nastropy\/stats\/sigma_clipping.py:        central value. Defaults to the median (`numpy.ma.median`).\nastropy\/stats\/sigma_clipping.py:        Defaults to the standard deviation (`numpy.std`).\nastropy\/stats\/sigma_clipping.py:        sigma_lower and sigma_upper to get the correct limits. Data\nastropy\/stats\/sigma_clipping.py:            clip over all axes.  Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:            as ``data``.  Defaults to `True`.\nastropy\/stats\/sigma_clipping.py:        ``sigma_lower`` and ``sigma_upper``, if input. Defaults to 3.\nastropy\/stats\/sigma_clipping.py:        used. Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:        used. Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:        last iteration clips nothing). Defaults to 5.\nastropy\/stats\/sigma_clipping.py:        central value. Defaults to the median (`numpy.ma.median`).\nastropy\/stats\/sigma_clipping.py:        Defaults to the standard deviation (`numpy.std`).\nastropy\/stats\/sigma_clipping.py:        Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:        ``data``.  Defaults to `True`.\nastropy\/stats\/sigma_clipping.py:        Data array or object that can be converted to an array.\nastropy\/stats\/sigma_clipping.py:        and ``sigma_upper``, if input. Defaults to 3.\nastropy\/stats\/sigma_clipping.py:        Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:        Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:        Defaults to 5.\nastropy\/stats\/sigma_clipping.py:        central value. Defaults to the median (`numpy.ma.median`).\nastropy\/stats\/sigma_clipping.py:        Defaults to the standard deviation (`numpy.std`).\nastropy\/stats\/sigma_clipping.py:        Defaults to `None`.\nastropy\/tests\/plugins\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/astrophys.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/astrophys.py:def_unit(['u', 'Da', 'Dalton'], _si.u, namespace=_ns,\nastropy\/units\/astrophys.py:# SPECTRAL DENSITY\nastropy\/units\/astrophys.py:# TODO: This is defined by the FITS standard as \"relative to the sun\".\nastropy\/units\/astrophys.py:# DOCSTRING\nastropy\/units\/format\/ogip.py:# Licensed under a 3-clause BSD style license - see LICNSE.rst\nastropy\/units\/format\/ogip.py:        'DIVISION',\nastropy\/units\/format\/ogip.py:        # Define the function names, so we can parse them, even though\nastropy\/units\/format\/ogip.py:        t_DIVISION = r'\/'\nastropy\/units\/format\/ogip.py:        # NOTE THE ORDERING OF THESE RULES IS IMPORTANT!!\nastropy\/units\/format\/ogip.py:        # Don't ignore whitespace\nastropy\/units\/format\/ogip.py:                if p[2] == 'DIVISION':\nastropy\/units\/format\/ogip.py:            division : DIVISION\nastropy\/units\/format\/ogip.py:                     | WHITESPACE DIVISION\nastropy\/units\/format\/ogip.py:                     | WHITESPACE DIVISION WHITESPACE\nastropy\/units\/format\/ogip.py:                     | DIVISION WHITESPACE\nastropy\/units\/format\/ogip.py:            p[0] = 'DIVISION'\nastropy\/units\/format\/ogip.py:            p[0] = 'PRODUCT'\nastropy\/cosmology\/tests\/test_pickle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/ogip_parsetab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/ogip_parsetab.py:# This file is automatically generated. Do not edit.\nastropy\/units\/format\/ogip_parsetab.py:_lr_signature = '6AD6E7286443B59D7DF329E6378BFC6B'\nastropy\/units\/format\/ogip_parsetab.py:_lr_action_items = {'UINT':([0,2,7,9,18,22,23,28,31,32,35,37,40,42,59,60,63,],[-38,19,-20,33,-21,39,-29,39,-23,39,39,-22,-38,-37,39,39,66,]),'WHITESPACE':([0,3,4,6,7,8,12,13,15,17,18,19,20,21,25,29,36,39,41,43,44,46,47,48,49,51,52,53,54,56,61,62,64,65,67,],[1,-30,24,29,31,-16,1,-17,-6,-10,37,-40,-41,1,45,1,-7,-32,-33,-31,57,-8,-9,-19,58,-15,-12,-18,-11,1,-34,-35,-14,-13,-36,]),'CLOSE_PAREN':([3,4,15,17,19,20,33,34,36,38,39,41,43,46,47,52,54,55,56,61,62,64,65,66,67,],[-30,-5,-6,-10,-40,-41,-39,52,-7,54,-32,-33,-31,-8,-9,-12,-11,61,62,-34,-35,-14,-13,67,-36,]),'OPEN_PAREN':([0,3,6,7,8,12,13,16,18,19,20,21,22,23,24,25,26,27,28,29,31,32,35,37,39,41,44,45,48,49,51,53,57,58,59,60,61,62,67,],[12,21,12,-20,-16,12,-17,12,-21,-40,-41,12,40,-29,-24,-25,12,12,40,12,-23,40,40,-22,-32,-33,-26,-28,-19,-20,-15,-18,-27,-22,40,40,-34,-35,-36,]),'UNIT':([0,6,7,8,12,13,16,18,19,20,21,24,25,26,27,29,31,37,39,41,44,45,48,49,51,53,57,58,61,62,67,],[3,3,-20,-16,3,-17,3,-21,-40,-41,3,-24,-25,3,3,3,-23,-22,-32,-33,-26,-28,-19,-20,-15,-18,-27,-22,-34,-35,-36,]),'UFLOAT':([0,2,9,22,23,28,32,35,40,42,59,60,],[-38,20,-37,-38,-29,-38,-38,-38,-38,-37,-38,-38,]),'SIGN':([0,22,23,28,32,35,40,59,60,],[9,42,-29,42,42,42,9,42,42,]),'DIVISION':([0,1,3,4,6,8,12,13,15,17,19,20,21,24,29,36,39,41,43,46,47,48,51,52,53,54,56,61,62,64,65,67,],[7,18,-30,7,7,-16,7,-17,-6,-10,-40,-41,7,18,49,-7,-32,-33,-31,-8,-9,-19,-15,-12,-18,-11,7,-34,-35,-14,-13,-36,]),'$end':([3,4,10,11,14,15,17,19,20,30,36,39,41,43,46,47,50,52,54,61,62,64,65,67,],[-30,-5,-1,-2,0,-6,-10,-40,-41,-3,-7,-32,-33,-31,-8,-9,-4,-12,-11,-34,-35,-14,-13,-36,]),'STARSTAR':([3,5,8,13,19,20,33,52,54,],[23,23,23,23,-40,-41,-39,23,23,]),'LIT10':([0,],[8,]),'STAR':([3,4,15,17,19,20,24,36,39,41,43,46,47,52,54,61,62,64,65,67,],[-30,25,-6,-10,-40,-41,44,-7,-32,-33,-31,-8,-9,-12,-11,-34,-35,-14,-13,-36,]),'UNKNOWN':([0,],[10,]),}\nastropy\/units\/format\/ogip_parsetab.py:  ('division -> DIVISION','division',1,'p_division','ogip.py',282),\nastropy\/units\/format\/ogip_parsetab.py:  ('division -> WHITESPACE DIVISION','division',2,'p_division','ogip.py',283),\nastropy\/units\/format\/ogip_parsetab.py:  ('division -> WHITESPACE DIVISION WHITESPACE','division',3,'p_division','ogip.py',284),\nastropy\/units\/format\/ogip_parsetab.py:  ('division -> DIVISION WHITESPACE','division',2,'p_division','ogip.py',285),\nastropy\/units\/format\/vounit.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/vounit.py:    <http:\/\/www.ivoa.net\/Documents\/VOUnits\/>`_.\nastropy\/units\/format\/vounit.py:            'A', 'C', 'D', 'F', 'G', 'H', 'Hz', 'J', 'Jy', 'K', 'N',\nastropy\/cosmology\/funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/funcs.py:      are trying to invert! Depending on the cosmology, there may not\nastropy\/cosmology\/funcs.py:      be a unique solution. For example, in the standard Lambda CDM\nastropy\/cosmology\/funcs.py:    >>> Dvals = (24 + np.random.rand(1e6) * 20) * u.mag\nastropy\/cosmology\/funcs.py:    >>> zmin = z_at_value(Planck13.distmod, Dvals.min())\nastropy\/cosmology\/funcs.py:    >>> zmax = z_at_value(Planck13.distmod, Dvals.max())\nastropy\/cosmology\/funcs.py:    >>> Dgrid = Planck13.distmod(zgrid)\nastropy\/cosmology\/funcs.py:    >>> zvals = np.interp(Dvals.value, zgrid, Dgrid.value)\nastropy\/cosmology\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/core.py:__all__ = [\"FLRW\", \"LambdaCDM\", \"FlatLambdaCDM\", \"wCDM\", \"FlatwCDM\",\nastropy\/cosmology\/core.py:           \"Flatw0waCDM\", \"w0waCDM\", \"wpwaCDM\", \"w0wzCDM\",\nastropy\/cosmology\/core.py:    subclasses such as `LambdaCDM` or `wCDM`.\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:                # FD vs. BE statistics.\nastropy\/cosmology\/core.py:        \"\"\" Does this cosmology have at least one massive neutrino species?\"\"\"\nastropy\/cosmology\/core.py:        \"\"\" Dimensionless Hubble constant: h = H_0 \/ 100 [km\/sec\/Mpc]\"\"\"\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:        the current concordance lambda CDM model).\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:        concordance lambda CDM model).\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:        \"\"\" Distance modulus at redshift ``z``.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Distance modulus at each input redshift, in magnitudes\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:        \"\"\"Differential comoving volume at redshift z.\nastropy\/cosmology\/core.py:          Differential comoving volume per redshift per steradian at\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:class LambdaCDM(FLRW):\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import LambdaCDM\nastropy\/cosmology\/core.py:    >>> cosmo = LambdaCDM(H0=70, Om0=0.3, Ode0=0.7)\nastropy\/cosmology\/core.py:class FlatLambdaCDM(LambdaCDM):\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import FlatLambdaCDM\nastropy\/cosmology\/core.py:    >>> cosmo = FlatLambdaCDM(H0=70, Om0=0.3)\nastropy\/cosmology\/core.py:        LambdaCDM.__init__(self, H0, Om0, 0.0, Tcmb0, Neff, m_nu, name=name,\nastropy\/cosmology\/core.py:        # Do some twiddling after the fact to get flatness\nastropy\/cosmology\/core.py:class wCDM(FLRW):\nastropy\/cosmology\/core.py:        Dark energy equation of state at all redshifts. This is\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import wCDM\nastropy\/cosmology\/core.py:    >>> cosmo = wCDM(H0=70, Om0=0.3, Ode0=0.7, w0=-0.9)\nastropy\/cosmology\/core.py:        \"\"\" Dark energy equation of state\"\"\"\nastropy\/cosmology\/core.py:class FlatwCDM(wCDM):\nastropy\/cosmology\/core.py:        Dark energy equation of state at all redshifts. This is\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import FlatwCDM\nastropy\/cosmology\/core.py:    >>> cosmo = FlatwCDM(H0=70, Om0=0.3, w0=-0.9)\nastropy\/cosmology\/core.py:        wCDM.__init__(self, H0, Om0, 0.0, w0, Tcmb0, Neff, m_nu,\nastropy\/cosmology\/core.py:        # Do some twiddling after the fact to get flatness\nastropy\/cosmology\/core.py:class w0waCDM(FLRW):\nastropy\/cosmology\/core.py:    D10, 213 (2001) and Linder PRL 90, 91301 (2003):\nastropy\/cosmology\/core.py:        Dark energy equation of state at z=0 (a=1). This is pressure\/density\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import w0waCDM\nastropy\/cosmology\/core.py:    >>> cosmo = w0waCDM(H0=70, Om0=0.3, Ode0=0.7, w0=-0.9, wa=0.2)\nastropy\/cosmology\/core.py:        \"\"\" Dark energy equation of state at z=0\"\"\"\nastropy\/cosmology\/core.py:class Flatw0waCDM(w0waCDM):\nastropy\/cosmology\/core.py:    D10, 213 (2001) and Linder PRL 90, 91301 (2003):\nastropy\/cosmology\/core.py:        Dark energy equation of state at z=0 (a=1). This is pressure\/density\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import Flatw0waCDM\nastropy\/cosmology\/core.py:    >>> cosmo = Flatw0waCDM(H0=70, Om0=0.3, w0=-0.9, wa=0.2)\nastropy\/cosmology\/core.py:        w0waCDM.__init__(self, H0, Om0, 0.0, w0=w0, wa=wa, Tcmb0=Tcmb0,\nastropy\/cosmology\/core.py:        # Do some twiddling after the fact to get flatness\nastropy\/cosmology\/core.py:class wpwaCDM(FLRW):\nastropy\/cosmology\/core.py:    D10, 213 (2001) and Linder PRL 90, 91301 (2003), but modified\nastropy\/cosmology\/core.py:    to have a pivot redshift as in the findings of the Dark Energy\nastropy\/cosmology\/core.py:        Dark energy equation of state at the pivot redshift zp. This is\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import wpwaCDM\nastropy\/cosmology\/core.py:    >>> cosmo = wpwaCDM(H0=70, Om0=0.3, Ode0=0.7, wp=-0.9, wa=0.2, zp=0.4)\nastropy\/cosmology\/core.py:        \"\"\" Dark energy equation of state at the pivot redshift zp\"\"\"\nastropy\/cosmology\/core.py:class w0wzCDM(FLRW):\nastropy\/cosmology\/core.py:        Dark energy equation of state at z=0. This is pressure\/density for\nastropy\/cosmology\/core.py:        Derivative of the dark energy equation of state with respect to z.\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import w0wzCDM\nastropy\/cosmology\/core.py:    >>> cosmo = w0wzCDM(H0=70, Om0=0.3, Ode0=0.7, w0=-0.9, wz=0.2)\nastropy\/cosmology\/core.py:        \"\"\" Dark energy equation of state at z=0\"\"\"\nastropy\/cosmology\/core.py:        \"\"\" Derivative of the dark energy equation of state w.r.t. z\"\"\"\nastropy\/cosmology\/core.py:# parameters module and creates a LambdaCDM or FlatLambdaCDM instance\nastropy\/cosmology\/core.py:# Note this assumes all the cosmologies in parameters are LambdaCDM,\nastropy\/cosmology\/core.py:        cosmo = FlatLambdaCDM(par['H0'], par['Om0'], Tcmb0=par['Tcmb0'],\nastropy\/cosmology\/core.py:        docstr = \"{} instance of FlatLambdaCDM cosmology\\n\\n(from {})\"\nastropy\/cosmology\/core.py:        cosmo = LambdaCDM(par['H0'], par['Om0'], par['Ode0'],\nastropy\/cosmology\/core.py:        docstr = \"{} instance of LambdaCDM cosmology\\n\\n(from {})\"\nastropy\/cosmology\/tests\/test_cosmology.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=-0.27)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27, Neff=-1)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27,\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=h0bad, Om0=0.27)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.2, Tcmb0=3, m_nu=0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.2, Tcmb0=3, m_nu=bad_mnu)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.2, Tcmb0=3, Neff=2, m_nu=bad_mnu)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.2, Tcmb0=3, m_nu=bad_mnu)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27, Ob0=-0.04)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27, Ob0=0.4)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27, Tcmb0=2.0, Neff=3.04,\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=H0, Om0=0.27, Tcmb0=T, Neff=3.04, Ob0=0.05)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27, Tcmb0=2.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27,\nastropy\/cosmology\/tests\/test_cosmology.py:    for tcosmo in [core.LambdaCDM(H0=70, Om0=0.27, Ode0=0.5),\nastropy\/cosmology\/tests\/test_cosmology.py:                   core.wCDM(H0=70, Om0=0.27, Ode0=0.5, w0=-1.2),\nastropy\/cosmology\/tests\/test_cosmology.py:                   core.w0waCDM(H0=70, Om0=0.27, Ode0=0.5, w0=-1.2, wa=-0.2),\nastropy\/cosmology\/tests\/test_cosmology.py:                   core.wpwaCDM(H0=70, Om0=0.27, Ode0=0.5,\nastropy\/cosmology\/tests\/test_cosmology.py:                   core.w0wzCDM(H0=70, Om0=0.27, Ode0=0.5, w0=-1.2, wz=0.1)]:\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70 * u.km \/ u.s \/ u.Mpc, Om0=0.27,\nastropy\/cosmology\/tests\/test_cosmology.py:    cmp = core.FlatLambdaCDM(H0=60 * u.km \/ u.s \/ u.Mpc, Om0=0.27,\nastropy\/cosmology\/tests\/test_cosmology.py:    cmp = core.FlatLambdaCDM(name=\"New name\", H0=65 * u.km \/ u.s \/ u.Mpc,\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(name=\"test w0wa\", H0=70 * u.km \/ u.s \/ u.Mpc,\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(70, 0.3, 0.5, Tcmb0=2.725)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(70, 0.3, 0.5, Tcmb0=2.725)\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('LambdaCDM(H0=70 km \/ (Mpc s), Om0=0.3, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(70, 0.3, 0.5, Tcmb0=2.725, m_nu=u.Quantity(0.01, u.eV))\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('LambdaCDM(H0=70 km \/ (Mpc s), Om0=0.3, Ode0=0.5, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(50.0, 0.27, Tcmb0=3, Ob0=0.05)\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('FlatLambdaCDM(H0=50 km \/ (Mpc s), Om0=0.27, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wCDM(60.0, 0.27, 0.6, Tcmb0=2.725, w0=-0.8, name='test1')\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('wCDM(name=\"test1\", H0=60 km \/ (Mpc s), Om0=0.27, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatwCDM(65.0, 0.27, w0=-0.6, name='test2')\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('FlatwCDM(name=\"test2\", H0=65 km \/ (Mpc s), Om0=0.27, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(60.0, 0.25, 0.4, w0=-0.6, Tcmb0=2.725, wa=0.1, name='test3')\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('w0waCDM(name=\"test3\", H0=60 km \/ (Mpc s), Om0=0.25, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.Flatw0waCDM(55.0, 0.35, w0=-0.9, wa=-0.2, name='test4',\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('Flatw0waCDM(name=\"test4\", H0=55 km \/ (Mpc s), Om0=0.35, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wpwaCDM(50.0, 0.3, 0.3, wp=-0.9, wa=-0.2,\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('wpwaCDM(name=\"test5\", H0=50 km \/ (Mpc s), Om0=0.3, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0wzCDM(55.0, 0.4, 0.8, w0=-1.05, wz=-0.2, Tcmb0=2.725,\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('w0wzCDM(H0=55 km \/ (Mpc s), Om0=0.4, Ode0=0.8, w0=-1.05, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=70, Om0=0.27, Ode0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=70, Om0=0.27, Ode0=0.73, Ob0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wCDM(H0=70, Om0=0.27, Ode0=0.73, w0=-0.9, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(H0=70, Om0=0.2, Ode0=0.8, w0=-1.1, wa=0.2, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(H0=70, Om0=0.3, Ode0=0.7, w0=-0.9, wa=0.0, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(H0=70, Om0=0.3, Ode0=0.7, w0=-0.9, wa=-0.5,\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wpwaCDM(H0=70, Om0=0.2, Ode0=0.8, wp=-1.1, wa=0.2, zp=0.5,\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wpwaCDM(H0=70, Om0=0.2, Ode0=0.8, wp=-1.1, wa=0.2, zp=0.9,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.0, 0.3, Ob0=0.045)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.0, 0.3)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.LambdaCDM(70.0, 0.3, 0.5, Tcmb0=u.Quantity(0.0, u.K))\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.0, 0.3, Tcmb0=0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.3, Tcmb0=0, Neff=3)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.3, Tcmb0=2.725, Neff=3)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.3, Tcmb0=4.0, Neff=3)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.3, Tcmb0=0, Neff=3.04)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.3, Tcmb0=2.725, Neff=3.04)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.3, Tcmb0=4.0, Neff=3.04)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=Om0, Tcmb0=2.725, Neff=3.04)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=Om0, Tcmb0=4.0, Neff=3.04)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=2.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=3.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(70, 0.3, 0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(70, 0.3, 0.5, m_nu=u.Quantity(0.01, u.eV))\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(50.0, 0.27)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wCDM(60.0, 0.27, 0.6, w0=-0.8)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatwCDM(65.0, 0.27, w0=-0.6)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(60.0, 0.25, 0.4, w0=-0.6, wa=0.1)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.Flatw0waCDM(55.0, 0.35, w0=-0.9, wa=-0.2)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wpwaCDM(50.0, 0.3, 0.3, wp=-0.9, wa=-0.2, zp=0.3)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0wzCDM(55.0, 0.4, 0.8, w0=-1.05, wz=-0.2)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    c_flat = core.LambdaCDM(H0=70, Om0=0.27, Ode0=0.73, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    c_open = core.LambdaCDM(H0=70, Om0=0.27, Ode0=0.0, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    c_closed = core.LambdaCDM(H0=70, Om0=2, Ode0=0.0, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    c_flat = core.LambdaCDM(H0=70, Om0=0.27, Ode0=0.73, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    c_open = core.LambdaCDM(H0=70, Om0=0.27, Ode0=0.0, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    c_closed = core.LambdaCDM(H0=70, Om0=2, Ode0=0.0, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=70, Om0=0.3, Ode0=0.70, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=70, Om0=0.3, Ode0=0.1, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=70, Om0=2, Ode0=0.1, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=73.2, Om0=0.3, Ode0=0.50)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=70, Om0=0.3, Ode0=0.70)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wCDM(H0=70, Om0=0.3, Ode0=0.70, w0=-0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0wzCDM(H0=70, Om0=0.3, Ode0=0.70, w0=-1, wz=0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(H0=70, Om0=0.3, Ode0=0.70, w0=-1, wa=-0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wpwaCDM(H0=70, Om0=0.3, Ode0=0.70, wp=-0.9,\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=70, Om0=0.3, Ode0=0.70)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wCDM(H0=70, Om0=0.3, Ode0=0.60, w0=-0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0wzCDM(H0=70, Om0=0.3, Ode0=0.50, w0=-1, wz=0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(H0=70, Om0=0.3, Ode0=0.70, w0=-1, wa=-0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wpwaCDM(H0=70, Om0=0.3, Ode0=0.70, wp=-0.9,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=3.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=3.0,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.LambdaCDM(70, 0.2, 1.3, Tcmb0=0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.LambdaCDM(100, 0.3, 0.8, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(100, 0.3, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    # http:\/\/www.astro.multivax.de:8000\/phillip\/angsiz_prog\/README.HTML\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.LambdaCDM(100, 0.3, 0.5, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.LambdaCDM(100, 1.0, 0.2, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.LambdaCDM(H0=70.4, Om0=0.2, Ode0=0.5, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.LambdaCDM(H0=100, Om0=2, Ode0=1, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Neff=4.05,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=0 * u.K,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=2.725 * u.K,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=2.725,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.LambdaCDM(75.0, 0.25, 0.5, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.LambdaCDM(75.0, 0.25, 0.6, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.LambdaCDM(75.0, 0.3, 0.4, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatwCDM(75.0, 0.25, w0=-1.05, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatwCDM(75.0, 0.25, w0=-0.95, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatwCDM(75.0, 0.25, w0=-0.9, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.wCDM(75.0, 0.25, 0.4, w0=-0.9, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.wCDM(75.0, 0.25, 0.4, w0=-1.1, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.wCDM(75.0, 0.25, 0.4, w0=-0.9, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.w0waCDM(75.0, 0.3, 0.6, w0=-0.9, wa=0.1, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.w0waCDM(75.0, 0.25, 0.5, w0=-0.9, wa=0.1, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.w0waCDM(75.0, 0.25, 0.5, w0=-0.9, wa=0.1, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.Flatw0waCDM(75.0, 0.25, w0=-0.95, wa=0.15, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.Flatw0waCDM(75.0, 0.25, w0=-0.95, wa=0.15, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.Flatw0waCDM(75.0, 0.25, w0=-0.95, wa=0.15, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.wpwaCDM(75.0, 0.3, 0.6, wp=-0.9, zp=0.5, wa=0.1, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.wpwaCDM(75.0, 0.25, 0.5, wp=-0.9, zp=0.4, wa=0.1,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.wpwaCDM(75.0, 0.25, 0.5, wp=-0.9, zp=1.0, wa=0.1, Tcmb0=3.0,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.w0wzCDM(75.0, 0.3, 0.6, w0=-0.9, wz=0.1, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.w0wzCDM(75.0, 0.25, 0.5, w0=-0.9, wz=0.1,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.w0wzCDM(75.0, 0.25, 0.5, w0=-0.9, wz=0.1, Tcmb0=3.0,\nastropy\/cosmology\/tests\/test_cosmology.py:    # for FlatLambdaCDM to give the scalar nu density functions a\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0, Neff=4.2,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(80.0, 0.30, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(80.0, 0.30, Tcmb0=3.0, Neff=3.04,\nastropy\/units\/format\/console.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nddata_withmixins.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nddata_withmixins.py:This module implements a class based on NDData with all Mixins.\nastropy\/nddata\/nddata_withmixins.py:from .nddata import NDData\nastropy\/nddata\/nddata_withmixins.py:from .mixins.ndslicing import NDSlicingMixin\nastropy\/nddata\/nddata_withmixins.py:from .mixins.ndarithmetic import NDArithmeticMixin\nastropy\/nddata\/nddata_withmixins.py:from .mixins.ndio import NDIOMixin\nastropy\/nddata\/nddata_withmixins.py:__all__ = ['NDDataRef']\nastropy\/nddata\/nddata_withmixins.py:class NDDataRef(NDArithmeticMixin, NDIOMixin, NDSlicingMixin, NDData):\nastropy\/nddata\/nddata_withmixins.py:    \"\"\"Implements `NDData` with all Mixins.\nastropy\/nddata\/nddata_withmixins.py:    This class implements a `NDData`-like container that supports reading and\nastropy\/nddata\/nddata_withmixins.py:    A key distinction from `NDDataArray` is that this class does not attempt\nastropy\/nddata\/nddata_withmixins.py:    NDData\nastropy\/nddata\/nddata_withmixins.py:    NDArithmeticMixin\nastropy\/nddata\/nddata_withmixins.py:    NDSlicingMixin\nastropy\/nddata\/nddata_withmixins.py:    NDIOMixin\nastropy\/nddata\/nddata_withmixins.py:    The mixins allow operation that are not possible with `NDData` or\nastropy\/nddata\/nddata_withmixins.py:    `NDDataBase`, i.e. simple arithmetics::\nastropy\/nddata\/nddata_withmixins.py:        >>> from astropy.nddata import NDDataRef, StdDevUncertainty\nastropy\/nddata\/nddata_withmixins.py:        >>> ndd1 = NDDataRef(data, uncertainty=StdDevUncertainty(data))\nastropy\/nddata\/nddata_withmixins.py:        >>> ndd2 = NDDataRef(data, uncertainty=StdDevUncertainty(data))\nastropy\/nddata\/nddata_withmixins.py:    see `NDArithmeticMixin` for a complete list of all supported arithmetic\nastropy\/nddata\/nddata_withmixins.py:    See `NDSlicingMixin` for a description how slicing works (which attributes)\nastropy\/nddata\/compat.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/compat.py:# This module contains a class equivalent to pre-1.0 NDData.\nastropy\/nddata\/compat.py:from .nddata import NDData\nastropy\/nddata\/compat.py:from .nduncertainty import NDUncertainty\nastropy\/nddata\/compat.py:from .mixins.ndslicing import NDSlicingMixin\nastropy\/nddata\/compat.py:from .mixins.ndarithmetic import NDArithmeticMixin\nastropy\/nddata\/compat.py:from .mixins.ndio import NDIOMixin\nastropy\/nddata\/compat.py:__all__ = ['NDDataArray']\nastropy\/nddata\/compat.py:class NDDataArray(NDArithmeticMixin, NDSlicingMixin, NDIOMixin, NDData):\nastropy\/nddata\/compat.py:    An ``NDData`` object with arithmetic. This class is functionally equivalent\nastropy\/nddata\/compat.py:    to ``NDData`` in astropy  versions prior to 1.0.\nastropy\/nddata\/compat.py:    data : `~numpy.ndarray` or `NDData`\nastropy\/nddata\/compat.py:        The actual data contained in this `NDData` object. Not that this\nastropy\/nddata\/compat.py:    uncertainty : `~astropy.nddata.NDUncertainty`, optional\nastropy\/nddata\/compat.py:        # setter logic below. In base NDData all that is done is to\nastropy\/nddata\/compat.py:        # Initial flags because it is no longer handled in NDData\nastropy\/nddata\/compat.py:        # or NDDataBase.\nastropy\/nddata\/compat.py:        if isinstance(data, NDDataArray):\nastropy\/nddata\/compat.py:                log.info(\"Overwriting NDDataArrays's current \"\nastropy\/nddata\/compat.py:    # Implement uncertainty as NDUncertainty to support propagation of\nastropy\/nddata\/compat.py:            if isinstance(value, NDUncertainty):\nastropy\/nddata\/compat.py:                                \"a NDUncertainty object\")\nastropy\/nddata\/compat.py:        This allows code that requests a Numpy array to use an NDData\nastropy\/nddata\/compat.py:        Returns a new `NDData` object whose values have been converted\nastropy\/nddata\/compat.py:        result : `~astropy.nddata.NDData`\nastropy\/units\/format\/cds.py:# Licensed under a 3-clause BSD style license - see LICNSE.rst\nastropy\/units\/format\/cds.py:Handles the CDS string format for units\nastropy\/units\/format\/cds.py:# TODO: Support logarithmic units using bracketed syntax\nastropy\/units\/format\/cds.py:class CDS(Base):\nastropy\/units\/format\/cds.py:    Support the `Centre de Donn\u00e9es astronomiques de Strasbourg\nastropy\/units\/format\/cds.py:        'PRODUCT',\nastropy\/units\/format\/cds.py:        'DIVISION',\nastropy\/units\/format\/cds.py:        t_PRODUCT = r'\\.'\nastropy\/units\/format\/cds.py:        t_DIVISION = r'\/'\nastropy\/units\/format\/cds.py:        # NOTE THE ORDERING OF THESE RULES IS IMPORTANT!!\nastropy\/units\/format\/cds.py:                        reflags=re.UNICODE)\nastropy\/units\/format\/cds.py:            product_of_units : unit_expression PRODUCT combined_units\nastropy\/units\/format\/cds.py:            division_of_units : DIVISION unit_expression\nastropy\/units\/format\/cds.py:                              | unit_expression DIVISION combined_units\nastropy\/units\/format\/cds.py:                        \"Only base ten exponents are allowed in CDS\")\nastropy\/units\/format\/cds.py:                        \"Only base ten exponents are allowed in CDS\")\nastropy\/units\/format\/cds.py:                    \"Unit '{0}' not supported by the CDS SAC \"\nastropy\/units\/format\/cds.py:            raise ValueError('CDS unit must not contain whitespace')\nastropy\/units\/format\/cds_lextab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/cds_lextab.py:_lextokens    = set(('UINT', 'PRODUCT', 'OPEN_PAREN', 'UNIT', 'SIGN', 'UFLOAT', 'DIVISION', 'CLOSE_PAREN', 'X'))\nastropy\/units\/format\/cds_lextab.py:_lexstatere   = {'INITIAL': [('(?P<t_UFLOAT>((\\\\d+\\\\.?\\\\d+)|(\\\\.\\\\d+))([eE][+-]?\\\\d+)?)|(?P<t_UINT>\\\\d+)|(?P<t_SIGN>[+-](?=\\\\d))|(?P<t_X>[x\u00d7])|(?P<t_UNIT>\\\\%|\u00b0|\\\\\\\\h|((?!\\\\d)\\\\w)+)|(?P<t_CLOSE_PAREN>\\\\))|(?P<t_OPEN_PAREN>\\\\()|(?P<t_PRODUCT>\\\\.)|(?P<t_DIVISION>\/)', [None, ('t_UFLOAT', 'UFLOAT'), None, None, None, None, ('t_UINT', 'UINT'), ('t_SIGN', 'SIGN'), ('t_X', 'X'), ('t_UNIT', 'UNIT'), None, (None, 'CLOSE_PAREN'), (None, 'OPEN_PAREN'), (None, 'PRODUCT'), (None, 'DIVISION')])]}\nastropy\/nddata\/nduncertainty.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nduncertainty.py:__all__ = ['MissingDataAssociationException',\nastropy\/nddata\/nduncertainty.py:           'IncompatibleUncertaintiesException', 'NDUncertainty',\nastropy\/nddata\/nduncertainty.py:           'StdDevUncertainty', 'UnknownUncertainty']\nastropy\/nddata\/nduncertainty.py:class MissingDataAssociationException(Exception):\nastropy\/nddata\/nduncertainty.py:    has not been associated with a parent `~astropy.nddata.NDData` object.\nastropy\/nddata\/nduncertainty.py:class NDUncertainty(metaclass=ABCMeta):\nastropy\/nddata\/nduncertainty.py:    \"\"\"This is the metaclass for uncertainty classes used with `NDData`.\nastropy\/nddata\/nduncertainty.py:        `NDUncertainty` subclasses are recommended.\nastropy\/nddata\/nduncertainty.py:        Default is ``None``.\nastropy\/nddata\/nduncertainty.py:        Default is ``None``.\nastropy\/nddata\/nduncertainty.py:        Default is ``True``.\nastropy\/nddata\/nduncertainty.py:        If given another `NDUncertainty`-like class as ``array`` if their\nastropy\/nddata\/nduncertainty.py:        if isinstance(array, NDUncertainty):\nastropy\/nddata\/nduncertainty.py:            # Given an NDUncertainty class or subclass check that the type\nastropy\/nddata\/nduncertainty.py:                # TODO : Clarify it (see NDData.init for same problem)?\nastropy\/nddata\/nduncertainty.py:        self.parent_nddata = None  # no associated NDData - until it is set!\nastropy\/nddata\/nduncertainty.py:        Defined as abstract property so subclasses *have* to override this.\nastropy\/nddata\/nduncertainty.py:        \"\"\"`NDData` : reference to `NDData` instance with this uncertainty.\nastropy\/nddata\/nduncertainty.py:        message = \"uncertainty is not associated with an NDData object\"\nastropy\/nddata\/nduncertainty.py:                raise MissingDataAssociationException(message)\nastropy\/nddata\/nduncertainty.py:                # The NDData is saved as weak reference so we must call it\nastropy\/nddata\/nduncertainty.py:                    log.info(\"parent_nddata should be a weakref to an NDData \"\nastropy\/nddata\/nduncertainty.py:            raise MissingDataAssociationException(message)\nastropy\/nddata\/nduncertainty.py:            # instance of NDData. Direct references should NOT be used:\nastropy\/nddata\/nduncertainty.py:            The operation that is performed on the `NDData`. Supported are\nastropy\/nddata\/nduncertainty.py:        other_nddata : `NDData` instance\nastropy\/nddata\/nduncertainty.py:        resulting_uncertainty : `NDUncertainty` instance\nastropy\/nddata\/nduncertainty.py:            Another instance of the same `NDUncertainty` subclass containing\nastropy\/nddata\/nduncertainty.py:        Checks if the other uncertainty is `NDUncertainty`-like and if so\nastropy\/nddata\/nduncertainty.py:        other_uncert : `NDUncertainty` subclass\nastropy\/nddata\/nduncertainty.py:        other_uncert : `NDUncertainty` subclass\nastropy\/nddata\/nduncertainty.py:            but converted to a compatible `NDUncertainty` subclass if\nastropy\/nddata\/nduncertainty.py:            `NDUncertainty` subclass.\nastropy\/nddata\/nduncertainty.py:        if isinstance(other_uncert, NDUncertainty):\nastropy\/nddata\/nduncertainty.py:class UnknownUncertainty(NDUncertainty):\nastropy\/nddata\/nduncertainty.py:        see `NDUncertainty`\nastropy\/nddata\/nduncertainty.py:class StdDevUncertainty(NDUncertainty):\nastropy\/nddata\/nduncertainty.py:    of `StdDevUncertainty`. The class can handle if the uncertainty has a\nastropy\/nddata\/nduncertainty.py:    unit that differs from (but is convertible to) the parents `NDData` unit.\nastropy\/nddata\/nduncertainty.py:        see `NDUncertainty`\nastropy\/nddata\/nduncertainty.py:    `StdDevUncertainty` should always be associated with an `NDData`-like\nastropy\/nddata\/nduncertainty.py:        >>> from astropy.nddata import NDData, StdDevUncertainty\nastropy\/nddata\/nduncertainty.py:        >>> ndd = NDData([1,2,3],\nastropy\/nddata\/nduncertainty.py:        ...              uncertainty=StdDevUncertainty([0.1, 0.1, 0.1]))\nastropy\/nddata\/nduncertainty.py:        StdDevUncertainty([0.1, 0.1, 0.1])\nastropy\/nddata\/nduncertainty.py:    or by setting it manually on the `NDData` instance::\nastropy\/nddata\/nduncertainty.py:        >>> ndd.uncertainty = StdDevUncertainty([0.2], unit='m', copy=True)\nastropy\/nddata\/nduncertainty.py:        StdDevUncertainty([0.2])\nastropy\/nddata\/nduncertainty.py:        StdDevUncertainty(2)\nastropy\/nddata\/nduncertainty.py:        \"\"\"`True` : `StdDevUncertainty` allows to propagate correlated \\\nastropy\/nddata\/nduncertainty.py:        \"\"\"``\"std\"`` : `StdDevUncertainty` implements standard deviation.\nastropy\/nddata\/nduncertainty.py:        if isinstance(other_uncert, StdDevUncertainty):\nastropy\/nddata\/nduncertainty.py:            # Determine the result depending on the correlation\nastropy\/units\/format\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/unicode_format.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/base.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/base.py:from ...utils.misc import InheritDocstrings\nastropy\/units\/format\/base.py:class _FormatterMeta(InheritDocstrings):\nastropy\/nddata\/tests\/test_decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_decorators.py:from ..nddata import NDData\nastropy\/nddata\/tests\/test_decorators.py:class CCDData(NDData):\nastropy\/nddata\/tests\/test_decorators.py:    nddata_in = NDData(data_in, wcs=wcs_in, unit=unit_in)\nastropy\/nddata\/tests\/test_decorators.py:    nddata_in = NDData(data_in, wcs=wcs_in, unit=unit_in)\nastropy\/nddata\/tests\/test_decorators.py:                                 \"an NDData property, using explicitly specified value\")\nastropy\/nddata\/tests\/test_decorators.py:    nddata_in = NDData(data_in, wcs=wcs_in, unit=unit_in, mask=[0, 1, 0])\nastropy\/nddata\/tests\/test_decorators.py:    nddata_in = NDData(data_in)\nastropy\/nddata\/tests\/test_decorators.py:    nddata_in = NDData(data_in)\nastropy\/nddata\/tests\/test_decorators.py:    assert isinstance(nddata_out, NDData)\nastropy\/nddata\/tests\/test_decorators.py:    class MyData(NDData):\nastropy\/nddata\/tests\/test_decorators.py:    @support_nddata(accepts=MyData)\nastropy\/nddata\/tests\/test_decorators.py:    nddata_in = NDData(data_in)\nastropy\/nddata\/tests\/test_decorators.py:    mydata_in = MyData(data_in)\nastropy\/nddata\/tests\/test_decorators.py:    assert exc.value.args[0] == \"Only NDData sub-classes that inherit from MyData can be used by this function\"\nastropy\/nddata\/tests\/test_decorators.py:    # accepts CCDData but was given just an NDData\nastropy\/nddata\/tests\/test_decorators.py:        @support_nddata(accepts=CCDData)\nastropy\/nddata\/tests\/test_decorators.py:        test(NDData(np.ones((3, 3))))\nastropy\/nddata\/tests\/test_decorators.py:    # NDData here so we don't get into troubles when creating a CCDData without\nastropy\/nddata\/tests\/test_decorators.py:        test(NDData(np.ones((3, 3))))  # do NOT use CCDData here.\nastropy\/nddata\/tests\/test_decorators.py:    assert isinstance(test(NDData(np.ones((3, 3)))), NDData)\nastropy\/nddata\/tests\/test_decorators.py:    ndd = NDData(np.ones((3, 3)))\nastropy\/nddata\/tests\/test_decorators.py:        assert func(NDData(1, wcs=[1, 2]), [1, 2, 3]) == [1, 2, 3]\nastropy\/nddata\/tests\/test_decorators.py:        assert func(NDData(1, wcs=[1, 2])) == [1, 2]\nastropy\/nddata\/tests\/test_decorators.py:    # Accepts flags attribute but NDData doesn't have one\nastropy\/nddata\/tests\/test_decorators.py:    ndd = NDData(np.ones((3, 3)))\nastropy\/nddata\/tests\/test_decorators.py:    ndd = NDData(np.ones((3, 3)))\nastropy\/nddata\/tests\/test_decorators.py:    # Meta is always set (OrderedDict) so it has a special case that it's\nastropy\/nddata\/tests\/test_decorators.py:    ndd = NDData(np.ones((3, 3)))\nastropy\/units\/format\/generic_lextab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/generic_lextab.py:_lextokens    = set(('CARET', 'CLOSE_PAREN', 'SOLIDUS', 'FUNCNAME', 'UFLOAT', 'STAR', 'SIGN', 'UINT', 'DOUBLE_STAR', 'OPEN_PAREN', 'PERIOD', 'UNIT'))\nastropy\/units\/format\/generic_lextab.py:_lexstatere   = {'INITIAL': [(\"(?P<t_UFLOAT>((\\\\d+\\\\.?\\\\d*)|(\\\\.\\\\d+))([eE][+-]?\\\\d+)?)|(?P<t_UINT>\\\\d+)|(?P<t_SIGN>[+-](?=\\\\d))|(?P<t_FUNCNAME>((sqrt)|(ln)|(exp)|(log)|(mag)|(dB)|(dex))(?=\\\\ *\\\\())|(?P<t_UNIT>%|([YZEPTGMkhdcmunpfazy]?'((?!\\\\d)\\\\w)+')|((?!\\\\d)\\\\w)+)|(?P<t_DOUBLE_STAR>\\\\*\\\\*)|(?P<t_CLOSE_PAREN>\\\\))|(?P<t_STAR>\\\\*)|(?P<t_PERIOD>\\\\.)|(?P<t_OPEN_PAREN>\\\\()|(?P<t_CARET>\\\\^)|(?P<t_SOLIDUS>\/)\", [None, ('t_UFLOAT', 'UFLOAT'), None, None, None, None, ('t_UINT', 'UINT'), ('t_SIGN', 'SIGN'), ('t_FUNCNAME', 'FUNCNAME'), None, None, None, None, None, None, None, None, ('t_UNIT', 'UNIT'), None, None, None, (None, 'DOUBLE_STAR'), (None, 'CLOSE_PAREN'), (None, 'STAR'), (None, 'PERIOD'), (None, 'OPEN_PAREN'), (None, 'CARET'), (None, 'SOLIDUS')])]}\nastropy\/nddata\/tests\/test_compat.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_compat.py:# This module contains tests of a class equivalent to pre-1.0 NDData.\nastropy\/nddata\/tests\/test_compat.py:from ..nddata import NDData\nastropy\/nddata\/tests\/test_compat.py:from ..compat import NDDataArray\nastropy\/nddata\/tests\/test_compat.py:from ..nduncertainty import StdDevUncertainty\nastropy\/nddata\/tests\/test_compat.py:NDDATA_ATTRIBUTES = ['mask', 'flags', 'uncertainty', 'unit', 'shape', 'size',\nastropy\/nddata\/tests\/test_compat.py:    ndd = NDDataArray([1, 2, 3])\nastropy\/nddata\/tests\/test_compat.py:    for attr in NDDATA_ATTRIBUTES:\nastropy\/nddata\/tests\/test_compat.py:    nd = NDDataArray(np.zeros((10, 10)))\nastropy\/nddata\/tests\/test_compat.py:    nd = NDDataArray(data=np.zeros((10, 10)))\nastropy\/nddata\/tests\/test_compat.py:    nd = NDDataArray(meta={}, data=np.zeros((10, 10)))\nastropy\/nddata\/tests\/test_compat.py:    uncertainty = StdDevUncertainty(0.1 + np.zeros_like(data))\nastropy\/nddata\/tests\/test_compat.py:    nd = NDDataArray(data, uncertainty)\nastropy\/nddata\/tests\/test_compat.py:    nd = NDDataArray(np.array([[1, 2, 3], [4, 5, 6]]))\nastropy\/nddata\/tests\/test_compat.py:    ndd = NDDataArray([1, 1], flags=flags_in)\nastropy\/nddata\/tests\/test_compat.py:        NDDataArray(np.zeros((10, 10)), flags=np.ones(shape))\nastropy\/nddata\/tests\/test_compat.py:    d = NDDataArray(np.ones((5, 5)))\nastropy\/nddata\/tests\/test_compat.py:    d.uncertainty = StdDevUncertainty(0.1 + np.zeros_like(d))\nastropy\/nddata\/tests\/test_compat.py:    # and NDData accepts only bool ndarray as mask\nastropy\/nddata\/tests\/test_compat.py:class SubNDData(NDDataArray):\nastropy\/nddata\/tests\/test_compat.py:    Subclass for test initialization of subclasses in NDData._arithmetic and\nastropy\/nddata\/tests\/test_compat.py:    NDData.convert_unit_to\nastropy\/nddata\/tests\/test_compat.py:    arr1 = SubNDData(data, unit='m', wcs=5)\nastropy\/nddata\/tests\/test_compat.py:    ndd1 = NDDataArray([1., 4., 9.],\nastropy\/nddata\/tests\/test_compat.py:                       uncertainty=StdDevUncertainty([1., 2., 3.]),\nastropy\/nddata\/tests\/test_compat.py:    ndd2 = NDDataArray(ndd1)\nastropy\/nddata\/tests\/test_compat.py:    ndd1 = NDData([1., 4., 9.],\nastropy\/nddata\/tests\/test_compat.py:                  uncertainty=StdDevUncertainty([1., 2., 3.]))\nastropy\/nddata\/tests\/test_compat.py:    ndd2 = NDDataArray(ndd1)\nastropy\/units\/format\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/__init__.py:from .cds import CDS\nastropy\/units\/format\/__init__.py:    'Base', 'Generic', 'CDS', 'Console', 'Fits', 'Latex', 'LatexInline',\nastropy\/nddata\/flag_collection.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/flag_collection.py:from collections import OrderedDict\nastropy\/nddata\/flag_collection.py:class FlagCollection(OrderedDict):\nastropy\/nddata\/flag_collection.py:    containing arrays of flags for the `NDData` class. Flags should be\nastropy\/nddata\/flag_collection.py:    `~collections.OrderedDict`, but with the addition of a ``shape=``\nastropy\/nddata\/flag_collection.py:    keyword argument used to pass the NDData shape.\nastropy\/nddata\/flag_collection.py:        OrderedDict.__init__(self, *args, **kwargs)\nastropy\/nddata\/flag_collection.py:                OrderedDict.__setitem__(self, item, value, **kwargs)\nastropy\/nddata\/mixins\/ndslicing.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/ndslicing.py:# This module implements the Slicing mixin to the NDData class.\nastropy\/nddata\/mixins\/ndslicing.py:__all__ = ['NDSlicingMixin']\nastropy\/nddata\/mixins\/ndslicing.py:class NDSlicingMixin:\nastropy\/nddata\/mixins\/ndslicing.py:    \"\"\"Mixin to provide slicing on objects using the `NDData`\nastropy\/nddata\/mixins\/ndslicing.py:    Using this Mixin with `~astropy.nddata.NDData`:\nastropy\/nddata\/mixins\/ndslicing.py:        >>> from astropy.nddata import NDData, NDSlicingMixin\nastropy\/nddata\/mixins\/ndslicing.py:        >>> class NDDataSliceable(NDSlicingMixin, NDData):\nastropy\/nddata\/mixins\/ndslicing.py:        >>> nd = NDDataSliceable([1,2,3,4,5])\nastropy\/nddata\/mixins\/ndslicing.py:        NDDataSliceable([2, 3])\nastropy\/nddata\/mixins\/ndslicing.py:        >>> nd2 = NDDataSliceable(nd, mask=mask)\nastropy\/nddata\/mixins\/ndslicing.py:        NDDataSliceable([3])\nastropy\/nddata\/mixins\/ndslicing.py:        NDDataSliceable([  1, 100,   3,   4,   5])\nastropy\/nddata\/mixins\/ndslicing.py:    NDDataRef\nastropy\/nddata\/mixins\/ndslicing.py:    NDDataArray\nastropy\/units\/format\/latex.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/decorators.py:from .nddata import NDData\nastropy\/nddata\/decorators.py:SUPPORTED_PROPERTIES = ['data', 'uncertainty', 'mask', 'meta', 'unit', 'wcs',\nastropy\/nddata\/decorators.py:def support_nddata(_func=None, accepts=NDData,\nastropy\/nddata\/decorators.py:    \"\"\"Decorator to wrap functions that could accept an NDData instance with\nastropy\/nddata\/decorators.py:        Default is ``None``.\nastropy\/nddata\/decorators.py:        The class or subclass of ``NDData`` that should be unpacked before\nastropy\/nddata\/decorators.py:        Default is ``NDData``\nastropy\/nddata\/decorators.py:        Default is ``False``.\nastropy\/nddata\/decorators.py:        Default is ``None``.\nastropy\/nddata\/decorators.py:        Default is ``None``.\nastropy\/nddata\/decorators.py:    If properties of ``NDData`` are set but have no corresponding function\nastropy\/nddata\/decorators.py:    If a property is set of the ``NDData`` are set and an explicit argument is\nastropy\/nddata\/decorators.py:    However, you might have an NDData instance that has the ``wcs`` property\nastropy\/nddata\/decorators.py:    WCS separately, or an NDData instance can be passed to the ``data``\nastropy\/nddata\/decorators.py:            if param.kind in (param.VAR_POSITIONAL, param.VAR_KEYWORD):\nastropy\/nddata\/decorators.py:            if not unpack and isinstance(data, NDData):\nastropy\/nddata\/decorators.py:                raise TypeError(\"Only NDData sub-classes that inherit from {0}\"\nastropy\/nddata\/decorators.py:            # If data is an NDData instance, we can try and find properties\nastropy\/nddata\/decorators.py:                for prop in islice(SUPPORTED_PROPERTIES, 1, None):\nastropy\/nddata\/decorators.py:                    # the NDData object\nastropy\/nddata\/decorators.py:                        # NDData.\nastropy\/nddata\/decorators.py:                                \"as an NDData property{1}, using explicitly \"\nastropy\/units\/format\/ogip_lextab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/ogip_lextab.py:_lextokens    = set(('UINT', 'WHITESPACE', 'STAR', 'OPEN_PAREN', 'UNIT', 'SIGN', 'UFLOAT', 'STARSTAR', 'DIVISION', 'LIT10', 'CLOSE_PAREN', 'UNKNOWN'))\nastropy\/units\/format\/ogip_lextab.py:_lexstatere   = {'INITIAL': [('(?P<t_UFLOAT>(((\\\\d+\\\\.?\\\\d*)|(\\\\.\\\\d+))([eE][+-]?\\\\d+))|(((\\\\d+\\\\.\\\\d*)|(\\\\.\\\\d+))([eE][+-]?\\\\d+)?))|(?P<t_UINT>\\\\d+)|(?P<t_SIGN>[+-](?=\\\\d))|(?P<t_X>[x\u00d7])|(?P<t_LIT10>10)|(?P<t_UNKNOWN>[Uu][Nn][Kk][Nn][Oo][Ww][Nn])|(?P<t_UNIT>[a-zA-Z][a-zA-Z_]*)|(?P<t_WHITESPACE>[ \\t]+)|(?P<t_STARSTAR>\\\\*\\\\*)|(?P<t_CLOSE_PAREN>\\\\))|(?P<t_OPEN_PAREN>\\\\()|(?P<t_STAR>\\\\*)|(?P<t_DIVISION>\/)', [None, ('t_UFLOAT', 'UFLOAT'), None, None, None, None, None, None, None, None, None, None, ('t_UINT', 'UINT'), ('t_SIGN', 'SIGN'), ('t_X', 'X'), ('t_LIT10', 'LIT10'), ('t_UNKNOWN', 'UNKNOWN'), ('t_UNIT', 'UNIT'), (None, 'WHITESPACE'), (None, 'STARSTAR'), (None, 'CLOSE_PAREN'), (None, 'OPEN_PAREN'), (None, 'STAR'), (None, 'DIVISION')])]}\nastropy\/nddata\/nddata_base.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nddata_base.py:# This module implements the base NDDataBase class.\nastropy\/nddata\/nddata_base.py:__all__ = ['NDDataBase']\nastropy\/nddata\/nddata_base.py:class NDDataBase(metaclass=ABCMeta):\nastropy\/nddata\/nddata_base.py:    `NDData` for a subclass that defines this interface on `numpy.ndarray`-like\nastropy\/nddata\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/__init__.py:The `astropy.nddata` subpackage provides the `~astropy.nddata.NDData`\nastropy\/nddata\/__init__.py:CCD images, IFU Data, grid-based simulation data, ...). This is more than\nastropy\/nddata\/__init__.py:        'Whether to issue a warning if `~astropy.nddata.NDData` arithmetic '\nastropy\/nddata\/__init__.py:        'Whether to issue a warning when the `~astropy.nddata.NDData` unit '\nastropy\/nddata\/tests\/test_utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_utils.py:                     Cutout2D)\nastropy\/nddata\/tests\/test_utils.py:    Test add_array_2D utility function.\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 1D array.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 1D array with func=np.mean.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 2D array.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 2D array with func=np.mean.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:        Test trimming of 2D array when size is not perfectly divisible\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 1D array.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 1D array with conserve_sum=False.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 2D array.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 2D array with conserve_sum=False.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:class TestCutout2D:\nastropy\/nddata\/tests\/test_utils.py:        wcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/nddata\/tests\/test_utils.py:            c = Cutout2D(self.data, position, size)\nastropy\/nddata\/tests\/test_utils.py:            Cutout2D(self.data, (2, 2), (1, 1, 1))\nastropy\/nddata\/tests\/test_utils.py:                Cutout2D(self.data, (2, 2), size)\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, (2, 2), size)\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, (2, 2), (0.1*u.arcsec), wcs=self.wcs)\nastropy\/nddata\/tests\/test_utils.py:            Cutout2D(self.data, (2, 2), (3, 3 * u.arcsec))\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, (0, 0), (3, 3), mode='trim')\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, (0, 0), (3, 3), mode='partial')\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, (0, 0), (3, 3), mode='partial',\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(data, (2, 3), (3, 3))\nastropy\/nddata\/tests\/test_utils.py:        c2 = Cutout2D(self.data, (2, 3), (3, 3), copy=True)\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, position, (3, 3))\nastropy\/nddata\/tests\/test_utils.py:            Cutout2D(self.data, self.position, (3, 3))\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, self.position, (3, 3), wcs=self.wcs)\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, self.position, (3, 3), wcs=self.wcs,\nastropy\/nddata\/tests\/test_nduncertainty.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_nduncertainty.py:from ..nduncertainty import (StdDevUncertainty, NDUncertainty,\nastropy\/nddata\/tests\/test_nduncertainty.py:from ..nddata import NDData\nastropy\/nddata\/tests\/test_nduncertainty.py:# Additionally they should be covered by NDData, NDArithmeticMixin which rely\nastropy\/nddata\/tests\/test_nduncertainty.py:# They should be covered by NDArithmeticMixin since there is generally no need\nastropy\/nddata\/tests\/test_nduncertainty.py:# Should be covered by NDSlicingMixin.\nastropy\/nddata\/tests\/test_nduncertainty.py:# Regarding StdDevUncertainty tests:\nastropy\/nddata\/tests\/test_nduncertainty.py:# they should be covered in NDArithmeticMixin.\nastropy\/nddata\/tests\/test_nduncertainty.py:class FakeUncertainty(NDUncertainty):\nastropy\/nddata\/tests\/test_nduncertainty.py:# Test the fake (added also StdDevUncertainty which should behave identical)\nastropy\/nddata\/tests\/test_nduncertainty.py:@pytest.mark.parametrize(('UncertClass'), [FakeUncertainty, StdDevUncertainty,\nastropy\/nddata\/tests\/test_nduncertainty.py:@pytest.mark.parametrize(('UncertClass'), [FakeUncertainty, StdDevUncertainty,\nastropy\/nddata\/tests\/test_nduncertainty.py:@pytest.mark.parametrize(('UncertClass'), [FakeUncertainty, StdDevUncertainty,\nastropy\/nddata\/tests\/test_nduncertainty.py:@pytest.mark.parametrize(('UncertClass'), [FakeUncertainty, StdDevUncertainty,\nastropy\/nddata\/tests\/test_nduncertainty.py:@pytest.mark.parametrize(('UncertClass'), [FakeUncertainty, StdDevUncertainty,\nastropy\/nddata\/tests\/test_nduncertainty.py:    # TODO : Find something that can be referenced without copy :-)\nastropy\/nddata\/tests\/test_nduncertainty.py:def test_init_fake_with_StdDevUncertainty():\nastropy\/nddata\/tests\/test_nduncertainty.py:    # Different instances of uncertainties are not directly convertible so this\nastropy\/nddata\/tests\/test_nduncertainty.py:    std_uncert = StdDevUncertainty(uncert)\nastropy\/nddata\/tests\/test_nduncertainty.py:        StdDevUncertainty(fake_uncert)\nastropy\/nddata\/tests\/test_nduncertainty.py:    std_uncert = StdDevUncertainty([10, 2])\nastropy\/nddata\/tests\/test_nduncertainty.py:    std_uncert = StdDevUncertainty([10, 2])\nastropy\/nddata\/tests\/test_nduncertainty.py:    # NDData and uncertainty\nastropy\/nddata\/tests\/test_nduncertainty.py:        NDData(np.ones(100))\nastropy\/nddata\/tests\/test_nduncertainty.py:        NDData(np.ones(100), uncertainty=StdDevUncertainty(np.ones(100)))\nastropy\/nddata\/tests\/test_nduncertainty.py:    test_leak(non_leaker_nddata, NDData)\nastropy\/nddata\/tests\/test_nduncertainty.py:    test_leak(leaker_nddata, NDData)\nastropy\/nddata\/tests\/test_nduncertainty.py:    # Same for NDDataArray:\nastropy\/nddata\/tests\/test_nduncertainty.py:    from ..compat import NDDataArray\nastropy\/nddata\/tests\/test_nduncertainty.py:        NDDataArray(np.ones(100))\nastropy\/nddata\/tests\/test_nduncertainty.py:        NDDataArray(np.ones(100), uncertainty=StdDevUncertainty(np.ones(100)))\nastropy\/nddata\/tests\/test_nduncertainty.py:    test_leak(non_leaker_nddataarray, NDDataArray)\nastropy\/nddata\/tests\/test_nduncertainty.py:    test_leak(leaker_nddataarray, NDDataArray)\nastropy\/nddata\/tests\/test_nduncertainty.py:    ndd1 = NDData(1, uncertainty=1)\nastropy\/nddata\/tests\/test_nduncertainty.py:    ndd2 = NDData(2, uncertainty=ndd1.uncertainty)\nastropy\/nddata\/tests\/test_flag_collection.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/tests\/test_ndio.py:from ... import NDData, NDIOMixin, NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndio.py:# Alias NDDataAllMixins in case this will be renamed ... :-)\nastropy\/nddata\/mixins\/tests\/test_ndio.py:NDDataIO = NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndio.py:    ndd = NDDataIO([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:from ... import NDData, NDSlicingMixin\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:from ...nduncertainty import NDUncertainty, StdDevUncertainty\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:# Just add the Mixin to NDData\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:# TODO: Make this use NDDataRef instead!\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:class NDDataSliceable(NDSlicingMixin, NDData):\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:# Just some uncertainty (following the StdDevUncertainty implementation of\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:class SomeUncertainty(NDUncertainty):\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data)\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data)\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data)\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    # Data is 2d but mask only 1d so this should let the IndexError when\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data, **kwarg)\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data, mask=mask, uncertainty=uncertainty, wcs=wcs,\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data, mask=mask, uncertainty=uncertainty, wcs=wcs)\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    # Slice only 1D\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    # Slice 3D\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data, mask=mask, uncertainty=uncertainty, wcs=wcs)\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data, mask=mask, uncertainty=uncertainty, wcs=wcs)\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    uncertainty = StdDevUncertainty(data.copy())\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data, mask=mask, uncertainty=uncertainty, wcs=wcs)\nastropy\/nddata\/tests\/test_ccddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_ccddata.py:# This module implements the base CCDData class.\nastropy\/nddata\/tests\/test_ccddata.py:from ..nduncertainty import StdDevUncertainty, MissingDataAssociationException\nastropy\/nddata\/tests\/test_ccddata.py:from ..ccddata import CCDData\nastropy\/nddata\/tests\/test_ccddata.py:DEFAULTS = {\nastropy\/nddata\/tests\/test_ccddata.py:DEFAULT_SEED = 123\nastropy\/nddata\/tests\/test_ccddata.py:DEFAULT_DATA_SIZE = 100\nastropy\/nddata\/tests\/test_ccddata.py:DEFAULT_DATA_SCALE = 1.0\nastropy\/nddata\/tests\/test_ccddata.py:        val = DEFAULTS[key]\nastropy\/nddata\/tests\/test_ccddata.py:    Return a CCDData object with units of ADU.\nastropy\/nddata\/tests\/test_ccddata.py:    Data values are initialized to random numbers drawn from a normal\nastropy\/nddata\/tests\/test_ccddata.py:    with NumpyRNGContext(DEFAULTS['seed']):\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(data, unit=u.adu)\nastropy\/nddata\/tests\/test_ccddata.py:        CCDData()  # empty initializer should fail\nastropy\/nddata\/tests\/test_ccddata.py:        CCDData(np.zeros([100, 100]))\nastropy\/nddata\/tests\/test_ccddata.py:        CCDData([1, 2, 3], unit='', meta={1: 1}, header={2: 2})\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.zeros((10, 10)), unit=\"electron\")\nastropy\/nddata\/tests\/test_ccddata.py:    hdu = fits.PrimaryHDU(ccd_data)\nastropy\/nddata\/tests\/test_ccddata.py:    hdulist = fits.HDUList([hdu])\nastropy\/nddata\/tests\/test_ccddata.py:    cd = CCDData.read(filename, unit=u.electron)\nastropy\/nddata\/tests\/test_ccddata.py:    hdu = fits.PrimaryHDU(fake_img)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData.read(filename)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd2 = CCDData.read(filename, unit=\"photon\")\nastropy\/nddata\/tests\/test_ccddata.py:def test_initialize_from_fits_with_ADU_in_header(tmpdir):\nastropy\/nddata\/tests\/test_ccddata.py:    hdu = fits.PrimaryHDU(fake_img)\nastropy\/nddata\/tests\/test_ccddata.py:    hdu.header['bunit'] = 'ADU'\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData.read(filename)\nastropy\/nddata\/tests\/test_ccddata.py:    hdu1 = fits.PrimaryHDU()\nastropy\/nddata\/tests\/test_ccddata.py:    hdu2 = fits.ImageHDU(fake_img)\nastropy\/nddata\/tests\/test_ccddata.py:    hdus = fits.HDUList([hdu1, hdu2])\nastropy\/nddata\/tests\/test_ccddata.py:        ccd = CCDData.read(filename, unit='adu')\nastropy\/nddata\/tests\/test_ccddata.py:    hdu0 = fits.PrimaryHDU()\nastropy\/nddata\/tests\/test_ccddata.py:    hdu1 = fits.ImageHDU(fake_img1)\nastropy\/nddata\/tests\/test_ccddata.py:    hdu2 = fits.ImageHDU(fake_img2)\nastropy\/nddata\/tests\/test_ccddata.py:    hdus = fits.HDUList([hdu0, hdu1, hdu2])\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData.read(filename, hdu=2, unit='adu')\nastropy\/nddata\/tests\/test_ccddata.py:        CCDData.read(filename, unit=ccd_data.unit,\nastropy\/nddata\/tests\/test_ccddata.py:        CCDData.read(filename, unit=ccd_data.unit, scale_back=True)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_disk = CCDData.read(filename, unit=ccd_data.unit)\nastropy\/nddata\/tests\/test_ccddata.py:    hdu = fits.PrimaryHDU(ccd_data)\nastropy\/nddata\/tests\/test_ccddata.py:    hdu2 = fits.PrimaryHDU(2 * ccd_data.data)\nastropy\/nddata\/tests\/test_ccddata.py:    hdulist = fits.HDUList(hdu)\nastropy\/nddata\/tests\/test_ccddata.py:    cd = CCDData.read(filename, unit=u.electron)\nastropy\/nddata\/tests\/test_ccddata.py:    cd = CCDData.read(filename, hdu=1, unit=u.electron)\nastropy\/nddata\/tests\/test_ccddata.py:    d1 = CCDData(np.ones((5, 5)), meta=hdr, unit=u.electron)\nastropy\/nddata\/tests\/test_ccddata.py:    d1 = CCDData(np.ones((5, 5)), meta=dic, unit=u.electron)\nastropy\/nddata\/tests\/test_ccddata.py:    d1 = CCDData(np.ones((5, 5)), unit=u.electron)\nastropy\/nddata\/tests\/test_ccddata.py:        CCDData(np.ones((5, 5)), meta=hdr, unit=u.adu)\nastropy\/nddata\/tests\/test_ccddata.py:        # Uncertainty is supposed to be an instance of NDUncertainty\nastropy\/nddata\/tests\/test_ccddata.py:    assert isinstance(fits_hdulist, fits.HDUList)\nastropy\/nddata\/tests\/test_ccddata.py:        ccd_data.uncertainty = StdDevUncertainty(np.ones_like(ccd_data))\nastropy\/nddata\/tests\/test_ccddata.py:    assert isinstance(result, CCDData)\nastropy\/nddata\/tests\/test_ccddata.py:            isinstance(result.uncertainty, StdDevUncertainty))\nastropy\/nddata\/tests\/test_ccddata.py:        ccd_data.uncertainty = StdDevUncertainty(np.ones_like(ccd_data))\nastropy\/nddata\/tests\/test_ccddata.py:    assert isinstance(result, CCDData)\nastropy\/nddata\/tests\/test_ccddata.py:            isinstance(result.uncertainty, StdDevUncertainty))\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((10, 10)), unit='')\nastropy\/nddata\/tests\/test_ccddata.py:    ccd1 = CCDData(np.ones((10, 10)), unit='', wcs=2)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd2 = CCDData(np.ones((10, 10)), unit='', wcs=5)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd1 = CCDData(np.ones((10, 10)), unit='', wcs=2)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd2 = CCDData(np.ones((10, 10)), unit='', wcs=5)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_data.uncertainty = StdDevUncertainty(np.ones_like(ccd_data))\nastropy\/nddata\/tests\/test_ccddata.py:    ccddata = CCDData(a)\nastropy\/nddata\/tests\/test_ccddata.py:    # TODO: Could also be parametrized.\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((3, 3)), unit='')\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((3, 3)), unit='adu')\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((3, 3)), unit='')\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((3, 3)), unit='adu')\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((3, 3)) * 3, unit=u.m)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((3, 3)), unit=u.m)\nastropy\/nddata\/tests\/test_ccddata.py:    hdu = fits.PrimaryHDU(fake_img)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_read = CCDData.read(tmp_file, unit=\"adu\")\nastropy\/nddata\/tests\/test_ccddata.py:        ccd_from_disk = CCDData.read(tmpfile.strpath, unit=explicit_unit_name)\nastropy\/nddata\/tests\/test_ccddata.py:    Check that WCS attribute gets added to header, and that if a CCDData\nastropy\/nddata\/tests\/test_ccddata.py:    is modified, then the CCDData object is turned back into an hdu, the\nastropy\/nddata\/tests\/test_ccddata.py:    wcs.wcs.ctype = [\"RA---AIR\", \"DEC--AIR\"]\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_new = CCDData.read(tmpfile.strpath)\nastropy\/nddata\/tests\/test_ccddata.py:    # Converting CCDData object with wcs to an hdu shouldn't\nastropy\/nddata\/tests\/test_ccddata.py:    # Making a CCDData with WCS (but not WCS in the header) should lead to\nastropy\/nddata\/tests\/test_ccddata.py:    # WCS information in the header when it is converted to an HDU.\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_wcs_not_in_header = CCDData(ccd_data.data, wcs=wcs, unit=\"adu\")\nastropy\/nddata\/tests\/test_ccddata.py:        # Every keyword in the WCS should be in the header of the HDU\nastropy\/nddata\/tests\/test_ccddata.py:    # Now check that if WCS of a CCDData is modified, then the CCDData is\nastropy\/nddata\/tests\/test_ccddata.py:    # converted to an HDU, the WCS keywords in the header are overwritten\nastropy\/nddata\/tests\/test_ccddata.py:    assert ccd_new_hdu_mod_wcs.header['CDELT1'] == ccd_new.wcs.wcs.cdelt[0]\nastropy\/nddata\/tests\/test_ccddata.py:    assert ccd_new_hdu_mod_wcs.header['CDELT2'] == ccd_new.wcs.wcs.cdelt[1]\nastropy\/nddata\/tests\/test_ccddata.py:    from ..ccddata import _KEEP_THESE_KEYWORDS_IN_HEADER\nastropy\/nddata\/tests\/test_ccddata.py:    keepers = set(_KEEP_THESE_KEYWORDS_IN_HEADER)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData.read(data_file)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData.read(data_file1, unit='count')\nastropy\/nddata\/tests\/test_ccddata.py:    from ..ccddata import _KEEP_THESE_KEYWORDS_IN_HEADER\nastropy\/nddata\/tests\/test_ccddata.py:    keepers = set(_KEEP_THESE_KEYWORDS_IN_HEADER)\nastropy\/nddata\/tests\/test_ccddata.py:    CDELT1  =           0.10380000 \/ X Scale projected on detector (#\/pix)\nastropy\/nddata\/tests\/test_ccddata.py:    CDELT2  =           0.10380000 \/ Y Scale projected on detector (#\/pix)\nastropy\/nddata\/tests\/test_ccddata.py:    CUNIT1  = 'degree  '           \/ Units used in both CRVAL1 and CDELT1\nastropy\/nddata\/tests\/test_ccddata.py:    CUNIT2  = 'nm      '           \/ Units used in both CRVAL2 and CDELT2\nastropy\/nddata\/tests\/test_ccddata.py:    CD1_1   =           0.20760000 \/ Pixel Coordinate translation matrix\nastropy\/nddata\/tests\/test_ccddata.py:    CD1_2   =           0.00000000 \/ Pixel Coordinate translation matrix\nastropy\/nddata\/tests\/test_ccddata.py:    CD2_1   =           0.00000000 \/ Pixel Coordinate translation matrix\nastropy\/nddata\/tests\/test_ccddata.py:    CD2_2   =           0.10380000 \/ Pixel Coordinate translation matrix\nastropy\/nddata\/tests\/test_ccddata.py:    C2YPE2  = 'DEC--TAN'           \/ Pixel coordinate system\nastropy\/nddata\/tests\/test_ccddata.py:    RADECSYS= 'FK5     '           \/ The equatorial coordinate system\nastropy\/nddata\/tests\/test_ccddata.py:    hdul = fits.HDUList([fits.PrimaryHDU(np.ones((4241, 1104)), header=hdr)])\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData.read(filename, unit='adu')\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(ccd_data, header=a)\nastropy\/nddata\/tests\/test_ccddata.py:    Check whether the ctypes RA---TAN-SIP and DEC--TAN-SIP survive\nastropy\/nddata\/tests\/test_ccddata.py:            'CTYPE2': 'DEC--TAN-SIP'\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_original = CCDData.read(data_file)\nastropy\/nddata\/tests\/test_ccddata.py:    assert ccd_no_relax[0].header['CTYPE2'] == 'DEC--TAN'\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_after = CCDData.read(filename)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_data.uncertainty = StdDevUncertainty(ccd_data.data * 10)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_after = CCDData.read(filename)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_data.uncertainty = StdDevUncertainty(ccd_data.data * 10)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_after = CCDData.read(filename)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_data.uncertainty = StdDevUncertainty(ccd_data.data * 10)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_after = CCDData.read(filename)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_after = CCDData.read(filename, hdu_mask='Fun', hdu_uncertainty='NoFun')\nastropy\/nddata\/tests\/test_ccddata.py:        from_disk = CCDData.read(path.strpath)\nastropy\/nddata\/tests\/test_ccddata.py:    with pytest.raises(MissingDataAssociationException):\nastropy\/nddata\/tests\/test_ccddata.py:        StdDevUncertainty(np.ones((10, 10))).parent_nddata\nastropy\/nddata\/tests\/test_ccddata.py:    # TODO: Remove this test if astropy 1.0 isn't supported anymore\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((10, 10)), unit='')\nastropy\/nddata\/tests\/test_ccddata.py:    uncert = StdDevUncertainty(np.ones((10, 10)))\nastropy\/nddata\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/cds_parsetab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/cds_parsetab.py:# This file is automatically generated. Do not edit.\nastropy\/units\/format\/cds_parsetab.py:_lr_signature = '6FC211F72F2851FC3FF7D2BFF951FE7A'\nastropy\/units\/format\/cds_parsetab.py:_lr_action_items = {'UINT':([0,2,3,14,15,16,19,23,],[1,-21,20,-20,28,29,30,32,]),'PRODUCT':([2,12,13,18,30,31,],[-18,-10,27,-17,-19,-11,]),'CLOSE_PAREN':([2,7,8,12,13,18,22,25,30,31,33,34,],[-18,-4,-5,-10,-7,-17,31,-8,-19,-11,-9,-6,]),'UNIT':([0,1,5,6,10,11,17,20,21,26,27,28,35,36,],[2,-15,2,-16,2,2,-14,-23,-24,2,2,-22,-13,-12,]),'OPEN_PAREN':([0,1,5,6,10,11,17,20,21,26,27,28,35,36,],[5,-15,5,-16,5,5,-14,-23,-24,5,5,-22,-13,-12,]),'$end':([1,2,4,6,7,8,9,10,12,13,17,18,20,21,24,25,28,30,31,33,34,35,36,],[-15,-18,-2,-16,-4,-5,0,-3,-10,-7,-14,-17,-23,-24,-1,-8,-22,-19,-11,-9,-6,-13,-12,]),'DIVISION':([0,1,2,5,6,10,12,13,17,18,20,21,26,27,28,30,31,35,36,],[11,-15,-18,11,-16,11,-10,26,-14,-17,-23,-24,11,11,-22,-19,-11,-13,-12,]),'UFLOAT':([0,3,14,],[-21,21,-20,]),'X':([1,6,20,21,],[16,23,-23,-24,]),'SIGN':([0,1,2,29,32,],[14,15,14,15,15,]),}\nastropy\/units\/format\/cds_parsetab.py:  ('product_of_units -> unit_expression PRODUCT combined_units','product_of_units',3,'p_product_of_units','cds.py',169),\nastropy\/units\/format\/cds_parsetab.py:  ('division_of_units -> DIVISION unit_expression','division_of_units',2,'p_division_of_units','cds.py',179),\nastropy\/units\/format\/cds_parsetab.py:  ('division_of_units -> unit_expression DIVISION combined_units','division_of_units',3,'p_division_of_units','cds.py',180),\nastropy\/nddata\/nddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nddata.py:# This module implements the base NDData class.\nastropy\/nddata\/nddata.py:from .nddata_base import NDDataBase\nastropy\/nddata\/nddata.py:from .nduncertainty import NDUncertainty, UnknownUncertainty\nastropy\/nddata\/nddata.py:from ..utils.metadata import MetaData\nastropy\/nddata\/nddata.py:__all__ = ['NDData']\nastropy\/nddata\/nddata.py:class NDData(NDDataBase):\nastropy\/nddata\/nddata.py:    `~astropy.nddata.NDDataBase` interface.\nastropy\/nddata\/nddata.py:    data : `numpy.ndarray`-like or `NDData`-like\nastropy\/nddata\/nddata.py:        `NDUncertainty` - but isn't mandatory. If the uncertainty has no such\nastropy\/nddata\/nddata.py:        Defaults to ``None``.\nastropy\/nddata\/nddata.py:        Defaults to ``None``.\nastropy\/nddata\/nddata.py:        Default is ``None``.\nastropy\/nddata\/nddata.py:        an empty `collections.OrderedDict` is created.\nastropy\/nddata\/nddata.py:        Default is ``None``.\nastropy\/nddata\/nddata.py:        Default is ``None``.\nastropy\/nddata\/nddata.py:        Default is ``False``.\nastropy\/nddata\/nddata.py:    ``data`` in a `NDData` object can be accessed through the `data`\nastropy\/nddata\/nddata.py:        >>> from astropy.nddata import NDData\nastropy\/nddata\/nddata.py:        >>> nd = NDData([1,2,3])\nastropy\/nddata\/nddata.py:        >>> nd2 = NDData(q, unit=u.cm)\nastropy\/nddata\/nddata.py:    NDDataRef\nastropy\/nddata\/nddata.py:    NDDataArray\nastropy\/nddata\/nddata.py:    # Instead of a custom property use the MetaData descriptor also used for\nastropy\/nddata\/nddata.py:    meta = MetaData(doc=_meta_doc, copy=False)\nastropy\/nddata\/nddata.py:        # Rather pointless since the NDDataBase does not implement any setting\nastropy\/nddata\/nddata.py:        # but before the NDDataBase did call the uncertainty\nastropy\/nddata\/nddata.py:        # to the superclass NDDataBase should be in here.\nastropy\/nddata\/nddata.py:        if isinstance(data, NDData):  # don't use self.__class__ (issue #4137)\nastropy\/nddata\/nddata.py:            # unit just overwrite the unit parameter with the NDData.unit\nastropy\/nddata\/nddata.py:                log.info(\"overwriting NDData's current \"\nastropy\/nddata\/nddata.py:                log.info(\"overwriting NDData's current \"\nastropy\/nddata\/nddata.py:                log.info(\"overwriting NDData's current \"\nastropy\/nddata\/nddata.py:                log.info(\"overwriting NDData's current \"\nastropy\/nddata\/nddata.py:                log.info(\"overwriting NDData's current \"\nastropy\/nddata\/nddata.py:            # Data doesn't look like a numpy array, try converting it to\nastropy\/nddata\/nddata.py:            # Data might have been copied before but no way of validating\nastropy\/nddata\/nddata.py:        self.meta = meta  # TODO: Make this call the setter sometime\nastropy\/nddata\/nddata.py:        `~astropy.nddata.NDUncertainty` but isn't mandatory.\nastropy\/nddata\/nddata.py:            # If it is a subclass of NDUncertainty we must set the\nastropy\/nddata\/nddata.py:            if isinstance(value, NDUncertainty):\nastropy\/nddata\/nddata.py:                # steal the uncertainty from another NDData object\nastropy\/nddata\/nddata.py:                # Then link it to this NDData instance (internally this needs\nastropy\/nddata\/nddata.py:                # to be saved as weakref but that's done by NDUncertainty\nastropy\/nddata\/ccddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/ccddata.py:\"\"\"This module implements the base CCDData class.\"\"\"\nastropy\/nddata\/ccddata.py:from .compat import NDDataArray\nastropy\/nddata\/ccddata.py:from .nduncertainty import StdDevUncertainty, NDUncertainty\nastropy\/nddata\/ccddata.py:__all__ = ['CCDData', 'fits_ccddata_reader', 'fits_ccddata_writer']\nastropy\/nddata\/ccddata.py:# CCDData. Should be used with care because several functions actually break\nastropy\/nddata\/ccddata.py:    \"\"\"Decorator factory which temporarly disables the need for a unit when\nastropy\/nddata\/ccddata.py:    creating a new CCDData instance. The final result must have a unit.\nastropy\/nddata\/ccddata.py:    Should only be used on CCDData ``add``, ``subtract``, ``divide`` or\nastropy\/nddata\/ccddata.py:    ``multiply`` because only these methods from NDArithmeticMixin are\nastropy\/nddata\/ccddata.py:            # Wrap it again as CCDData so it checks the final unit.\nastropy\/nddata\/ccddata.py:        inner.__doc__ = (\"See `astropy.nddata.NDArithmeticMixin.{}`.\"\nastropy\/nddata\/ccddata.py:class CCDData(NDDataArray):\nastropy\/nddata\/ccddata.py:    \"\"\"A class describing basic CCD data.\nastropy\/nddata\/ccddata.py:    The CCDData class is based on the NDData object and includes a data array,\nastropy\/nddata\/ccddata.py:    information for a single CCD image.\nastropy\/nddata\/ccddata.py:    data : `~astropy.nddata.CCDData`-like or `numpy.ndarray`-like\nastropy\/nddata\/ccddata.py:        The actual data contained in this `~astropy.nddata.CCDData` object.\nastropy\/nddata\/ccddata.py:    uncertainty : `~astropy.nddata.StdDevUncertainty`, `numpy.ndarray` or \\\nastropy\/nddata\/ccddata.py:        Default is ``None``.\nastropy\/nddata\/ccddata.py:        Default is ``None``.\nastropy\/nddata\/ccddata.py:        Default is ``None``.\nastropy\/nddata\/ccddata.py:        Default is ``None``.\nastropy\/nddata\/ccddata.py:        Default is ``None``.\nastropy\/nddata\/ccddata.py:        ``Classmethod`` to create an CCDData instance based on a ``FITS`` file.\nastropy\/nddata\/ccddata.py:        Writes the contents of the CCDData instance into a new ``FITS`` file.\nastropy\/nddata\/ccddata.py:    `~astropy.nddata.CCDData` objects can be easily converted to a regular\nastropy\/nddata\/ccddata.py:        >>> from astropy.nddata import CCDData\nastropy\/nddata\/ccddata.py:        >>> x = CCDData([1,2,3], unit='adu')\nastropy\/nddata\/ccddata.py:    This is useful, for example, when plotting a 2D image using\nastropy\/nddata\/ccddata.py:        >>> from astropy.nddata import CCDData\nastropy\/nddata\/ccddata.py:        >>> x = CCDData([[1,2,3], [4,5,6]], unit='adu')\nastropy\/nddata\/ccddata.py:        # _CCDDataUnit contextmanager.\nastropy\/nddata\/ccddata.py:            raise ValueError(\"a unit for CCDData must be specified.\")\nastropy\/nddata\/ccddata.py:            if isinstance(value, NDUncertainty):\nastropy\/nddata\/ccddata.py:                self._uncertainty = StdDevUncertainty(value)\nastropy\/nddata\/ccddata.py:                         \"StdDevUncertainty.\")\nastropy\/nddata\/ccddata.py:                                \"NDUncertainty object or a numpy array.\")\nastropy\/nddata\/ccddata.py:        \"\"\"Creates an HDUList object from a CCDData object.\nastropy\/nddata\/ccddata.py:            If it is a string append this attribute to the HDUList as\nastropy\/nddata\/ccddata.py:            `~astropy.io.fits.ImageHDU` with the string as extension name.\nastropy\/nddata\/ccddata.py:            Default is ``'MASK'`` for mask, ``'UNCERT'`` for uncertainty and\nastropy\/nddata\/ccddata.py:            ``CTYPE`` ``RA---TAN-SIP`` and ``DEC--TAN-SIP`` requires\nastropy\/nddata\/ccddata.py:              `~astropy.nddata.StdDevUncertainty`.\nastropy\/nddata\/ccddata.py:        hdulist : `~astropy.io.fits.HDUList`\nastropy\/nddata\/ccddata.py:            # Copy here so that we can modify the HDU header by adding WCS\nastropy\/nddata\/ccddata.py:            # information without changing the header of the CCDData object.\nastropy\/nddata\/ccddata.py:            # we need to create a dummy CCDData instance to hold the FITS\nastropy\/nddata\/ccddata.py:            dummy_ccd = CCDData([1], meta=fits.Header(), unit=\"adu\")\nastropy\/nddata\/ccddata.py:        hdus = [fits.PrimaryHDU(self.data, header)]\nastropy\/nddata\/ccddata.py:            hduMask = fits.ImageHDU(self.mask.astype(np.uint8), name=hdu_mask)\nastropy\/nddata\/ccddata.py:            # used so that loading the HDUList can infer the uncertainty type.\nastropy\/nddata\/ccddata.py:            # No idea how this can be done so only allow StdDevUncertainty.\nastropy\/nddata\/ccddata.py:            if self.uncertainty.__class__.__name__ != 'StdDevUncertainty':\nastropy\/nddata\/ccddata.py:                raise ValueError('only StdDevUncertainty can be saved.')\nastropy\/nddata\/ccddata.py:            # Assuming uncertainty is an StdDevUncertainty save just the array\nastropy\/nddata\/ccddata.py:            hduUncert = fits.ImageHDU(self.uncertainty.array,\nastropy\/nddata\/ccddata.py:            raise NotImplementedError('adding the flags to a HDU is not '\nastropy\/nddata\/ccddata.py:        hdulist = fits.HDUList(hdus)\nastropy\/nddata\/ccddata.py:        Return a copy of the CCDData object.\nastropy\/nddata\/ccddata.py:    add = _arithmetic(np.add)(NDDataArray.add)\nastropy\/nddata\/ccddata.py:    subtract = _arithmetic(np.subtract)(NDDataArray.subtract)\nastropy\/nddata\/ccddata.py:    multiply = _arithmetic(np.multiply)(NDDataArray.multiply)\nastropy\/nddata\/ccddata.py:    divide = _arithmetic(np.true_divide)(NDDataArray.divide)\nastropy\/nddata\/ccddata.py:_KEEP_THESE_KEYWORDS_IN_HEADER = [\nastropy\/nddata\/ccddata.py:    'JD-OBS',\nastropy\/nddata\/ccddata.py:    'MJD-OBS',\nastropy\/nddata\/ccddata.py:    'DATE-OBS'\nastropy\/nddata\/ccddata.py:        if k not in _KEEP_THESE_KEYWORDS_IN_HEADER:\nastropy\/nddata\/ccddata.py:    Generate a CCDData object from a FITS file.\nastropy\/nddata\/ccddata.py:        FITS extension from which CCDData should be initialized. If zero and\nastropy\/nddata\/ccddata.py:        Default is ``0``.\nastropy\/nddata\/ccddata.py:        Default is ``None``.\nastropy\/nddata\/ccddata.py:        extension does not exist the uncertainty of the CCDData is ``None``.\nastropy\/nddata\/ccddata.py:        Default is ``'UNCERT'``.\nastropy\/nddata\/ccddata.py:        extension does not exist the mask of the CCDData is ``None``.\nastropy\/nddata\/ccddata.py:        Default is ``'MASK'``.\nastropy\/nddata\/ccddata.py:        Default is ``None``.\nastropy\/nddata\/ccddata.py:            uncertainty = StdDevUncertainty(hdus[hdu_uncertainty].data)\nastropy\/nddata\/ccddata.py:                    log.info(\"first HDU with data is extension \"\nastropy\/nddata\/ccddata.py:            # patch to handle FITS files using ADU for the unit instead of the\nastropy\/nddata\/ccddata.py:        ccd_data = CCDData(hdus[hdu].data, meta=hdr, unit=use_unit,\nastropy\/nddata\/ccddata.py:    Write CCDData object to FITS file.\nastropy\/nddata\/ccddata.py:        If it is a string append this attribute to the HDUList as\nastropy\/nddata\/ccddata.py:        `~astropy.io.fits.ImageHDU` with the string as extension name.\nastropy\/nddata\/ccddata.py:        Default is ``'MASK'`` for mask, ``'UNCERT'`` for uncertainty and\nastropy\/nddata\/ccddata.py:          `~astropy.nddata.StdDevUncertainty`.\nastropy\/nddata\/ccddata.py:with registry.delay_doc_updates(CCDData):\nastropy\/nddata\/ccddata.py:    registry.register_reader('fits', CCDData, fits_ccddata_reader)\nastropy\/nddata\/ccddata.py:    registry.register_writer('fits', CCDData, fits_ccddata_writer)\nastropy\/nddata\/ccddata.py:    registry.register_identifier('fits', CCDData, fits.connect.is_fits)\nastropy\/nddata\/ccddata.py:    CCDData.read.__doc__ = fits_ccddata_reader.__doc__\nastropy\/nddata\/ccddata.py:    CCDData.read.__func__.__doc__ = fits_ccddata_reader.__doc__\nastropy\/nddata\/ccddata.py:    CCDData.write.__doc__ = fits_ccddata_writer.__doc__\nastropy\/nddata\/ccddata.py:    CCDData.write.__func__.__doc__ = fits_ccddata_writer.__doc__\nastropy\/constants\/codata2014.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/codata2014.py:class CODATA2014(Constant):\nastropy\/constants\/codata2014.py:    default_reference = 'CODATA 2014'\nastropy\/constants\/codata2014.py:class EMCODATA2014(CODATA2014, EMConstant):\nastropy\/constants\/codata2014.py:    _registry = CODATA2014._registry\nastropy\/constants\/codata2014.py:h = CODATA2014('h', \"Planck constant\", 6.626070040e-34,\nastropy\/constants\/codata2014.py:hbar = CODATA2014('hbar', \"Reduced Planck constant\", 1.054571800e-34,\nastropy\/constants\/codata2014.py:k_B = CODATA2014('k_B', \"Boltzmann constant\", 1.38064852e-23,\nastropy\/constants\/codata2014.py:c = CODATA2014('c', \"Speed of light in vacuum\", 299792458.,\nastropy\/constants\/codata2014.py:G = CODATA2014('G', \"Gravitational constant\", 6.67408e-11,\nastropy\/constants\/codata2014.py:g0 = CODATA2014('g0', \"Standard acceleration of gravity\", 9.80665,\nastropy\/constants\/codata2014.py:m_p = CODATA2014('m_p', \"Proton mass\", 1.672621898e-27,\nastropy\/constants\/codata2014.py:m_n = CODATA2014('m_n', \"Neutron mass\", 1.674927471e-27,\nastropy\/constants\/codata2014.py:m_e = CODATA2014('m_e', \"Electron mass\", 9.10938356e-31,\nastropy\/constants\/codata2014.py:u = CODATA2014('u', \"Atomic mass\", 1.660539040e-27,\nastropy\/constants\/codata2014.py:sigma_sb = CODATA2014('sigma_sb', \"Stefan-Boltzmann constant\", 5.670367e-8,\nastropy\/constants\/codata2014.py:e = EMCODATA2014('e', 'Electron charge', 1.6021766208e-19,\nastropy\/constants\/codata2014.py:eps0 = EMCODATA2014('eps0', 'Electric constant', 8.854187817e-12,\nastropy\/constants\/codata2014.py:N_A = CODATA2014('N_A', \"Avogadro's number\", 6.022140857e23,\nastropy\/constants\/codata2014.py:R = CODATA2014('R', \"Gas constant\", 8.3144598,\nastropy\/constants\/codata2014.py:Ryd = CODATA2014('Ryd', 'Rydberg constant', 10973731.568508,\nastropy\/constants\/codata2014.py:a0 = CODATA2014('a0', \"Bohr radius\", 0.52917721067e-10,\nastropy\/constants\/codata2014.py:muB = CODATA2014('muB', \"Bohr magneton\", 927.4009994e-26,\nastropy\/constants\/codata2014.py:alpha = CODATA2014('alpha', \"Fine-structure constant\", 7.2973525664e-3,\nastropy\/constants\/codata2014.py:atm = CODATA2014('atm', \"Standard atmosphere\", 101325,\nastropy\/constants\/codata2014.py:mu0 = CODATA2014('mu0', \"Magnetic constant\", 4.0e-7 * np.pi, 'N\/A2', 0.0,\nastropy\/constants\/codata2014.py:sigma_T = CODATA2014('sigma_T', \"Thomson scattering cross-section\",\nastropy\/constants\/codata2014.py:b_wien = CODATA2014('b_wien', 'Wien wavelength displacement law constant',\nastropy\/constants\/codata2014.py:e_esu = EMCODATA2014(e.abbrev, e.name, e.value * c.value * 10.0,\nastropy\/constants\/codata2014.py:e_emu = EMCODATA2014(e.abbrev, e.name, e.value \/ 10, 'abC',\nastropy\/constants\/codata2014.py:e_gauss = EMCODATA2014(e.abbrev, e.name, e.value * c.value * 10.0,\nastropy\/nddata\/mixins\/ndarithmetic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/ndarithmetic.py:# This module implements the Arithmetic mixin to the NDData class.\nastropy\/nddata\/mixins\/ndarithmetic.py:from ..nduncertainty import NDUncertainty\nastropy\/nddata\/mixins\/ndarithmetic.py:__all__ = ['NDArithmeticMixin']\nastropy\/nddata\/mixins\/ndarithmetic.py:# Docstring templates for add, subtract, multiply, divide methods.\nastropy\/nddata\/mixins\/ndarithmetic.py:    operand, operand2 : `NDData`-like instance or convertible to one.\nastropy\/nddata\/mixins\/ndarithmetic.py:        that the uncertainties are `NDUncertainty`-like. Default is ``True``.\nastropy\/nddata\/mixins\/ndarithmetic.py:        Default is `numpy.logical_or`.\nastropy\/nddata\/mixins\/ndarithmetic.py:        Default is ``None``.\nastropy\/nddata\/mixins\/ndarithmetic.py:        not successful. Default is ``'first_found'``.\nastropy\/nddata\/mixins\/ndarithmetic.py:        Default is 0.\nastropy\/nddata\/mixins\/ndarithmetic.py:    result : `~astropy.nddata.NDData`-like\nastropy\/nddata\/mixins\/ndarithmetic.py:class NDArithmeticMixin:\nastropy\/nddata\/mixins\/ndarithmetic.py:    Mixin class to add arithmetic to an NDData object.\nastropy\/nddata\/mixins\/ndarithmetic.py:    so that the subclass sees NDData as the main superclass. See\nastropy\/nddata\/mixins\/ndarithmetic.py:    `~astropy.nddata.NDDataArray` for an example.\nastropy\/nddata\/mixins\/ndarithmetic.py:        - ``uncertainty`` : has to be something that has a `NDUncertainty`-like\nastropy\/nddata\/mixins\/ndarithmetic.py:    For example for uncertainties not representing an `NDUncertainty`-like\nastropy\/nddata\/mixins\/ndarithmetic.py:    :meth:`NDArithmeticMixin.add`. ``None`` means that the result will have no\nastropy\/nddata\/mixins\/ndarithmetic.py:    Decomposing the units is not attempted, mainly due to the internal mechanics\nastropy\/nddata\/mixins\/ndarithmetic.py:    Using this Mixin with `~astropy.nddata.NDData`:\nastropy\/nddata\/mixins\/ndarithmetic.py:        >>> from astropy.nddata import NDData, NDArithmeticMixin\nastropy\/nddata\/mixins\/ndarithmetic.py:        >>> class NDDataWithMath(NDArithmeticMixin, NDData):\nastropy\/nddata\/mixins\/ndarithmetic.py:        >>> ndd = NDDataWithMath(100)\nastropy\/nddata\/mixins\/ndarithmetic.py:        NDDataWithMath(120)\nastropy\/nddata\/mixins\/ndarithmetic.py:        >>> ndd = NDDataWithMath(-4)\nastropy\/nddata\/mixins\/ndarithmetic.py:        NDDataWithMath(-0.25)\nastropy\/nddata\/mixins\/ndarithmetic.py:        >>> NDDataWithMath.subtract(5, 4)\nastropy\/nddata\/mixins\/ndarithmetic.py:        NDDataWithMath(1)\nastropy\/nddata\/mixins\/ndarithmetic.py:            The operation that is performed on the `NDData`. Supported are\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            different :meth:`NDArithmeticMixin._arithmetic_mask` (or wcs, ...)\nastropy\/nddata\/mixins\/ndarithmetic.py:            :meth:`NDArithmeticMixin.add`.\nastropy\/nddata\/mixins\/ndarithmetic.py:        # Determine the other properties\nastropy\/nddata\/mixins\/ndarithmetic.py:            see `NDArithmeticMixin._arithmetic` parameter description.\nastropy\/nddata\/mixins\/ndarithmetic.py:        operand : `NDData`-like instance\nastropy\/nddata\/mixins\/ndarithmetic.py:        # Do the calculation with or without units\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\nastropy\/nddata\/mixins\/ndarithmetic.py:        operand : `NDData`-like instance\nastropy\/nddata\/mixins\/ndarithmetic.py:            The result of :meth:`NDArithmeticMixin._arithmetic_data`.\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add` parameter description.\nastropy\/nddata\/mixins\/ndarithmetic.py:        result_uncertainty : `NDUncertainty` subclass instance or None\nastropy\/nddata\/mixins\/ndarithmetic.py:            The resulting uncertainty already saved in the same `NDUncertainty`\nastropy\/nddata\/mixins\/ndarithmetic.py:        # Make sure these uncertainties are NDUncertainties so this kind of\nastropy\/nddata\/mixins\/ndarithmetic.py:                not isinstance(self.uncertainty, NDUncertainty)):\nastropy\/nddata\/mixins\/ndarithmetic.py:                            \"subclasses of NDUncertainty.\")\nastropy\/nddata\/mixins\/ndarithmetic.py:                not isinstance(operand.uncertainty, NDUncertainty)):\nastropy\/nddata\/mixins\/ndarithmetic.py:                            \"subclasses of NDUncertainty.\")\nastropy\/nddata\/mixins\/ndarithmetic.py:        # TODO: There is no enforced requirement that actually forbids the\nastropy\/nddata\/mixins\/ndarithmetic.py:        # sign of the uncertainty DOES matter.\nastropy\/nddata\/mixins\/ndarithmetic.py:            # Delete the temporary uncertainty again.\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\nastropy\/nddata\/mixins\/ndarithmetic.py:        operand : `NDData`-like instance\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\nastropy\/nddata\/mixins\/ndarithmetic.py:        operand : `NDData` instance or subclass\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add` parameter description.\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\nastropy\/nddata\/mixins\/ndarithmetic.py:        operand : `NDData`-like instance\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            Do not override this method in subclasses.\nastropy\/nddata\/mixins\/ndarithmetic.py:        result : `~astropy.nddata.NDData`-like\nastropy\/nddata\/mixins\/ndarithmetic.py:            Depending how this method was called either ``self_or_cls``\nastropy\/nddata\/mixins\/ndarithmetic.py:            is the NDData-subclass that is used as wrapper for the result.\nastropy\/nddata\/mixins\/ndarithmetic.py:        # DO NOT OVERRIDE THIS METHOD IN SUBCLASSES.\nastropy\/nddata\/mixins\/ndarithmetic.py:        if isinstance(self_or_cls, NDArithmeticMixin):\nastropy\/nddata\/mixins\/ndarithmetic.py:        # of NDData.\nastropy\/nddata\/tests\/test_nddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_nddata.py:from collections import OrderedDict\nastropy\/nddata\/tests\/test_nddata.py:from ..nddata import NDData\nastropy\/nddata\/tests\/test_nddata.py:from ..nduncertainty import NDUncertainty, StdDevUncertainty\nastropy\/nddata\/tests\/test_nddata.py:class FakeUncertainty(NDUncertainty):\nastropy\/nddata\/tests\/test_nddata.py:    These attributes are checked for by NDData.\nastropy\/nddata\/tests\/test_nddata.py:    Define the minimum attributes acceptable as an uncertainty object.\nastropy\/nddata\/tests\/test_nddata.py:class BadNDDataSubclass(NDData):\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData([1, 2, 3])\nastropy\/nddata\/tests\/test_nddata.py:    # parent_nddata attribute from NDUncertainty)\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(nd)\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData([1, 2, 3])\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(nd, mask=True)\nastropy\/nddata\/tests\/test_nddata.py:        NDData()  # empty initializer should fail\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(inp)\nastropy\/nddata\/tests\/test_nddata.py:        nd = NDData(np.random.random((10, 10)))\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(np.array([[1, 2, 3], [4, 5, 6]]))\nastropy\/nddata\/tests\/test_nddata.py:    # Tests to ensure that creating a new NDData object copies by *reference*.\nastropy\/nddata\/tests\/test_nddata.py:    nd_ref = NDData(a)\nastropy\/nddata\/tests\/test_nddata.py:    nd_ref = NDData(a, copy=True)\nastropy\/nddata\/tests\/test_nddata.py:        NDData(np.random.random((10, 10)),\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(marr)\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(marr, copy=True)\nastropy\/nddata\/tests\/test_nddata.py:    ndd = NDData(quantity)\nastropy\/nddata\/tests\/test_nddata.py:        ndd = NDData(quantity, copy=True)\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(mq)\nastropy\/nddata\/tests\/test_nddata.py:    nd1 = NDData(np.array([1]))\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(nd1)\nastropy\/nddata\/tests\/test_nddata.py:    nd1 = NDData(np.ones((5, 5)))\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(nd1)\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(nd1, copy=True)\nastropy\/nddata\/tests\/test_nddata.py:    nd1 = NDData(np.array([1]), mask=False, uncertainty=10, unit=u.s,\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(nd1)\nastropy\/nddata\/tests\/test_nddata.py:    nd3 = NDData(nd1, mask=True, uncertainty=200, unit=u.km,\nastropy\/nddata\/tests\/test_nddata.py:    # There might be some incompatible subclasses of NDData around.\nastropy\/nddata\/tests\/test_nddata.py:    bnd = BadNDDataSubclass(False, True, 3, 2, 'gollum', 100)\nastropy\/nddata\/tests\/test_nddata.py:    # Before changing the NDData init this would not have raised an error but\nastropy\/nddata\/tests\/test_nddata.py:        NDData(bnd)\nastropy\/nddata\/tests\/test_nddata.py:    bnd_good = BadNDDataSubclass(np.array([1, 2]), True, 3, 2,\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(bnd_good)\nastropy\/nddata\/tests\/test_nddata.py:        NDData({'a': 'dict'})\nastropy\/nddata\/tests\/test_nddata.py:        NDData(Shape())\nastropy\/nddata\/tests\/test_nddata.py:    ndd1 = NDData(FakeNumpyArray())\nastropy\/nddata\/tests\/test_nddata.py:    # First make sure that NDData isn't converting its data to a numpy array.\nastropy\/nddata\/tests\/test_nddata.py:    # Make a new NDData initialized from an NDData\nastropy\/nddata\/tests\/test_nddata.py:    ndd2 = NDData(ndd1)\nastropy\/nddata\/tests\/test_nddata.py:    u = StdDevUncertainty(array=np.ones((5, 5)))\nastropy\/nddata\/tests\/test_nddata.py:    d = NDData(np.ones((5, 5)), uncertainty=u)\nastropy\/nddata\/tests\/test_nddata.py:    # Test conflicting uncertainties (other NDData)\nastropy\/nddata\/tests\/test_nddata.py:    u2 = StdDevUncertainty(array=np.ones((5, 5))*2)\nastropy\/nddata\/tests\/test_nddata.py:    d2 = NDData(d, uncertainty=u2)\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData([1], wcs=3)\nastropy\/nddata\/tests\/test_nddata.py:    # Test conflicting wcs (other NDData)\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(nd, wcs=2)\nastropy\/nddata\/tests\/test_nddata.py:        NDData([1], meta=3)\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData([1, 2, 3], meta={})\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData([1, 2, 3])\nastropy\/nddata\/tests\/test_nddata.py:    assert isinstance(nd.meta, OrderedDict)\nastropy\/nddata\/tests\/test_nddata.py:    # Test conflicting meta (other NDData)\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(nd, meta={'image': 'sun'})\nastropy\/nddata\/tests\/test_nddata.py:    nd3 = NDData(nd2, meta={'image': 'moon'})\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData([1], mask=False)\nastropy\/nddata\/tests\/test_nddata.py:    # Test conflicting mask (other NDData)\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(nd, mask=True)\nastropy\/nddata\/tests\/test_nddata.py:    nd3 = NDData(np.ma.array([1], mask=False), mask=True)\nastropy\/nddata\/tests\/test_nddata.py:    nd4 = NDData(mq, mask=True)\nastropy\/nddata\/tests\/test_nddata.py:        NDData(np.ones((5, 5)), unit=\"NotAValidUnit\")\nastropy\/nddata\/tests\/test_nddata.py:    NDData([1, 2, 3], unit='meter')\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(q, unit='cm')\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(mq, unit=u.s)\nastropy\/nddata\/tests\/test_nddata.py:    # (another NDData as data)\nastropy\/nddata\/tests\/test_nddata.py:    nd3 = NDData(nd, unit='km')\nastropy\/nddata\/tests\/test_nddata.py:class TestMetaNDData(MetaBaseTest):\nastropy\/nddata\/tests\/test_nddata.py:    test_class = NDData\nastropy\/nddata\/tests\/test_nddata.py:    arr1d = NDData(np.array([1, 2, 3]))\nastropy\/nddata\/tests\/test_nddata.py:    arr2d = NDData(np.array([[1, 2], [3, 4]]))\nastropy\/nddata\/tests\/test_nddata.py:    arr3d = NDData(np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]))\nastropy\/nddata\/tests\/test_nddata.py:    arr1d = NDData(np.array([1, 2, 3]))\nastropy\/nddata\/tests\/test_nddata.py:    assert repr(arr1d) == 'NDData([1, 2, 3])'\nastropy\/nddata\/tests\/test_nddata.py:    arr2d = NDData(np.array([[1, 2], [3, 4]]))\nastropy\/nddata\/tests\/test_nddata.py:        NDData([[1, 2],\nastropy\/nddata\/tests\/test_nddata.py:    arr3d = NDData(np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]))\nastropy\/nddata\/tests\/test_nddata.py:        NDData([[[1, 2],\nastropy\/nddata\/tests\/test_nddata.py:    ndd = NDData(np.ones((5, 5)))\nastropy\/nddata\/tests\/test_nddata.py:    ndd = NDData(np.ones((5, 5)))\nastropy\/utils\/codegen.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/ndio.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/ndio.py:# This module implements the I\/O mixin to the NDData class.\nastropy\/nddata\/mixins\/ndio.py:__all__ = ['NDIOMixin']\nastropy\/nddata\/mixins\/ndio.py:class NDIOMixin:\nastropy\/nddata\/mixins\/ndio.py:    Mixin class to connect NDData to the astropy input\/output registry.\nastropy\/nddata\/mixins\/ndio.py:        NDData-derived object.\nastropy\/nddata\/mixins\/ndio.py:        This function provides the NDDataBase interface to the astropy unified\nastropy\/nddata\/mixins\/ndio.py:        This function provides the NDDataBase interface to the astropy unified\nastropy\/nddata\/tests\/test_nddata_base.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_nddata_base.py:# Tests of NDDataBase\nastropy\/nddata\/tests\/test_nddata_base.py:from ..nddata_base import NDDataBase\nastropy\/nddata\/tests\/test_nddata_base.py:class MinimalSubclass(NDDataBase):\nastropy\/units\/format\/generic_parsetab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/generic_parsetab.py:# This file is automatically generated. Do not edit.\nastropy\/units\/format\/generic_parsetab.py:_lr_signature = 'A63D4C561E2ED1A045DB279536CAFDDA'\nastropy\/units\/format\/generic_parsetab.py:_lr_action_items = {'CARET':([16,17,29,42,],[39,39,39,39,]),'FUNCNAME':([0,1,4,5,7,8,9,14,15,16,17,19,20,21,22,24,25,27,31,33,34,35,36,45,52,55,58,59,65,66,67,69,72,73,74,76,77,79,81,],[18,-16,18,-32,-17,18,18,-14,-48,-37,-20,-15,18,-33,18,18,-46,-47,18,18,-53,-52,-36,-21,-18,-34,-38,-35,-23,-27,-22,-26,-51,-19,-55,-39,-24,-28,-25,]),'CLOSE_PAREN':([1,2,4,5,7,9,10,12,14,16,17,19,21,23,26,28,30,32,34,35,36,45,47,48,49,50,51,52,55,56,57,58,59,61,62,63,65,66,67,69,71,72,73,74,75,76,77,78,79,81,83,],[-16,-4,-10,-32,-17,-31,-1,-7,-14,-37,-20,-15,-33,-5,-8,-2,55,-30,-53,-52,-36,-21,-13,-11,-6,-9,-3,-18,-34,-29,74,-38,-35,-42,-41,76,-23,-27,-22,-26,79,-51,-19,-55,-40,-39,-24,81,-28,-25,-43,]),'UFLOAT':([0,6,13,33,41,60,68,70,],[-45,-44,34,-45,-45,34,-44,-45,]),'$end':([1,2,3,4,5,7,9,10,12,14,16,17,19,21,23,26,28,32,34,35,36,45,47,48,49,50,51,52,55,56,58,59,65,66,67,69,72,73,74,76,77,79,81,],[-16,-4,0,-10,-32,-17,-31,-1,-7,-14,-37,-20,-15,-33,-5,-8,-2,-30,-53,-52,-36,-21,-13,-11,-6,-9,-3,-18,-34,-29,-38,-35,-23,-27,-22,-26,-51,-19,-55,-39,-24,-28,-25,]),'SOLIDUS':([0,1,2,4,5,7,9,10,14,16,17,19,21,23,24,25,27,28,32,33,34,35,36,45,48,49,51,52,55,56,58,59,65,66,67,69,72,73,74,75,76,77,79,81,],[15,-16,15,15,-32,-17,-31,-12,-14,-37,-20,-15,-33,15,15,-46,-47,-12,-30,15,-53,-52,-36,-21,-11,15,-12,-18,-34,-29,-38,-35,-23,-27,-22,-26,-51,-19,-55,15,-39,-24,-28,-25,]),'UINT':([0,6,7,13,15,16,17,33,34,35,37,38,39,40,41,43,44,53,54,60,64,68,70,80,82,],[17,-44,29,35,-48,-45,42,17,-53,-52,58,-45,-50,-49,-45,66,-45,72,-45,75,-45,72,-45,-45,83,]),'SIGN':([0,15,16,17,29,33,38,39,40,41,42,44,46,54,64,70,80,],[6,-48,6,43,53,6,6,-50,-49,6,53,68,53,6,6,68,6,]),'DOUBLE_STAR':([16,17,29,42,],[40,40,40,40,]),'OPEN_PAREN':([0,1,4,5,7,8,9,11,14,15,16,17,18,19,20,21,22,24,25,27,31,33,34,35,36,38,39,40,44,45,52,54,55,58,59,64,65,66,67,69,72,73,74,76,77,79,81,],[8,-16,8,-32,-17,8,8,33,-14,-48,41,46,-54,-15,8,-33,8,8,-46,-47,8,8,-53,-52,-36,41,-50,-49,70,-21,-18,41,-34,-38,-35,41,-23,-27,-22,-26,-51,-19,-55,-39,-24,-28,-25,]),'PERIOD':([1,4,5,7,9,14,16,17,19,21,34,35,36,45,52,55,58,59,65,66,67,69,72,73,74,76,77,79,81,],[-16,27,-32,-17,27,-14,-37,-20,-15,-33,-53,-52,-36,-21,-18,-34,-38,-35,-23,-27,-22,-26,-51,-19,-55,-39,-24,-28,-25,]),'STAR':([1,4,5,7,9,14,16,17,19,21,34,35,36,45,52,55,58,59,65,66,67,69,72,73,74,76,77,79,81,],[-16,25,-32,-17,25,-14,-37,-20,-15,-33,-53,-52,-36,-21,-18,-34,-38,-35,-23,-27,-22,-26,-51,-19,-55,-39,-24,-28,-25,]),'UNIT':([0,1,4,5,7,8,9,14,15,16,17,19,20,21,22,24,25,27,31,33,34,35,36,45,52,55,58,59,65,66,67,69,72,73,74,76,77,79,81,],[16,-16,16,-32,-17,16,16,-14,-48,-37,-20,-15,16,-33,16,16,-46,-47,16,16,-53,-52,-36,-21,-18,-34,-38,-35,-23,-27,-22,-26,-51,-19,-55,-39,-24,-28,-25,]),}\nastropy\/units\/format\/generic_parsetab.py:  ('product -> PERIOD','product',1,'p_product','generic.py',366),\nastropy\/units\/format\/generic_parsetab.py:  ('division -> SOLIDUS','division',1,'p_division','generic.py',372),\nastropy\/units\/format\/generic_parsetab.py:  ('power -> DOUBLE_STAR','power',1,'p_power','generic.py',378),\nastropy\/nddata\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/utils.py:           'NoOverlapError', 'PartialOverlapError', 'Cutout2D']\nastropy\/nddata\/utils.py:        The shape of the large array (for 1D arrays, this can be an\nastropy\/nddata\/utils.py:        The shape of the small array (for 1D arrays, this can be an\nastropy\/nddata\/utils.py:        The shape of the extracted array (for 1D arrays, this can be an\nastropy\/nddata\/utils.py:        (for 1D arrays, this can be a number).\nastropy\/nddata\/utils.py:    Downsample a data array by applying a function to local blocks.\nastropy\/nddata\/utils.py:class Cutout2D:\nastropy\/nddata\/utils.py:    Create a cutout object from a 2D array.\nastropy\/nddata\/utils.py:    The returned object will contain a 2D cutout array.  If\nastropy\/nddata\/utils.py:        The 2D data array from which to extract the cutout array.\nastropy\/nddata\/utils.py:    data : 2D `~numpy.ndarray`\nastropy\/nddata\/utils.py:        The 2D cutout array.\nastropy\/nddata\/utils.py:    >>> from astropy.nddata.utils import Cutout2D\nastropy\/nddata\/utils.py:    >>> cutout1 = Cutout2D(data, (2, 2), (3, 3))\nastropy\/nddata\/utils.py:    >>> cutout2 = Cutout2D(data, (2, 2), 3)\nastropy\/nddata\/utils.py:    >>> cutout3 = Cutout2D(data, (0, 0), size)\nastropy\/nddata\/utils.py:    >>> cutout4 = Cutout2D(data, (0, 0), (3 * u.pixel, 3))\nastropy\/nddata\/utils.py:    >>> cutout5 = Cutout2D(data, (0, 0), (3, 3), mode='partial')\nastropy\/constants\/tests\/test_pickle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/fits.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/fits.py:            'ct', 'photon', 'ph', 'pixel', 'pix', 'D', 'Sun', 'chan',\nastropy\/units\/format\/generic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/generic.py:        'DOUBLE_STAR',\nastropy\/units\/format\/generic.py:        'PERIOD',\nastropy\/units\/format\/generic.py:        'SOLIDUS',\nastropy\/units\/format\/generic.py:        t_PERIOD = r'\\.'\nastropy\/units\/format\/generic.py:        t_SOLIDUS = r'\/'\nastropy\/units\/format\/generic.py:        t_DOUBLE_STAR = r'\\*\\*'\nastropy\/units\/format\/generic.py:        # NOTE THE ORDERING OF THESE RULES IS IMPORTANT!!\nastropy\/units\/format\/generic.py:                        reflags=re.UNICODE)\nastropy\/units\/format\/generic.py:                    | PERIOD\nastropy\/units\/format\/generic.py:            division : SOLIDUS\nastropy\/units\/format\/generic.py:            power : DOUBLE_STAR\nastropy\/_erfa\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/astropyconst20.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/_erfa\/erfa_generator.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/_erfa\/erfa_generator.py:from collections import OrderedDict\nastropy\/_erfa\/erfa_generator.py:                  'eraLDBODY': \"dt_eraLDBODY\",\nastropy\/_erfa\/erfa_generator.py:NDIMS_REX = re.compile(re.escape(\"numpy.dtype([('fi0', '.*', <(.*)>)])\").replace(r'\\.\\*', '.*').replace(r'\\<', '(').replace(r'\\>', ')'))\nastropy\/_erfa\/erfa_generator.py:class FunctionDoc:\nastropy\/_erfa\/erfa_generator.py:            result = re.search(\"Given([^\\n]*):\\n(.+?)  \\n\", self.doc, re.DOTALL)\nastropy\/_erfa\/erfa_generator.py:                    arg_doc = ArgumentDoc(i)\nastropy\/_erfa\/erfa_generator.py:            result = re.search(\"Given and returned([^\\n]*):\\n(.+?)  \\n\", self.doc, re.DOTALL)\nastropy\/_erfa\/erfa_generator.py:                    arg_doc = ArgumentDoc(i)\nastropy\/_erfa\/erfa_generator.py:            result = re.search(\"Returned([^\\n]*):\\n(.+?)  \\n\", self.doc, re.DOTALL)\nastropy\/_erfa\/erfa_generator.py:                    arg_doc = ArgumentDoc(i)\nastropy\/_erfa\/erfa_generator.py:            result = re.search(\"Given and returned([^\\n]*):\\n(.+?)  \\n\", self.doc, re.DOTALL)\nastropy\/_erfa\/erfa_generator.py:                    arg_doc = ArgumentDoc(i)\nastropy\/_erfa\/erfa_generator.py:            result = re.search(\"Returned \\\\(function value\\\\)([^\\n]*):\\n(.+?)  \\n\", self.doc, re.DOTALL)\nastropy\/_erfa\/erfa_generator.py:                ret_info.append(ReturnDoc(result.group(2)))\nastropy\/_erfa\/erfa_generator.py:class ArgumentDoc:\nastropy\/_erfa\/erfa_generator.py:class ReturnDoc:\nastropy\/_erfa\/erfa_generator.py:        p = re.compile(pattern, flags=re.DOTALL | re.MULTILINE)\nastropy\/_erfa\/erfa_generator.py:        self.doc = FunctionDoc(search.group(2))\nastropy\/_erfa\/erfa_generator.py:                raise ValueError('Did not find prototype {} in file '\nastropy\/_erfa\/erfa_generator.py:    funcs = OrderedDict()\nastropy\/_erfa\/erfa_generator.py:                                              erfa_h, flags=re.DOTALL | re.MULTILINE)\nastropy\/_erfa\/erfa_generator.py:            func_names = re.findall(r' (\\w+)\\(.*?\\);', functions, flags=re.DOTALL)\nastropy\/_erfa\/erfa_generator.py:        result = re.findall(r\"#define (ERFA_\\w+?) (.+?)$\", chunk, flags=re.DOTALL | re.MULTILINE)\nastropy\/_erfa\/erfa_generator.py:            doc = re.findall(r\"\/\\* (.+?) \\*\/\\n\", chunk, flags=re.DOTALL)\nastropy\/_erfa\/erfa_generator.py:    # TODO: re-enable this when const char* return values and non-status code integer rets are possible\nastropy\/_erfa\/erfa_generator.py:    print_(\"Done!\")\nastropy\/_erfa\/erfa_generator.py:DEFAULT_ERFA_LOC = os.path.join(os.path.split(__file__)[0],\nastropy\/_erfa\/erfa_generator.py:DEFAULT_TEMPLATE_LOC = os.path.split(__file__)[0]\nastropy\/_erfa\/erfa_generator.py:    ap.add_argument('srcdir', default=DEFAULT_ERFA_LOC, nargs='?',\nastropy\/_erfa\/erfa_generator.py:                    help='Directory where the ERFA c and header files '\nastropy\/_erfa\/erfa_generator.py:                         'erfa.h). Defaults to the builtin astropy '\nastropy\/_erfa\/erfa_generator.py:                         'erfa: \"{0}\"'.format(DEFAULT_ERFA_LOC))\nastropy\/_erfa\/erfa_generator.py:                    default=DEFAULT_TEMPLATE_LOC,\nastropy\/extern\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/__init__.py:See the README.rst in this directory of the Astropy source repository for more\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:from ...nduncertainty import (StdDevUncertainty, UnknownUncertainty,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:from ... import NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:from ...nddata import NDData\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# Alias NDDataAllMixins in case this will be renamed ... :-)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:NDDataArithmetic = NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:class StdDevUncertaintyUncorrelated(StdDevUncertainty):\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# Test with Data covers:\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# scalars, 1D, 2D and 3D\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Division\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic([1, 2])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# Test with Data and unit and covers:\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Division\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# Test with Data and unit and covers:\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Division is possible\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(1, wcs=wcs1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(1, wcs=wcs2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Division\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# Masks are completely separated in the NDArithmetics from the data so we need\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# masks 1D, 2D and mixed cases with broadcasting\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(1, mask=mask1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(1, mask=mask2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Division\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(1, mask=np.array([1, 0], dtype=np.bool_))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(1, mask=np.array([1, 0, 1], dtype=np.bool_))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic([1, 2, 3], uncertainty=StdDevUncertainty([1, 1, 3]))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic([2, 2, 2], uncertainty=StdDevUncertainty([2, 2, 2]))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Multiplication and Division only work with almost equal array comparisons\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# TODO: Maybe covering units too but I think that should work because of\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1, uncertainty=StdDevUncertainty(uncert1))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2, uncertainty=StdDevUncertainty(uncert2))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Multiplication and Division only work with almost equal array comparisons\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1, uncertainty=StdDevUncertainty(uncert1))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2, uncertainty=StdDevUncertainty(uncert2))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:                           uncertainty=StdDevUncertaintyUncorrelated(uncert1))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:                           uncertainty=StdDevUncertaintyUncorrelated(uncert2))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic([1, -2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1_ref = NDDataArithmetic([1, -2, 3],\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:                               uncertainty=StdDevUncertainty([0, 0, 0]))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic([2, 2, -2],\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:                           uncertainty=StdDevUncertainty([2, 2, 2]))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Division\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# compared against correctly scaled NDDatas\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Data has same units\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        uncert1 = StdDevUncertainty(uncert1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        uncert_ref1 = StdDevUncertainty(uncert1_ref, copy=True)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        uncert2 = StdDevUncertainty(uncert2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        uncert_ref2 = StdDevUncertainty(uncert2_ref, copy=True)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1, uncertainty=uncert1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2, uncertainty=uncert2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1_ref = NDDataArithmetic(data1, uncertainty=uncert_ref1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2_ref = NDDataArithmetic(data2, uncertainty=uncert_ref2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Division\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty1 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty2 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1, meta=meta1, mask=mask1, wcs=wcs1,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2, meta=meta2, mask=mask2, wcs=wcs2,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = NDDataArithmetic(data1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty1 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty2 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1, meta=meta1, mask=mask1, wcs=wcs1,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2, meta=meta2, mask=mask2, wcs=wcs2,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty1 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty2 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1, meta=meta1, mask=mask1, wcs=wcs1,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2, meta=meta2, mask=mask2, wcs=wcs2,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty1 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty2 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1, meta=meta1, mask=mask1, wcs=wcs1,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2, meta=meta2, mask=mask2, wcs=wcs2,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd1 = NDDataArithmetic(np.ones((3, 3)))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd2 = NDDataArithmetic(np.ones((3, 3)))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd3 = getattr(NDDataArithmetic, meth)(ndd1, ndd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd3 = getattr(NDDataArithmetic(-100), meth)(ndd1, ndd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd3 = getattr(NDDataArithmetic, meth)(data1, data2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Compare it with the instance-useage and two identical NDData-like\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd1 = NDDataArithmetic(data1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd2 = NDDataArithmetic(data2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd3 = getattr(NDDataArithmetic(-100), meth)(data1, data2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd1 = NDDataArithmetic(np.ones((3, 3)),\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd2 = NDDataArithmetic(np.ones((3, 3)),\nastropy\/constants\/tests\/test_prior_version.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/tests\/test_prior_version.py:    # check that the value is the CODATA2010 value\nastropy\/_erfa\/tests\/test_erfa.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/six.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/ply\/__init__.py:# Author: David Beazley (dave@dabeaz.com)\nastropy\/extern\/ply\/lex.py:# David M. Beazley (Dabeaz LLC)\nastropy\/extern\/ply\/lex.py:# * Neither the name of the David Beazley or Dabeaz LLC may be used to\nastropy\/extern\/ply\/lex.py:# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\nastropy\/extern\/ply\/lex.py:# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nastropy\/extern\/ply\/lex.py:# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nastropy\/extern\/ply\/lex.py:# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nastropy\/extern\/ply\/lex.py:# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nastropy\/extern\/ply\/lex.py:# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nastropy\/extern\/ply\/lex.py:# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nastropy\/extern\/ply\/lex.py:# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nastropy\/extern\/ply\/lex.py:# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nastropy\/extern\/ply\/lex.py:# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nastropy\/extern\/ply\/lex.py:# Null logger is used when no output is generated. Does nothing.\nastropy\/extern\/ply\/lex.py:        self.lexstatere = {}          # Dictionary mapping lexer states to master regexs\nastropy\/extern\/ply\/lex.py:        self.lexstateretext = {}      # Dictionary mapping lexer states to regex strings\nastropy\/extern\/ply\/lex.py:        self.lexstaterenames = {}     # Dictionary mapping lexer states to symbol names\nastropy\/extern\/ply\/lex.py:        self.lexstateignore = {}      # Dictionary of ignored characters for each state\nastropy\/extern\/ply\/lex.py:        self.lexstateerrorf = {}      # Dictionary of error functions for each state\nastropy\/extern\/ply\/lex.py:        self.lexstateeoff = {}        # Dictionary of eof functions for each state\nastropy\/extern\/ply\/lex.py:            tf.write('# %s.py. This file automatically created by PLY (version %s). Don\\'t edit!\\n' % (basetabmodule, __version__))\nastropy\/extern\/ply\/lex.py:    # as possible.  Don't make changes unless you really know what\nastropy\/extern\/ply\/lex.py:    # Determine if the module is package of a package or not.\nastropy\/extern\/ply\/lex.py:    # Dump some basic debugging information\nastropy\/extern\/ply\/ctokens.py:    'ID', 'TYPEID', 'INTEGER', 'FLOAT', 'STRING', 'CHARACTER',\nastropy\/extern\/ply\/ctokens.py:    'PLUS', 'MINUS', 'TIMES', 'DIVIDE', 'MODULO',\nastropy\/extern\/ply\/ctokens.py:    'OR', 'AND', 'NOT', 'XOR', 'LSHIFT', 'RSHIFT',\nastropy\/extern\/ply\/ctokens.py:    'LOR', 'LAND', 'LNOT',\nastropy\/extern\/ply\/ctokens.py:    'EQUALS', 'TIMESEQUAL', 'DIVEQUAL', 'MODEQUAL', 'PLUSEQUAL', 'MINUSEQUAL',\nastropy\/extern\/ply\/ctokens.py:    'LSHIFTEQUAL','RSHIFTEQUAL', 'ANDEQUAL', 'XOREQUAL', 'OREQUAL',\nastropy\/extern\/ply\/ctokens.py:    'INCREMENT', 'DECREMENT',\nastropy\/extern\/ply\/ctokens.py:    # Delimeters ( ) [ ] { } , . ; :\nastropy\/extern\/ply\/ctokens.py:    'COMMA', 'PERIOD', 'SEMI', 'COLON',\nastropy\/extern\/ply\/ctokens.py:t_DIVIDE           = r'\/'\nastropy\/extern\/ply\/ctokens.py:t_MODULO           = r'%'\nastropy\/extern\/ply\/ctokens.py:t_AND              = r'&'\nastropy\/extern\/ply\/ctokens.py:t_LAND             = r'&&'\nastropy\/extern\/ply\/ctokens.py:t_DIVEQUAL         = r'\/='\nastropy\/extern\/ply\/ctokens.py:t_MODEQUAL         = r'%='\nastropy\/extern\/ply\/ctokens.py:t_ANDEQUAL         = r'&='\nastropy\/extern\/ply\/ctokens.py:t_DECREMENT        = r'--'\nastropy\/extern\/ply\/ctokens.py:# Delimeters\nastropy\/extern\/ply\/ctokens.py:t_PERIOD           = r'\\.'\nastropy\/extern\/ply\/ctokens.py:t_ID = r'[A-Za-z_][A-Za-z0-9_]*'\nastropy\/extern\/ply\/yacc.py:# David M. Beazley (Dabeaz LLC)\nastropy\/extern\/ply\/yacc.py:# * Neither the name of the David Beazley or Dabeaz LLC may be used to\nastropy\/extern\/ply\/yacc.py:# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\nastropy\/extern\/ply\/yacc.py:# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nastropy\/extern\/ply\/yacc.py:# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nastropy\/extern\/ply\/yacc.py:# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nastropy\/extern\/ply\/yacc.py:# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nastropy\/extern\/ply\/yacc.py:# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nastropy\/extern\/ply\/yacc.py:# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nastropy\/extern\/ply\/yacc.py:# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nastropy\/extern\/ply\/yacc.py:# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nastropy\/extern\/ply\/yacc.py:# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nastropy\/extern\/ply\/yacc.py:# Techniques, and Tools\" (The Dragon Book).  LALR(1) has since been replaced\nastropy\/extern\/ply\/yacc.py:# by the more efficient DeRemer and Pennello algorithm.\nastropy\/extern\/ply\/yacc.py:yaccdebug   = True             # Debugging mode.  If set, yacc generates a\nastropy\/extern\/ply\/yacc.py:debug_file  = 'parser.out'     # Default name of the debugging file\nastropy\/extern\/ply\/yacc.py:tab_module  = 'parsetab'       # Default name of the table module\nastropy\/extern\/ply\/yacc.py:default_lr  = 'LALR'           # Default LR table generation method\nastropy\/extern\/ply\/yacc.py:# Null logger is used when no output is generated. Does nothing.\nastropy\/extern\/ply\/yacc.py:_warnmsg = '''PLY: Don't use global functions errok(), token(), and restart() in p_error().\nastropy\/extern\/ply\/yacc.py:    # Defaulted state support.\nastropy\/extern\/ply\/yacc.py:    # See:  http:\/\/www.gnu.org\/software\/bison\/manual\/html_node\/Default-Reductions.html#Default-Reductions\nastropy\/extern\/ply\/yacc.py:    #      #--! DEBUG\nastropy\/extern\/ply\/yacc.py:    #      #--! DEBUG\nastropy\/extern\/ply\/yacc.py:        #--! DEBUG\nastropy\/extern\/ply\/yacc.py:        debug.info('PLY: PARSE DEBUG START')\nastropy\/extern\/ply\/yacc.py:        #--! DEBUG\nastropy\/extern\/ply\/yacc.py:            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                debug.debug('Defaulted state %s: Reduce using %d', state, -t)\nastropy\/extern\/ply\/yacc.py:                #--! DEBUG\nastropy\/extern\/ply\/yacc.py:            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                    #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                    #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                    # Decrease error count on successful shift\nastropy\/extern\/ply\/yacc.py:                    #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                    #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                    #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                    debug.info('Done   : Returning %s', format_result(result))\nastropy\/extern\/ply\/yacc.py:                    debug.info('PLY: PARSE DEBUG END')\nastropy\/extern\/ply\/yacc.py:                    #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                #--! DEBUG\nastropy\/extern\/ply\/yacc.py:    # Optimized version of parse() method.  DO NOT EDIT THIS CODE DIRECTLY!\nastropy\/extern\/ply\/yacc.py:                    # Decrease error count on successful shift\nastropy\/extern\/ply\/yacc.py:    # DO NOT EDIT THIS CODE DIRECTLY. This code is automatically generated\nastropy\/extern\/ply\/yacc.py:                    # Decrease error count on successful shift\nastropy\/extern\/ply\/yacc.py:        # Determine the precedence level\nastropy\/extern\/ply\/yacc.py:            del syms[-2:]     # Drop %prec from the rule\nastropy\/extern\/ply\/yacc.py:            raise GrammarError('%s:%d: Duplicate rule %s. ' % (file, line, m) +\nastropy\/extern\/ply\/yacc.py:                        # Don't need to consider any more productions for this n.\nastropy\/extern\/ply\/yacc.py:    # During execution of compute_first1, the result may be incomplete.\nastropy\/extern\/ply\/yacc.py:    # non-terminal.  See the Dragon book, 2nd Ed. p. 189.\nastropy\/extern\/ply\/yacc.py:        # Diagonistic information filled in by the table generator\nastropy\/extern\/ply\/yacc.py:    # The method used here is due to DeRemer and Pennelo (1982).\nastropy\/extern\/ply\/yacc.py:    # DeRemer, F. L., and T. J. Pennelo: \"Efficient Computation of LALR(1)\nastropy\/extern\/ply\/yacc.py:    # Computes the DR(p,A) relationships for non-terminal transitions.  The input\nastropy\/extern\/ply\/yacc.py:    # Computes the READS() relation (p,A) READS (t,C).\nastropy\/extern\/ply\/yacc.py:    # Determines the lookback and includes relations\nastropy\/extern\/ply\/yacc.py:    # INCLUDES:\nastropy\/extern\/ply\/yacc.py:    # Computes the INCLUDE() relation (p,A) INCLUDES (p',B).\nastropy\/extern\/ply\/yacc.py:    # inside of other non-terminal transition states.   (p,A) INCLUDES (p', B)\nastropy\/extern\/ply\/yacc.py:        lookdict = {}          # Dictionary of lookback relations\nastropy\/extern\/ply\/yacc.py:        includedict = {}       # Dictionary of include relations\nastropy\/extern\/ply\/yacc.py:    # Follow(p,A) = Read(p,A) U U {Follow(p',B) | (p,A) INCLUDES (p',B)}\nastropy\/extern\/ply\/yacc.py:        # Determine all of the nullable nonterminals\nastropy\/extern\/ply\/yacc.py:                                        # Do a precedence check.\nastropy\/extern\/ply\/yacc.py:# This file is automatically generated. Do not edit.\nastropy\/extern\/ply\/yacc.py:    # Determine if the module is package of a package or not.\nastropy\/constants\/tests\/test_constant.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/configobj\/validate.py:# Michael Foord: fuzzyman AT voidspace DOT org DOT uk\nastropy\/extern\/configobj\/validate.py:# Mark Andrews: mark AT la-la DOT com\nastropy\/extern\/configobj\/validate.py:# Nicola Larosa: nico AT tekNico DOT net\nastropy\/extern\/configobj\/validate.py:# Rob Dennis: rdennis AT gmail DOT com\nastropy\/extern\/configobj\/validate.py:# Eli Courtwright: eli AT courtwright DOT org\nastropy\/extern\/configobj\/validate.py:# This software is licensed under the terms of the BSD license.\nastropy\/extern\/configobj\/validate.py:# http:\/\/opensource.org\/licenses\/BSD-3-Clause\nastropy\/extern\/configobj\/validate.py:# https:\/\/github.com\/DiffSK\/configobj\nastropy\/extern\/configobj\/validate.py:    'numToDottedQuad',\nastropy\/extern\/configobj\/validate.py:#TODO - #21 - six is part of the repo now, but we didn't switch over to it here\nastropy\/extern\/configobj\/validate.py:''', re.VERBOSE | re.DOTALL)    # two groups\nastropy\/extern\/configobj\/validate.py:''', re.VERBOSE | re.DOTALL)    # one group\nastropy\/extern\/configobj\/validate.py:def numToDottedQuad(num):\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(long(-1))\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(long(1))\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(long(16777218))\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(long(16908291))\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(long(16909060))\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(long(4294967295))\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(long(4294967296))\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(-1)\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(1)\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(16777218)\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(16908291)\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(16909060)\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(4294967295)\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(4294967296)\nastropy\/extern\/configobj\/validate.py:    _func_re = re.compile(r'(.+?)\\((.*)\\)', re.DOTALL)\nastropy\/extern\/configobj\/validate.py:    _key_arg = re.compile(r'^([a-zA-Z_][a-zA-Z0-9_]*)\\s*=\\s*(.*)$',  re.DOTALL)\nastropy\/extern\/configobj\/validate.py:    _paramfinder = re.compile(_paramstring, re.VERBOSE | re.DOTALL)\nastropy\/extern\/configobj\/validate.py:    _matchfinder = re.compile(_matchstring, re.VERBOSE | re.DOTALL)\nastropy\/extern\/configobj\/validate.py:        # Default must be deleted if the value is specified too,\nastropy\/extern\/configobj\/validate.py:        Dummy check that always passes\nastropy\/extern\/configobj\/validate.py:        optionflags=doctest.IGNORE_EXCEPTION_DETAIL | doctest.ELLIPSIS)\nexamples\/template\/example-template.py:*License: BSD*\nexamples\/template\/example-template.py:    \"\"\"Dummy function to make sure docstrings don't get rendered as text\"\"\"\nastropy\/_erfa\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/_erfa\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/_erfa\/setup_package.py:ERFAPKGDIR = os.path.relpath(os.path.dirname(__file__))\nastropy\/_erfa\/setup_package.py:ERFA_SRC = os.path.abspath(os.path.join(ERFAPKGDIR, '..', '..', 'cextern', 'erfa'))\nastropy\/_erfa\/setup_package.py:SRC_FILES += [os.path.join(ERFAPKGDIR, filename)\nastropy\/_erfa\/setup_package.py:GEN_FILES = [os.path.join(ERFAPKGDIR, 'core.py'), os.path.join(ERFAPKGDIR, 'core.c')]\nastropy\/_erfa\/setup_package.py:        # Determine modification times\nastropy\/_erfa\/setup_package.py:    filename = os.path.join(ERFAPKGDIR, 'erfa_generator.py')\nastropy\/_erfa\/setup_package.py:    gen.main(gen.DEFAULT_ERFA_LOC,\nastropy\/_erfa\/setup_package.py:             os.path.join(ERFAPKGDIR, 'core.py'),\nastropy\/_erfa\/setup_package.py:             gen.DEFAULT_TEMPLATE_LOC,\nastropy\/_erfa\/setup_package.py:    sources = [os.path.join(ERFAPKGDIR, \"core.c\")]\nastropy\/extern\/ply\/cpp.py:# Author:  David Beazley (http:\/\/www.dabeaz.com)\nastropy\/extern\/ply\/cpp.py:# Default preprocessor lexer definitions.   These tokens are enough to get\nastropy\/extern\/ply\/cpp.py:   'CPP_ID','CPP_INTEGER', 'CPP_FLOAT', 'CPP_STRING', 'CPP_CHAR', 'CPP_WS', 'CPP_COMMENT1', 'CPP_COMMENT2', 'CPP_POUND','CPP_DPOUND'\nastropy\/extern\/ply\/cpp.py:t_CPP_POUND = r'\\#'\nastropy\/extern\/ply\/cpp.py:t_CPP_DPOUND = r'\\#\\#'\nastropy\/extern\/ply\/cpp.py:t_CPP_ID = r'[A-Za-z_][\\w_]*'\nastropy\/extern\/ply\/cpp.py:        self.define(\"__DATE__ \\\"%s\\\"\" % time.strftime(\"%b %d %Y\",tm))\nastropy\/extern\/ply\/cpp.py:        # Determine the token type for identifiers\nastropy\/extern\/ply\/cpp.py:            self.t_ID = tok.type\nastropy\/extern\/ply\/cpp.py:        # Determine the token type for integers\nastropy\/extern\/ply\/cpp.py:        # Determine the token type for strings enclosed in double quotes\nastropy\/extern\/ply\/cpp.py:        # Determine the token type for whitespace--if any\nastropy\/extern\/ply\/cpp.py:        # Determine the token type for newlines\nastropy\/extern\/ply\/cpp.py:            if macro.value[i].type == self.t_ID and macro.value[i].value in macro.arglist:\nastropy\/extern\/ply\/cpp.py:                        ((i+1) < len(macro.value)) and (macro.value[i+1].type == self.t_ID) and \\\nastropy\/extern\/ply\/cpp.py:            if t.type == self.t_ID:\nastropy\/extern\/ply\/cpp.py:            if tokens[i].type == self.t_ID and tokens[i].value == 'defined':\nastropy\/extern\/ply\/cpp.py:                    elif tokens[j].type == self.t_ID:\nastropy\/extern\/ply\/cpp.py:            if t.type == self.t_ID:\nastropy\/extern\/ply\/cpp.py:                while tokens[i].value[-1] not in \"0123456789abcdefABCDEF\":\nastropy\/extern\/ply\/cpp.py:    # Define a new macro\nastropy\/extern\/ply\/cpp.py:                        a[0].type = self.t_ID\nastropy\/extern\/ply\/cpp.py:                    elif astr[-3:] == \"...\" and a[0].type == self.t_ID:\nastropy\/extern\/ply\/cpp.py:                    if len(a) > 1 or a[0].type != self.t_ID:\nastropy\/extern\/configobj\/configobj.py:# Michael Foord: fuzzyman AT voidspace DOT org DOT uk\nastropy\/extern\/configobj\/configobj.py:# Nicola Larosa: nico AT tekNico DOT net\nastropy\/extern\/configobj\/configobj.py:# Rob Dennis: rdennis AT gmail DOT com\nastropy\/extern\/configobj\/configobj.py:# Eli Courtwright: eli AT courtwright DOT org\nastropy\/extern\/configobj\/configobj.py:# This software is licensed under the terms of the BSD license.\nastropy\/extern\/configobj\/configobj.py:# http:\/\/opensource.org\/licenses\/BSD-3-Clause\nastropy\/extern\/configobj\/configobj.py:# https:\/\/github.com\/DiffSK\/configobj\nastropy\/extern\/configobj\/configobj.py:# TODO: the list of aliases is not meant to be exhaustive, is there a\nastropy\/extern\/configobj\/configobj.py:    'DEFAULT_INDENT_TYPE',\nastropy\/extern\/configobj\/configobj.py:    'DEFAULT_INTERPOLATION',\nastropy\/extern\/configobj\/configobj.py:    'DuplicateError',\nastropy\/extern\/configobj\/configobj.py:DEFAULT_INTERPOLATION = 'configparser'\nastropy\/extern\/configobj\/configobj.py:DEFAULT_INDENT_TYPE = '    '\nastropy\/extern\/configobj\/configobj.py:MAX_INTERPOL_DEPTH = 10\nastropy\/extern\/configobj\/configobj.py:OPTION_DEFAULTS = {\nastropy\/extern\/configobj\/configobj.py:    def build_Dict(self, o):\nastropy\/extern\/configobj\/configobj.py:class DuplicateError(ConfigObjError):\nastropy\/extern\/configobj\/configobj.py:            # try \"DEFAULT\" next\nastropy\/extern\/configobj\/configobj.py:            val = current_section.get('DEFAULT', {}).get(key)\nastropy\/extern\/configobj\/configobj.py:    Interpolation is tried first from this object, then from the 'DEFAULT'\nastropy\/extern\/configobj\/configobj.py:    section of this object, next from the parent and its 'DEFAULT' section,\nastropy\/extern\/configobj\/configobj.py:                name = DEFAULT_INTERPOLATION\nastropy\/extern\/configobj\/configobj.py:        'D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\nastropy\/extern\/configobj\/configobj.py:        \"\"\"D.items() -> list of D's (key, value) pairs, as 2-tuples\"\"\"\nastropy\/extern\/configobj\/configobj.py:        \"\"\"D.keys() -> list of D's keys\"\"\"\nastropy\/extern\/configobj\/configobj.py:        \"\"\"D.values() -> list of D's values\"\"\"\nastropy\/extern\/configobj\/configobj.py:        \"\"\"D.iteritems() -> an iterator over the (key, value) items of D\"\"\"\nastropy\/extern\/configobj\/configobj.py:        \"\"\"D.iterkeys() -> an iterator over the keys of D\"\"\"\nastropy\/extern\/configobj\/configobj.py:        \"\"\"D.itervalues() -> an iterator over the values of D\"\"\"\nastropy\/extern\/configobj\/configobj.py:                    # TODO: Why do we raise a KeyError here?\nastropy\/extern\/configobj\/configobj.py:        >>> a.as_float('a')  #doctest: +IGNORE_EXCEPTION_DETAIL\nastropy\/extern\/configobj\/configobj.py:                          DeprecationWarning)\nastropy\/extern\/configobj\/configobj.py:            # TODO: check the values too.\nastropy\/extern\/configobj\/configobj.py:                if entry not in OPTION_DEFAULTS:\nastropy\/extern\/configobj\/configobj.py:            for entry, value in list(OPTION_DEFAULTS.items()):\nastropy\/extern\/configobj\/configobj.py:            options = OPTION_DEFAULTS\nastropy\/extern\/configobj\/configobj.py:        ``UnicodeDecodeError``.\nastropy\/extern\/configobj\/configobj.py:            # TODO: if encoding is just UTF16 - we ought to check for both\nastropy\/extern\/configobj\/configobj.py:            # TODO: big endian and little endian versions.\nastropy\/extern\/configobj\/configobj.py:                        # Don't need to remove BOM\nastropy\/extern\/configobj\/configobj.py:                # If we get this far, will *probably* raise a DecodeError\nastropy\/extern\/configobj\/configobj.py:        \"\"\"Decode ASCII strings to unicode if a self.encoding is specified.\"\"\"\nastropy\/extern\/configobj\/configobj.py:        Decode infile to unicode. Using the specified encoding.\nastropy\/extern\/configobj\/configobj.py:            # NOTE: Could raise a ``UnicodeDecodeError``\nastropy\/extern\/configobj\/configobj.py:                    # NOTE: Or could raise a ``UnicodeDecodeError``\nastropy\/extern\/configobj\/configobj.py:        \"\"\"Decode element to unicode if necessary.\"\"\"\nastropy\/extern\/configobj\/configobj.py:    # TODO: this may need to be modified\nastropy\/extern\/configobj\/configobj.py:                    self._handle_error('Duplicate section name',\nastropy\/extern\/configobj\/configobj.py:                                       DuplicateError, infile, cur_index)\nastropy\/extern\/configobj\/configobj.py:                        'Duplicate keyword name',\nastropy\/extern\/configobj\/configobj.py:                        DuplicateError, infile, cur_index)\nastropy\/extern\/configobj\/configobj.py:        * Don't quote values that don't need it.\nastropy\/extern\/configobj\/configobj.py:        \"\"\"Deal with a comment.\"\"\"\nastropy\/extern\/configobj\/configobj.py:            self.indent_type = DEFAULT_INDENT_TYPE\nastropy\/extern\/configobj\/configobj.py:            # FIXME: this means DEFAULT is not copied in copy mode\nastropy\/extern\/configobj\/configobj.py:            if section is self and entry == 'DEFAULT':\nastropy\/extern\/configobj\/configobj.py:        for entry in OPTION_DEFAULTS:\nexamples\/coordinates\/rv-to-gsr.py:*License: BSD*\nexamples\/coordinates\/rv-to-gsr.py:# velocity of the star HD 155967, as obtained from\nexamples\/coordinates\/rv-to-gsr.py:# `~astropy.coordinates.CartesianDifferential` object ``galcen_v_sun``:\nexamples\/coordinates\/rv-to-gsr.py:        The 3D velocity of the solar system barycenter in the GSR frame.\nexamples\/coordinates\/rv-to-gsr.py:        Defaults to the same solar motion as in the\nastropy\/extern\/bundled\/six.py:# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nastropy\/extern\/bundled\/six.py:# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nastropy\/extern\/bundled\/six.py:# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nastropy\/extern\/bundled\/six.py:# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nastropy\/extern\/bundled\/six.py:# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nastropy\/extern\/bundled\/six.py:class _LazyDescr(object):\nastropy\/extern\/bundled\/six.py:class MovedModule(_LazyDescr):\nastropy\/extern\/bundled\/six.py:class MovedAttribute(_LazyDescr):\nastropy\/extern\/bundled\/six.py:    MovedAttribute(\"UserDict\", \"UserDict\", \"collections\"),\nastropy\/extern\/bundled\/six.py:    MovedModule(\"tkinter_dialog\", \"Dialog\", \"tkinter.dialog\"),\nastropy\/extern\/bundled\/six.py:    MovedModule(\"tkinter_filedialog\", \"FileDialog\", \"tkinter.filedialog\"),\nastropy\/extern\/bundled\/six.py:    MovedModule(\"tkinter_simpledialog\", \"SimpleDialog\", \"tkinter.simpledialog\"),\nastropy\/extern\/bundled\/six.py:    MovedModule(\"tkinter_commondialog\", \"tkCommonDialog\",\nastropy\/extern\/bundled\/six.py:    MovedModule(\"tkinter_tkfiledialog\", \"tkFileDialog\", \"tkinter.filedialog\"),\nastropy\/extern\/bundled\/six.py:    MovedModule(\"tkinter_tksimpledialog\", \"tkSimpleDialog\",\nastropy\/extern\/bundled\/six.py:    MovedAttribute(\"OpenerDirector\", \"urllib2\", \"urllib.request\"),\nastropy\/extern\/bundled\/six.py:    MovedAttribute(\"HTTPDefaultErrorHandler\", \"urllib2\", \"urllib.request\"),\nastropy\/extern\/bundled\/six.py:    MovedAttribute(\"HTTPPasswordMgrWithDefaultRealm\", \"urllib2\", \"urllib.request\"),\nastropy\/extern\/bundled\/six.py:    MovedAttribute(\"AbstractDigestAuthHandler\", \"urllib2\", \"urllib.request\"),\nastropy\/extern\/bundled\/six.py:    MovedAttribute(\"HTTPDigestAuthHandler\", \"urllib2\", \"urllib.request\"),\nastropy\/extern\/bundled\/six.py:    MovedAttribute(\"ProxyDigestAuthHandler\", \"urllib2\", \"urllib.request\"),\nastropy\/extern\/bundled\/six.py:              updated=functools.WRAPPER_UPDATES):\nexamples\/coordinates\/plot_obs-planning.py:Determining and plotting the altitude\/azimuth of a celestial object\nexamples\/coordinates\/plot_obs-planning.py:*License: BSD*\nexamples\/coordinates\/plot_obs-planning.py:# Mountain and set the time to 11pm EDT on 2012 July 12:\nexamples\/coordinates\/plot_obs-planning.py:utcoffset = -4*u.hour  # Eastern Daylight Time\nexamples\/coordinates\/plot_obs-planning.py:# and 7am EDT:\nexamples\/coordinates\/plot_obs-planning.py:plt.xlabel('Hours from EDT Midnight')\nexamples\/coordinates\/plot_obs-planning.py:# Do the same with `~astropy.coordinates.get_moon` to find when the moon is\nexamples\/coordinates\/plot_obs-planning.py:plt.xlabel('Hours from EDT Midnight')\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:Dwarf Galaxy (hereafter Sgr; as defined in Majewski et al. 2003).  The Sgr\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:  Dwarf Galaxy. I. Morphology of the Sagittarius Core and Tidal Arms\",\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:* Law & Majewski 2010, \"The Sagittarius Dwarf Galaxy: A Model for Evolution in a\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:* David Law's Sgr info page http:\/\/www.stsci.edu\/~dlaw\/Sgr\/\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:*License: BSD*\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:        The Distance for this object along the line-of-sight.\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:        The proper motion in Declination for this object (``pm_ra_cosdec`` must\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:    default_differential = coord.SphericalCosLatDifferential\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:        coord.SphericalCosLatDifferential: [\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:        coord.SphericalDifferential: [\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:    frame_specific_representation_info[coord.UnitSphericalCosLatDifferential] = \\\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:        frame_specific_representation_info[coord.SphericalCosLatDifferential]\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:    frame_specific_representation_info[coord.UnitSphericalDifferential] = \\\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:        frame_specific_representation_info[coord.SphericalDifferential]\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:D = rotation_matrix(SGR_PHI, \"z\")\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:SGR_MATRIX = matrix_product(A, B, C, D)\nexamples\/coordinates\/plot_galactocentric-frame.py:*License: BSD*\nexamples\/coordinates\/plot_galactocentric-frame.py:# We'll use the data for the star HD 39881 from the `Simbad\nexamples\/coordinates\/plot_galactocentric-frame.py:# and velocity to a Galactocentric frame to see if it has a large 3D velocity\nexamples\/coordinates\/plot_galactocentric-frame.py:# `~astropy.coordinates.Galactocentric` instance to see the 3D Cartesian\nexamples\/coordinates\/plot_galactocentric-frame.py:# ``z_sun`` which set the sun-Galactic center distance, the 3D velocity vector\nexamples\/coordinates\/plot_galactocentric-frame.py:# `~astropy.coordinates.CartesianDifferential` instance, as in the example\nexamples\/coordinates\/plot_galactocentric-frame.py:v_sun = coord.CartesianDifferential([11.1, 244, 7.25]*u.km\/u.s)\nexamples\/coordinates\/plot_galactocentric-frame.py:                                 galcen_v_sun=coord.CartesianDifferential(vx, vy, vz),\nexamples\/coordinates\/plot_galactocentric-frame.py:ring_dif = coord.CylindricalDifferential(","role":"tool","tool_calls":null}],"task":"default","reward":0.0,"generation_ms":0.0,"scoring_ms":0.4224777222,"total_ms":0.4224777222,"info":{"instance_id":"astropy__astropy-6938","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/io\/fits\/fitsrec.py\": {\"old_start\": 1261, \"old_count\": 7, \"new_start\": 1261, \"new_count\": 7, \"hunks\": [{\"old_start\": 1261, \"old_count\": 7, \"new_start\": 1261, \"new_count\": 7}]}}","file_localization_reward":0.0}
{"example_id":0,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"Modeling's `separability_matrix` does not compute separability correctly for nested CompoundModels\nConsider the following model:\r\n\r\n```python\r\nfrom astropy.modeling import models as m\r\nfrom astropy.modeling.separable import separability_matrix\r\n\r\ncm = m.Linear1D(10) & m.Linear1D(5)\r\n```\r\n\r\nIt's separability matrix as you might expect is a diagonal:\r\n\r\n```python\r\n>>> separability_matrix(cm)\r\narray([[ True, False],\r\n       [False,  True]])\r\n```\r\n\r\nIf I make the model more complex:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5))\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True, False],\r\n       [False, False, False,  True]])\r\n```\r\n\r\nThe output matrix is again, as expected, the outputs and inputs to the linear models are separable and independent of each other.\r\n\r\nIf however, I nest these compound models:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & cm)\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True,  True],\r\n       [False, False,  True,  True]])\r\n```\r\nSuddenly the inputs and outputs are no longer separable?\r\n\r\nThis feels like a bug to me, but I might be missing something?\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-5bdf664a990a4fcca941d86af3fa408f\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'separability_matrix' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"astropy\/modeling\/separable.py:__all__ = [\"is_separable\", \"separability_matrix\"]\nastropy\/modeling\/separable.py:def separability_matrix(transform):\nastropy\/modeling\/separable.py:    >>> separability_matrix(Shift(1) & Shift(2) | Scale(1) & Scale(2))\nastropy\/modeling\/separable.py:    >>> separability_matrix(Shift(1) & Shift(2) | Rotation2D(2))\nastropy\/modeling\/separable.py:    >>> separability_matrix(Shift(1) & Shift(2) | Mapping([0, 1, 0, 1]) | \\\nastropy\/modeling\/separable.py:    >>> separability_matrix(Shift(1) & Shift(2) | Mapping([0, 1, 0, 1]))\nastropy\/modeling\/separable.py:    if (transform_matrix := transform._calculate_separability_matrix()) is not NotImplemented:\nastropy\/modeling\/tests\/test_models.py:from astropy.modeling.separable import separability_matrix\nastropy\/modeling\/tests\/test_models.py:    def _calculate_separability_matrix(self):\nastropy\/modeling\/tests\/test_models.py:def test_custom_separability_matrix():\nastropy\/modeling\/tests\/test_models.py:    original = separability_matrix(ModelDefault(slope=1, intercept=2))\nastropy\/modeling\/tests\/test_models.py:    custom = separability_matrix(ModelCustom(slope=1, intercept=2))\nastropy\/modeling\/tests\/test_separable.py:                                        _cstack, _arith_oper, separability_matrix)\nastropy\/modeling\/tests\/test_separable.py:    assert_allclose(separability_matrix(compound_model), result[1])\nastropy\/modeling\/tests\/test_separable.py:    assert np.all(separability_matrix(model_c()) == [True, True])\nastropy\/modeling\/tests\/test_core.py:from astropy.modeling.separable import separability_matrix\nastropy\/modeling\/tests\/test_core.py:    assert (separability_matrix(m) == [[True, True],\nastropy\/modeling\/tests\/test_core.py:    assert (separability_matrix(m) == [[True, True, True],\nastropy\/modeling\/core.py:    def _calculate_separability_matrix(self):","role":"tool","tool_calls":null},{"content":"\n\n<files>\nastropy\/modeling\/separable.py\nastropy\/modeling\/core.py\nastropy\/modeling\/tests\/test_separable.py\n<\/files>","role":"assistant","tool_calls":null}],"task":"default","reward":0.5,"generation_ms":45022.777557373,"scoring_ms":0.1075267792,"total_ms":45022.8850841522,"info":{"instance_id":"astropy__astropy-12907","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/modeling\/separable.py\": {\"old_start\": 242, \"old_count\": 7, \"new_start\": 242, \"new_count\": 7, \"hunks\": [{\"old_start\": 242, \"old_count\": 7, \"new_start\": 242, \"new_count\": 7}]}}","file_localization_reward":0.5}
{"example_id":1,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"Please support header rows in RestructuredText output\n### Description\r\n\r\nIt would be great if the following would work:\r\n\r\n```Python\r\n>>> from astropy.table import QTable\r\n>>> import astropy.units as u\r\n>>> import sys\r\n>>> tbl = QTable({'wave': [350,950]*u.nm, 'response': [0.7, 1.2]*u.count})\r\n>>> tbl.write(sys.stdout,  format=\"ascii.rst\")\r\n===== ========\r\n wave response\r\n===== ========\r\n350.0      0.7\r\n950.0      1.2\r\n===== ========\r\n>>> tbl.write(sys.stdout,  format=\"ascii.fixed_width\", header_rows=[\"name\", \"unit\"])\r\n|  wave | response |\r\n|    nm |       ct |\r\n| 350.0 |      0.7 |\r\n| 950.0 |      1.2 |\r\n>>> tbl.write(sys.stdout,  format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/table\/connect.py\", line 129, in __call__\r\n    self.registry.write(instance, *args, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/registry\/core.py\", line 369, in write\r\n    return writer(data, *args, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/ascii\/connect.py\", line 26, in io_write\r\n    return write(table, filename, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/ascii\/ui.py\", line 856, in write\r\n    writer = get_writer(Writer=Writer, fast_writer=fast_writer, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/ascii\/ui.py\", line 800, in get_writer\r\n    writer = core._get_writer(Writer, fast_writer, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/ascii\/core.py\", line 1719, in _get_writer\r\n    writer = Writer(**writer_kwargs)\r\nTypeError: RST.__init__() got an unexpected keyword argument 'header_rows'\r\n```\r\n\r\n\r\n### Additional context\r\n\r\nRestructuredText output is a great way to fill autogenerated documentation with content, so having this flexible makes the life easier `:-)`\r\n\r\n\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-264c47e2fba548be9d77fd6ede3f3bfb\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'RST' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-63d08e23ae8d43caa460c78ce72a2aae\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'header_rows' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-5b0c06c991c6434db3651d28fa7e9047\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'Writer' -t py | grep -E 'core.py|ascii.py'\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"docs\/conf.py:# This is added to the end of RST files - a good place to put substitutions to\nastropy\/units\/format\/ogip_lextab.py:_lextokens    = set(('CLOSE_PAREN', 'DIVISION', 'LIT10', 'OPEN_PAREN', 'SIGN', 'STAR', 'STARSTAR', 'UFLOAT', 'UINT', 'UNIT', 'UNKNOWN', 'WHITESPACE'))\nastropy\/units\/format\/ogip_lextab.py:_lexstatere   = {'INITIAL': [('(?P<t_UFLOAT>(((\\\\d+\\\\.?\\\\d*)|(\\\\.\\\\d+))([eE][+-]?\\\\d+))|(((\\\\d+\\\\.\\\\d*)|(\\\\.\\\\d+))([eE][+-]?\\\\d+)?))|(?P<t_UINT>\\\\d+)|(?P<t_SIGN>[+-](?=\\\\d))|(?P<t_X>[x\u00d7])|(?P<t_LIT10>10)|(?P<t_UNKNOWN>[Uu][Nn][Kk][Nn][Oo][Ww][Nn])|(?P<t_UNIT>[a-zA-Z][a-zA-Z_]*)|(?P<t_WHITESPACE>[ \\t]+)|(?P<t_STARSTAR>\\\\*\\\\*)|(?P<t_OPEN_PAREN>\\\\()|(?P<t_CLOSE_PAREN>\\\\))|(?P<t_STAR>\\\\*)|(?P<t_DIVISION>\/)', [None, ('t_UFLOAT', 'UFLOAT'), None, None, None, None, None, None, None, None, None, None, ('t_UINT', 'UINT'), ('t_SIGN', 'SIGN'), ('t_X', 'X'), ('t_LIT10', 'LIT10'), ('t_UNKNOWN', 'UNKNOWN'), ('t_UNIT', 'UNIT'), (None, 'WHITESPACE'), (None, 'STARSTAR'), (None, 'OPEN_PAREN'), (None, 'CLOSE_PAREN'), (None, 'STAR'), (None, 'DIVISION')])]}\nastropy\/units\/format\/ogip_parsetab.py:_lr_signature = 'CLOSE_PAREN DIVISION LIT10 OPEN_PAREN SIGN STAR STARSTAR UFLOAT UINT UNIT UNKNOWN WHITESPACE\\n            main : UNKNOWN\\n                 | complete_expression\\n                 | scale_factor complete_expression\\n                 | scale_factor WHITESPACE complete_expression\\n            \\n            complete_expression : product_of_units\\n            \\n            product_of_units : unit_expression\\n                             | division unit_expression\\n                             | product_of_units product unit_expression\\n                             | product_of_units division unit_expression\\n            \\n            unit_expression : unit\\n                            | UNIT OPEN_PAREN complete_expression CLOSE_PAREN\\n                            | OPEN_PAREN complete_expression CLOSE_PAREN\\n                            | UNIT OPEN_PAREN complete_expression CLOSE_PAREN power numeric_power\\n                            | OPEN_PAREN complete_expression CLOSE_PAREN power numeric_power\\n            \\n            scale_factor : LIT10 power numeric_power\\n                         | LIT10\\n                         | signed_float\\n                         | signed_float power numeric_power\\n                         | signed_int power numeric_power\\n            \\n            division : DIVISION\\n                     | WHITESPACE DIVISION\\n                     | WHITESPACE DIVISION WHITESPACE\\n                     | DIVISION WHITESPACE\\n            \\n            product : WHITESPACE\\n                    | STAR\\n                    | WHITESPACE STAR\\n                    | WHITESPACE STAR WHITESPACE\\n                    | STAR WHITESPACE\\n            \\n            power : STARSTAR\\n            \\n            unit : UNIT\\n                 | UNIT power numeric_power\\n            \\n            numeric_power : UINT\\n                          | signed_float\\n                          | OPEN_PAREN signed_int CLOSE_PAREN\\n                          | OPEN_PAREN signed_float CLOSE_PAREN\\n                          | OPEN_PAREN signed_float division UINT CLOSE_PAREN\\n            \\n            sign : SIGN\\n                 |\\n            \\n            signed_int : SIGN UINT\\n            \\n            signed_float : sign UINT\\n                         | sign UFLOAT\\n            '\nastropy\/units\/format\/ogip_parsetab.py:_lr_action_items = {'UNKNOWN':([0,],[2,]),'LIT10':([0,],[7,]),'SIGN':([0,25,26,27,28,34,47,59,63,],[13,48,-29,48,48,48,13,48,48,]),'UNIT':([0,4,7,8,11,16,17,19,20,21,22,23,24,30,31,33,36,38,39,42,43,44,45,46,49,50,54,55,60,61,67,],[15,15,-16,-17,15,15,-20,15,-21,15,15,-24,-25,-40,-41,15,-23,-20,-22,-26,-28,-15,-32,-33,-18,-19,-22,-27,-34,-35,-36,]),'OPEN_PAREN':([0,4,7,8,11,15,16,17,19,20,21,22,23,24,25,26,27,28,30,31,33,34,36,38,39,42,43,44,45,46,49,50,54,55,59,60,61,63,67,],[16,16,-16,-17,16,33,16,-20,16,-21,16,16,-24,-25,47,-29,47,47,-40,-41,16,47,-23,-20,-22,-26,-28,-15,-32,-33,-18,-19,-22,-27,47,-34,-35,47,-36,]),'DIVISION':([0,4,5,6,7,8,10,14,15,16,19,23,29,30,31,33,40,41,44,45,46,49,50,52,53,57,58,60,61,64,66,67,],[17,17,20,17,-16,-17,-6,-10,-30,17,38,20,-7,-40,-41,17,-8,-9,-15,-32,-33,-18,-19,-31,-12,17,-11,-34,-35,-14,-13,-36,]),'WHITESPACE':([0,4,6,7,8,10,14,15,16,17,19,20,24,29,30,31,33,38,40,41,42,44,45,46,49,50,52,53,57,58,60,61,64,66,67,],[5,19,23,-16,-17,-6,-10,-30,5,36,5,39,43,-7,-40,-41,5,54,-8,-9,55,-15,-32,-33,-18,-19,-31,-12,5,-11,-34,-35,-14,-13,-36,]),'UINT':([0,12,13,17,20,25,26,27,28,34,36,39,47,48,59,62,63,],[-38,30,32,-20,-21,45,-29,45,45,45,-23,-22,-38,-37,45,65,45,]),'UFLOAT':([0,12,13,25,26,27,28,34,47,48,59,63,],[-38,31,-37,-38,-29,-38,-38,-38,-38,-37,-38,-38,]),'$end':([1,2,3,6,10,14,15,18,29,30,31,37,40,41,45,46,52,53,58,60,61,64,66,67,],[0,-1,-2,-5,-6,-10,-30,-3,-7,-40,-41,-4,-8,-9,-32,-33,-31,-12,-11,-34,-35,-14,-13,-36,]),'CLOSE_PAREN':([6,10,14,15,29,30,31,32,35,40,41,45,46,51,52,53,56,57,58,60,61,64,65,66,67,],[-5,-6,-10,-30,-7,-40,-41,-39,53,-8,-9,-32,-33,58,-31,-12,60,61,-11,-34,-35,-14,67,-13,-36,]),'STAR':([6,10,14,15,23,29,30,31,40,41,45,46,52,53,58,60,61,64,66,67,],[24,-6,-10,-30,42,-7,-40,-41,-8,-9,-32,-33,-31,-12,-11,-34,-35,-14,-13,-36,]),'STARSTAR':([7,8,9,15,30,31,32,53,58,],[26,26,26,26,-40,-41,-39,26,26,]),}\nastropy\/units\/format\/ogip_parsetab.py:  ('power -> STARSTAR','power',1,'p_power','ogip.py',297),\nastropy\/units\/format\/ogip.py:        \"STARSTAR\",\nastropy\/units\/format\/ogip.py:        t_STARSTAR = r\"\\*\\*\"\nastropy\/units\/format\/ogip.py:            power : STARSTAR\nastropy\/io\/ascii\/ui.py:    # same for RST.\nastropy\/io\/ascii\/ui.py:        rst.RST,\nastropy\/io\/ascii\/rst.py:class SimpleRSTHeader(FixedWidthHeader):\nastropy\/io\/ascii\/rst.py:class SimpleRSTData(FixedWidthData):\nastropy\/io\/ascii\/rst.py:class RST(FixedWidth):\nastropy\/io\/ascii\/rst.py:    data_class = SimpleRSTData\nastropy\/io\/ascii\/rst.py:    header_class = SimpleRSTHeader\nastropy\/io\/ascii\/__init__.py:from .rst import RST\nastropy\/io\/ascii\/tests\/test_rst.py:    \"\"\"Normal SimpleRST Table\"\"\"\nastropy\/io\/ascii\/tests\/test_rst.py:    reader = ascii.get_reader(Reader=ascii.RST)\nastropy\/io\/ascii\/tests\/test_rst.py:    \"\"\"Normal SimpleRST Table with provided column names\"\"\"\nastropy\/io\/ascii\/tests\/test_rst.py:    reader = ascii.get_reader(Reader=ascii.RST, names=(\"name1\", \"name2\"))\nastropy\/io\/ascii\/tests\/test_rst.py:    \"\"\"Normal SimpleRST Table with provided column names\"\"\"\nastropy\/io\/ascii\/tests\/test_rst.py:        Reader=ascii.RST,\nastropy\/io\/ascii\/tests\/test_rst.py:    \"\"\"Nice, typical SimpleRST table with col name excluded\"\"\"\nastropy\/io\/ascii\/tests\/test_rst.py:    reader = ascii.get_reader(Reader=ascii.RST, exclude_names=(\"Col1\",))\nastropy\/io\/ascii\/tests\/test_rst.py:    reader = ascii.get_reader(Reader=ascii.RST)\nastropy\/io\/ascii\/tests\/test_rst.py:    reader = ascii.get_reader(Reader=ascii.RST)\nastropy\/io\/ascii\/tests\/test_rst.py:    reader = ascii.get_reader(Reader=ascii.RST)\nastropy\/io\/ascii\/tests\/test_rst.py:    reader = ascii.get_reader(Reader=ascii.RST)\nastropy\/io\/ascii\/tests\/test_rst.py:dat = ascii.read(table, Reader=ascii.RST)\nastropy\/io\/ascii\/tests\/test_rst.py:    \"\"\"Write a table as a normal SimpleRST Table\"\"\"\nastropy\/io\/ascii\/tests\/test_rst.py:    ascii.write(dat, out, Writer=ascii.RST)\nastropy\/io\/misc\/asdf\/tags\/coordinates\/frames.py:class ICRSType(CoordType):\nastropy\/io\/misc\/asdf\/tags\/coordinates\/frames.py:class ICRSType10(AstropyType):\nastropy\/time\/tests\/test_ut1.py:class TestTimeUT1SpecificIERSTable:\nastropy\/extern\/ply\/yacc.py:        self.First        = {}      # A dictionary of precomputed FIRST(x) symbols\nastropy\/extern\/ply\/yacc.py:    # Compute the value of FIRST1(beta) where beta is a tuple of symbols.\nastropy\/extern\/ply\/yacc.py:    # Compute the value of FIRST1(X) for all symbols","role":"tool","tool_calls":null},{"content":"astropy\/io\/ascii\/fixedwidth.py:        header_rows = getattr(self, \"header_rows\", [\"name\"])\nastropy\/io\/ascii\/fixedwidth.py:            line = self.get_line(lines, start_line + header_rows.index(\"name\"))\nastropy\/io\/ascii\/fixedwidth.py:        for ii, attr in enumerate(header_rows):\nastropy\/io\/ascii\/fixedwidth.py:        default_header_rows = [] if self.header.start_line is None else [\"name\"]\nastropy\/io\/ascii\/fixedwidth.py:        header_rows = getattr(self, \"header_rows\", default_header_rows)\nastropy\/io\/ascii\/fixedwidth.py:        for col_attr in header_rows:\nastropy\/io\/ascii\/fixedwidth.py:        header_rows=None,\nastropy\/io\/ascii\/fixedwidth.py:        if header_rows is None:\nastropy\/io\/ascii\/fixedwidth.py:            header_rows = [\"name\"]\nastropy\/io\/ascii\/fixedwidth.py:        self.header.header_rows = header_rows\nastropy\/io\/ascii\/fixedwidth.py:        self.data.header_rows = header_rows\nastropy\/io\/ascii\/fixedwidth.py:            self.data.start_line = len(header_rows)\nastropy\/io\/ascii\/fixedwidth.py:            header_rows=[],\nastropy\/io\/ascii\/fixedwidth.py:        header_rows=None,\nastropy\/io\/ascii\/fixedwidth.py:            delimiter_pad=delimiter_pad, bookend=bookend, header_rows=header_rows\nastropy\/io\/ascii\/fixedwidth.py:            position_line = len(self.header.header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:def test_fixed_width_header_rows():\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    header_rows = [\"dtype\", \"name\", \"unit\", \"format\", \"description\"]\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    dat = ascii.read(tbl, format=\"fixed_width\", delimiter=\"|\", header_rows=header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    ascii.write(dat, out, format=\"fixed_width\", delimiter=\"|\", header_rows=header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:def test_fixed_width_two_line_header_rows():\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    header_rows = [\"dtype\", \"unit\", \"format\", \"description\", \"name\"]\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    dat = ascii.read(tbl, format=\"fixed_width_two_line\", header_rows=header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    ascii.write(dat, out, format=\"fixed_width_two_line\", header_rows=header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:def test_fixed_width_no_header_header_rows():\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    with pytest.raises(TypeError, match=r\"unexpected keyword argument 'header_rows'\"):\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:        ascii.read(tbl, format=\"fixed_width_no_header\", header_rows=[\"unit\"])","role":"tool","tool_calls":null},{"content":"astropy\/io\/fits\/tests\/test_core.py:        fh = safeio.CatchZeroByteWriter(open(self.temp(\"bright.fits\"), mode=\"wb\"))\nastropy\/io\/fits\/tests\/test_core.py:        fh = safeio.CatchZeroByteWriter(open(self.temp(\"image.fits\"), mode=\"wb\"))\nastropy\/io\/ascii\/core.py:class CsvWriter:\nastropy\/io\/ascii\/core.py:    >>> from astropy.io.ascii.core import CsvWriter\nastropy\/io\/ascii\/core.py:    >>> writer = CsvWriter(delimiter=' ')\nastropy\/io\/ascii\/core.py:            self.csv_writer = CsvWriter(\nastropy\/io\/ascii\/core.py:def _get_writer(Writer, fast_writer, **kwargs):\nastropy\/io\/ascii\/core.py:    if issubclass(Writer, FastBasic):  # Fast writers handle args separately\nastropy\/io\/ascii\/core.py:        return Writer(**kwargs)\nastropy\/io\/ascii\/core.py:    elif fast_writer and f\"fast_{Writer._format_name}\" in FAST_CLASSES:\nastropy\/io\/ascii\/core.py:        return FAST_CLASSES[f\"fast_{Writer._format_name}\"](**kwargs)\nastropy\/io\/ascii\/core.py:    writer = Writer(**writer_kwargs)\nastropy\/io\/ascii\/core.py:            # whitespace.  This may have been changed in the Writer\nastropy\/io\/registry\/core.py:                f\"Writer for format '{data_format}' and class '{data_class.__name__}'\"","role":"tool","tool_calls":null},{"content":"\n\n<files>\nastropy\/io\/ascii\/rst.py\nastropy\/io\/ascii\/core.py\nastropy\/io\/ascii\/ui.py\n<\/files>","role":"assistant","tool_calls":null}],"task":"default","reward":0.5,"generation_ms":41307.8083992004,"scoring_ms":0.2360343933,"total_ms":41308.0444335938,"info":{"instance_id":"astropy__astropy-14182","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/io\/ascii\/rst.py\": {\"old_start\": 27, \"old_count\": 40, \"new_start\": 27, \"new_count\": 61, \"hunks\": [{\"old_start\": 27, \"old_count\": 7, \"new_start\": 27, \"new_count\": 6}, {\"old_start\": 39, \"old_count\": 12, \"new_start\": 38, \"new_count\": 29}, {\"old_start\": 57, \"old_count\": 10, \"new_start\": 73, \"new_count\": 15}]}}","file_localization_reward":0.5}
{"example_id":2,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"ascii.qdp Table format assumes QDP commands are upper case\n### Description\n\nascii.qdp assumes that commands in a QDP file are upper case, for example, for errors they must be \"READ SERR 1 2\" whereas QDP itself is not case sensitive and case use \"read serr 1 2\". \r\n\r\nAs many QDP files are created by hand, the expectation that all commands be all-caps should be removed.\n\n### Expected behavior\n\nThe following qdp file should read into a `Table` with errors, rather than crashing.\r\n```\r\nread serr 1 2 \r\n1 0.5 1 0.5\r\n```\n\n### How to Reproduce\n\nCreate a QDP file:\r\n```\r\n> cat > test.qdp\r\nread serr 1 2 \r\n1 0.5 1 0.5\r\n<EOF>\r\n\r\n > python\r\nPython 3.10.9 (main, Dec  7 2022, 02:03:23) [Clang 13.0.0 (clang-1300.0.29.30)] on darwin\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> from astropy.table import Table\r\n>>> Table.read('test.qdp',format='ascii.qdp')\r\nWARNING: table_id not specified. Reading the first available table [astropy.io.ascii.qdp]\r\nTraceback (most recent call last):\r\n...\r\n    raise ValueError(f'Unrecognized QDP line: {line}')\r\nValueError: Unrecognized QDP line: read serr 1 2\r\n```\r\n\r\nRunning \"qdp test.qdp\" works just fine.\r\n\n\n### Versions\n\nPython 3.10.9 (main, Dec  7 2022, 02:03:23) [Clang 13.0.0 (clang-1300.0.29.30)]\r\nastropy 5.1\r\nNumpy 1.24.1\r\npyerfa 2.0.0.1\r\nScipy 1.10.0\r\nMatplotlib 3.6.3\r\n\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-c6e62d6f7f9f4c7c8fd421b5ce070ad9\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'ascii\\\\\\\\.qdp' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-6ab428c2cca5436091051eb57b13da9f\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'QDP' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-20fd518fc6524f1e9812d08a6775f7c6\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'unrecognized QDP line' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"astropy\/io\/ascii\/qdp.py:        t = Table.read(example_qdp, format='ascii.qdp', table_id=1, names=['a', 'b', 'c', 'd'])\nastropy\/io\/ascii\/tests\/test_qdp.py:from astropy.io.ascii.qdp import _get_lines_from_file, _read_table_qdp, _write_table_qdp\nastropy\/io\/ascii\/tests\/test_qdp.py:        example_qdp, format=\"ascii.qdp\", table_id=1, names=[\"a\", \"b\", \"c\", \"d\"]\nastropy\/io\/ascii\/tests\/test_qdp.py:        example_qdp, format=\"ascii.qdp\", table_id=1, names=[\"a\", \"b\", \"c\", \"d\"]\nastropy\/io\/ascii\/tests\/test_qdp.py:        example_qdp, format=\"ascii.qdp\", table_id=1, names=[\"a\", \"b\", \"c\", \"d\"], sep=\",\"\nastropy\/io\/ascii\/tests\/test_qdp.py:    t1.write(test_file, format=\"ascii.qdp\")\nastropy\/io\/ascii\/tests\/test_qdp.py:        t2 = Table.read(test_file, format=\"ascii.qdp\")\nastropy\/io\/ascii\/tests\/test_qdp.py:    t1.write(test_file, format=\"ascii.qdp\")\nastropy\/io\/ascii\/tests\/test_qdp.py:    t2 = Table.read(test_file, table_id=0, format=\"ascii.qdp\", names=[\"a\"])","role":"tool","tool_calls":null},{"content":"astropy\/io\/ascii\/qdp.py:This package contains functions for reading and writing QDP tables that are\nastropy\/io\/ascii\/qdp.py:    \"\"\"Interpret a QDP file line.\nastropy\/io\/ascii\/qdp.py:    ValueError: Unrecognized QDP line...\nastropy\/io\/ascii\/qdp.py:    ValueError: Unrecognized QDP line...\nastropy\/io\/ascii\/qdp.py:        raise ValueError(f\"Unrecognized QDP line: {line}\")\nastropy\/io\/ascii\/qdp.py:    \"\"\"Read through the list of QDP file lines and label each line by type.\nastropy\/io\/ascii\/qdp.py:    \"\"\"Get all tables from a QDP file.\nastropy\/io\/ascii\/qdp.py:        Input QDP file name\nastropy\/io\/ascii\/qdp.py:        List containing all the tables present inside the QDP file\nastropy\/io\/ascii\/qdp.py:    \"\"\"Read a table from a QDP file.\nastropy\/io\/ascii\/qdp.py:        Input QDP file name\nastropy\/io\/ascii\/qdp.py:        Number of the table to be read from the QDP file. This is useful\nastropy\/io\/ascii\/qdp.py:        List containing all the tables present inside the QDP file\nastropy\/io\/ascii\/qdp.py:    \"\"\"Write a table to a QDP file.\nastropy\/io\/ascii\/qdp.py:        Output QDP file name\nastropy\/io\/ascii\/qdp.py:        which columns have symmetric and two-sided errors (see QDP format\nastropy\/io\/ascii\/qdp.py:class QDPSplitter(core.DefaultSplitter):\nastropy\/io\/ascii\/qdp.py:    Split on space for QDP tables.\nastropy\/io\/ascii\/qdp.py:class QDPHeader(basic.CommentedHeaderHeader):\nastropy\/io\/ascii\/qdp.py:    Header that uses the :class:`astropy.io.ascii.basic.QDPSplitter`.\nastropy\/io\/ascii\/qdp.py:    splitter_class = QDPSplitter\nastropy\/io\/ascii\/qdp.py:class QDPData(basic.BasicData):\nastropy\/io\/ascii\/qdp.py:    splitter_class = QDPSplitter\nastropy\/io\/ascii\/qdp.py:class QDP(basic.Basic):\nastropy\/io\/ascii\/qdp.py:    The QDP format differentiates between data and error columns. The table\nastropy\/io\/ascii\/qdp.py:    header_class = QDPHeader\nastropy\/io\/ascii\/qdp.py:    data_class = QDPData\nastropy\/io\/ascii\/tests\/test_write.py:        # QDP tables are for numeric values only\nastropy\/io\/ascii\/__init__.py:from .qdp import QDP","role":"tool","tool_calls":null},{"content":"Command failed with exit code 1","role":"tool","tool_calls":null},{"content":"\n\n<files>\nastropy\/io\/ascii\/qdp.py\nastropy\/io\/ascii\/tests\/test_qdp.py\n<\/files>","role":"assistant","tool_calls":null}],"task":"default","reward":0.6666666667,"generation_ms":47523.898601532,"scoring_ms":0.164270401,"total_ms":47524.062871933,"info":{"instance_id":"astropy__astropy-14365","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/io\/ascii\/qdp.py\": {\"old_start\": 68, \"old_count\": 245, \"new_start\": 68, \"new_count\": 245, \"hunks\": [{\"old_start\": 68, \"old_count\": 7, \"new_start\": 68, \"new_count\": 7}, {\"old_start\": 306, \"old_count\": 7, \"new_start\": 306, \"new_count\": 7}]}}","file_localization_reward":0.6666666667}
{"example_id":3,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"In v5.3, NDDataRef mask propagation fails when one of the operand does not have a mask\n### Description\n\nThis applies to v5.3. \r\n\r\nIt looks like when one of the operand does not have a mask, the mask propagation when doing arithmetic, in particular with `handle_mask=np.bitwise_or` fails.  This is not a problem in v5.2.\r\n\r\nI don't know enough about how all that works, but it seems from the error that the operand without a mask is set as a mask of None's and then the bitwise_or tries to operate on an integer and a None and fails.\n\n### Expected behavior\n\nWhen one of the operand does not have mask, the mask that exists should just be copied over to the output.  Or whatever was done in that situation in v5.2 where there's no problem.\n\n### How to Reproduce\n\nThis is with v5.3.   With v5.2, there are no errors.\r\n\r\n```\r\n>>> import numpy as np\r\n>>> from astropy.nddata import NDDataRef\r\n\r\n>>> array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\r\n>>> mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\r\n\r\n>>> nref_nomask = NDDataRef(array)\r\n>>> nref_mask = NDDataRef(array, mask=mask)\r\n\r\n# multiply no mask by constant (no mask * no mask)\r\n>>> nref_nomask.multiply(1., handle_mask=np.bitwise_or).mask   # returns nothing, no mask,  OK\r\n\r\n# multiply no mask by itself (no mask * no mask)\r\n>>> nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask # return nothing, no mask, OK\r\n\r\n# multiply mask by constant (mask * no mask)\r\n>>> nref_mask.multiply(1., handle_mask=np.bitwise_or).mask\r\n...\r\nTypeError: unsupported operand type(s) for |: 'int' and 'NoneType'\r\n\r\n# multiply mask by itself (mask * mask)\r\n>>> nref_mask.multiply(nref_mask, handle_mask=np.bitwise_or).mask\r\narray([[ 0,  1, 64],\r\n       [ 8,  0,  1],\r\n       [ 2,  1,  0]])\r\n\r\n# multiply mask by no mask (mask * no mask)\r\n>>> nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask\r\n...\r\nTypeError: unsupported operand type(s) for |: 'int' and 'NoneType'\r\n```\r\n\n\n### Versions\n\n>>> import sys; print(\"Python\", sys.version)\r\nPython 3.10.11 | packaged by conda-forge | (main, May 10 2023, 19:07:22) [Clang 14.0.6 ]\r\n>>> import astropy; print(\"astropy\", astropy.__version__)\r\nastropy 5.3\r\n>>> import numpy; print(\"Numpy\", numpy.__version__)\r\nNumpy 1.24.3\r\n>>> import erfa; print(\"pyerfa\", erfa.__version__)\r\npyerfa 2.0.0.3\r\n>>> import scipy; print(\"Scipy\", scipy.__version__)\r\nScipy 1.10.1\r\n>>> import matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\nMatplotlib 3.7.1\r\n\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-70a33c8a8eea4d19a6b25ad374094874\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'NDDataRef' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-8f849dd854d84b5f92e664cbfb002eb8\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'mask' -t py | grep 'NDDataRef'\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-ff435faf978f46c381e3f813bfbd64c7\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'multiply' -t py | grep 'NDDataRef'\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"astropy\/nddata\/nddata_withmixins.py:__all__ = [\"NDDataRef\"]\nastropy\/nddata\/nddata_withmixins.py:class NDDataRef(NDArithmeticMixin, NDIOMixin, NDSlicingMixin, NDData):\nastropy\/nddata\/nddata_withmixins.py:        >>> from astropy.nddata import NDDataRef, StdDevUncertainty\nastropy\/nddata\/nddata_withmixins.py:        >>> ndd1 = NDDataRef(data, uncertainty=StdDevUncertainty(data))\nastropy\/nddata\/nddata_withmixins.py:        >>> ndd2 = NDDataRef(data, uncertainty=StdDevUncertainty(data))\nastropy\/nddata\/nddata.py:    NDDataRef\nastropy\/nddata\/mixins\/ndslicing.py:    NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:# TODO: Make this use NDDataRef instead!\nastropy\/nddata\/mixins\/tests\/test_ndio.py:from astropy.nddata import NDData, NDDataRef, NDIOMixin  # noqa: F401\nastropy\/nddata\/mixins\/tests\/test_ndio.py:NDDataIO = NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:from astropy.nddata import NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:NDDataArithmetic = NDDataRef","role":"tool","tool_calls":null},{"content":"Command failed with exit code 1","role":"tool","tool_calls":null},{"content":"Command failed with exit code 1","role":"tool","tool_calls":null},{"content":"\n\n<files>\nastropy\/nddata\/nddata_withmixins.py\nastropy\/nddata\/nddata.py\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py\n<\/files>","role":"assistant","tool_calls":null}],"task":"default","reward":0.0,"generation_ms":48315.0453567505,"scoring_ms":0.1788139343,"total_ms":48315.2241706848,"info":{"instance_id":"astropy__astropy-14995","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/nddata\/mixins\/ndarithmetic.py\": {\"old_start\": 520, \"old_count\": 10, \"new_start\": 520, \"new_count\": 10, \"hunks\": [{\"old_start\": 520, \"old_count\": 10, \"new_start\": 520, \"new_count\": 10}]}}","file_localization_reward":0.0}
{"example_id":4,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"Possible bug in io.fits related to D exponents\nI came across the following code in ``fitsrec.py``:\r\n\r\n```python\r\n        # Replace exponent separator in floating point numbers\r\n        if 'D' in format:\r\n            output_field.replace(encode_ascii('E'), encode_ascii('D'))\r\n```\r\n\r\nI think this may be incorrect because as far as I can tell ``replace`` is not an in-place operation for ``chararray`` (it returns a copy). Commenting out this code doesn't cause any tests to fail so I think this code isn't being tested anyway.\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-e885fea2dffd42c68ddfd861f15802d8\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'D' -t py | grep -v 'fitsrec.py'\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-3e60ae97a0bc4a55a8c73f3142dfbef6\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'chararray' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-79f2d1d247fb427d9fdfc56bfb2185f1\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'replace' -t py | grep -v 'fitsrec.py'\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"setup.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nsetup.py:# Register ASDF extensions\nsetup.py:      author='The Astropy Developers',\nsetup.py:      license='BSD',\nsetup.py:          'License :: OSI Approved :: BSD License',\nah_bootstrap.py:    # This may raise a DistributionNotFound in which case no version of\nah_bootstrap.py:        # this results in DistributionNotFound we want to give up\nah_bootstrap.py:# later cause the TemporaryDirectory class defined in it to stop working when\nah_bootstrap.py:from setuptools import Distribution\nah_bootstrap.py:from distutils.debug import DEBUG\nah_bootstrap.py:# TODO: Maybe enable checking for a specific version of astropy_helpers?\nah_bootstrap.py:DIST_NAME = 'astropy-helpers'\nah_bootstrap.py:# Defaults for other options\nah_bootstrap.py:DOWNLOAD_IF_NEEDED = True\nah_bootstrap.py:INDEX_URL = 'https:\/\/pypi.python.org\/simple'\nah_bootstrap.py:AUTO_UPGRADE = True\nah_bootstrap.py:        self.index_url = index_url if index_url is not None else INDEX_URL\nah_bootstrap.py:                         else DOWNLOAD_IF_NEEDED)\nah_bootstrap.py:                             if auto_upgrade is not None else AUTO_UPGRADE)\nah_bootstrap.py:        # Declared as False by default--later we check if astropy-helpers can be\nah_bootstrap.py:            if DEBUG:\nah_bootstrap.py:        # custom command or even custom Distribution class defines an argument\nah_bootstrap.py:        # directory\/submodule its Distribution object gets a \"precedence\" of\nah_bootstrap.py:        # \"DEVELOP_DIST\".  However, in other cases it gets a precedence of\nah_bootstrap.py:        # \"EGG_DIST\".  However, when activing the distribution it will only be\nah_bootstrap.py:        # placed early on sys.path if it is treated as an EGG_DIST, so always\nah_bootstrap.py:        dist = dist.clone(precedence=pkg_resources.EGG_DIST)\nah_bootstrap.py:            if DEBUG:\nah_bootstrap.py:            log.warn('Downloading {0!r} disabled.'.format(DIST_NAME))\nah_bootstrap.py:            \"Downloading {0!r}; run setup.py with the --offline option to \"\nah_bootstrap.py:            \"force offline installation.\".format(DIST_NAME))\nah_bootstrap.py:            if DEBUG:\nah_bootstrap.py:                '{2}'.format(DIST_NAME, self.index_url, str(e)))\nah_bootstrap.py:        dist = ws.by_key.get(DIST_NAME)\nah_bootstrap.py:        # Distribution (such as options) before handling setup_requires, so it\nah_bootstrap.py:        class _Distribution(Distribution):\nah_bootstrap.py:                opts = Distribution.get_option_dict(self, command_name)\nah_bootstrap.py:            req = '{0}=={1}'.format(DIST_NAME, version)\nah_bootstrap.py:            req = DIST_NAME\nah_bootstrap.py:            if DEBUG:\nah_bootstrap.py:                _Distribution(attrs=attrs)\nah_bootstrap.py:                    _Distribution(attrs=attrs)\nah_bootstrap.py:            return pkg_resources.working_set.by_key.get(DIST_NAME)\nah_bootstrap.py:            if DEBUG:\nah_bootstrap.py:            elif index_url != INDEX_URL:\nah_bootstrap.py:            raise Exception(msg.format(DIST_NAME, source, repr(e)))\nah_bootstrap.py:            '{0}>{1},<{2}'.format(DIST_NAME, dist.version, next_version))\nah_bootstrap.py:        if DEBUG:\nah_bootstrap.py:        # Due to an OSX oddity locale.getdefaultlocale() can also crash\nah_bootstrap.py:class _DummyFile(object):\nah_bootstrap.py:    sys.stdout = _DummyFile()\nah_bootstrap.py:    sys.stderr = _DummyFile()\nah_bootstrap.py:        updates to any git submodule.  Defaults to `True`.\ndocs\/conf.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\ndocs\/conf.py:ON_RTD = os.environ.get('READTHEDOCS') == 'True'\ndocs\/conf.py:# Don't use the default - which includes a numpy and matplotlib import\ndocs\/conf.py:author = u'The Astropy Developers'\ndocs\/conf.py:latex_documents = [('index', project + '.tex', project + u' Documentation',\ndocs\/conf.py:man_pages = [('index', project.lower(), project + u' Documentation',\ndocs\/conf.py:# Don't import the module as \"version\" or it will override the\ndocs\/wcs\/examples\/from_file.py:    # Parse the WCS keywords in the primary HDU\ndocs\/wcs\/examples\/programmatic.py:w.wcs.ctype = [\"RA---AIR\", \"DEC--AIR\"]\ndocs\/wcs\/examples\/programmatic.py:# PrimaryHDU and write it to a file.\ndocs\/wcs\/examples\/programmatic.py:hdu = fits.PrimaryHDU(header=header)\nez_setup.py:This method is DEPRECATED. Check https:\/\/github.com\/pypa\/setuptools\/issues\/581 for more details.\nez_setup.py:DEFAULT_VERSION = \"33.1.1\"\nez_setup.py:DEFAULT_URL = \"https:\/\/pypi.io\/packages\/source\/s\/setuptools\/\"\nez_setup.py:DEFAULT_SAVE_DIR = os.curdir\nez_setup.py:DEFAULT_DEPRECATION_MESSAGE = \"ez_setup.py is deprecated and when using it setuptools will be pinned to {0} since it's the last version that supports setuptools self upgrade\/installation, check https:\/\/github.com\/pypa\/setuptools\/issues\/581 for more info; use pip to install setuptools\"\nez_setup.py:MEANINGFUL_INVALID_ZIP_ERR_MSG = 'Maybe {0} is corrupted, delete it and try again.'\nez_setup.py:log.warn(DEFAULT_DEPRECATION_MESSAGE.format(DEFAULT_VERSION))\nez_setup.py:                MEANINGFUL_INVALID_ZIP_ERR_MSG.format(filename),\nez_setup.py:    \"\"\"Download Setuptools.\"\"\"\nez_setup.py:        version=DEFAULT_VERSION, download_base=DEFAULT_URL,\nez_setup.py:        to_dir=DEFAULT_SAVE_DIR, download_delay=15):\nez_setup.py:    except pkg_resources.DistributionNotFound:\nez_setup.py:    Download the file at url to target using Powershell.\nez_setup.py:        \"[System.Net.WebRequest]::DefaultWebProxy.Credentials = \"\nez_setup.py:        \"[System.Net.CredentialCache]::DefaultCredentials; \"\nez_setup.py:        '(new-object System.Net.WebClient).DownloadFile(\"%(url)s\", \"%(target)s\")'\nez_setup.py:    \"\"\"Determine if Powershell is available.\"\"\"\nez_setup.py:        version=DEFAULT_VERSION, download_base=DEFAULT_URL,\nez_setup.py:        to_dir=DEFAULT_SAVE_DIR, delay=15,\nez_setup.py:    Download setuptools from a specified location and return its filename.\nez_setup.py:        log.warn(\"Downloading %s\", url)\nez_setup.py:        default=DEFAULT_URL,\nez_setup.py:        default=DEFAULT_VERSION,\nez_setup.py:        help=\"Directory to save (and re-use) package\",\nez_setup.py:        default=DEFAULT_SAVE_DIR,\nconftest.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/codegen.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/conftest.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/conftest.py:from astropy.tests.plugins.display import PYTEST_HEADER_MODULES\nastropy\/conftest.py:PYTEST_HEADER_MODULES['Cython'] = 'cython'\nexamples\/template\/example-template.py:*License: BSD*\nexamples\/template\/example-template.py:    \"\"\"Dummy function to make sure docstrings don't get rendered as text\"\"\"\nexamples\/io\/plot_fits-image.py:*License: BSD*\nexamples\/io\/plot_fits-image.py:# Download the example FITS files used by this example:\nexamples\/io\/plot_fits-image.py:# Generally the image information is located in the Primary HDU, also known\nexamples\/io\/plot_fits-image.py:# The data is now stored as a 2D numpy array. Print the dimensions using the\nexamples\/io\/plot_fits-image.py:# Display the image data:\nastropy\/utils\/data.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/data.py:        'Block size for computing MD5 file hashes.')\nastropy\/utils\/data.py:        from a remote server.  Default is `True`.\nastropy\/utils\/data.py:              file in ``astropy\/pkgname\/data\/file.dat``.  Double-dots\nastropy\/utils\/data.py:        ...                           encoding='binary') as fobj:  # doctest: +REMOTE_DATA\nastropy\/utils\/data.py:        Downloading http:\/\/data.astropy.org\/allsky\/allsky_rosat.fits [Done]\nastropy\/utils\/data.py:        ...                           encoding='binary', cache=False) as fobj:  # doctest: +REMOTE_DATA\nastropy\/utils\/data.py:        Downloading http:\/\/data.astropy.org\/allsky\/allsky_rosat.fits [Done]\nastropy\/utils\/data.py:              file in ``astropy\/pkgname\/data\/file.dat``.  Double-dots\nastropy\/utils\/data.py:        from a remote server.  Default is `True`.\nastropy\/utils\/data.py:              file in ``astropy\/pkgname\/data\/file.dat``.  Double-dots\nastropy\/utils\/data.py:    \"\"\" Computes the MD5 hash for a file.\nastropy\/utils\/data.py:        The hex digest of the MD5 hash for the contents of the ``localfn``\nastropy\/utils\/data.py:        retval = ctypes.windll.kernel32.GetDiskFreeSpaceExW(\nastropy\/utils\/data.py:    Determines if a given directory has enough space to hold a file of\nastropy\/utils\/data.py:    returning the filename, with a name determined by the file's MD5\nastropy\/utils\/data.py:            dlmsg = \"Downloading {0}\".format(remote_url)\nastropy\/utils\/data.py:    Downloads multiple files in parallel from the given URLs.  Blocks until\nastropy\/utils\/data.py:        warn(\"Disabling the cache does not work because of multiprocessing, it \"\nastropy\/utils\/data.py:        msg = 'Data cache directory {0} is not a directory'\nastropy\/utils\/data.py:        msg = 'Data cache shelve object location {0} is a directory'\nastropy\/extern\/six.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/astropyconst20.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/ply\/lex.py:# David M. Beazley (Dabeaz LLC)\nastropy\/extern\/ply\/lex.py:# * Neither the name of the David Beazley or Dabeaz LLC may be used to\nastropy\/extern\/ply\/lex.py:# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\nastropy\/extern\/ply\/lex.py:# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nastropy\/extern\/ply\/lex.py:# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nastropy\/extern\/ply\/lex.py:# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nastropy\/extern\/ply\/lex.py:# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nastropy\/extern\/ply\/lex.py:# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nastropy\/extern\/ply\/lex.py:# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nastropy\/extern\/ply\/lex.py:# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nastropy\/extern\/ply\/lex.py:# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nastropy\/extern\/ply\/lex.py:# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nastropy\/extern\/ply\/lex.py:# Null logger is used when no output is generated. Does nothing.\nastropy\/extern\/ply\/lex.py:        self.lexstatere = {}          # Dictionary mapping lexer states to master regexs\nastropy\/extern\/ply\/lex.py:        self.lexstateretext = {}      # Dictionary mapping lexer states to regex strings\nastropy\/extern\/ply\/lex.py:        self.lexstaterenames = {}     # Dictionary mapping lexer states to symbol names\nastropy\/extern\/ply\/lex.py:        self.lexstateignore = {}      # Dictionary of ignored characters for each state\nastropy\/extern\/ply\/lex.py:        self.lexstateerrorf = {}      # Dictionary of error functions for each state\nastropy\/extern\/ply\/lex.py:        self.lexstateeoff = {}        # Dictionary of eof functions for each state\nastropy\/extern\/ply\/lex.py:            tf.write('# %s.py. This file automatically created by PLY (version %s). Don\\'t edit!\\n' % (basetabmodule, __version__))\nastropy\/extern\/ply\/lex.py:    # as possible.  Don't make changes unless you really know what\nastropy\/extern\/ply\/lex.py:    # Determine if the module is package of a package or not.\nastropy\/extern\/ply\/lex.py:    # Dump some basic debugging information\nexamples\/io\/skip_create-large-fits.py:*License: BSD*\nexamples\/io\/skip_create-large-fits.py:hdu = fits.PrimaryHDU(data=data)\nexamples\/io\/skip_create-large-fits.py:# blocks, large enough for 36 keywords per block (including the END keyword in\nexamples\/io\/skip_create-large-fits.py:# use 4 blocks by default. Then, excluding the END card which Astropy will add\nexamples\/io\/skip_create-large-fits.py:# Create a stub array to initialize the HDU; its\nexamples\/io\/skip_create-large-fits.py:hdu = fits.PrimaryHDU(data=data)\nexamples\/io\/skip_create-large-fits.py:    # Data we want to write.\nastropy\/logger.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/logger.py:# log.setLevel(log.DEBUG), for example\nastropy\/logger.py:logging_levels = ['NOTSET', 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL',\nastropy\/logger.py:        \"will be ignored. The levels are ``'DEBUG'``, \"\nastropy\/logger.py:            loggerDict = logging.Logger.manager.loggerDict\nastropy\/logger.py:            for key in loggerDict.keys():\nastropy\/logger.py:                    del loggerDict[key]\nastropy\/logger.py:        # Deliberately not using isinstance here: We want to display\nastropy\/logger.py:        Disable logging of warnings.warn() calls\nastropy\/logger.py:        Determine if the exception-logging mechanism is enabled.\nastropy\/logger.py:        Disable logging of exceptions\nastropy\/logger.py:        Disable colorized output\nastropy\/logger.py:            'INFO', then setting ``filter_level`` to ``INFO`` or ``DEBUG``\nastropy\/logger.py:            'INFO', then setting ``filter_level`` to ``INFO`` or ``DEBUG``\nastropy\/logger.py:    A specialized StreamHandler that logs INFO and DEBUG messages to\nastropy\/logger.py:        if record.levelno < logging.DEBUG or not _conf.use_color:\nastropy\/utils\/state.py:            \"This class is a singleton.  Do not instantiate.\")\nastropy\/utils\/console.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/console.py:_DEFAULT_ENCODING = 'utf-8'\nastropy\/utils\/console.py:    \"\"\"Decode the supplied byte string using the preferred encoding\nastropy\/utils\/console.py:            enc = _DEFAULT_ENCODING\nastropy\/utils\/console.py:    except UnicodeDecodeError:\nastropy\/utils\/console.py:        Writer = codecs.getwriter(_DEFAULT_ENCODING)\nastropy\/utils\/console.py:        Where to write to.  Defaults to `sys.stdout`.  If file is not\nastropy\/utils\/console.py:        The ending of the message.  Defaults to ``\\\\n``.  The end will\nastropy\/utils\/console.py:    Depending on the number of seconds given, can be one of::\nastropy\/utils\/console.py:            The file to write the progress bar to.  Defaults to\nastropy\/utils\/console.py:                signal.signal(signal.SIGWINCH, signal.SIG_DFL)\nastropy\/utils\/console.py:        Does a `map` operation while displaying a progress bar with\nastropy\/utils\/console.py:            The file to write the progress bar to.  Defaults to\nastropy\/utils\/console.py:            The file to write the spinner to.  Defaults to\nastropy\/utils\/console.py:            color_print(' [Done]', 'green', file=file)\nastropy\/utils\/console.py:            The file to write the to.  Defaults to `sys.stdout`.  If\nastropy\/utils\/console.py:        Where to write to.  Defaults to `sys.stdout`.\nastropy\/utils\/console.py:        The number of spaces per tab (``'\\\\t'``) character.  Default\nastropy\/utils\/console.py:        truncated.  Defaults to 70 (this matches the default in the\nastropy\/utils\/console.py:            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\nastropy\/utils\/console.py:        if Carbon.Evt.EventAvail(0x0008)[0] == 0:  # 0x0008 is the keyDownMask\nastropy\/constants\/iau2012.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/iau2012.py:# DISTANCE\nastropy\/constants\/iau2012.py:              \"Derived from au\", system='si')\nastropy\/constants\/iau2012.py:               \"Derived from au\", system='si')\nastropy\/constants\/cgs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nexamples\/io\/split-jpeg-to-fits.py:*License: BSD*\nexamples\/io\/split-jpeg-to-fits.py:red = fits.PrimaryHDU(data=r_data)\nexamples\/io\/split-jpeg-to-fits.py:green = fits.PrimaryHDU(data=g_data)\nexamples\/io\/split-jpeg-to-fits.py:blue = fits.PrimaryHDU(data=b_data)\nexamples\/io\/split-jpeg-to-fits.py:# Delete the files created\nastropy\/cosmology\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/__init__.py:    '   Name        Value            Unit       Description',\nastropy\/utils\/exceptions.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/exceptions.py:class AstropyDeprecationWarning(AstropyWarning):\nastropy\/utils\/exceptions.py:class AstropyPendingDeprecationWarning(PendingDeprecationWarning, AstropyWarning):\nastropy\/utils\/misc.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/misc.py:from collections import defaultdict, OrderedDict\nastropy\/utils\/misc.py:           'JsonCustomEncoder', 'indent', 'InheritDocstrings',\nastropy\/utils\/misc.py:           'OrderedDescriptor', 'OrderedDescriptorContainer', 'set_locale',\nastropy\/utils\/misc.py:           'ShapedLikeNDArray', 'check_broadcast', 'IncompatibleShapeError',\nastropy\/utils\/misc.py:class _DummyFile:\nastropy\/utils\/misc.py:    sys.stdout = _DummyFile()\nastropy\/utils\/misc.py:    sys.stderr = _DummyFile()\nastropy\/utils\/misc.py:            raise ZeroDivisionError(\nastropy\/utils\/misc.py:    Determines the URL of the API page for the specified object, and\nastropy\/utils\/misc.py:        location that should be the *base* of the documentation. Defaults to\nastropy\/utils\/misc.py:    Determines if a given file or directory is hidden.\nastropy\/utils\/misc.py:        c for c in unicodedata.normalize('NFD', s)\nastropy\/utils\/misc.py:        Returns the string \"Did you mean X, Y, or Z?\", or the empty\nastropy\/utils\/misc.py:        return 'Did you mean {0}?'.format(matches)\nastropy\/utils\/misc.py:class InheritDocstrings(type):\nastropy\/utils\/misc.py:        >>> from astropy.utils.misc import InheritDocstrings\nastropy\/utils\/misc.py:        >>> class A(metaclass=InheritDocstrings):\nastropy\/utils\/misc.py:class OrderedDescriptor(metaclass=abc.ABCMeta):\nastropy\/utils\/misc.py:    `OrderedDescriptorContainer` metaclass.\nastropy\/utils\/misc.py:    Subclasses of `OrderedDescriptor` must define a value for a class attribute\nastropy\/utils\/misc.py:    `~collections.OrderedDict` at class creation time.  This\nastropy\/utils\/misc.py:    `~collections.OrderedDict` will contain a mapping of all class attributes\nastropy\/utils\/misc.py:    that were assigned instances of the `OrderedDescriptor` subclass, to the\nastropy\/utils\/misc.py:    `OrderedDescriptorContainer` for a concrete example.\nastropy\/utils\/misc.py:    Optionally, subclasses of `OrderedDescriptor` may define a value for a\nastropy\/utils\/misc.py:    # This id increments for each OrderedDescriptor instance created, so they\nastropy\/utils\/misc.py:        of all instances of that `OrderedDescriptor` subclass defined in the class\nastropy\/utils\/misc.py:        # different subclasses of OrderedDescriptors can be sorted correctly\nastropy\/utils\/misc.py:        self.__order = OrderedDescriptor._nextid\nastropy\/utils\/misc.py:        OrderedDescriptor._nextid += 1\nastropy\/utils\/misc.py:        Defined for convenient sorting of `OrderedDescriptor` instances, which\nastropy\/utils\/misc.py:        if (isinstance(self, OrderedDescriptor) and\nastropy\/utils\/misc.py:                isinstance(other, OrderedDescriptor)):\nastropy\/utils\/misc.py:class OrderedDescriptorContainer(type):\nastropy\/utils\/misc.py:    Classes should use this metaclass if they wish to use `OrderedDescriptor`\nastropy\/utils\/misc.py:    Every subclass of `OrderedDescriptor` has an attribute called\nastropy\/utils\/misc.py:        class ExampleDecorator(OrderedDescriptor):\nastropy\/utils\/misc.py:    Then when a class with the `OrderedDescriptorContainer` metaclass is\nastropy\/utils\/misc.py:    referencing an `~collections.OrderedDict` containing all instances of\nastropy\/utils\/misc.py:    ``ExampleDecorator`` defined in the class body, mapped to by the names of\nastropy\/utils\/misc.py:    `OrderedDescriptor` classes that *should* be added from base classes.\nastropy\/utils\/misc.py:    >>> from astropy.utils import OrderedDescriptor, OrderedDescriptorContainer\nastropy\/utils\/misc.py:    >>> class TypedAttribute(OrderedDescriptor):\nastropy\/utils\/misc.py:        >>> class Point2D(metaclass=OrderedDescriptorContainer):\nastropy\/utils\/misc.py:        >>> p1 = Point2D(1.0, 2.0)\nastropy\/utils\/misc.py:        >>> p2 = Point2D('a', 'b')  # doctest: +IGNORE_EXCEPTION_DETAIL\nastropy\/utils\/misc.py:        ValueError: Point2D.x must be of type (float, int>)\nastropy\/utils\/misc.py:    `OrderedDescriptorContainer` did for us::\nastropy\/utils\/misc.py:        >>> Point2D.typed_attributes\nastropy\/utils\/misc.py:        OrderedDict([('x', <TypedAttribute(name=x, type=(float, int))>),\nastropy\/utils\/misc.py:        >>> class Point3D(Point2D):\nastropy\/utils\/misc.py:        >>> Point3D.typed_attributes\nastropy\/utils\/misc.py:        OrderedDict([('z', <TypedAttribute(name=z, type=(float, int))>)])\nastropy\/utils\/misc.py:    However, if we specify ``_inherit_descriptors_`` from ``Point2D`` then\nastropy\/utils\/misc.py:        >>> class Point3D(Point2D):\nastropy\/utils\/misc.py:        >>> Point3D.typed_attributes\nastropy\/utils\/misc.py:        OrderedDict([('x', <TypedAttribute(name=x, type=(float, int))>),\nastropy\/utils\/misc.py:        also allows a class of type `OrderedDescriptorContainer` to use\nastropy\/utils\/misc.py:        multiple different `OrderedDescriptor` classes simultaneously.\nastropy\/utils\/misc.py:                if (not isinstance(obj, OrderedDescriptor) or\nastropy\/utils\/misc.py:                # Don't just use the descriptor's class directly; instead go\nastropy\/utils\/misc.py:                # OrderedDescriptor *may* override _class_attribute_ and have\nastropy\/utils\/misc.py:                # some OrderedDescriptor are still grouped together\nastropy\/utils\/misc.py:                # TODO: It might be worth clarifying this in the docs\nastropy\/utils\/misc.py:                # any OrderedDescriptors from any of the base classes, and\nastropy\/utils\/misc.py:            instances = OrderedDict((key, value) for value, key in instances)\nastropy\/utils\/misc.py:            # Don't do anything if locale is already the requested locale\nastropy\/utils\/misc.py:class ShapedLikeNDArray(metaclass=abc.ABCMeta):\nastropy\/utils\/misc.py:        using ``ShapedLikeNDArray``).\nastropy\/utils\/misc.py:    Determines whether two or more Numpy arrays can be broadcast with each\nastropy\/utils\/metadata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/metadata.py:from collections import OrderedDict\nastropy\/utils\/metadata.py:           'MergeStrategyMeta', 'enable_merge_strategies', 'merge', 'MetaData']\nastropy\/utils\/metadata.py:class MetaData:\nastropy\/utils\/metadata.py:        Documentation for the attribute of the class.\nastropy\/utils\/metadata.py:        Default is ``\"\"``.\nastropy\/utils\/metadata.py:        Default is ``True``.\nastropy\/utils\/metadata.py:            instance._meta = OrderedDict()\nastropy\/utils\/metadata.py:            instance._meta = OrderedDict()\nastropy\/units\/astrophys.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/astrophys.py:def_unit(['u', 'Da', 'Dalton'], _si.u, namespace=_ns,\nastropy\/units\/astrophys.py:# SPECTRAL DENSITY\nastropy\/units\/astrophys.py:# TODO: This is defined by the FITS standard as \"relative to the sun\".\nastropy\/units\/astrophys.py:# DOCSTRING\nastropy\/wcs\/tests\/test_pickle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/unescaper.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/unescaper.py:# STDLIB\nastropy\/utils\/xml\/unescaper.py:# This is DIY\nastropy\/wcs\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/physical.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/physical.py:Defines physical unit names.\nastropy\/utils\/xml\/check.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/check.py:def check_id(ID):\nastropy\/utils\/xml\/check.py:    Returns `True` if *ID* is a valid XML ID.\nastropy\/utils\/xml\/check.py:    return re.match(r\"^[A-Za-z_][A-Za-z0-9_\\.\\-]*$\", ID) is not None\nastropy\/utils\/xml\/check.py:def fix_id(ID):\nastropy\/utils\/xml\/check.py:    if re.match(r\"^[A-Za-z_][A-Za-z0-9_\\.\\-]*$\", ID):\nastropy\/utils\/xml\/check.py:        return ID\nastropy\/utils\/xml\/check.py:    if len(ID):\nastropy\/utils\/xml\/check.py:        corrected = ID\nastropy\/units\/required_by_vounit.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/required_by_vounit.py:# DOCSTRING\nastropy\/units\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/__init__.py:code under a BSD license.\nastropy\/utils\/xml\/writer.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/writer.py:# STDLIB\nastropy\/utils\/xml\/writer.py:        Escapes &, < and > in an XML CDATA string.\nastropy\/units\/format\/generic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/generic.py:        'DOUBLE_STAR',\nastropy\/units\/format\/generic.py:        'PERIOD',\nastropy\/units\/format\/generic.py:        'SOLIDUS',\nastropy\/units\/format\/generic.py:        t_PERIOD = r'\\.'\nastropy\/units\/format\/generic.py:        t_SOLIDUS = r'\/'\nastropy\/units\/format\/generic.py:        t_DOUBLE_STAR = r'\\*\\*'\nastropy\/units\/format\/generic.py:        # NOTE THE ORDERING OF THESE RULES IS IMPORTANT!!\nastropy\/units\/format\/generic.py:                        reflags=re.UNICODE)\nastropy\/units\/format\/generic.py:                    | PERIOD\nastropy\/units\/format\/generic.py:            division : SOLIDUS\nastropy\/units\/format\/generic.py:            power : DOUBLE_STAR\nastropy\/units\/format\/fits.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/fits.py:            'ct', 'photon', 'ph', 'pixel', 'pix', 'D', 'Sun', 'chan',\nastropy\/units\/format\/console.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/py3_test_quantity_annotations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/generic_parsetab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/generic_parsetab.py:# This file is automatically generated. Do not edit.\nastropy\/units\/format\/generic_parsetab.py:_lr_signature = 'A63D4C561E2ED1A045DB279536CAFDDA'\nastropy\/units\/format\/generic_parsetab.py:_lr_action_items = {'CARET':([16,17,29,42,],[39,39,39,39,]),'FUNCNAME':([0,1,4,5,7,8,9,14,15,16,17,19,20,21,22,24,25,27,31,33,34,35,36,45,52,55,58,59,65,66,67,69,72,73,74,76,77,79,81,],[18,-16,18,-32,-17,18,18,-14,-48,-37,-20,-15,18,-33,18,18,-46,-47,18,18,-53,-52,-36,-21,-18,-34,-38,-35,-23,-27,-22,-26,-51,-19,-55,-39,-24,-28,-25,]),'CLOSE_PAREN':([1,2,4,5,7,9,10,12,14,16,17,19,21,23,26,28,30,32,34,35,36,45,47,48,49,50,51,52,55,56,57,58,59,61,62,63,65,66,67,69,71,72,73,74,75,76,77,78,79,81,83,],[-16,-4,-10,-32,-17,-31,-1,-7,-14,-37,-20,-15,-33,-5,-8,-2,55,-30,-53,-52,-36,-21,-13,-11,-6,-9,-3,-18,-34,-29,74,-38,-35,-42,-41,76,-23,-27,-22,-26,79,-51,-19,-55,-40,-39,-24,81,-28,-25,-43,]),'UFLOAT':([0,6,13,33,41,60,68,70,],[-45,-44,34,-45,-45,34,-44,-45,]),'$end':([1,2,3,4,5,7,9,10,12,14,16,17,19,21,23,26,28,32,34,35,36,45,47,48,49,50,51,52,55,56,58,59,65,66,67,69,72,73,74,76,77,79,81,],[-16,-4,0,-10,-32,-17,-31,-1,-7,-14,-37,-20,-15,-33,-5,-8,-2,-30,-53,-52,-36,-21,-13,-11,-6,-9,-3,-18,-34,-29,-38,-35,-23,-27,-22,-26,-51,-19,-55,-39,-24,-28,-25,]),'SOLIDUS':([0,1,2,4,5,7,9,10,14,16,17,19,21,23,24,25,27,28,32,33,34,35,36,45,48,49,51,52,55,56,58,59,65,66,67,69,72,73,74,75,76,77,79,81,],[15,-16,15,15,-32,-17,-31,-12,-14,-37,-20,-15,-33,15,15,-46,-47,-12,-30,15,-53,-52,-36,-21,-11,15,-12,-18,-34,-29,-38,-35,-23,-27,-22,-26,-51,-19,-55,15,-39,-24,-28,-25,]),'UINT':([0,6,7,13,15,16,17,33,34,35,37,38,39,40,41,43,44,53,54,60,64,68,70,80,82,],[17,-44,29,35,-48,-45,42,17,-53,-52,58,-45,-50,-49,-45,66,-45,72,-45,75,-45,72,-45,-45,83,]),'SIGN':([0,15,16,17,29,33,38,39,40,41,42,44,46,54,64,70,80,],[6,-48,6,43,53,6,6,-50,-49,6,53,68,53,6,6,68,6,]),'DOUBLE_STAR':([16,17,29,42,],[40,40,40,40,]),'OPEN_PAREN':([0,1,4,5,7,8,9,11,14,15,16,17,18,19,20,21,22,24,25,27,31,33,34,35,36,38,39,40,44,45,52,54,55,58,59,64,65,66,67,69,72,73,74,76,77,79,81,],[8,-16,8,-32,-17,8,8,33,-14,-48,41,46,-54,-15,8,-33,8,8,-46,-47,8,8,-53,-52,-36,41,-50,-49,70,-21,-18,41,-34,-38,-35,41,-23,-27,-22,-26,-51,-19,-55,-39,-24,-28,-25,]),'PERIOD':([1,4,5,7,9,14,16,17,19,21,34,35,36,45,52,55,58,59,65,66,67,69,72,73,74,76,77,79,81,],[-16,27,-32,-17,27,-14,-37,-20,-15,-33,-53,-52,-36,-21,-18,-34,-38,-35,-23,-27,-22,-26,-51,-19,-55,-39,-24,-28,-25,]),'STAR':([1,4,5,7,9,14,16,17,19,21,34,35,36,45,52,55,58,59,65,66,67,69,72,73,74,76,77,79,81,],[-16,25,-32,-17,25,-14,-37,-20,-15,-33,-53,-52,-36,-21,-18,-34,-38,-35,-23,-27,-22,-26,-51,-19,-55,-39,-24,-28,-25,]),'UNIT':([0,1,4,5,7,8,9,14,15,16,17,19,20,21,22,24,25,27,31,33,34,35,36,45,52,55,58,59,65,66,67,69,72,73,74,76,77,79,81,],[16,-16,16,-32,-17,16,16,-14,-48,-37,-20,-15,16,-33,16,16,-46,-47,16,16,-53,-52,-36,-21,-18,-34,-38,-35,-23,-27,-22,-26,-51,-19,-55,-39,-24,-28,-25,]),}\nastropy\/units\/format\/generic_parsetab.py:  ('product -> PERIOD','product',1,'p_product','generic.py',366),\nastropy\/units\/format\/generic_parsetab.py:  ('division -> SOLIDUS','division',1,'p_division','generic.py',372),\nastropy\/units\/format\/generic_parsetab.py:  ('power -> DOUBLE_STAR','power',1,'p_power','generic.py',378),\nastropy\/units\/imperial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/imperial.py:# SPEED\nastropy\/units\/imperial.py:def_unit(['deg_F', 'Fahrenheit'], namespace=_ns, doc='Degrees Fahrenheit',\nastropy\/units\/imperial.py:# DOCSTRING\nastropy\/units\/format\/base.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/base.py:from ...utils.misc import InheritDocstrings\nastropy\/units\/format\/base.py:class _FormatterMeta(InheritDocstrings):\nastropy\/units\/format\/vounit.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/vounit.py:    <http:\/\/www.ivoa.net\/Documents\/VOUnits\/>`_.\nastropy\/units\/format\/vounit.py:            'A', 'C', 'D', 'F', 'G', 'H', 'Hz', 'J', 'Jy', 'K', 'N',\nastropy\/units\/format\/unicode_format.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/_docutil.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/_docutil.py:__all__ = ['TWO_OR_THREE_ARGS', 'RETURNS', 'ORIGIN', 'RA_DEC_ORDER']\nastropy\/wcs\/_docutil.py:def RA_DEC_ORDER(indent=0):\nastropy\/wcs\/_docutil.py:    the axes specified by the in the ``CTYPE`` keywords.  Default is\nastropy\/units\/tests\/test_equivalencies.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_equivalencies.py:# THIRD-PARTY\nastropy\/units\/tests\/test_equivalencies.py:    # Density\nastropy\/units\/tests\/test_equivalencies.py:    # Define F_nu in Jy\nastropy\/units\/tests\/test_equivalencies.py:    # Define F_lambda in ergs \/ cm^2 \/ s \/ micron\nastropy\/units\/tests\/test_equivalencies.py:        assert False, \"Didn't find speed in compose results\"\nastropy\/units\/format\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/__init__.py:from .cds import CDS\nastropy\/units\/format\/__init__.py:    'Base', 'Generic', 'CDS', 'Console', 'Fits', 'Latex', 'LatexInline',\nastropy\/units\/tests\/test_quantity_decorator.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/__init__.py:.. _SIP: http:\/\/irsa.ipac.caltech.edu\/data\/SPITZER\/docs\/files\/spitzer\/shupeADASS.pdf\nastropy\/wcs\/__init__.py:  `~astropy.wcs.DistortionLookupTable`.\nastropy\/units\/format\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_deprecated.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/cds.py:# Licensed under a 3-clause BSD style license - see LICNSE.rst\nastropy\/units\/format\/cds.py:Handles the CDS string format for units\nastropy\/units\/format\/cds.py:# TODO: Support logarithmic units using bracketed syntax\nastropy\/units\/format\/cds.py:class CDS(Base):\nastropy\/units\/format\/cds.py:    Support the `Centre de Donn\u00e9es astronomiques de Strasbourg\nastropy\/units\/format\/cds.py:        'PRODUCT',\nastropy\/units\/format\/cds.py:        'DIVISION',\nastropy\/units\/format\/cds.py:        t_PRODUCT = r'\\.'\nastropy\/units\/format\/cds.py:        t_DIVISION = r'\/'\nastropy\/units\/format\/cds.py:        # NOTE THE ORDERING OF THESE RULES IS IMPORTANT!!\nastropy\/units\/format\/cds.py:                        reflags=re.UNICODE)\nastropy\/units\/format\/cds.py:            product_of_units : unit_expression PRODUCT combined_units\nastropy\/units\/format\/cds.py:            division_of_units : DIVISION unit_expression\nastropy\/units\/format\/cds.py:                              | unit_expression DIVISION combined_units\nastropy\/units\/format\/cds.py:                        \"Only base ten exponents are allowed in CDS\")\nastropy\/units\/format\/cds.py:                        \"Only base ten exponents are allowed in CDS\")\nastropy\/units\/format\/cds.py:                    \"Unit '{0}' not supported by the CDS SAC \"\nastropy\/units\/format\/cds.py:            raise ValueError('CDS unit must not contain whitespace')\nastropy\/units\/tests\/test_units.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_units.py:COMPOSE_ROUNDTRIP = set()\nastropy\/units\/tests\/test_units.py:        COMPOSE_ROUNDTRIP.add(val)\nastropy\/units\/tests\/test_units.py:@pytest.mark.parametrize('unit', sorted(COMPOSE_ROUNDTRIP, key=_unit_as_str), ids=_unit_as_str)\nastropy\/units\/tests\/test_units.py:            assert 'Did you mean {0}?'.format(matches) in str(e)\nastropy\/units\/tests\/test_format.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_format.py:    ([\"dB(mW)\", \"dB (mW)\"], u.DecibelUnit(u.mW)),\nastropy\/units\/tests\/test_format.py:    ([\"dex(cm s**-2)\", \"dex(cm\/s2)\"], u.DexUnit(u.cm \/ u.s**2))])\nastropy\/units\/tests\/test_format.py:        unit2 = u_format.CDS.parse(s)\nastropy\/units\/tests\/test_format.py:        u_format.CDS.parse(string)\nastropy\/units\/tests\/test_format.py:    val for key, val in u_format.CDS._units.items()\nastropy\/units\/tests\/test_format.py:    u_format.CDS._units\nastropy\/units\/tests\/test_format.py:    and CDS, but not in fits and vounit.\"\"\"\nastropy\/units\/tests\/test_format.py:        assert 'Did you mean Angstrom or angstrom?' in str(e)\nastropy\/units\/tests\/test_quantity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_quantity.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/units\/tests\/test_quantity.py:from ...units.quantity import _UNIT_NOT_INITIALISED\nastropy\/units\/tests\/test_quantity.py:        numbers are converted to float (including decimal.Decimal, which\nastropy\/units\/tests\/test_quantity.py:        q4 = u.Quantity(decimal.Decimal('10.25'), u.m)\nastropy\/units\/tests\/test_quantity.py:        q5 = u.Quantity(decimal.Decimal('10.25'), u.m, dtype=object)\nastropy\/units\/tests\/test_quantity.py:            with catch_warnings(AstropyDeprecationWarning) as warning_lines:\nastropy\/units\/tests\/test_quantity.py:                assert warning_lines[0].category == AstropyDeprecationWarning\nastropy\/units\/tests\/test_quantity.py:class TestQuantityDisplay:\nastropy\/units\/tests\/test_quantity.py:        assert str(bad_quantity).endswith(_UNIT_NOT_INITIALISED)\nastropy\/units\/tests\/test_quantity.py:        assert repr(bad_quantity).endswith(_UNIT_NOT_INITIALISED + '>')\nastropy\/units\/tests\/test_quantity.py:    TODO: create PNG output and check against reference image\nastropy\/units\/format\/ogip_lextab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/ogip_lextab.py:_lextokens    = set(('UINT', 'WHITESPACE', 'STAR', 'OPEN_PAREN', 'UNIT', 'SIGN', 'UFLOAT', 'STARSTAR', 'DIVISION', 'LIT10', 'CLOSE_PAREN', 'UNKNOWN'))\nastropy\/units\/format\/ogip_lextab.py:_lexstatere   = {'INITIAL': [('(?P<t_UFLOAT>(((\\\\d+\\\\.?\\\\d*)|(\\\\.\\\\d+))([eE][+-]?\\\\d+))|(((\\\\d+\\\\.\\\\d*)|(\\\\.\\\\d+))([eE][+-]?\\\\d+)?))|(?P<t_UINT>\\\\d+)|(?P<t_SIGN>[+-](?=\\\\d))|(?P<t_X>[x\u00d7])|(?P<t_LIT10>10)|(?P<t_UNKNOWN>[Uu][Nn][Kk][Nn][Oo][Ww][Nn])|(?P<t_UNIT>[a-zA-Z][a-zA-Z_]*)|(?P<t_WHITESPACE>[ \\t]+)|(?P<t_STARSTAR>\\\\*\\\\*)|(?P<t_CLOSE_PAREN>\\\\))|(?P<t_OPEN_PAREN>\\\\()|(?P<t_STAR>\\\\*)|(?P<t_DIVISION>\/)', [None, ('t_UFLOAT', 'UFLOAT'), None, None, None, None, None, None, None, None, None, None, ('t_UINT', 'UINT'), ('t_SIGN', 'SIGN'), ('t_X', 'X'), ('t_LIT10', 'LIT10'), ('t_UNKNOWN', 'UNKNOWN'), ('t_UNIT', 'UNIT'), (None, 'WHITESPACE'), (None, 'STARSTAR'), (None, 'CLOSE_PAREN'), (None, 'OPEN_PAREN'), (None, 'STAR'), (None, 'DIVISION')])]}\nastropy\/units\/format\/cds_lextab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/cds_lextab.py:_lextokens    = set(('UINT', 'PRODUCT', 'OPEN_PAREN', 'UNIT', 'SIGN', 'UFLOAT', 'DIVISION', 'CLOSE_PAREN', 'X'))\nastropy\/units\/format\/cds_lextab.py:_lexstatere   = {'INITIAL': [('(?P<t_UFLOAT>((\\\\d+\\\\.?\\\\d+)|(\\\\.\\\\d+))([eE][+-]?\\\\d+)?)|(?P<t_UINT>\\\\d+)|(?P<t_SIGN>[+-](?=\\\\d))|(?P<t_X>[x\u00d7])|(?P<t_UNIT>\\\\%|\u00b0|\\\\\\\\h|((?!\\\\d)\\\\w)+)|(?P<t_CLOSE_PAREN>\\\\))|(?P<t_OPEN_PAREN>\\\\()|(?P<t_PRODUCT>\\\\.)|(?P<t_DIVISION>\/)', [None, ('t_UFLOAT', 'UFLOAT'), None, None, None, None, ('t_UINT', 'UINT'), ('t_SIGN', 'SIGN'), ('t_X', 'X'), ('t_UNIT', 'UNIT'), None, (None, 'CLOSE_PAREN'), (None, 'OPEN_PAREN'), (None, 'PRODUCT'), (None, 'DIVISION')])]}\nastropy\/units\/format\/ogip.py:# Licensed under a 3-clause BSD style license - see LICNSE.rst\nastropy\/units\/format\/ogip.py:        'DIVISION',\nastropy\/units\/format\/ogip.py:        # Define the function names, so we can parse them, even though\nastropy\/units\/format\/ogip.py:        t_DIVISION = r'\/'\nastropy\/units\/format\/ogip.py:        # NOTE THE ORDERING OF THESE RULES IS IMPORTANT!!\nastropy\/units\/format\/ogip.py:        # Don't ignore whitespace\nastropy\/units\/format\/ogip.py:                if p[2] == 'DIVISION':\nastropy\/units\/format\/ogip.py:            division : DIVISION\nastropy\/units\/format\/ogip.py:                     | WHITESPACE DIVISION\nastropy\/units\/format\/ogip.py:                     | WHITESPACE DIVISION WHITESPACE\nastropy\/units\/format\/ogip.py:                     | DIVISION WHITESPACE\nastropy\/units\/format\/ogip.py:            p[0] = 'DIVISION'\nastropy\/units\/format\/ogip.py:            p[0] = 'PRODUCT'\nastropy\/units\/format\/latex.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_physical.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/cgs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/cgs.py:# DYNAMIC VISCOSITY\nastropy\/units\/cgs.py:def_unit(['D', 'Debye', 'debye'], Fraction(1, 3) * 1e-29 * C * si.m,\nastropy\/units\/cgs.py:         doc=\"Debye: CGS unit of electric dipole moment\")\nastropy\/units\/cgs.py:# DOCSTRING\nastropy\/units\/format\/cds_parsetab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/cds_parsetab.py:# This file is automatically generated. Do not edit.\nastropy\/units\/format\/cds_parsetab.py:_lr_signature = '6FC211F72F2851FC3FF7D2BFF951FE7A'\nastropy\/units\/format\/cds_parsetab.py:_lr_action_items = {'UINT':([0,2,3,14,15,16,19,23,],[1,-21,20,-20,28,29,30,32,]),'PRODUCT':([2,12,13,18,30,31,],[-18,-10,27,-17,-19,-11,]),'CLOSE_PAREN':([2,7,8,12,13,18,22,25,30,31,33,34,],[-18,-4,-5,-10,-7,-17,31,-8,-19,-11,-9,-6,]),'UNIT':([0,1,5,6,10,11,17,20,21,26,27,28,35,36,],[2,-15,2,-16,2,2,-14,-23,-24,2,2,-22,-13,-12,]),'OPEN_PAREN':([0,1,5,6,10,11,17,20,21,26,27,28,35,36,],[5,-15,5,-16,5,5,-14,-23,-24,5,5,-22,-13,-12,]),'$end':([1,2,4,6,7,8,9,10,12,13,17,18,20,21,24,25,28,30,31,33,34,35,36,],[-15,-18,-2,-16,-4,-5,0,-3,-10,-7,-14,-17,-23,-24,-1,-8,-22,-19,-11,-9,-6,-13,-12,]),'DIVISION':([0,1,2,5,6,10,12,13,17,18,20,21,26,27,28,30,31,35,36,],[11,-15,-18,11,-16,11,-10,26,-14,-17,-23,-24,11,11,-22,-19,-11,-13,-12,]),'UFLOAT':([0,3,14,],[-21,21,-20,]),'X':([1,6,20,21,],[16,23,-23,-24,]),'SIGN':([0,1,2,29,32,],[14,15,14,15,15,]),}\nastropy\/units\/format\/cds_parsetab.py:  ('product_of_units -> unit_expression PRODUCT combined_units','product_of_units',3,'p_product_of_units','cds.py',169),\nastropy\/units\/format\/cds_parsetab.py:  ('division_of_units -> DIVISION unit_expression','division_of_units',2,'p_division_of_units','cds.py',179),\nastropy\/units\/format\/cds_parsetab.py:  ('division_of_units -> unit_expression DIVISION combined_units','division_of_units',3,'p_division_of_units','cds.py',180),\nastropy\/utils\/xml\/iterparser.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/iterparser.py:# STDLIB\nastropy\/utils\/xml\/iterparser.py:    parser.CharacterDataHandler = text.append\nastropy\/utils\/xml\/iterparser.py:            - *data*: Depends on the value of *event*:\nastropy\/utils\/xml\/iterparser.py:    Determine the encoding of an XML file by reading its header.\nastropy\/units\/format\/ogip_parsetab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/ogip_parsetab.py:# This file is automatically generated. Do not edit.\nastropy\/units\/format\/ogip_parsetab.py:_lr_signature = '6AD6E7286443B59D7DF329E6378BFC6B'\nastropy\/units\/format\/ogip_parsetab.py:_lr_action_items = {'UINT':([0,2,7,9,18,22,23,28,31,32,35,37,40,42,59,60,63,],[-38,19,-20,33,-21,39,-29,39,-23,39,39,-22,-38,-37,39,39,66,]),'WHITESPACE':([0,3,4,6,7,8,12,13,15,17,18,19,20,21,25,29,36,39,41,43,44,46,47,48,49,51,52,53,54,56,61,62,64,65,67,],[1,-30,24,29,31,-16,1,-17,-6,-10,37,-40,-41,1,45,1,-7,-32,-33,-31,57,-8,-9,-19,58,-15,-12,-18,-11,1,-34,-35,-14,-13,-36,]),'CLOSE_PAREN':([3,4,15,17,19,20,33,34,36,38,39,41,43,46,47,52,54,55,56,61,62,64,65,66,67,],[-30,-5,-6,-10,-40,-41,-39,52,-7,54,-32,-33,-31,-8,-9,-12,-11,61,62,-34,-35,-14,-13,67,-36,]),'OPEN_PAREN':([0,3,6,7,8,12,13,16,18,19,20,21,22,23,24,25,26,27,28,29,31,32,35,37,39,41,44,45,48,49,51,53,57,58,59,60,61,62,67,],[12,21,12,-20,-16,12,-17,12,-21,-40,-41,12,40,-29,-24,-25,12,12,40,12,-23,40,40,-22,-32,-33,-26,-28,-19,-20,-15,-18,-27,-22,40,40,-34,-35,-36,]),'UNIT':([0,6,7,8,12,13,16,18,19,20,21,24,25,26,27,29,31,37,39,41,44,45,48,49,51,53,57,58,61,62,67,],[3,3,-20,-16,3,-17,3,-21,-40,-41,3,-24,-25,3,3,3,-23,-22,-32,-33,-26,-28,-19,-20,-15,-18,-27,-22,-34,-35,-36,]),'UFLOAT':([0,2,9,22,23,28,32,35,40,42,59,60,],[-38,20,-37,-38,-29,-38,-38,-38,-38,-37,-38,-38,]),'SIGN':([0,22,23,28,32,35,40,59,60,],[9,42,-29,42,42,42,9,42,42,]),'DIVISION':([0,1,3,4,6,8,12,13,15,17,19,20,21,24,29,36,39,41,43,46,47,48,51,52,53,54,56,61,62,64,65,67,],[7,18,-30,7,7,-16,7,-17,-6,-10,-40,-41,7,18,49,-7,-32,-33,-31,-8,-9,-19,-15,-12,-18,-11,7,-34,-35,-14,-13,-36,]),'$end':([3,4,10,11,14,15,17,19,20,30,36,39,41,43,46,47,50,52,54,61,62,64,65,67,],[-30,-5,-1,-2,0,-6,-10,-40,-41,-3,-7,-32,-33,-31,-8,-9,-4,-12,-11,-34,-35,-14,-13,-36,]),'STARSTAR':([3,5,8,13,19,20,33,52,54,],[23,23,23,23,-40,-41,-39,23,23,]),'LIT10':([0,],[8,]),'STAR':([3,4,15,17,19,20,24,36,39,41,43,46,47,52,54,61,62,64,65,67,],[-30,25,-6,-10,-40,-41,44,-7,-32,-33,-31,-8,-9,-12,-11,-34,-35,-14,-13,-36,]),'UNKNOWN':([0,],[10,]),}\nastropy\/units\/format\/ogip_parsetab.py:  ('division -> DIVISION','division',1,'p_division','ogip.py',282),\nastropy\/units\/format\/ogip_parsetab.py:  ('division -> WHITESPACE DIVISION','division',2,'p_division','ogip.py',283),\nastropy\/units\/format\/ogip_parsetab.py:  ('division -> WHITESPACE DIVISION WHITESPACE','division',3,'p_division','ogip.py',284),\nastropy\/units\/format\/ogip_parsetab.py:  ('division -> DIVISION WHITESPACE','division',2,'p_division','ogip.py',285),\nastropy\/units\/cds.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/cds.py:This package defines units used in the CDS format, both the units\nastropy\/units\/cds.py:defined in `Centre de Donn\u00e9es astronomiques de Strasbourg\nastropy\/units\/cds.py:    # The CDS format also supports power-of-2 prefixes as defined here:\nastropy\/units\/cds.py:    # CDS only uses the short prefixes\nastropy\/units\/cds.py:        (['D'], u.D, \"Debye (dipole)\"),\nastropy\/units\/cds.py:        (['JD'], u.d, \"Julian day\", ['M']),\nastropy\/units\/cds.py:        (['MJD'], u.d, \"Julian day\"),\nastropy\/units\/cds.py:# DOCSTRING\nastropy\/units\/cds.py:    Enable CDS units so they appear in results of\nastropy\/units\/cds.py:    This may be used with the ``with`` statement to enable CDS\nastropy\/units\/tests\/test_quantity_ufuncs.py:        all_q_ufuncs = (qh.UNSUPPORTED_UFUNCS |\nastropy\/units\/function\/units.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/units.py:                              doc=\"Dex: Base 10 logarithmic unit\")\nastropy\/units\/function\/units.py:                         doc=\"Decibel: ten per base 10 logarithmic unit\")\nastropy\/units\/function\/units.py:# DOCSTRING\nastropy\/units\/format\/generic_lextab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/format\/generic_lextab.py:_lextokens    = set(('CARET', 'CLOSE_PAREN', 'SOLIDUS', 'FUNCNAME', 'UFLOAT', 'STAR', 'SIGN', 'UINT', 'DOUBLE_STAR', 'OPEN_PAREN', 'PERIOD', 'UNIT'))\nastropy\/units\/format\/generic_lextab.py:_lexstatere   = {'INITIAL': [(\"(?P<t_UFLOAT>((\\\\d+\\\\.?\\\\d*)|(\\\\.\\\\d+))([eE][+-]?\\\\d+)?)|(?P<t_UINT>\\\\d+)|(?P<t_SIGN>[+-](?=\\\\d))|(?P<t_FUNCNAME>((sqrt)|(ln)|(exp)|(log)|(mag)|(dB)|(dex))(?=\\\\ *\\\\())|(?P<t_UNIT>%|([YZEPTGMkhdcmunpfazy]?'((?!\\\\d)\\\\w)+')|((?!\\\\d)\\\\w)+)|(?P<t_DOUBLE_STAR>\\\\*\\\\*)|(?P<t_CLOSE_PAREN>\\\\))|(?P<t_STAR>\\\\*)|(?P<t_PERIOD>\\\\.)|(?P<t_OPEN_PAREN>\\\\()|(?P<t_CARET>\\\\^)|(?P<t_SOLIDUS>\/)\", [None, ('t_UFLOAT', 'UFLOAT'), None, None, None, None, ('t_UINT', 'UINT'), ('t_SIGN', 'SIGN'), ('t_FUNCNAME', 'FUNCNAME'), None, None, None, None, None, None, None, None, ('t_UNIT', 'UNIT'), None, None, None, (None, 'DOUBLE_STAR'), (None, 'CLOSE_PAREN'), (None, 'STAR'), (None, 'PERIOD'), (None, 'OPEN_PAREN'), (None, 'CARET'), (None, 'SOLIDUS')])]}\nastropy\/units\/function\/logarithmic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/logarithmic.py:__all__ = ['LogUnit', 'MagUnit', 'DexUnit', 'DecibelUnit',\nastropy\/units\/function\/logarithmic.py:           'LogQuantity', 'Magnitude', 'Decibel', 'Dex',\nastropy\/units\/function\/logarithmic.py:    such `MagUnit`, `DecibelUnit`, and `DexUnit`.\nastropy\/units\/function\/logarithmic.py:class DexUnit(LogUnit):\nastropy\/units\/function\/logarithmic.py:        return Dex\nastropy\/units\/function\/logarithmic.py:class DecibelUnit(LogUnit):\nastropy\/units\/function\/logarithmic.py:        return Decibel\nastropy\/units\/function\/logarithmic.py:        >>> u.Decibel(1.*u.W, u.DecibelUnit(u.mW))  # doctest: +FLOAT_CMP\nastropy\/units\/function\/logarithmic.py:        <Decibel 30. dB(mW)>\nastropy\/units\/function\/logarithmic.py:        # Do calculation in-place using _function_view of array.\nastropy\/units\/function\/logarithmic.py:        # Do calculation in-place using _function_view of array.\nastropy\/units\/function\/logarithmic.py:class Dex(LogQuantity):\nastropy\/units\/function\/logarithmic.py:    _unit_class = DexUnit\nastropy\/units\/function\/logarithmic.py:class Decibel(LogQuantity):\nastropy\/units\/function\/logarithmic.py:    _unit_class = DecibelUnit\nastropy\/units\/function\/logarithmic.py:dex._function_unit_class = DexUnit\nastropy\/units\/function\/logarithmic.py:dB._function_unit_class = DecibelUnit\nastropy\/wcs\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/utils.py:    if radesys == '' and xcoord == 'RA--' and ycoord == 'DEC-':\nastropy\/wcs\/utils.py:    from ..coordinates import BaseRADecFrame, FK4, FK4NoETerms, FK5, ICRS, Galactic\nastropy\/wcs\/utils.py:    if isinstance(frame, BaseRADecFrame):\nastropy\/wcs\/utils.py:        ycoord = 'DEC-'\nastropy\/wcs\/utils.py:        CDELT1  =                  1.0 \/ [deg] Coordinate increment at reference point\nastropy\/wcs\/utils.py:        CDELT2  =                  1.0 \/ [deg] Coordinate increment at reference point\nastropy\/wcs\/utils.py:        CTYPE2  = 'DEC--TAN'           \/ Declination, gnomonic projection\nastropy\/wcs\/utils.py:        RADESYS = 'FK5'                \/ Equatorial coordinate system\nastropy\/wcs\/utils.py:        Pixel area is defined only for 2D pixels. Most likely the\nastropy\/wcs\/utils.py:    Depending on the application, square root of the pixel area can be used to\nastropy\/wcs\/utils.py:        raise ValueError(\"Pixel area is defined only for 2D pixels.\")\nastropy\/wcs\/utils.py:    (from ``PC`` and ``CDELT``) CD matrix. `is_proj_plane_distorted`\nastropy\/wcs\/utils.py:        Accuracy to which the CD matrix, **normalized** such\nastropy\/wcs\/utils.py:        that :math:`|det(CD)|=1`, should be close to being an\nastropy\/wcs\/utils.py:        raise ValueError(\"CD (or PC) matrix must be a 2D square matrix.\")\nastropy\/wcs\/utils.py:        raise ValueError(\"CD (or PC) matrix is singular.\")\nastropy\/wcs\/utils.py:    # However, I am not aware of complex CD\/PC matrices...\nastropy\/wcs\/utils.py:# TODO: in future, we should think about how the following two functions can be\nastropy\/units\/equivalencies.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/equivalencies.py:# THIRD-PARTY\nastropy\/units\/equivalencies.py:    Defines the conversion between Jy\/beam and \"brightness temperature\",\nastropy\/wcs\/tests\/test_wcsprm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: We need some data with -NCP or -GLS projections to test\nastropy\/wcs\/tests\/test_wcsprm.py:    w.ctype = [b'RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_wcsprm.py:    assert w.lattyp == 'DEC'\nastropy\/wcs\/tests\/test_wcsprm.py:    assert list(w.ctype) == ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_wcsprm.py:    assert w.lattyp == 'DEC'\nastropy\/wcs\/tests\/test_wcsprm.py:    w.ctype = [b'RA-\\t--TAN', 'DEC-\\n-TAN']\nastropy\/wcs\/tests\/test_wcsprm.py:    assert repr(w.ctype == '[\"RA-\\t--TAN\", \"DEC-\\n-TAN\"]')\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: We need some data with broken cylindrical projections to\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: When dateavg is verified, check that it works\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: When dateavg is verified, check that it works\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: We need some data with PSi_ma keywords\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: We need some data with PVi_ma keywords\nastropy\/wcs\/tests\/test_wcsprm.py:    w.ctype = [b'RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: We need some data with broken spectral headers here to\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: Write me\nastropy\/wcs\/tests\/test_wcsprm.py:    # TODO: Inject some headers that have tables and test\nastropy\/wcs\/tests\/test_wcsprm.py:    w.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_wcsprm.py:    # coordinates\", for those systems the RADESYS keyword can be used to\nastropy\/wcs\/tests\/test_wcsprm.py:    # \"For RADESYSa values of FK4 and FK4-NO-E, any stated equinox is Besselian\nastropy\/wcs\/tests\/test_wcsprm.py:    # RADESYS a. However, if it should happen to ap- pear by itself then\nastropy\/wcs\/tests\/test_wcsprm.py:    # RADESYSa defaults to FK4 if EQUINOXa < 1984.0, or to FK5 if EQUINOXa\nastropy\/wcs\/tests\/test_wcsprm.py:    # By default RADESYS is empty\nastropy\/wcs\/tests\/test_wcsprm.py:    for ctype in [('RA---TAN', 'DEC--TAN'),\nastropy\/wcs\/tests\/test_wcsprm.py:                  ('DEC--TAN', 'RA---TAN'),\nastropy\/wcs\/tests\/test_wcsprm.py:        # Check defaults for RADESYS\nastropy\/units\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/utils.py:     - Description\nastropy\/units\/utils.py:            # Denominators of 1 can just be integers.\nastropy\/units\/decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/decorators.py:        # Define a new function to return in place of the wrapped one\nastropy\/units\/decorators.py:                if param.kind in (inspect.Parameter.VAR_KEYWORD,\nastropy\/units\/tests\/test_logarithmic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/tests\/test_logarithmic.py:lu_subclasses = [u.DexUnit, u.MagUnit, u.DecibelUnit]\nastropy\/units\/tests\/test_logarithmic.py:lq_subclasses = [u.Dex, u.Magnitude, u.Decibel]\nastropy\/units\/tests\/test_logarithmic.py:        \"\"\"Do some spot checks that str, repr, etc. work as expected.\"\"\"\nastropy\/units\/tests\/test_logarithmic.py:        dm0 = u.Unit('DM', 1.\/(4.*np.pi*(10.*u.pc)**2))\nastropy\/units\/tests\/test_logarithmic.py:            q.view(u.Dex)\nastropy\/units\/tests\/test_logarithmic.py:        lq = q.view(u.Dex)\nastropy\/units\/tests\/test_logarithmic.py:        assert isinstance(lq, u.Dex)\nastropy\/units\/tests\/test_logarithmic.py:        dm0 = u.Unit('DM', 1.\/(4.*np.pi*(10.*u.pc)**2))\nastropy\/units\/tests\/test_logarithmic.py:        DMmag = u.mag(dm0)\nastropy\/units\/tests\/test_logarithmic.py:        dm = 5. * DMmag\nastropy\/units\/tests\/test_logarithmic.py:        lq3 = u.Dex(2.*u.Jy)\nastropy\/wcs\/tests\/extension\/setup.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/extension\/setup.py:            ('YY_NO_UNISTD_H', None),\nastropy\/wcs\/tests\/extension\/setup.py:            ('_NO_OLDNAMES', None),  # for mingw32\nastropy\/wcs\/tests\/extension\/setup.py:            ('NO_OLDNAMES', None),  # for mingw64\nastropy\/wcs\/tests\/extension\/setup.py:            ('__STDC__', None)  # for MSVC\nastropy\/wcs\/tests\/extension\/test_extension.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/extension\/test_extension.py:    except UnicodeDecodeError:\nastropy\/wcs\/tests\/extension\/test_extension.py:        # Don't try to guess about encoding; just display the text\nastropy\/wcs\/tests\/test_wcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_wcs.py:    # TODO: write this to test the expected output behavior of pix2world,\nastropy\/wcs\/tests\/test_wcs.py:    # Dictionary with no actual WCS, returns identity transform\nastropy\/wcs\/tests\/test_wcs.py:                 'CDELT1': -0.1,\nastropy\/wcs\/tests\/test_wcs.py:                 'CDELT2': 0.1})\nastropy\/wcs\/tests\/test_wcs.py:    WCSAXES =                    2 \/ Number of coordinate axes                      CRPIX1  =                  0.0 \/ Pixel coordinate of reference point            CRPIX2  =                  0.0 \/ Pixel coordinate of reference point            CDELT1  =                  1.0 \/ Coordinate increment at reference point        CDELT2  =                  1.0 \/ Coordinate increment at reference point        CRVAL1  =                  0.0 \/ Coordinate value at reference point            CRVAL2  =                  0.0 \/ Coordinate value at reference point            LATPOLE =                 90.0 \/ [deg] Native latitude of celestial pole        END\"\"\"\nastropy\/wcs\/tests\/test_wcs.py:    assert isinstance(wfits, fits.HDUList)\nastropy\/wcs\/tests\/test_wcs.py:    assert isinstance(wfits[0], fits.PrimaryHDU)\nastropy\/wcs\/tests\/test_wcs.py:    assert 'A_ORDER' in str(w[0])\nastropy\/wcs\/tests\/test_wcs.py:            print(\"Diverging solutions:\\n{}\\n\"\nastropy\/wcs\/tests\/test_wcs.py:                 'CTYPE2': 'DEC--ZPN', 'CRUNIT2': 'deg',\nastropy\/wcs\/tests\/test_wcs.py:    h['RADESYSA'] = 'ICRS'\nastropy\/wcs\/tests\/test_wcs.py:    hdu = fits.PrimaryHDU([[0]], header=h)\nastropy\/wcs\/tests\/test_wcs.py:    hdulist = fits.HDUList([hdu])\nastropy\/wcs\/tests\/test_wcs.py:CTYPE2  = 'DEC--TAN' \/ TAN (gnomic) projection\nastropy\/wcs\/tests\/test_wcs.py:CRVAL2  =        23.1148929108 \/ DEC of reference point\nastropy\/wcs\/tests\/test_wcs.py:CD1_1   =    -0.00912247310646 \/ Transformation matrix\nastropy\/wcs\/tests\/test_wcs.py:CD1_2   =    -0.00250608809647 \/ no comment\nastropy\/wcs\/tests\/test_wcs.py:CD2_1   =     0.00250608809647 \/ no comment\nastropy\/wcs\/tests\/test_wcs.py:CD2_2   =    -0.00912247310646 \/ no comment\nastropy\/wcs\/tests\/test_wcs.py:    w.wcs.ctype = ['RA---TAN', 'DEC--TAN', 'FREQ']\nastropy\/wcs\/tests\/test_wcs.py:        assert header['CDELT{0}'.format(ii + 1)] == w.wcs.cdelt[ii]\nastropy\/wcs\/tests\/test_wcs.py:    w.wcs.ctype = ['RA---SIN', 'DEC--SIN', 'FREQ']\nastropy\/wcs\/tests\/test_wcs.py:        assert header['CDELT{0}'.format(ii + 1)] == w.wcs.cdelt[ii]\nastropy\/wcs\/tests\/test_wcs.py:    w.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_wcs.py:    header = w.to_header(relax=wcs.WCSHDO_P17)\nastropy\/wcs\/tests\/test_wcs.py:    w.wcs.ctype = ['RA---TAN', 'DEC--TAN', 'FREQ']\nastropy\/wcs\/tests\/test_wcs.py:def test_passing_ImageHDU():\nastropy\/wcs\/tests\/test_wcs.py:    Passing ImageHDU or PrimaryHDU and comparing it with\nastropy\/wcs\/tests\/test_wcs.py:    w.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_wcs.py:    w.wcs.ctype = [\"RA---CAR\", \"DEC--CAR\"]\nastropy\/wcs\/tests\/test_wcs.py:    h1['CTYPE2A'] = \"DEC--SIN-SIP\"\nastropy\/wcs\/tests\/test_wcs.py:    assert (w.wcs.ctype == np.array(['RA---SIN-SIP', 'DEC--SIN-SIP'])).all()\nastropy\/wcs\/tests\/test_wcs.py:    assert isinstance(wfits, fits.HDUList)\nastropy\/wcs\/tests\/test_wcs.py:    assert isinstance(wfits[0], fits.PrimaryHDU)\nastropy\/wcs\/tests\/test_wcs.py:    assert isinstance(wfits[1], fits.ImageHDU)\nastropy\/units\/function\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/core.py:SUPPORTED_UFUNCS = set(getattr(np.core.umath, ufunc) for ufunc in (\nastropy\/units\/function\/core.py:# TODO: the following could work if helper changed relative to Quantity:\nastropy\/units\/function\/core.py:SUPPORTED_FUNCTIONS = set(getattr(np, function) for function in\nastropy\/units\/function\/core.py:        \"\"\"Default function unit corresponding to the function.\nastropy\/units\/function\/core.py:            # Don't know what to do with anything not like a unit.\nastropy\/units\/function\/core.py:    \"\"\"Default `~astropy.units.function.FunctionUnitBase` subclass.\nastropy\/units\/function\/core.py:    # Define functions that work on FunctionQuantity.\nastropy\/units\/function\/core.py:    _supported_ufuncs = SUPPORTED_UFUNCS\nastropy\/units\/function\/core.py:    _supported_functions = SUPPORTED_FUNCTIONS\nastropy\/units\/function\/core.py:        \"\"\"Do a comparison between self and other, raising UnitsError when\nastropy\/wcs\/tests\/test_profiling.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_profiling.py:# OLD COMMENTS:\nastropy\/utils\/xml\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/setup_package.py:    XML_DIR = 'astropy\/utils\/xml\/src'\nastropy\/utils\/xml\/setup_package.py:    cfg = setup_helpers.DistutilsExtensionArgs({\nastropy\/utils\/xml\/setup_package.py:        'sources': [join(XML_DIR, \"iterparse.c\")]\nastropy\/utils\/xml\/setup_package.py:        EXPAT_DIR = 'cextern\/expat\/lib'\nastropy\/utils\/xml\/setup_package.py:            join(EXPAT_DIR, fn) for fn in\nastropy\/utils\/xml\/setup_package.py:        cfg['include_dirs'].extend([XML_DIR, EXPAT_DIR])\nastropy\/utils\/xml\/setup_package.py:                    join(XML_DIR, 'iterparse.map'))\nastropy\/utils\/xml\/setup_package.py:            cfg['define_macros'].append(('BYTEORDER', '4321'))\nastropy\/utils\/xml\/setup_package.py:            cfg['define_macros'].append(('BYTEORDER', '1234'))\nastropy\/utils\/xml\/setup_package.py:            cfg['define_macros'].append(('HAVE_UNISTD_H', None))\nastropy\/utils\/xml\/validate.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/validate.py:Functions to do XML schema and DTD validation.  At the moment, this\nastropy\/utils\/xml\/validate.py:    Validates an XML file against a schema or DTD.\nastropy\/utils\/xml\/validate.py:        The path to the XML schema or DTD\nastropy\/utils\/xml\/validate.py:        raise TypeError(\"schema_file must be a path to an XML Schema or DTD\")\nastropy\/units\/quantity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/quantity.py:from ..utils.exceptions import AstropyDeprecationWarning\nastropy\/units\/quantity.py:from ..utils.misc import isiterable, InheritDocstrings\nastropy\/units\/quantity.py:from ..utils.data_info import ParentDtypeInfo\nastropy\/units\/quantity.py:_UNIT_NOT_INITIALISED = \"(Unit not initialised)\"\nastropy\/units\/quantity.py:    ``q``.  It allows iterating over the array as if it were a 1-D array,\nastropy\/units\/quantity.py:class QuantityInfoBase(ParentDtypeInfo):\nastropy\/units\/quantity.py:class Quantity(np.ndarray, metaclass=InheritDocstrings):\nastropy\/units\/quantity.py:        `~astropy.units.Dex` for ``u.dex(u.AA)``).\nastropy\/units\/quantity.py:    # Default unit for initialization; can be overridden by subclasses,\nastropy\/units\/quantity.py:                # Default to dimensionless for no (initialized) unit attribute.\nastropy\/units\/quantity.py:        # DataInfo works, `'info' in obj.__dict__` is False until the\nastropy\/units\/quantity.py:        # Determine required conversion functions -- to bring the unit of the\nastropy\/units\/quantity.py:        # Determine the unit and quantity subclass that we need for the view.\nastropy\/units\/quantity.py:            except DeprecationWarning:\nastropy\/units\/quantity.py:                # We treat the DeprecationWarning separately, since it may\nastropy\/units\/quantity.py:            except DeprecationWarning:\nastropy\/units\/quantity.py:        \"\"\" Division between `Quantity` objects and other objects.\"\"\"\nastropy\/units\/quantity.py:        \"\"\" Right Division between `Quantity` objects and other objects.\"\"\"\nastropy\/units\/quantity.py:        \"\"\" Division between `Quantity` objects. \"\"\"\nastropy\/units\/quantity.py:        \"\"\" Division between `Quantity` objects. \"\"\"\nastropy\/units\/quantity.py:        \"\"\" Division between `Quantity` objects. \"\"\"\nastropy\/units\/quantity.py:                      AstropyDeprecationWarning)\nastropy\/units\/quantity.py:            unitstr = _UNIT_NOT_INITIALISED\nastropy\/units\/quantity.py:    # Display\nastropy\/units\/quantity.py:    # TODO: we may want to add a hook for dimensionless quantities?\nastropy\/units\/quantity.py:                      else _UNIT_NOT_INITIALISED)\nastropy\/units\/quantity.py:        decomposed. Decomposed units have only irreducible units in\nastropy\/units\/quantity.py:        Generates a new `Quantity` with the units decomposed. Decomposed\nastropy\/units\/quantity.py:        \"\"\"A 1-D iterator over the Quantity array.\nastropy\/units\/quantity.py:    :class:`~astropy.coordinates.Distance`\nastropy\/units\/quantity.py:    # Default unit for initialization through the constructor.\nastropy\/units\/deprecated.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/deprecated.py:# DOCSTRING\nastropy\/units\/si.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/si.py:# DIMENSIONLESS\nastropy\/units\/si.py:    ['deg_C', 'Celsius'], namespace=_ns, doc='Degrees Celsius',\nastropy\/units\/si.py:# RADIOACTIVITY\nastropy\/units\/si.py:# DOCSTRING\nastropy\/wcs\/wcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/wcs.py:     functionality in `wcslib`_.  (This includes TPV and TPD\nastropy\/wcs\/wcs.py:   - `~astropy.wcs.DistortionLookupTable`: Handles `distortion paper`_\nastropy\/wcs\/wcs.py:   - Detector to image plane correction (by a pair of\nastropy\/wcs\/wcs.py:     `~astropy.wcs.DistortionLookupTable` objects).\nastropy\/wcs\/wcs.py:     `~astropy.wcs.DistortionLookupTable` objects).\nastropy\/wcs\/wcs.py:# STDLIB\nastropy\/wcs\/wcs.py:# THIRD-PARTY\nastropy\/wcs\/wcs.py:from ..utils.exceptions import AstropyWarning, AstropyUserWarning, AstropyDeprecationWarning\nastropy\/wcs\/wcs.py:           'DistortionLookupTable', 'Sip', 'Tabprm', 'Wcsprm',\nastropy\/wcs\/wcs.py:    DistortionLookupTable = _wcs.DistortionLookupTable\nastropy\/wcs\/wcs.py:        if key.startswith(('WCSSUB', 'WCSHDR', 'WCSHDO')):\nastropy\/wcs\/wcs.py:    DistortionLookupTable = object\nastropy\/wcs\/wcs.py:WCSHDO_SIP = 0x80000\nastropy\/wcs\/wcs.py:                keysel_flags |= _wcs.WCSHDR_IMGHEAD\nastropy\/wcs\/wcs.py:                keysel_flags |= _wcs.WCSHDR_BIMGARR\nastropy\/wcs\/wcs.py:                keysel_flags |= _wcs.WCSHDR_PIXLIST\nastropy\/wcs\/wcs.py:                          AstropyDeprecationWarning)\nastropy\/wcs\/wcs.py:    header : astropy.io.fits header object, Primary HDU, Image HDU, string, dict-like, or None, optional\nastropy\/wcs\/wcs.py:        Degree of permissiveness:\nastropy\/wcs\/wcs.py:            elif isinstance(header, fits.hdu.image._ImageBaseHDU):\nastropy\/wcs\/wcs.py:                header, fobj, dist='CPDIS', err=minerr)\nastropy\/wcs\/wcs.py:            header_string = header_string.replace('END' + ' ' * 77, '')\nastropy\/wcs\/wcs.py:            hours (Henry), and ``\"D\"`` for days (Debye).\nastropy\/wcs\/wcs.py:            - If the string contains ``\"d\"``, translate ``\"D\"`` to\nastropy\/wcs\/wcs.py:        if not isinstance(fobj, fits.HDUList):\nastropy\/wcs\/wcs.py:        dist = 'D2IMDIS'\nastropy\/wcs\/wcs.py:        d_kw = 'D2IM'\nastropy\/wcs\/wcs.py:        err_kw = 'D2IMERR'\nastropy\/wcs\/wcs.py:                    assert isinstance(fobj, fits.HDUList), ('An astropy.io.fits.HDUList'\nastropy\/wcs\/wcs.py:                        d_data = fobj[str('D2IMARR'), d_extver].data\nastropy\/wcs\/wcs.py:                        d_data = (fobj[str('D2IMARR'), d_extver].data).transpose()\nastropy\/wcs\/wcs.py:                    d_header = fobj[str('D2IMARR'), d_extver].header\nastropy\/wcs\/wcs.py:                    d_cdelt = (d_header.get(str('CDELT1'), 1.0), d_header.get(str('CDELT2'), 1.0))\nastropy\/wcs\/wcs.py:                    d_lookup = DistortionLookupTable(d_data, d_crpix,\nastropy\/wcs\/wcs.py:        warnings.warn(\"The use of ``AXISCORR`` for D2IM correction has been deprecated.\"\nastropy\/wcs\/wcs.py:                      AstropyDeprecationWarning)\nastropy\/wcs\/wcs.py:            d2im_data = fobj[(str('D2IMARR'), 1)].data\nastropy\/wcs\/wcs.py:        d2im_hdr = fobj[(str('D2IMARR'), 1)].header\nastropy\/wcs\/wcs.py:            cdelt[i - 1] = d2im_hdr.get(str('CDELT') + str(i), 1.0)\nastropy\/wcs\/wcs.py:        cpdis = DistortionLookupTable(d2im_data, crpix, crval, cdelt)\nastropy\/wcs\/wcs.py:        `astropy.io.fits.HDUList`.\nastropy\/wcs\/wcs.py:        dist = 'D2IMDIS'\nastropy\/wcs\/wcs.py:        d_kw = 'D2IM'\nastropy\/wcs\/wcs.py:        err_kw = 'D2IMERR'\nastropy\/wcs\/wcs.py:                'LOOKUP', 'Detector to image correction type')\nastropy\/wcs\/wcs.py:                num, 'Version number of WCSDVARR extension')\nastropy\/wcs\/wcs.py:            image = fits.ImageHDU(det2im.data, name=str('D2IMARR'))\nastropy\/wcs\/wcs.py:            header[str('CDELT1')] = (det2im.cdelt[0],\nastropy\/wcs\/wcs.py:            header[str('CDELT2')] = (det2im.cdelt[1],\nastropy\/wcs\/wcs.py:    def _read_distortion_kw(self, header, fobj, dist='CPDIS', err=0.0):\nastropy\/wcs\/wcs.py:        returns a 2-tuple of `~astropy.wcs.DistortionLookupTable`\nastropy\/wcs\/wcs.py:        if dist == 'CPDIS':\nastropy\/wcs\/wcs.py:            d_kw = str('DP')\nastropy\/wcs\/wcs.py:            d_kw = str('DQ')\nastropy\/wcs\/wcs.py:                    if not isinstance(fobj, fits.HDUList):\nastropy\/wcs\/wcs.py:                        raise ValueError('an astropy.io.fits.HDUList is '\nastropy\/wcs\/wcs.py:                        d_data = fobj[str('WCSDVARR'), d_extver].data\nastropy\/wcs\/wcs.py:                        d_data = (fobj[str('WCSDVARR'), d_extver].data).transpose()\nastropy\/wcs\/wcs.py:                    d_header = fobj[str('WCSDVARR'), d_extver].header\nastropy\/wcs\/wcs.py:                    d_cdelt = (d_header.get(str('CDELT1'), 1.0),\nastropy\/wcs\/wcs.py:                               d_header.get(str('CDELT2'), 1.0))\nastropy\/wcs\/wcs.py:                    d_lookup = DistortionLookupTable(d_data, d_crpix, d_crval, d_cdelt)\nastropy\/wcs\/wcs.py:    def _write_distortion_kw(self, hdulist, dist='CPDIS'):\nastropy\/wcs\/wcs.py:        `fits.HDUList`.\nastropy\/wcs\/wcs.py:        if dist == 'CPDIS':\nastropy\/wcs\/wcs.py:            d_kw = str('DP')\nastropy\/wcs\/wcs.py:            d_kw = str('DQ')\nastropy\/wcs\/wcs.py:                num, 'Version number of WCSDVARR extension')\nastropy\/wcs\/wcs.py:            image = fits.ImageHDU(cpdis.data, name=str('WCSDVARR'))\nastropy\/wcs\/wcs.py:            header[str('CDELT1')] = (cpdis.cdelt[0], 'Coordinate increment along axis')\nastropy\/wcs\/wcs.py:            header[str('CDELT2')] = (cpdis.cdelt[1], 'Coordinate increment along axis')\nastropy\/wcs\/wcs.py:            # TODO: Parse SIP from a string without pyfits around\nastropy\/wcs\/wcs.py:        if str(\"A_ORDER\") in header and header[str('A_ORDER')] > 1:\nastropy\/wcs\/wcs.py:            if str(\"B_ORDER\") not in header:\nastropy\/wcs\/wcs.py:                    \"A_ORDER provided without corresponding B_ORDER \"\nastropy\/wcs\/wcs.py:            m = int(header[str(\"A_ORDER\")])\nastropy\/wcs\/wcs.py:            m = int(header[str(\"B_ORDER\")])\nastropy\/wcs\/wcs.py:            del header[str('A_ORDER')]\nastropy\/wcs\/wcs.py:            del header[str('B_ORDER')]\nastropy\/wcs\/wcs.py:        elif str(\"B_ORDER\") in header and header[str('B_ORDER')] > 1:\nastropy\/wcs\/wcs.py:                \"B_ORDER provided without corresponding A_ORDER \" +\nastropy\/wcs\/wcs.py:        if str(\"AP_ORDER\") in header and header[str('AP_ORDER')] > 1:\nastropy\/wcs\/wcs.py:            if str(\"BP_ORDER\") not in header:\nastropy\/wcs\/wcs.py:                    \"AP_ORDER provided without corresponding BP_ORDER \"\nastropy\/wcs\/wcs.py:            m = int(header[str(\"AP_ORDER\")])\nastropy\/wcs\/wcs.py:            m = int(header[str(\"BP_ORDER\")])\nastropy\/wcs\/wcs.py:            del header[str('AP_ORDER')]\nastropy\/wcs\/wcs.py:            del header[str('BP_ORDER')]\nastropy\/wcs\/wcs.py:        elif str(\"BP_ORDER\") in header and header[str('BP_ORDER')] > 1:\nastropy\/wcs\/wcs.py:                \"BP_ORDER provided without corresponding AP_ORDER \"\nastropy\/wcs\/wcs.py:            keywords[str('{0}_ORDER').format(name)] = size - 1\nastropy\/wcs\/wcs.py:        if self.wcs.lattyp != 'DEC':\nastropy\/wcs\/wcs.py:                \"WCS does not have longitude type of 'DEC', therefore \" +\nastropy\/wcs\/wcs.py:        if self.wcs.lattyp != 'DEC':\nastropy\/wcs\/wcs.py:                \"WCS does not have longitude type of 'DEC', therefore \" +\nastropy\/wcs\/wcs.py:                    \"a 1-D array for each axis, followed by an origin.\")\nastropy\/wcs\/wcs.py:            - Detector to image plane correction (if present in the\nastropy\/wcs\/wcs.py:                   __.RA_DEC_ORDER(8),\nastropy\/wcs\/wcs.py:                   __.RA_DEC_ORDER(8),\nastropy\/wcs\/wcs.py:        # #          DESCRIPTION OF THE NUMERICAL METHOD            ##\nastropy\/wcs\/wcs.py:        # (1)   x = CD*(u+f(u)),\nastropy\/wcs\/wcs.py:        # (CD matrix + projection onto celestial sphere) part of the\nastropy\/wcs\/wcs.py:        #      ### Direct Solving of Equation (2)  ###\nastropy\/wcs\/wcs.py:        #      ### Description of the Method Used here ###\nastropy\/wcs\/wcs.py:        # (when any of the non-CD-matrix-based corrections are\nastropy\/wcs\/wcs.py:        # #                NON-ADAPTIVE ITERATIONS:                 ##\nastropy\/wcs\/wcs.py:        # #                  ADAPTIVE ITERATIONS:                   ##\nastropy\/wcs\/wcs.py:                    # AND that do not diverge:\nastropy\/wcs\/wcs.py:        # #         FINAL DETECTION OF INVALID, DIVERGING,          ##\nastropy\/wcs\/wcs.py:        # #         AND FAILED-TO-CONVERGE POINTS                   ##\nastropy\/wcs\/wcs.py:        # #  RAISE EXCEPTION IF DIVERGING OR TOO SLOWLY CONVERGING  ##\nastropy\/wcs\/wcs.py:        # #  DATA POINTS HAVE BEEN DETECTED:                        ##\nastropy\/wcs\/wcs.py:        tolerance : float, optional (Default = 1.0e-4)\nastropy\/wcs\/wcs.py:        maxiter : int, optional (Default = 20)\nastropy\/wcs\/wcs.py:        quiet : bool, optional (Default = False)\nastropy\/wcs\/wcs.py:            Do not throw :py:class:`NoConvergence` exceptions when\nastropy\/wcs\/wcs.py:        adaptive : bool, optional (Default = False)\nastropy\/wcs\/wcs.py:            accuracy for the next iteration. Default is recommended\nastropy\/wcs\/wcs.py:        detect_divergence : bool, optional (Default = True)\nastropy\/wcs\/wcs.py:                   __.RA_DEC_ORDER(8),\nastropy\/wcs\/wcs.py:                   __.RA_DEC_ORDER(8),\nastropy\/wcs\/wcs.py:        Generate an `astropy.io.fits.HDUList` object with all of the\nastropy\/wcs\/wcs.py:            Degree of permissiveness:\nastropy\/wcs\/wcs.py:        hdulist : `astropy.io.fits.HDUList`\nastropy\/wcs\/wcs.py:        hdu = fits.PrimaryHDU(header=header)\nastropy\/wcs\/wcs.py:        hdulist = fits.HDUList(hdu)\nastropy\/wcs\/wcs.py:            Degree of permissiveness:\nastropy\/wcs\/wcs.py:             ``END``.\nastropy\/wcs\/wcs.py:          2. Deprecated (e.g. ``CROTAn``) or non-standard usage will\nastropy\/wcs\/wcs.py:        precision = WCSHDO_P14\nastropy\/wcs\/wcs.py:            do_sip = relax & WCSHDO_SIP\nastropy\/wcs\/wcs.py:            relax &= ~WCSHDO_SIP\nastropy\/wcs\/wcs.py:            relax = WCSHDO_all if relax is True else WCSHDO_safe\nastropy\/wcs\/wcs.py:            # This is called when relax is not False or WCSHDO_SIP\nastropy\/wcs\/wcs.py:        comments = ('# Region file format: DS9 version 4.0 \\n'\nastropy\/wcs\/wcs.py:                            'AMPLIFIER', 'DETECTOR'):\nastropy\/wcs\/wcs.py:            s = 'CDELT' + sfmt\nastropy\/wcs\/wcs.py:                    s += \"\".join(['CD', str(i+1), '_', str(j+1), ' '])\nastropy\/wcs\/wcs.py:        # if wcs.wcs.ctype == ['RA','DEC','VLSR'], you want\nastropy\/wcs\/wcs.py:        # wcs.sub([1,2]) to get 'RA','DEC' back\nastropy\/wcs\/wcs.py:        # We COULD allow wcs[1] to link to wcs.sub([2])\nastropy\/wcs\/wcs.py:        Degree of permissiveness:\nastropy\/wcs\/wcs.py:    source : str path, readable file-like object or `astropy.io.fits.HDUList` object\nastropy\/wcs\/wcs.py:        corresponds to the HDUs in the given file.  The next level has\nastropy\/wcs\/wcs.py:                result = ['HDU {0}{1}:'.format(self._hdu_index, hdu_name)]\nastropy\/wcs\/wcs.py:    if isinstance(source, fits.HDUList):\nastropy\/wcs\/wcs.py:                hdu.header, relax=_wcs.WCSHDR_reject,\nastropy\/wcs\/wcs.py:                        relax=_wcs.WCSHDR_reject,\nastropy\/utils\/iers\/iers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/iers\/iers.py:           'FROM_IERS_B', 'FROM_IERS_A', 'FROM_IERS_A_PREDICTION',\nastropy\/utils\/iers\/iers.py:           'TIME_BEFORE_IERS_RANGE', 'TIME_BEYOND_IERS_RANGE',\nastropy\/utils\/iers\/iers.py:           'IERS_A_FILE', 'IERS_A_URL', 'IERS_A_README',\nastropy\/utils\/iers\/iers.py:           'IERS_B_FILE', 'IERS_B_URL', 'IERS_B_README',\nastropy\/utils\/iers\/iers.py:IERS_A_README = get_pkg_data_filename('data\/ReadMe.finals2000A')\nastropy\/utils\/iers\/iers.py:IERS_B_README = get_pkg_data_filename('data\/ReadMe.eopc04_IAU2000')\nastropy\/utils\/iers\/iers.py:FROM_IERS_A_PREDICTION = 2\nastropy\/utils\/iers\/iers.py:TIME_BEYOND_IERS_RANGE = -2\nastropy\/utils\/iers\/iers.py:MJD_ZERO = 2400000.5\nastropy\/utils\/iers\/iers.py:        'then the local IERS-B file will be used by default. Default is True.')\nastropy\/utils\/iers\/iers.py:        'Maximum age (days) of predictive data before auto-downloading. Default is 30.')\nastropy\/utils\/iers\/iers.py:    'MJD', 'UT1_UTC', 'dX_2000A'\/'dY_2000A', and 'PM_x'\/'PM_y'.\nastropy\/utils\/iers\/iers.py:            Whether to use cache. Defaults to False, since IERS files\nastropy\/utils\/iers\/iers.py:        \"\"\"Turn a time to MJD, returning integer and fractional parts.\nastropy\/utils\/iers\/iers.py:            first part of two-part JD, or Time object\nastropy\/utils\/iers\/iers.py:            second part of two-part JD.\nastropy\/utils\/iers\/iers.py:            Default is 0., ignored if jd1 is `~astropy.time.Time`.\nastropy\/utils\/iers\/iers.py:            integer part of MJD\nastropy\/utils\/iers\/iers.py:            fractional part of MJD\nastropy\/utils\/iers\/iers.py:        mjd = np.floor(jd1 - MJD_ZERO + jd2)\nastropy\/utils\/iers\/iers.py:        utc = jd1 - (MJD_ZERO+mjd) + jd2\nastropy\/utils\/iers\/iers.py:            first part of two-part JD, or Time object\nastropy\/utils\/iers\/iers.py:            second part of two-part JD.\nastropy\/utils\/iers\/iers.py:            Default is 0., ignored if jd1 is `~astropy.time.Time`.\nastropy\/utils\/iers\/iers.py:            ``iers.FROM_IERS_A_PREDICTION``\nastropy\/utils\/iers\/iers.py:            ``iers.TIME_BEYOND_IERS_RANGE``\nastropy\/utils\/iers\/iers.py:            first part of two-part JD, or Time object\nastropy\/utils\/iers\/iers.py:            second part of two-part JD (default 0., ignored if jd1 is Time)\nastropy\/utils\/iers\/iers.py:        D_x : Quantity with angle units\nastropy\/utils\/iers\/iers.py:        D_y : Quantity with angle units\nastropy\/utils\/iers\/iers.py:            ``iers.FROM_IERS_A_PREDICTION``\nastropy\/utils\/iers\/iers.py:            ``iers.TIME_BEYOND_IERS_RANGE``\nastropy\/utils\/iers\/iers.py:            first part of two-part JD, or Time object\nastropy\/utils\/iers\/iers.py:            second part of two-part JD.\nastropy\/utils\/iers\/iers.py:            Default is 0., ignored if jd1 is `~astropy.time.Time`.\nastropy\/utils\/iers\/iers.py:            ``iers.FROM_IERS_A_PREDICTION``\nastropy\/utils\/iers\/iers.py:            ``iers.TIME_BEYOND_IERS_RANGE``\nastropy\/utils\/iers\/iers.py:        # For typical format, will always find a match (since MJD are integer)\nastropy\/utils\/iers\/iers.py:        # self['MJD'][i-1]<=mjd<self['MJD'][i]\nastropy\/utils\/iers\/iers.py:        i = np.searchsorted(self['MJD'].value, mjd, side='right')\nastropy\/utils\/iers\/iers.py:        # Get index to MJD at or just below given mjd, clipping to ensure we\nastropy\/utils\/iers\/iers.py:        mjd_0, mjd_1 = self['MJD'][i0].value, self['MJD'][i1].value\nastropy\/utils\/iers\/iers.py:            # Do not extrapolate outside range, instead just propagate last values.\nastropy\/utils\/iers\/iers.py:            status[i == len(self)] = TIME_BEYOND_IERS_RANGE\nastropy\/utils\/iers\/iers.py:        # IERS A has some rows at the end that hold nothing but dates & MJD\nastropy\/utils\/iers\/iers.py:        table.meta['predictive_mjd'] = table['MJD'][table.meta['predictive_index']]\nastropy\/utils\/iers\/iers.py:            Defaults to ``iers.IERS_A_FILE``.\nastropy\/utils\/iers\/iers.py:            full path to ascii file holding CDS-style readme.\nastropy\/utils\/iers\/iers.py:            Defaults to package version, ``iers.IERS_A_README``.\nastropy\/utils\/iers\/iers.py:            readme = IERS_A_README\nastropy\/utils\/iers\/iers.py:        source[ut1flag == 'P'] = FROM_IERS_A_PREDICTION\nastropy\/utils\/iers\/iers.py:        source[nutflag == 'P'] = FROM_IERS_A_PREDICTION\nastropy\/utils\/iers\/iers.py:        source[pmflag == 'P'] = FROM_IERS_A_PREDICTION\nastropy\/utils\/iers\/iers.py:            Defaults to package version, ``iers.IERS_B_FILE``.\nastropy\/utils\/iers\/iers.py:            full path to ascii file holding CDS-style readme.\nastropy\/utils\/iers\/iers.py:            Defaults to package version, ``iers.IERS_B_README``.\nastropy\/utils\/iers\/iers.py:            starting row. Default is 14, appropriate for standard IERS files.\nastropy\/utils\/iers\/iers.py:            readme = IERS_B_README\nastropy\/utils\/iers\/iers.py:            if new_table['MJD'][-1] > self['MJD'][-1]:\nastropy\/utils\/iers\/iers.py:                new_fpi = np.searchsorted(new_table['MJD'].value, predictive_mjd, side='right')\nastropy\/utils\/iers\/iers.py:                if new_table['MJD'][new_fpi + n_replace] - self['MJD'][-1] != 1.0 * u.d:\nastropy\/utils\/iers\/iers.py:                    raise ValueError('unexpected gap in MJD when refreshing IERS table')\nastropy\/utils\/iers\/iers.py:        mjd_b = table['MJD'][~table['UT1_UTC_B'].mask]\nastropy\/utils\/iers\/iers.py:        i0 = np.searchsorted(iers_b['MJD'].value, mjd_b[0], side='left')\nastropy\/utils\/iers\/iers.py:        i1 = np.searchsorted(iers_b['MJD'].value, mjd_b[-1], side='right')\nastropy\/utils\/iers\/iers.py:            if not np.allclose(table['MJD'][:n_iers_b], iers_b['MJD'].value):\nastropy\/cosmology\/parameters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/parameters.py:    n           Density perturbation spectral index\nastropy\/cosmology\/parameters.py:    sigma8      Density perturbation amplitude\nastropy\/units\/quantity_helper.py:UNSUPPORTED_UFUNCS = set([np.bitwise_and, np.bitwise_or,\nastropy\/units\/quantity_helper.py:    UNSUPPORTED_UFUNCS |= {np.isnat}\nastropy\/units\/quantity_helper.py:    # TODO: find a better way to do this, currently need to signal that one\nastropy\/units\/quantity_helper.py:    \"\"\"Determine the required converters and the unit of the ufunc result.\nastropy\/units\/quantity_helper.py:    if function in UNSUPPORTED_UFUNCS:\nastropy\/units\/quantity_helper.py:        # TODO: find a better way to deal with this.\nastropy\/units\/function\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/magnitude_zero_points.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/function\/magnitude_zero_points.py:# DOCSTRING\nastropy\/constants\/si.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/units\/core.py:from ..utils.misc import isiterable, InheritDocstrings\nastropy\/units\/core.py:class UnitBase(metaclass=InheritDocstrings):\nastropy\/units\/core.py:            # TODO: maybe better for other to have a `_back_converter` method?\nastropy\/units\/core.py:        # Don't presume decomposition is possible; e.g.,\nastropy\/units\/core.py:        # Do we have any minimal results?\nastropy\/units\/core.py:            Default is `False`.\nastropy\/units\/core.py:            Default is `False`.\nastropy\/units\/core.py:class _UnitMetaClass(InheritDocstrings):\nastropy\/units\/core.py:                    # Deliberately not issubclass here. Subclasses\nastropy\/units\/core.py:        # get string bases and powers from the ID tuple\nastropy\/units\/core.py:    Direct use of this class is not recommended. Instead use the\nastropy\/units\/core.py:        Default is `False`.  This function always returns the base\nastropy\/units\/core.py:# TODO: Is this still needed? Should there be a deprecation warning?\nastropy\/utils\/xml\/tests\/test_iterparse.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/xml\/tests\/test_iterparse.py:HEADER = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\nastropy\/utils\/xml\/tests\/test_iterparse.py:   <FIELD ID=\"foo\" name=\"foo\" datatype=\"int\" arraysize=\"1\"\/>\nastropy\/utils\/xml\/tests\/test_iterparse.py:    <DATA>\nastropy\/utils\/xml\/tests\/test_iterparse.py:     <TABLEDATA>\nastropy\/utils\/xml\/tests\/test_iterparse.py:ROW = \"\"\"<TR><TD>0<\/TD><\/TR>\nastropy\/utils\/xml\/tests\/test_iterparse.py:    <\/TABLEDATA>\nastropy\/utils\/xml\/tests\/test_iterparse.py:   <\/DATA>\nastropy\/utils\/xml\/tests\/test_iterparse.py:VOTABLE_XML = HEADER + 125*ROW + FOOTER\nastropy\/utils\/xml\/tests\/test_iterparse.py:    zlib_GZIP_STYLE_HEADER = 16\nastropy\/utils\/xml\/tests\/test_iterparse.py:                             zlib.DEFLATED,\nastropy\/utils\/xml\/tests\/test_iterparse.py:                             zlib.MAX_WBITS + zlib_GZIP_STYLE_HEADER)\nastropy\/utils\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/compat\/funcsigs.py:from ..exceptions import AstropyDeprecationWarning\nastropy\/utils\/compat\/funcsigs.py:              \"use inspect instead\", AstropyDeprecationWarning)\nastropy\/utils\/compat\/misc.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/compat\/misc.py:    Determine if the ``filename`` argument is an allowable type for a filename.\nastropy\/wcs\/docstrings.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/docstrings.py:``int`` (read-only) Order of the polynomial (``A_ORDER``).\nastropy\/wcs\/docstrings.py:Does the following:\nastropy\/wcs\/docstrings.py:    - Detector to image plane correction (if present)\nastropy\/wcs\/docstrings.py:``int`` (read-only) Order of the polynomial (``AP_ORDER``).\nastropy\/wcs\/docstrings.py:``int`` (read-only) Order of the polynomial (``B_ORDER``).\nastropy\/wcs\/docstrings.py:    transformations.  Default is `True`.\nastropy\/wcs\/docstrings.py:    transformations.  Default is `True`.\nastropy\/wcs\/docstrings.py:``int`` (read-only) Order of the polynomial (``BP_ORDER``).\nastropy\/wcs\/docstrings.py:``double array[naxis][naxis]`` The ``CDi_ja`` linear transformation\nastropy\/wcs\/docstrings.py:``PCi_ja`` with ``CDELTia``, ``CDi_ja``, and the deprecated\nastropy\/wcs\/docstrings.py:if ``CDi_ja`` is present (and no ``PCi_ja``).  If no ``CROTAia`` is\nastropy\/wcs\/docstrings.py:``double array[naxis]`` Coordinate increments (``CDELTia``) for each\nastropy\/wcs\/docstrings.py:If a ``CDi_ja`` linear transformation matrix is present, a warning is\nastropy\/wcs\/docstrings.py:raised and `~astropy.wcs.Wcsprm.cdelt` is ignored.  The ``CDi_ja``\nastropy\/wcs\/docstrings.py:Fix erroneously omitted ``CDi_ja`` keywords.\nastropy\/wcs\/docstrings.py:Sets the diagonal element of the ``CDi_ja`` matrix to unity if all\nastropy\/wcs\/docstrings.py:``CDi_ja`` keywords associated with a given axis were omitted.\nastropy\/wcs\/docstrings.py:According to Paper I, if any ``CDi_ja`` keywords at all are given in a\nastropy\/wcs\/docstrings.py:(0, 0)`` at the fiducial point, (phi_0, theta_0).  Default is `False`.\nastropy\/wcs\/docstrings.py:      change the WCS transformation, such as ``DATE-OBS`` or\nastropy\/wcs\/docstrings.py:`~astropy.wcs.DistortionLookupTable`\nastropy\/wcs\/docstrings.py:The pre-linear transformation distortion lookup table, ``CPDIS1``.\nastropy\/wcs\/docstrings.py:`~astropy.wcs.DistortionLookupTable`\nastropy\/wcs\/docstrings.py:The pre-linear transformation distortion lookup table, ``CPDIS2``.\nastropy\/wcs\/docstrings.py:``CRDERia``.\nastropy\/wcs\/docstrings.py:``PCi_ja`` with ``CDELTia``, ``CDi_ja``, and the deprecated\nastropy\/wcs\/docstrings.py:if ``CDi_ja`` is present (and no ``PCi_ja``).  If no ``CROTAia`` is\nastropy\/wcs\/docstrings.py:These define the units of measurement of the ``CRVALia``, ``CDELTia``\nastropy\/wcs\/docstrings.py:and ``CDi_ja`` keywords.\nastropy\/wcs\/docstrings.py:`~astropy.wcs.DistortionLookupTable`.\nastropy\/wcs\/docstrings.py:Translates the old ``DATE-OBS`` date format to year-2000 standard form\nastropy\/wcs\/docstrings.py:``(yyyy-mm-ddThh:mm:ss)`` and derives ``MJD-OBS`` from it if not\nastropy\/wcs\/docstrings.py:A `~astropy.wcs.DistortionLookupTable` object for detector to image plane\nastropy\/wcs\/docstrings.py:A `~astropy.wcs.DistortionLookupTable` object for detector to image plane\nastropy\/wcs\/docstrings.py:DistortionLookupTable = \"\"\"\nastropy\/wcs\/docstrings.py:DistortionLookupTable(*table*, *crpix*, *crval*, *cdelt*)\nastropy\/wcs\/docstrings.py:    Degree of permissiveness:\nastropy\/wcs\/docstrings.py:    - ``WCSHDR_IMGHEAD``: Image header keywords.\nastropy\/wcs\/docstrings.py:    - ``WCSHDR_BIMGARR``: Binary table image array.\nastropy\/wcs\/docstrings.py:    - ``WCSHDR_PIXLIST``: Pixel list keywords.\nastropy\/wcs\/docstrings.py:    used.  The same applies to ``\"H\"`` for hours (Henry), and ``\"D\"``\nastropy\/wcs\/docstrings.py:    for days (Debye).\nastropy\/wcs\/docstrings.py:    - If the string contains ``\"d\"``, translate ``\"D\"`` to ``\"d\"``.\nastropy\/wcs\/docstrings.py:Coordinate increments (``CDELTia``) for each coord axis.\nastropy\/wcs\/docstrings.py:Returns the ``CDELT`` offsets in read-only form.  Unlike the\nastropy\/wcs\/docstrings.py:``CDi_ja`` or ``CROTAia`` forms.  This is useful when you want access\nastropy\/wcs\/docstrings.py:``CDi_ja`` or ``CROTAia`` forms.  This is useful when you want access\nastropy\/wcs\/docstrings.py:Returns `True` if ``CDi_ja`` is present.\nastropy\/wcs\/docstrings.py:``CDi_ja`` is an alternate specification of the linear transformation\nastropy\/wcs\/docstrings.py:``CDi_ja = CDELTia * PCi_ja``, but the defaults differ from that of\nastropy\/wcs\/docstrings.py:the ``PCi_ja`` matrix.  If one or more ``CDi_ja`` keywords are present\nastropy\/wcs\/docstrings.py:then all unspecified ``CDi_ja`` default to zero.  If no ``CDi_ja`` (or\nastropy\/wcs\/docstrings.py:since this results in an interpretation of ``CDELTia`` consistent with\nastropy\/wcs\/docstrings.py:While ``CDi_ja`` may not formally co-exist with ``PCi_ja``, it may\nastropy\/wcs\/docstrings.py:co-exist with ``CDELTia`` and ``CROTAia`` which are to be ignored.\nastropy\/wcs\/docstrings.py:astropy.wcs.Wcsprm.cd : Get the raw ``CDi_ja`` values.\nastropy\/wcs\/docstrings.py:the image plane that is applied *after* the ``CDELTia``; any other\nastropy\/wcs\/docstrings.py:``CDELTia`` may formally co-exist with ``CDi_ja`` but if so are to be\nastropy\/wcs\/docstrings.py:``double array[2][2]`` (read-only) Inverse of the ``CDELT`` or ``PC``\nastropy\/wcs\/docstrings.py:Inverse containing the product of the ``CDELTia`` diagonal matrix and\nastropy\/wcs\/docstrings.py:For example, \"RA\", \"DEC\", \"GLON\", \"GLAT\", etc. extracted from \"RA--\",\nastropy\/wcs\/docstrings.py:\"DEC-\", \"GLON\", \"GLAT\", etc. in the first four characters of\nastropy\/wcs\/docstrings.py:For example, \"RA\", \"DEC\", \"GLON\", \"GLAT\", etc. extracted from \"RA--\",\nastropy\/wcs\/docstrings.py:\"DEC-\", \"GLON\", \"GLAT\", etc. in the first four characters of\nastropy\/wcs\/docstrings.py:``double`` Modified Julian Date corresponding to ``DATE-AVG``.\nastropy\/wcs\/docstrings.py:``(MJD = JD - 2400000.5)``.\nastropy\/wcs\/docstrings.py:``double`` Modified Julian Date corresponding to ``DATE-OBS``.\nastropy\/wcs\/docstrings.py:``(MJD = JD - 2400000.5)``.\nastropy\/wcs\/docstrings.py:    Definition of the latitude and longitude axes\nastropy\/wcs\/docstrings.py:``PCi_ja`` with ``CDELTia``, ``CDi_ja``, and the deprecated\nastropy\/wcs\/docstrings.py:if ``CDi_ja`` is present (and no ``PCi_ja``).  If no ``CROTAia`` is\nastropy\/wcs\/docstrings.py:the ``CDELTia`` diagonal matrix and the ``PCi_ja`` matrix.\nastropy\/wcs\/docstrings.py:``RADESYSa``.\nastropy\/wcs\/docstrings.py:    Definition of the latitude and longitude axes\nastropy\/wcs\/docstrings.py:    Its size must be (*m* + 1, *m* + 1) where *m* = ``A_ORDER``.\nastropy\/wcs\/docstrings.py:    Its size must be (*m* + 1, *m* + 1) where *m* = ``B_ORDER``.\nastropy\/wcs\/docstrings.py:    Its size must be (*m* + 1, *m* + 1) where *m* = ``AP_ORDER``.\nastropy\/wcs\/docstrings.py:    Its size must be (*m* + 1, *m* + 1) where *m* = ``BP_ORDER``.\nastropy\/wcs\/docstrings.py:Shupe, D. L., M. Moshir, J. Li, D. Makovoz and R. Narron.  2005.\nastropy\/wcs\/docstrings.py:\"The SIP Convention for Representing Distortion in FITS Image\nastropy\/wcs\/docstrings.py:Headers.\"  ADASS XIV.\nastropy\/wcs\/docstrings.py:    - ``'longitude'`` \/ ``WCSSUB_LONGITUDE``: Celestial longitude\nastropy\/wcs\/docstrings.py:    - ``'latitude'`` \/ ``WCSSUB_LATITUDE``: Celestial latitude\nastropy\/wcs\/docstrings.py:    wcs.sub([WCSSUB_LONGITUDE | WCSSUB_LATITUDE | WCSSUB_SPECTRAL])\nastropy\/wcs\/docstrings.py:``WCSSUB_LONGITUDE | WCSSUB_LATITUDE | WCSSUB_CUBEFACE``.\nastropy\/wcs\/docstrings.py:      WCSSUB_LONGITUDE,\nastropy\/wcs\/docstrings.py:      WCSSUB_LATITUDE,\nastropy\/wcs\/docstrings.py:       such as ``SIMPLE``, ``NAXIS``, ``BITPIX``, or ``END``.\nastropy\/wcs\/docstrings.py:    2. Deprecated (e.g. ``CROTAn``) or non-standard usage will be\nastropy\/wcs\/docstrings.py:    Degree of permissiveness:\nastropy\/wcs\/docstrings.py:For example, ``DEG`` -> ``deg``, also stripping off unnecessary\nastropy\/wcs\/docstrings.py:    Do potentially unsafe translations of non-standard unit strings.\nastropy\/wcs\/docstrings.py:    and ``\\\"D\\\"`` for days (Debye).\nastropy\/wcs\/docstrings.py:    - If the string contains ``\\\"d\\\"``, translate ``\\\"D\\\"`` to ``\\\"d\\\"``.\nastropy\/wcs\/docstrings.py:cpdis : A pair of `~astropy.wcs.DistortionLookupTable` objects, or\nastropy\/wcs\/docstrings.py:det2im : A pair of `~astropy.wcs.DistortionLookupTable` objects, or\nastropy\/wcs\/docstrings.py:    Degree of permissiveness:\nastropy\/wcs\/docstrings.py:        - ``WCSHDR_IMGHEAD``: Image header keywords.\nastropy\/wcs\/docstrings.py:        - ``WCSHDR_BIMGARR``: Binary table image array.\nastropy\/wcs\/docstrings.py:        - ``WCSHDR_PIXLIST``: Pixel list keywords.\nastropy\/wcs\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/setup_package.py:CONTACT = \"Michael Droettboom\"\nastropy\/wcs\/setup_package.py:    #ifndef YY_NO_UNISTD_H\nastropy\/wcs\/setup_package.py:    #define YY_NO_UNISTD_H\nastropy\/wcs\/setup_package.py:    #ifndef _NO_OLDNAMES\nastropy\/wcs\/setup_package.py:    #define _NO_OLDNAMES\nastropy\/wcs\/setup_package.py:    #ifndef NO_OLDNAMES\nastropy\/wcs\/setup_package.py:    #define NO_OLDNAMES\nastropy\/wcs\/setup_package.py:    #ifndef __STDC__\nastropy\/wcs\/setup_package.py:    #define __STDC__ 1\nastropy\/wcs\/setup_package.py:# GENERATE DOCSTRINGS IN C\nastropy\/wcs\/setup_package.py:DO NOT EDIT!\nastropy\/wcs\/setup_package.py:#ifndef __DOCSTRINGS_H__\nastropy\/wcs\/setup_package.py:#define __DOCSTRINGS_H__\nastropy\/wcs\/setup_package.py:DO NOT EDIT!\nastropy\/wcs\/setup_package.py:        ('ASTROPY_WCS_BUILD', None),\nastropy\/wcs\/setup_package.py:        cfg['define_macros'].append(('DEBUG', None))\nastropy\/wcs\/setup_package.py:        cfg['undef_macros'].append('NDEBUG')\nastropy\/wcs\/setup_package.py:        # Define ECHO as nothing to prevent spurious newlines from\nastropy\/wcs\/setup_package.py:        cfg['define_macros'].append(('NDEBUG', None))\nastropy\/wcs\/setup_package.py:        cfg['undef_macros'].append('DEBUG')\nastropy\/wcs\/setup_package.py:            ('YY_NO_UNISTD_H', None),\nastropy\/wcs\/setup_package.py:            ('_NO_OLDNAMES', None),  # for mingw32\nastropy\/wcs\/setup_package.py:            ('NO_OLDNAMES', None),  # for mingw64\nastropy\/wcs\/setup_package.py:            ('__STDC__', None)  # for MSVC\nastropy\/wcs\/setup_package.py:    # DISTUTILS SETUP\nastropy\/wcs\/setup_package.py:    cfg = setup_helpers.DistutilsExtensionArgs()\nastropy\/utils\/compat\/numpy\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/iers\/tests\/test_iers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/iers\/tests\/test_iers.py:FILE_NOT_FOUND_ERROR = getattr(__builtins__, 'FileNotFoundError', OSError)\nastropy\/utils\/iers\/tests\/test_iers.py:        assert status4 == iers.TIME_BEYOND_IERS_RANGE\nastropy\/utils\/iers\/tests\/test_iers.py:        with pytest.raises(FILE_NOT_FOUND_ERROR):\nastropy\/utils\/iers\/tests\/test_iers.py:        assert status2 == iers.TIME_BEYOND_IERS_RANGE\nastropy\/utils\/iers\/tests\/test_iers.py:        assert status3 == iers.FROM_IERS_A_PREDICTION\nastropy\/utils\/iers\/tests\/test_iers.py:            assert dat['MJD'][0] == 57359.0 * u.d\nastropy\/utils\/iers\/tests\/test_iers.py:            assert dat['MJD'][-1] == 57539.0 * u.d\nastropy\/utils\/iers\/tests\/test_iers.py:            # the IERS-B value from MJD=57359.  The value in\nastropy\/utils\/iers\/tests\/test_iers.py:        # Now point to a later file with same values but MJD increased by\nastropy\/utils\/iers\/tests\/test_iers.py:            assert dat['MJD'][0] == 57359.0 * u.d\nastropy\/utils\/iers\/tests\/test_iers.py:            assert dat['MJD'][-1] == (57539.0 + 60) * u.d\nastropy\/utils\/compat\/futures\/__init__.py:from ...exceptions import AstropyDeprecationWarning\nastropy\/utils\/compat\/futures\/__init__.py:              \"use concurrent.futures instead\", AstropyDeprecationWarning)\nastropy\/wcs\/wcslint.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/__init__.py:    # TODO: Issue a warning using the logging framework\nastropy\/__init__.py:    # TODO: Issue a warning using the logging framework\nastropy\/__init__.py:    except config.configuration.ConfigurationDefaultMissingError as e:\nastropy\/__init__.py:        warn(config.configuration.ConfigurationDefaultMissingWarning(wmsg))\nastropy\/utils\/compat\/numpy\/core\/multiarray.py:from ....exceptions import AstropyDeprecationWarning\nastropy\/utils\/compat\/numpy\/core\/multiarray.py:        'numpy.matmul directly.', AstropyDeprecationWarning)\nastropy\/cosmology\/funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/funcs.py:      are trying to invert! Depending on the cosmology, there may not\nastropy\/cosmology\/funcs.py:      be a unique solution. For example, in the standard Lambda CDM\nastropy\/cosmology\/funcs.py:    >>> Dvals = (24 + np.random.rand(1e6) * 20) * u.mag\nastropy\/cosmology\/funcs.py:    >>> zmin = z_at_value(Planck13.distmod, Dvals.min())\nastropy\/cosmology\/funcs.py:    >>> zmax = z_at_value(Planck13.distmod, Dvals.max())\nastropy\/cosmology\/funcs.py:    >>> Dgrid = Planck13.distmod(zgrid)\nastropy\/cosmology\/funcs.py:    >>> zvals = np.interp(Dvals.value, zgrid, Dgrid.value)\nastropy\/utils\/decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/decorators.py:from .exceptions import (AstropyDeprecationWarning, AstropyUserWarning,\nastropy\/utils\/decorators.py:                         AstropyPendingDeprecationWarning)\nastropy\/utils\/decorators.py:        If True, uses a AstropyPendingDeprecationWarning instead of a\nastropy\/utils\/decorators.py:        AstropyDeprecationWarning.\nastropy\/utils\/decorators.py:        ``AstropyDeprecationWarning`` when it is called.\nastropy\/utils\/decorators.py:                category = AstropyPendingDeprecationWarning\nastropy\/utils\/decorators.py:                category = AstropyDeprecationWarning\nastropy\/utils\/decorators.py:        If True, uses a AstropyPendingDeprecationWarning instead of a\nastropy\/utils\/decorators.py:        AstropyDeprecationWarning.\nastropy\/utils\/decorators.py:    \"\"\"Deprecate a _renamed_ function argument.\nastropy\/utils\/decorators.py:        Default is ``False``.\nastropy\/utils\/decorators.py:        Default is ``False``.\nastropy\/utils\/decorators.py:        Default is ``False``.\nastropy\/utils\/decorators.py:            # Determine the position of the argument.\nastropy\/utils\/decorators.py:                if param.kind == param.POSITIONAL_OR_KEYWORD:\nastropy\/utils\/decorators.py:                elif param.kind == param.KEYWORD_ONLY:\nastropy\/utils\/decorators.py:                    # Display the deprecation warning only when it's only\nastropy\/utils\/decorators.py:                            AstropyDeprecationWarning, stacklevel=2)\nastropy\/utils\/decorators.py:# TODO: This can still be made to work for setters by implementing an\nastropy\/utils\/decorators.py:          updated=functools.WRAPPER_UPDATES, exclude_args=()):\nastropy\/utils\/decorators.py:            # Delete documentation in this case so we don't end up with\nastropy\/utils\/compat\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/compat\/numpycompat.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/compat\/numpycompat.py:# TODO: It might also be nice to have aliases to these named for specific\nastropy\/utils\/compat\/numpycompat.py:# astropy.table.table._BROKEN_UNICODE_TABLE_SORT)\nastropy\/wcs\/tests\/test_utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/wcs\/tests\/test_utils.py:    # Default: numpy order\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN', 'VOPT-LSR', 'STOKES']\nastropy\/wcs\/tests\/test_utils.py:    assert mywcs.axis_type_names == ['RA', 'DEC', 'VOPT', 'STOKES']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.cname = ['RA', 'DEC', 'VOPT', 'STOKES']\nastropy\/wcs\/tests\/test_utils.py:    assert mywcs.axis_type_names == ['RA', 'DEC', 'VOPT', 'STOKES']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN', 'VOPT', 'STOKES']\nastropy\/wcs\/tests\/test_utils.py:    assert tuple(cel.wcs.ctype) == ('RA---TAN', 'DEC--TAN')\nastropy\/wcs\/tests\/test_utils.py:    assert cel.axis_type_names == ['RA', 'DEC']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['DEC--TAN', 'RA---TAN']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['DEC--TAN', 'VELOCITY', 'RA---TAN']\nastropy\/wcs\/tests\/test_utils.py:    assert tuple(mywcs.wcs.ctype) == ('RA---TAN', 'DEC--TAN')\nastropy\/wcs\/tests\/test_utils.py:    assert tuple(mywcs.wcs.ctype) == ('RA---TAN', 'DEC--TAN')\nastropy\/wcs\/tests\/test_utils.py:    assert tuple(mywcs.wcs.ctype) == ('RA---TAN', 'DEC--TAN')\nastropy\/wcs\/tests\/test_utils.py:    assert tuple(mywcs.wcs.ctype) == ('RA---TAN', 'DEC--TAN')\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN', 'VOPT']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_utils.py:    mywcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_utils.py:                         ((['RA---TAN', 'DEC--TAN'], True),\nastropy\/wcs\/tests\/test_utils.py:                          (['RA---TAN', 'DEC--TAN', 'FREQ'], False),\nastropy\/wcs\/tests\/test_utils.py:                         ((['RA---TAN', 'DEC--TAN'], True),\nastropy\/wcs\/tests\/test_utils.py:                          (['RA---TAN', 'DEC--TAN', 'FREQ'], True),\nastropy\/wcs\/tests\/test_utils.py:    # non-orthogonal CD:\nastropy\/wcs\/tests\/test_utils.py:    wcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/wcs\/tests\/test_utils.py:    # almost orthogonal CD:\nastropy\/units\/function\/mixin.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/tests\/test_pickle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/tests\/test_cosmology.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=-0.27)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27, Neff=-1)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27,\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=h0bad, Om0=0.27)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.2, Tcmb0=3, m_nu=0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.2, Tcmb0=3, m_nu=bad_mnu)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.2, Tcmb0=3, Neff=2, m_nu=bad_mnu)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.2, Tcmb0=3, m_nu=bad_mnu)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27, Ob0=-0.04)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27, Ob0=0.4)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27)\nastropy\/cosmology\/tests\/test_cosmology.py:        cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27, Tcmb0=2.0, Neff=3.04,\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=H0, Om0=0.27, Tcmb0=T, Neff=3.04, Ob0=0.05)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27, Tcmb0=2.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27,\nastropy\/cosmology\/tests\/test_cosmology.py:    for tcosmo in [core.LambdaCDM(H0=70, Om0=0.27, Ode0=0.5),\nastropy\/cosmology\/tests\/test_cosmology.py:                   core.wCDM(H0=70, Om0=0.27, Ode0=0.5, w0=-1.2),\nastropy\/cosmology\/tests\/test_cosmology.py:                   core.w0waCDM(H0=70, Om0=0.27, Ode0=0.5, w0=-1.2, wa=-0.2),\nastropy\/cosmology\/tests\/test_cosmology.py:                   core.wpwaCDM(H0=70, Om0=0.27, Ode0=0.5,\nastropy\/cosmology\/tests\/test_cosmology.py:                   core.w0wzCDM(H0=70, Om0=0.27, Ode0=0.5, w0=-1.2, wz=0.1)]:\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70 * u.km \/ u.s \/ u.Mpc, Om0=0.27,\nastropy\/cosmology\/tests\/test_cosmology.py:    cmp = core.FlatLambdaCDM(H0=60 * u.km \/ u.s \/ u.Mpc, Om0=0.27,\nastropy\/cosmology\/tests\/test_cosmology.py:    cmp = core.FlatLambdaCDM(name=\"New name\", H0=65 * u.km \/ u.s \/ u.Mpc,\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(name=\"test w0wa\", H0=70 * u.km \/ u.s \/ u.Mpc,\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(70, 0.3, 0.5, Tcmb0=2.725)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(70, 0.3, 0.5, Tcmb0=2.725)\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('LambdaCDM(H0=70 km \/ (Mpc s), Om0=0.3, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(70, 0.3, 0.5, Tcmb0=2.725, m_nu=u.Quantity(0.01, u.eV))\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('LambdaCDM(H0=70 km \/ (Mpc s), Om0=0.3, Ode0=0.5, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(50.0, 0.27, Tcmb0=3, Ob0=0.05)\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('FlatLambdaCDM(H0=50 km \/ (Mpc s), Om0=0.27, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wCDM(60.0, 0.27, 0.6, Tcmb0=2.725, w0=-0.8, name='test1')\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('wCDM(name=\"test1\", H0=60 km \/ (Mpc s), Om0=0.27, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatwCDM(65.0, 0.27, w0=-0.6, name='test2')\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('FlatwCDM(name=\"test2\", H0=65 km \/ (Mpc s), Om0=0.27, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(60.0, 0.25, 0.4, w0=-0.6, Tcmb0=2.725, wa=0.1, name='test3')\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('w0waCDM(name=\"test3\", H0=60 km \/ (Mpc s), Om0=0.25, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.Flatw0waCDM(55.0, 0.35, w0=-0.9, wa=-0.2, name='test4',\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('Flatw0waCDM(name=\"test4\", H0=55 km \/ (Mpc s), Om0=0.35, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wpwaCDM(50.0, 0.3, 0.3, wp=-0.9, wa=-0.2,\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('wpwaCDM(name=\"test5\", H0=50 km \/ (Mpc s), Om0=0.3, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0wzCDM(55.0, 0.4, 0.8, w0=-1.05, wz=-0.2, Tcmb0=2.725,\nastropy\/cosmology\/tests\/test_cosmology.py:    expected = ('w0wzCDM(H0=55 km \/ (Mpc s), Om0=0.4, Ode0=0.8, w0=-1.05, '\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=70, Om0=0.27, Ode0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.27, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=70, Om0=0.27, Ode0=0.73, Ob0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wCDM(H0=70, Om0=0.27, Ode0=0.73, w0=-0.9, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(H0=70, Om0=0.2, Ode0=0.8, w0=-1.1, wa=0.2, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(H0=70, Om0=0.3, Ode0=0.7, w0=-0.9, wa=0.0, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(H0=70, Om0=0.3, Ode0=0.7, w0=-0.9, wa=-0.5,\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wpwaCDM(H0=70, Om0=0.2, Ode0=0.8, wp=-1.1, wa=0.2, zp=0.5,\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wpwaCDM(H0=70, Om0=0.2, Ode0=0.8, wp=-1.1, wa=0.2, zp=0.9,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.0, 0.3, Ob0=0.045)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.0, 0.3)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.LambdaCDM(70.0, 0.3, 0.5, Tcmb0=u.Quantity(0.0, u.K))\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.0, 0.3, Tcmb0=0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.3, Tcmb0=0, Neff=3)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.3, Tcmb0=2.725, Neff=3)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.3, Tcmb0=4.0, Neff=3)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.3, Tcmb0=0, Neff=3.04)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.3, Tcmb0=2.725, Neff=3.04)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=0.3, Tcmb0=4.0, Neff=3.04)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=Om0, Tcmb0=2.725, Neff=3.04)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(H0=70, Om0=Om0, Tcmb0=4.0, Neff=3.04)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=2.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=3.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(70, 0.3, 0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(70, 0.3, 0.5, m_nu=u.Quantity(0.01, u.eV))\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(50.0, 0.27)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wCDM(60.0, 0.27, 0.6, w0=-0.8)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatwCDM(65.0, 0.27, w0=-0.6)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(60.0, 0.25, 0.4, w0=-0.6, wa=0.1)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.Flatw0waCDM(55.0, 0.35, w0=-0.9, wa=-0.2)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wpwaCDM(50.0, 0.3, 0.3, wp=-0.9, wa=-0.2, zp=0.3)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0wzCDM(55.0, 0.4, 0.8, w0=-1.05, wz=-0.2)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    c_flat = core.LambdaCDM(H0=70, Om0=0.27, Ode0=0.73, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    c_open = core.LambdaCDM(H0=70, Om0=0.27, Ode0=0.0, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    c_closed = core.LambdaCDM(H0=70, Om0=2, Ode0=0.0, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    c_flat = core.LambdaCDM(H0=70, Om0=0.27, Ode0=0.73, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    c_open = core.LambdaCDM(H0=70, Om0=0.27, Ode0=0.0, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    c_closed = core.LambdaCDM(H0=70, Om0=2, Ode0=0.0, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=70, Om0=0.3, Ode0=0.70, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=70, Om0=0.3, Ode0=0.1, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=70, Om0=2, Ode0=0.1, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=73.2, Om0=0.3, Ode0=0.50)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=70, Om0=0.3, Ode0=0.70)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wCDM(H0=70, Om0=0.3, Ode0=0.70, w0=-0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0wzCDM(H0=70, Om0=0.3, Ode0=0.70, w0=-1, wz=0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(H0=70, Om0=0.3, Ode0=0.70, w0=-1, wa=-0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wpwaCDM(H0=70, Om0=0.3, Ode0=0.70, wp=-0.9,\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.LambdaCDM(H0=70, Om0=0.3, Ode0=0.70)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wCDM(H0=70, Om0=0.3, Ode0=0.60, w0=-0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0wzCDM(H0=70, Om0=0.3, Ode0=0.50, w0=-1, wz=0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.w0waCDM(H0=70, Om0=0.3, Ode0=0.70, w0=-1, wa=-0.5)\nastropy\/cosmology\/tests\/test_cosmology.py:    cosmo = core.wpwaCDM(H0=70, Om0=0.3, Ode0=0.70, wp=-0.9,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=3.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=3.0,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.LambdaCDM(70, 0.2, 1.3, Tcmb0=0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.LambdaCDM(100, 0.3, 0.8, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(100, 0.3, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    # http:\/\/www.astro.multivax.de:8000\/phillip\/angsiz_prog\/README.HTML\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.LambdaCDM(100, 0.3, 0.5, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.LambdaCDM(100, 1.0, 0.2, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.LambdaCDM(H0=70.4, Om0=0.2, Ode0=0.5, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.LambdaCDM(H0=100, Om0=2, Ode0=1, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Neff=4.05,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=0 * u.K,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=2.725 * u.K,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(70.4, 0.272, Tcmb0=2.725,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.LambdaCDM(75.0, 0.25, 0.5, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.LambdaCDM(75.0, 0.25, 0.6, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.LambdaCDM(75.0, 0.3, 0.4, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatwCDM(75.0, 0.25, w0=-1.05, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatwCDM(75.0, 0.25, w0=-0.95, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatwCDM(75.0, 0.25, w0=-0.9, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.wCDM(75.0, 0.25, 0.4, w0=-0.9, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.wCDM(75.0, 0.25, 0.4, w0=-1.1, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.wCDM(75.0, 0.25, 0.4, w0=-0.9, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.w0waCDM(75.0, 0.3, 0.6, w0=-0.9, wa=0.1, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.w0waCDM(75.0, 0.25, 0.5, w0=-0.9, wa=0.1, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.w0waCDM(75.0, 0.25, 0.5, w0=-0.9, wa=0.1, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.Flatw0waCDM(75.0, 0.25, w0=-0.95, wa=0.15, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.Flatw0waCDM(75.0, 0.25, w0=-0.95, wa=0.15, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.Flatw0waCDM(75.0, 0.25, w0=-0.95, wa=0.15, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.wpwaCDM(75.0, 0.3, 0.6, wp=-0.9, zp=0.5, wa=0.1, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.wpwaCDM(75.0, 0.25, 0.5, wp=-0.9, zp=0.4, wa=0.1,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.wpwaCDM(75.0, 0.25, 0.5, wp=-0.9, zp=1.0, wa=0.1, Tcmb0=3.0,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.w0wzCDM(75.0, 0.3, 0.6, w0=-0.9, wz=0.1, Tcmb0=0.0)\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.w0wzCDM(75.0, 0.25, 0.5, w0=-0.9, wz=0.1,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.w0wzCDM(75.0, 0.25, 0.5, w0=-0.9, wz=0.1, Tcmb0=3.0,\nastropy\/cosmology\/tests\/test_cosmology.py:    # for FlatLambdaCDM to give the scalar nu density functions a\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0,\nastropy\/cosmology\/tests\/test_cosmology.py:    cos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0, Neff=4.2,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(75.0, 0.25, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(80.0, 0.30, Tcmb0=3.0, Neff=3,\nastropy\/cosmology\/tests\/test_cosmology.py:    tcos = core.FlatLambdaCDM(80.0, 0.30, Tcmb0=3.0, Neff=3.04,\nastropy\/visualization\/mpl_style.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/mpl_style.py:    'patch.facecolor': '#348ABD',\nastropy\/visualization\/mpl_style.py:color_cycle = ['#348ABD',   # blue\nastropy\/constants\/codata2010.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/codata2010.py:class CODATA2010(Constant):\nastropy\/constants\/codata2010.py:    default_reference = 'CODATA 2010'\nastropy\/constants\/codata2010.py:class EMCODATA2010(CODATA2010, EMConstant):\nastropy\/constants\/codata2010.py:    _registry = CODATA2010._registry\nastropy\/constants\/codata2010.py:h = CODATA2010('h', \"Planck constant\", 6.62606957e-34, 'J s',\nastropy\/constants\/codata2010.py:hbar = CODATA2010('hbar', \"Reduced Planck constant\",\nastropy\/constants\/codata2010.py:k_B = CODATA2010('k_B', \"Boltzmann constant\", 1.3806488e-23, 'J \/ (K)',\nastropy\/constants\/codata2010.py:c = CODATA2010('c', \"Speed of light in vacuum\", 2.99792458e8, 'm \/ (s)', 0.,\nastropy\/constants\/codata2010.py:G = CODATA2010('G', \"Gravitational constant\", 6.67384e-11, 'm3 \/ (kg s2)',\nastropy\/constants\/codata2010.py:g0 = CODATA2010('g0', \"Standard acceleration of gravity\", 9.80665, 'm \/ s2', 0.0,\nastropy\/constants\/codata2010.py:m_p = CODATA2010('m_p', \"Proton mass\", 1.672621777e-27, 'kg', 0.000000074e-27,\nastropy\/constants\/codata2010.py:m_n = CODATA2010('m_n', \"Neutron mass\", 1.674927351e-27, 'kg', 0.000000074e-27,\nastropy\/constants\/codata2010.py:m_e = CODATA2010('m_e', \"Electron mass\", 9.10938291e-31, 'kg', 0.00000040e-31,\nastropy\/constants\/codata2010.py:u = CODATA2010('u', \"Atomic mass\", 1.660538921e-27, 'kg', 0.000000073e-27,\nastropy\/constants\/codata2010.py:sigma_sb = CODATA2010('sigma_sb', \"Stefan-Boltzmann constant\", 5.670373e-8,\nastropy\/constants\/codata2010.py:e = EMCODATA2010('e', 'Electron charge', 1.602176565e-19, 'C', 0.000000035e-19,\nastropy\/constants\/codata2010.py:eps0 = EMCODATA2010('eps0', 'Electric constant', 8.854187817e-12, 'F\/m', 0.0,\nastropy\/constants\/codata2010.py:N_A = CODATA2010('N_A', \"Avogadro's number\", 6.02214129e23, '1 \/ (mol)',\nastropy\/constants\/codata2010.py:R = CODATA2010('R', \"Gas constant\", 8.3144621, 'J \/ (K mol)', 0.0000075,\nastropy\/constants\/codata2010.py:Ryd = CODATA2010('Ryd', 'Rydberg constant', 10973731.568539, '1 \/ (m)',\nastropy\/constants\/codata2010.py:a0 = CODATA2010('a0', \"Bohr radius\", 0.52917721092e-10, 'm', 0.00000000017e-10,\nastropy\/constants\/codata2010.py:muB = CODATA2010('muB', \"Bohr magneton\", 927.400968e-26, 'J\/T', 0.00002e-26,\nastropy\/constants\/codata2010.py:alpha = CODATA2010('alpha', \"Fine-structure constant\", 7.2973525698e-3,\nastropy\/constants\/codata2010.py:atm = CODATA2010('atm', \"Standard atmosphere\", 101325, 'Pa', 0.0,\nastropy\/constants\/codata2010.py:mu0 = CODATA2010('mu0', \"Magnetic constant\", 4.0e-7 * np.pi, 'N\/A2', 0.0,\nastropy\/constants\/codata2010.py:sigma_T = CODATA2010('sigma_T', \"Thomson scattering cross-section\",\nastropy\/constants\/codata2010.py:                  2.8977721e-3, 'm K', 0.0000026e-3, 'CODATA 2010', system='si')\nastropy\/constants\/codata2010.py:e_esu = EMCODATA2010(e.abbrev, e.name, e.value * c.value * 10.0,\nastropy\/constants\/codata2010.py:e_emu = EMCODATA2010(e.abbrev, e.name, e.value \/ 10, 'abC',\nastropy\/constants\/codata2010.py:e_gauss = EMCODATA2010(e.abbrev, e.name, e.value * c.value * 10.0,\nastropy\/convolution\/kernels.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/kernels.py:from .core import Kernel1D, Kernel2D, Kernel\nastropy\/convolution\/kernels.py:from ..modeling.core import Fittable1DModel, Fittable2DModel\nastropy\/convolution\/kernels.py:__all__ = ['Gaussian1DKernel', 'Gaussian2DKernel', 'CustomKernel',\nastropy\/convolution\/kernels.py:           'Box1DKernel', 'Box2DKernel', 'Tophat2DKernel',\nastropy\/convolution\/kernels.py:           'Trapezoid1DKernel', 'MexicanHat1DKernel', 'MexicanHat2DKernel',\nastropy\/convolution\/kernels.py:           'AiryDisk2DKernel', 'Moffat2DKernel', 'Model1DKernel',\nastropy\/convolution\/kernels.py:           'Model2DKernel', 'TrapezoidDisk2DKernel', 'Ring2DKernel']\nastropy\/convolution\/kernels.py:class Gaussian1DKernel(Kernel1D):\nastropy\/convolution\/kernels.py:    1D Gaussian filter kernel.\nastropy\/convolution\/kernels.py:        Size of the kernel array. Default = 8 * stddev\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by linearly interpolating\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10. If the factor\nastropy\/convolution\/kernels.py:    Box1DKernel, Trapezoid1DKernel, MexicanHat1DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Gaussian1DKernel\nastropy\/convolution\/kernels.py:        gauss_1D_kernel = Gaussian1DKernel(10)\nastropy\/convolution\/kernels.py:        plt.plot(gauss_1D_kernel, drawstyle='steps')\nastropy\/convolution\/kernels.py:        self._model = models.Gaussian1D(1. \/ (np.sqrt(2 * np.pi) * stddev),\nastropy\/convolution\/kernels.py:class Gaussian2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D Gaussian filter kernel.\nastropy\/convolution\/kernels.py:        Size in x direction of the kernel array. Default = 8 * stddev.\nastropy\/convolution\/kernels.py:        Size in y direction of the kernel array. Default = 8 * stddev.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Box2DKernel, Tophat2DKernel, MexicanHat2DKernel, Ring2DKernel,\nastropy\/convolution\/kernels.py:    TrapezoidDisk2DKernel, AiryDisk2DKernel, Moffat2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Gaussian2DKernel\nastropy\/convolution\/kernels.py:        gaussian_2D_kernel = Gaussian2DKernel(10)\nastropy\/convolution\/kernels.py:        plt.imshow(gaussian_2D_kernel, interpolation='none', origin='lower')\nastropy\/convolution\/kernels.py:        self._model = models.Gaussian2D(1. \/ (2 * np.pi * x_stddev * y_stddev),\nastropy\/convolution\/kernels.py:class Box1DKernel(Kernel1D):\nastropy\/convolution\/kernels.py:    1D Box filter kernel.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by linearly interpolating\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian1DKernel, Trapezoid1DKernel, MexicanHat1DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Box1DKernel\nastropy\/convolution\/kernels.py:        box_1D_kernel = Box1DKernel(9)\nastropy\/convolution\/kernels.py:        plt.plot(box_1D_kernel, drawstyle='steps')\nastropy\/convolution\/kernels.py:        self._model = models.Box1D(1. \/ width, 0, width)\nastropy\/convolution\/kernels.py:class Box2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D Box filter kernel.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian2DKernel, Tophat2DKernel, MexicanHat2DKernel, Ring2DKernel,\nastropy\/convolution\/kernels.py:    TrapezoidDisk2DKernel, AiryDisk2DKernel, Moffat2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Box2DKernel\nastropy\/convolution\/kernels.py:        box_2D_kernel = Box2DKernel(9)\nastropy\/convolution\/kernels.py:        plt.imshow(box_2D_kernel, interpolation='none', origin='lower',\nastropy\/convolution\/kernels.py:        self._model = models.Box2D(1. \/ width ** 2, 0, 0, width, width)\nastropy\/convolution\/kernels.py:class Tophat2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D Tophat filter kernel.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian2DKernel, Box2DKernel, MexicanHat2DKernel, Ring2DKernel,\nastropy\/convolution\/kernels.py:    TrapezoidDisk2DKernel, AiryDisk2DKernel, Moffat2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Tophat2DKernel\nastropy\/convolution\/kernels.py:        tophat_2D_kernel = Tophat2DKernel(40)\nastropy\/convolution\/kernels.py:        plt.imshow(tophat_2D_kernel, interpolation='none', origin='lower')\nastropy\/convolution\/kernels.py:        self._model = models.Disk2D(1. \/ (np.pi * radius ** 2), 0, 0, radius)\nastropy\/convolution\/kernels.py:class Ring2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D Ring filter kernel.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian2DKernel, Box2DKernel, Tophat2DKernel, MexicanHat2DKernel,\nastropy\/convolution\/kernels.py:    Ring2DKernel, AiryDisk2DKernel, Moffat2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Ring2DKernel\nastropy\/convolution\/kernels.py:        ring_2D_kernel = Ring2DKernel(9, 8)\nastropy\/convolution\/kernels.py:        plt.imshow(ring_2D_kernel, interpolation='none', origin='lower')\nastropy\/convolution\/kernels.py:        self._model = models.Ring2D(1. \/ (np.pi * (radius_out ** 2 - radius_in ** 2)),\nastropy\/convolution\/kernels.py:class Trapezoid1DKernel(Kernel1D):\nastropy\/convolution\/kernels.py:    1D trapezoid kernel.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by linearly interpolating\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Box1DKernel, Gaussian1DKernel, MexicanHat1DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Trapezoid1DKernel\nastropy\/convolution\/kernels.py:        trapezoid_1D_kernel = Trapezoid1DKernel(17, slope=0.2)\nastropy\/convolution\/kernels.py:        plt.plot(trapezoid_1D_kernel, drawstyle='steps')\nastropy\/convolution\/kernels.py:        self._model = models.Trapezoid1D(1, 0, width, slope)\nastropy\/convolution\/kernels.py:class TrapezoidDisk2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D trapezoid kernel.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian2DKernel, Box2DKernel, Tophat2DKernel, MexicanHat2DKernel,\nastropy\/convolution\/kernels.py:    Ring2DKernel, AiryDisk2DKernel, Moffat2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import TrapezoidDisk2DKernel\nastropy\/convolution\/kernels.py:        trapezoid_2D_kernel = TrapezoidDisk2DKernel(20, slope=0.2)\nastropy\/convolution\/kernels.py:        plt.imshow(trapezoid_2D_kernel, interpolation='none', origin='lower')\nastropy\/convolution\/kernels.py:        self._model = models.TrapezoidDisk2D(1, 0, 0, radius, slope)\nastropy\/convolution\/kernels.py:class MexicanHat1DKernel(Kernel1D):\nastropy\/convolution\/kernels.py:    1D Mexican hat filter kernel.\nastropy\/convolution\/kernels.py:        Size in x direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by linearly interpolating\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Box1DKernel, Gaussian1DKernel, Trapezoid1DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import MexicanHat1DKernel\nastropy\/convolution\/kernels.py:        mexicanhat_1D_kernel = MexicanHat1DKernel(10)\nastropy\/convolution\/kernels.py:        plt.plot(mexicanhat_1D_kernel, drawstyle='steps')\nastropy\/convolution\/kernels.py:        self._model = models.MexicanHat1D(amplitude, 0, width)\nastropy\/convolution\/kernels.py:class MexicanHat2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D Mexican hat filter kernel.\nastropy\/convolution\/kernels.py:        Size in x direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/kernels.py:        Size in y direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian2DKernel, Box2DKernel, Tophat2DKernel, Ring2DKernel,\nastropy\/convolution\/kernels.py:    TrapezoidDisk2DKernel, AiryDisk2DKernel, Moffat2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import MexicanHat2DKernel\nastropy\/convolution\/kernels.py:        mexicanhat_2D_kernel = MexicanHat2DKernel(10)\nastropy\/convolution\/kernels.py:        plt.imshow(mexicanhat_2D_kernel, interpolation='none', origin='lower')\nastropy\/convolution\/kernels.py:        self._model = models.MexicanHat2D(amplitude, 0, 0, width)\nastropy\/convolution\/kernels.py:class AiryDisk2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D Airy disk kernel.\nastropy\/convolution\/kernels.py:        Size in x direction of the kernel array. Default = 8 * radius.\nastropy\/convolution\/kernels.py:        Size in y direction of the kernel array. Default = 8 * radius.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian2DKernel, Box2DKernel, Tophat2DKernel, MexicanHat2DKernel,\nastropy\/convolution\/kernels.py:    Ring2DKernel, TrapezoidDisk2DKernel, AiryDisk2DKernel, Moffat2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import AiryDisk2DKernel\nastropy\/convolution\/kernels.py:        airydisk_2D_kernel = AiryDisk2DKernel(10)\nastropy\/convolution\/kernels.py:        plt.imshow(airydisk_2D_kernel, interpolation='none', origin='lower')\nastropy\/convolution\/kernels.py:        self._model = models.AiryDisk2D(1, 0, 0, radius)\nastropy\/convolution\/kernels.py:class Moffat2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    2D Moffat kernel.\nastropy\/convolution\/kernels.py:        Size in x direction of the kernel array. Default = 8 * radius.\nastropy\/convolution\/kernels.py:        Size in y direction of the kernel array. Default = 8 * radius.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:    Gaussian2DKernel, Box2DKernel, Tophat2DKernel, MexicanHat2DKernel,\nastropy\/convolution\/kernels.py:    Ring2DKernel, TrapezoidDisk2DKernel, AiryDisk2DKernel\nastropy\/convolution\/kernels.py:        from astropy.convolution import Moffat2DKernel\nastropy\/convolution\/kernels.py:        moffat_2D_kernel = Moffat2DKernel(3, 2)\nastropy\/convolution\/kernels.py:        plt.imshow(moffat_2D_kernel, interpolation='none', origin='lower')\nastropy\/convolution\/kernels.py:        self._model = models.Moffat2D((gamma - 1.0) \/ (np.pi * alpha * alpha),\nastropy\/convolution\/kernels.py:class Model1DKernel(Kernel1D):\nastropy\/convolution\/kernels.py:    Create kernel from 1D model.\nastropy\/convolution\/kernels.py:    model : `~astropy.modeling.Fittable1DModel`\nastropy\/convolution\/kernels.py:        Size in x direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by linearly interpolating\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:        If model is not an instance of `~astropy.modeling.Fittable1DModel`\nastropy\/convolution\/kernels.py:    Model2DKernel : Create kernel from `~astropy.modeling.Fittable2DModel`\nastropy\/convolution\/kernels.py:    Define a Gaussian1D model:\nastropy\/convolution\/kernels.py:        >>> from astropy.modeling.models import Gaussian1D\nastropy\/convolution\/kernels.py:        >>> from astropy.convolution.kernels import Model1DKernel\nastropy\/convolution\/kernels.py:        >>> gauss = Gaussian1D(1, 0, 2)\nastropy\/convolution\/kernels.py:        >>> gauss_kernel = Model1DKernel(gauss, x_size=9)\nastropy\/convolution\/kernels.py:        if isinstance(model, Fittable1DModel):\nastropy\/convolution\/kernels.py:            raise TypeError(\"Must be Fittable1DModel\")\nastropy\/convolution\/kernels.py:class Model2DKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    Create kernel from 2D model.\nastropy\/convolution\/kernels.py:    model : `~astropy.modeling.Fittable2DModel`\nastropy\/convolution\/kernels.py:        Size in x direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/kernels.py:        Size in y direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/kernels.py:                Discretize model by taking the value\nastropy\/convolution\/kernels.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/kernels.py:                Discretize model by taking the average\nastropy\/convolution\/kernels.py:                Discretize model by integrating the\nastropy\/convolution\/kernels.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/kernels.py:        If model is not an instance of `~astropy.modeling.Fittable2DModel`\nastropy\/convolution\/kernels.py:    Model1DKernel : Create kernel from `~astropy.modeling.Fittable1DModel`\nastropy\/convolution\/kernels.py:    Define a Gaussian2D model:\nastropy\/convolution\/kernels.py:        >>> from astropy.modeling.models import Gaussian2D\nastropy\/convolution\/kernels.py:        >>> from astropy.convolution.kernels import Model2DKernel\nastropy\/convolution\/kernels.py:        >>> gauss = Gaussian2D(1, 0, 0, 2, 2)\nastropy\/convolution\/kernels.py:        >>> gauss_kernel = Model2DKernel(gauss, x_size=9)\nastropy\/convolution\/kernels.py:        if isinstance(model, Fittable2DModel):\nastropy\/convolution\/kernels.py:            raise TypeError(\"Must be Fittable2DModel\")\nastropy\/convolution\/kernels.py:class PSFKernel(Kernel2D):\nastropy\/convolution\/kernels.py:    Model2DKernel, Model1DKernel\nastropy\/convolution\/kernels.py:    Define one dimensional array:\nastropy\/convolution\/kernels.py:    Define two dimensional array:\nastropy\/visualization\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/utils.py:class DiscretizationError(Exception):\nastropy\/convolution\/utils.py:def add_kernel_arrays_1D(array_1, array_2):\nastropy\/convolution\/utils.py:    Add two 1D kernel arrays of different size.\nastropy\/convolution\/utils.py:def add_kernel_arrays_2D(array_1, array_2):\nastropy\/convolution\/utils.py:    Add two 2D kernel arrays of different size.\nastropy\/convolution\/utils.py:        size is well defined. Necessary only for 2D models.\nastropy\/convolution\/utils.py:                Discretize model by taking the value\nastropy\/convolution\/utils.py:                Discretize model by linearly interpolating\nastropy\/convolution\/utils.py:                For 2D models interpolation is bilinear.\nastropy\/convolution\/utils.py:                Discretize model by taking the average\nastropy\/convolution\/utils.py:                Discretize model by integrating the model\nastropy\/convolution\/utils.py:        Factor of oversampling. Default = 10.\nastropy\/convolution\/utils.py:    scale. Here is the example of a normalized Gaussian1D:\nastropy\/convolution\/utils.py:        from astropy.modeling.models import Gaussian1D\nastropy\/convolution\/utils.py:        gauss_1D = Gaussian1D(1 \/ (0.5 * np.sqrt(2 * np.pi)), 0, 0.5)\nastropy\/convolution\/utils.py:        y_center = discretize_model(gauss_1D, (-2, 3), mode='center')\nastropy\/convolution\/utils.py:        y_corner = discretize_model(gauss_1D, (-2, 3), mode='linear_interp')\nastropy\/convolution\/utils.py:        y_oversample = discretize_model(gauss_1D, (-2, 3), mode='oversample')\nastropy\/convolution\/utils.py:            return discretize_center_1D(model, x_range)\nastropy\/convolution\/utils.py:            return discretize_center_2D(model, x_range, y_range)\nastropy\/convolution\/utils.py:            return discretize_linear_1D(model, x_range)\nastropy\/convolution\/utils.py:            return discretize_bilinear_2D(model, x_range, y_range)\nastropy\/convolution\/utils.py:            return discretize_oversample_1D(model, x_range, factor)\nastropy\/convolution\/utils.py:            return discretize_oversample_2D(model, x_range, y_range, factor)\nastropy\/convolution\/utils.py:            return discretize_integrate_1D(model, x_range)\nastropy\/convolution\/utils.py:            return discretize_integrate_2D(model, x_range, y_range)\nastropy\/convolution\/utils.py:        raise DiscretizationError('Invalid mode.')\nastropy\/convolution\/utils.py:def discretize_center_1D(model, x_range):\nastropy\/convolution\/utils.py:    Discretize model by taking the value at the center of the bin.\nastropy\/convolution\/utils.py:def discretize_center_2D(model, x_range, y_range):\nastropy\/convolution\/utils.py:    Discretize model by taking the value at the center of the pixel.\nastropy\/convolution\/utils.py:def discretize_linear_1D(model, x_range):\nastropy\/convolution\/utils.py:    Discretize model by performing a linear interpolation.\nastropy\/convolution\/utils.py:def discretize_bilinear_2D(model, x_range, y_range):\nastropy\/convolution\/utils.py:    Discretize model by performing a bilinear interpolation.\nastropy\/convolution\/utils.py:def discretize_oversample_1D(model, x_range, factor=10):\nastropy\/convolution\/utils.py:    Discretize model by taking the average on an oversampled grid.\nastropy\/convolution\/utils.py:def discretize_oversample_2D(model, x_range, y_range, factor=10):\nastropy\/convolution\/utils.py:    Discretize model by taking the average on an oversampled grid.\nastropy\/convolution\/utils.py:def discretize_integrate_1D(model, x_range):\nastropy\/convolution\/utils.py:    Discretize model by integrating numerically the model over the bin.\nastropy\/convolution\/utils.py:def discretize_integrate_2D(model, x_range, y_range):\nastropy\/convolution\/utils.py:    Discretize model by integrating the model over the pixel.\nexamples\/io\/fits-tables.py:*License: BSD*\nexamples\/io\/fits-tables.py:# Download a FITS file\nexamples\/io\/fits-tables.py:# Display information about the contents of the FITS file.\nastropy\/io\/misc\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/lupton_rgb.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/lupton_rgb.py:        The asinh softening parameter. Default is 8.\nastropy\/io\/misc\/hdf5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/hdf5.py:This package contains functions for reading and writing HDF5 tables that are\nastropy\/io\/misc\/hdf5.py:# NOTE: Do not import anything from astropy.table here.\nastropy\/io\/misc\/hdf5.py:from ...utils.exceptions import AstropyUserWarning, AstropyDeprecationWarning\nastropy\/io\/misc\/hdf5.py:HDF5_SIGNATURE = b'\\x89HDF\\r\\n\\x1a\\n'\nastropy\/io\/misc\/hdf5.py:    Find all structured arrays in an HDF5 file\nastropy\/io\/misc\/hdf5.py:        if isinstance(obj, h5py.Dataset) and obj.dtype.kind == 'V':\nastropy\/io\/misc\/hdf5.py:        return signature == HDF5_SIGNATURE\nastropy\/io\/misc\/hdf5.py:        return isinstance(args[0], (h5py.highlevel.File, h5py.highlevel.Group, h5py.highlevel.Dataset))\nastropy\/io\/misc\/hdf5.py:    Read a Table object from an HDF5 file\nastropy\/io\/misc\/hdf5.py:    table is present in the HDF5 file or group, the first table is read in and\nastropy\/io\/misc\/hdf5.py:        :class:`h5py:Dataset` If a string, the filename to read the table from.\nastropy\/io\/misc\/hdf5.py:        The path from which to read the table inside the HDF5 file.\nastropy\/io\/misc\/hdf5.py:        raise Exception(\"h5py is required to read and write HDF5 files\")\nastropy\/io\/misc\/hdf5.py:                raise ValueError(\"no table found in HDF5 group {0}\".\nastropy\/io\/misc\/hdf5.py:    elif not isinstance(input, h5py.highlevel.Dataset):\nastropy\/io\/misc\/hdf5.py:    # If we are here, `input` should be a Dataset object, which we can now\nastropy\/io\/misc\/hdf5.py:    # attributes of the HDF5 dataset.\nastropy\/io\/misc\/hdf5.py:    # that *require* YAML serialization.  HDF5 already has support for\nastropy\/io\/misc\/hdf5.py:                                \"to HDF5 without PyYAML installed.\"\nastropy\/io\/misc\/hdf5.py:    Write a Table object to an HDF5 file\nastropy\/io\/misc\/hdf5.py:        Data table that is to be written to file.\nastropy\/io\/misc\/hdf5.py:        The path to which to write the table inside the HDF5 file.\nastropy\/io\/misc\/hdf5.py:        Whether to compress the table inside the HDF5 file. If set to `True`,\nastropy\/io\/misc\/hdf5.py:        Whether to append the table to an existing HDF5 file.\nastropy\/io\/misc\/hdf5.py:        raise Exception(\"h5py is required to read and write HDF5 files\")\nastropy\/io\/misc\/hdf5.py:            # Delete only the dataset itself\nastropy\/io\/misc\/hdf5.py:    # HDF5 can store natively (name, dtype) with no meta.\nastropy\/io\/misc\/hdf5.py:                          AstropyDeprecationWarning)\nastropy\/io\/misc\/hdf5.py:                \"Attributes could not be written to the output HDF5 \"\nastropy\/io\/misc\/hdf5.py:        # Write the Table meta dict key:value pairs to the file as HDF5\nastropy\/io\/misc\/hdf5.py:                              \"HDF5 files - skipping. (Consider specifying \"\nastropy\/io\/misc\/hdf5.py:    Register HDF5 with Unified I\/O.\nastropy\/convolution\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/util.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/util.py:# STDLIB\nastropy\/io\/votable\/util.py:        If `True`, create a gzip-compressed file.  (Default is `False`).\nastropy\/io\/votable\/util.py:# <http:\/\/www.ivoa.net\/Documents\/REC\/DM\/STC-20071030.html>\nastropy\/io\/votable\/util.py:    'SUPER_GALACTIC', 'AZ_EL', 'BODY', 'GEO_C', 'GEO_D', 'MAG', 'GSE', 'GSM',\nastropy\/io\/votable\/util.py:    <http:\/\/www.ivoa.net\/Documents\/REC\/DAL\/SSA-20080201.html>`_.\nastropy\/io\/votable\/util.py:        TODO\nastropy\/convolution\/convolve.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/convolve.py:from .core import Kernel, Kernel1D, Kernel2D, MAX_NORMALIZATION\nastropy\/convolution\/convolve.py:# Disabling all doctests in this module until a better way of handling warnings\nastropy\/convolution\/convolve.py:BOUNDARY_OPTIONS = [None, 'fill', 'wrap', 'extend']\nastropy\/convolution\/convolve.py:    array : `numpy.ndarray` or `~astropy.nddata.NDData`\nastropy\/convolution\/convolve.py:        3-dimensional array.  If an `~astropy.nddata.NDData`, the ``mask`` of\nastropy\/convolution\/convolve.py:        the `~astropy.nddata.NDData` will be used as the ``mask`` argument.\nastropy\/convolution\/convolve.py:        normalized. Default is \"1e-8\".\nastropy\/convolution\/convolve.py:    if boundary not in BOUNDARY_OPTIONS:\nastropy\/convolution\/convolve.py:                         .format(BOUNDARY_OPTIONS))\nastropy\/convolution\/convolve.py:    # if it's a floating point type.  Don't bother with this for lists --\nastropy\/convolution\/convolve.py:            if isinstance(array, Kernel1D) and isinstance(kernel, Kernel1D):\nastropy\/convolution\/convolve.py:                new_kernel = Kernel1D(array=new_array)\nastropy\/convolution\/convolve.py:            elif isinstance(array, Kernel2D) and isinstance(kernel, Kernel2D):\nastropy\/convolution\/convolve.py:                new_kernel = Kernel2D(array=new_array)\nastropy\/convolution\/convolve.py:                raise Exception(\"Can't convolve 1D and 2D kernel.\")\nastropy\/convolution\/convolve.py:        normalized. Default is \"1e-8\".\nastropy\/convolution\/convolve.py:        Default on.  Zero-pad image to the nearest 2^n.  With\nastropy\/convolution\/convolve.py:        Default on.  Return an image of the size of the larger of the input\nastropy\/convolution\/convolve.py:        ``ifft(fft(image)*fft(kernel))``).  Useful for making PSDs.\nastropy\/visualization\/transform.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/tree_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/stretch.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/stretch.py:from ..utils.misc import InheritDocstrings\nastropy\/visualization\/stretch.py:           \"PowerDistStretch\", \"SquaredStretch\", \"LogStretch\", \"AsinhStretch\",\nastropy\/visualization\/stretch.py:class BaseStretch(BaseTransform, metaclass=InheritDocstrings):\nastropy\/visualization\/stretch.py:class PowerDistStretch(BaseStretch):\nastropy\/visualization\/stretch.py:        The ``a`` parameter used in the above formula.  Default is 1000.\nastropy\/visualization\/stretch.py:        return InvertedPowerDistStretch(a=self.exp)\nastropy\/visualization\/stretch.py:class InvertedPowerDistStretch(BaseStretch):\nastropy\/visualization\/stretch.py:    `~astropy.image.scaling.PowerDistStretch`.\nastropy\/visualization\/stretch.py:        The ``a`` parameter used in the above formula.  Default is 1000.\nastropy\/visualization\/stretch.py:        return PowerDistStretch(a=self.exp)\nastropy\/visualization\/stretch.py:        The ``a`` parameter used in the above formula.  Default is 1000.\nastropy\/visualization\/stretch.py:        The ``a`` parameter used in the above formula.  Default is 1000.\nastropy\/visualization\/stretch.py:        Default is 0.1\nastropy\/visualization\/stretch.py:        The ``a`` parameter used in the above formula.  Default is 1\/3.\nastropy\/io\/votable\/validator\/html.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/validator\/html.py:# STDLIB\nastropy\/io\/votable\/validator\/html.py:<!DOCTYPE html\nastropy\/io\/votable\/validator\/html.py:        PUBLIC \"-\/\/W3C\/\/DTD XHTML Basic 1.0\/\/EN\"\nastropy\/io\/votable\/validator\/result.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/validator\/result.py:# STDLIB\nastropy\/io\/votable\/validator\/result.py:                fd.write('FAILED: {0}\\n'.format(reason).encode('utf-8'))\nastropy\/visualization\/scripts\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/scripts\/fits2bitmap.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/scripts\/fits2bitmap.py:        The pixel value of the minimum cut level.  Data values less than\nastropy\/visualization\/scripts\/fits2bitmap.py:        The pixel value of the maximum cut level.  Data values greater\nastropy\/visualization\/scripts\/fits2bitmap.py:        log.critical('data in FITS extension {0} is not a 2D array'\nastropy\/visualization\/scripts\/fits2bitmap.py:                        help='Specify the HDU extension number or name '\nastropy\/visualization\/scripts\/fits2bitmap.py:                             '(Default is 0).')\nastropy\/visualization\/scripts\/fits2bitmap.py:                        help='Filename for the output image (Default is a '\nastropy\/visualization\/scripts\/fits2bitmap.py:                        '\"power\", \"log\", or \"asinh\") (Default is \"linear\").')\nastropy\/visualization\/scripts\/fits2bitmap.py:                        help='Power index for \"power\" stretching (Default is '\nastropy\/visualization\/scripts\/fits2bitmap.py:                             '(Default is 0.1).')\nastropy\/visualization\/scripts\/fits2bitmap.py:                             '(Default is the image minimum).')\nastropy\/visualization\/scripts\/fits2bitmap.py:                             '(Default is the image maximum).')\nastropy\/visualization\/scripts\/fits2bitmap.py:                             'minimum cut level (Default is 0).')\nastropy\/visualization\/scripts\/fits2bitmap.py:                             'maximum cut level (Default is 100).')\nastropy\/visualization\/scripts\/fits2bitmap.py:                             'maximum cut levels (Default is 100).')\nastropy\/visualization\/scripts\/fits2bitmap.py:                                                '(Default is \"Greys_r\").')\nastropy\/io\/votable\/volint.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/ucd_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/resource_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/resource_test.py:    assert groups[0].entries[0].name == \"ID\"\nastropy\/io\/votable\/tests\/resource_test.py:    assert params[0].name == \"standardID\"\nastropy\/io\/votable\/ucd.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/ucd.py:This file contains routines to verify the correctness of UCD strings.\nastropy\/io\/votable\/ucd.py:# STDLIB\nastropy\/io\/votable\/ucd.py:class UCDWords:\nastropy\/io\/votable\/ucd.py:    Manages a list of acceptable UCD words.\nastropy\/io\/votable\/ucd.py:        Returns the official English description of the given UCD\nastropy\/io\/votable\/ucd.py:    Parse the UCD into its component parts.\nastropy\/io\/votable\/ucd.py:        The UCD string\nastropy\/io\/votable\/ucd.py:        If `True`, then each word in the UCD will be verified against\nastropy\/io\/votable\/ucd.py:        the UCD1+ controlled vocabulary, (as required by the VOTable\nastropy\/io\/votable\/ucd.py:        If `True`, the UCD may contain a colon (as defined in earlier\nastropy\/io\/votable\/ucd.py:        _ucd_singleton = UCDWords()\nastropy\/io\/votable\/ucd.py:        raise ValueError(\"UCD has invalid character '{}' in '{}'\".format(\nastropy\/io\/votable\/ucd.py:        The UCD string\nastropy\/io\/votable\/ucd.py:        If `True`, then each word in the UCD will be verified against\nastropy\/io\/votable\/ucd.py:        the UCD1+ controlled vocabulary, (as required by the VOTable\nastropy\/io\/votable\/ucd.py:        If `True`, the UCD may contain a colon (as defined in earlier\nastropy\/io\/votable\/tests\/util_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/converters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/converters.py:to\/from TABLEDATA_ and BINARY_ formats.\nastropy\/io\/votable\/converters.py:# STDLIB\nastropy\/io\/votable\/converters.py:# THIRD-PARTY\nastropy\/io\/votable\/converters.py:    converting a specific VOTABLE data type to\/from the TABLEDATA_ and\nastropy\/io\/votable\/converters.py:        The position in the XML file where the FIELD object was\nastropy\/io\/votable\/converters.py:        Convert the string *value* from the TABLEDATA_ format into an\nastropy\/io\/votable\/converters.py:            value in TABLEDATA format\nastropy\/io\/votable\/converters.py:            value in TABLEDATA format\nastropy\/io\/votable\/converters.py:        to a unicode string suitable for serializing in the TABLEDATA_\nastropy\/io\/votable\/converters.py:                vo_raise(E01, (field.arraysize, 'char', field.ID), config)\nastropy\/io\/votable\/converters.py:                vo_raise(E01, (field.arraysize, 'unicode', field.ID), config)\nastropy\/io\/votable\/converters.py:class Double(FloatingPoint):\nastropy\/io\/votable\/converters.py:    Handles the double datatype.  Double-precision IEEE\nastropy\/io\/votable\/converters.py:class DoubleComplex(Complex):\nastropy\/io\/votable\/converters.py:    'double': Double,\nastropy\/io\/votable\/converters.py:    'doubleComplex': DoubleComplex,\nastropy\/io\/votable\/converters.py:        vo_raise(E06, (field.datatype, field.ID), config)\nastropy\/io\/votable\/converters.py:    a VOTable FIELD element and correspond to that type.\nastropy\/io\/votable\/converters.py:       set on a VOTable FIELD element.\nastropy\/io\/votable\/converters.py:    necessary to create a VOTable FIELD element that corresponds to\nastropy\/io\/votable\/converters.py:       set on a VOTable FIELD element.\nastropy\/io\/votable\/exceptions.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/exceptions.py:# STDLIB\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#toc-header-35>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:TABLEDATA>`__\nastropy\/io\/votable\/exceptions.py:        According to the XML standard, the attribute ``ID`` is a\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:name>`__,\nastropy\/io\/votable\/exceptions.py:    The VOTable 1.1 spec says the following about ``name`` vs. ``ID``\nastropy\/io\/votable\/exceptions.py:    on ``FIELD`` and ``VALUE`` elements:\nastropy\/io\/votable\/exceptions.py:        ``ID`` and ``name`` attributes have a different role in\nastropy\/io\/votable\/exceptions.py:        VOTable: the ``ID`` is meant as a *unique identifier* of an\nastropy\/io\/votable\/exceptions.py:        throughout the VOTable document. The ``ID`` attribute is\nastropy\/io\/votable\/exceptions.py:        referenced, but in principle any element may have an ``ID``\nastropy\/io\/votable\/exceptions.py:        attribute. ... In summary, the ``ID`` is different from the\nastropy\/io\/votable\/exceptions.py:        ``name`` attribute in that (a) the ``ID`` attribute is made\nastropy\/io\/votable\/exceptions.py:        relevant element with matching ``ID``.\nastropy\/io\/votable\/exceptions.py:        While the ``ID`` attribute has to be unique in a VOTable\nastropy\/io\/votable\/exceptions.py:        ``name`` attributes of ``FIELD``, ``PARAM`` and optional\nastropy\/io\/votable\/exceptions.py:    columns, ``ID`` is used for the column name when present.\nastropy\/io\/votable\/exceptions.py:    However, when ``ID`` is not present, (since it is not required by\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:name>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:name>`__\nastropy\/io\/votable\/exceptions.py:    message_template = \"Implicitly generating an ID from a name '{}' -> '{}'\"\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:link>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:link>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/vizier.u-strasbg.fr\/doc\/UCD.htx>`__.\nastropy\/io\/votable\/exceptions.py:    If the VOTable version is 1.2 or later, the UCD will also be\nastropy\/io\/votable\/exceptions.py:    by UCD1+.\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:ucd>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:ucd>`__\nastropy\/io\/votable\/exceptions.py:    message_template = \"Invalid UCD '{}': {}\"\nastropy\/io\/votable\/exceptions.py:    Defined in this XML Schema snippet::\nastropy\/io\/votable\/exceptions.py:    The VOTable specification uses the attribute name ``ID`` (with\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:name>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:name>`__\nastropy\/io\/votable\/exceptions.py:    message_template = \"ID attribute not capitalized\"\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC54>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC58>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:link>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:link>`__\nastropy\/io\/votable\/exceptions.py:    ``FIELD`` element must have either an ``ID`` or ``name`` attribute\nastropy\/io\/votable\/exceptions.py:    ``name`` is not present by ``ID`` is, and *pedantic mode* is off,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:name>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:name>`__\nastropy\/io\/votable\/exceptions.py:        \"'{}' element must have at least one of 'ID' or 'name' attributes\")\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:# W14: Deprecated\nastropy\/io\/votable\/exceptions.py:    The ``name`` attribute is required on every ``FIELD`` element.\nastropy\/io\/votable\/exceptions.py:    an ``ID`` instead.  In this case, when *pedantic mode* is off,\nastropy\/io\/votable\/exceptions.py:    ``vo.table`` will copy the ``name`` attribute to a new ``ID``\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:name>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:name>`__\nastropy\/io\/votable\/exceptions.py:# W16: Deprecated\nastropy\/io\/votable\/exceptions.py:    A ``DESCRIPTION`` element can only appear once within its parent\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC54>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC58>`__)\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:addesc>`__\nastropy\/io\/votable\/exceptions.py:    message_template = \"{} element contains more than one DESCRIPTION element\"\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC10>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC10>`__\nastropy\/io\/votable\/exceptions.py:    The column fields as defined using ``FIELD`` elements do not match\nastropy\/io\/votable\/exceptions.py:    Version 1.0 of the VOTable specification used the ``DEFINITIONS``\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:definitions>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:definitions>`__\nastropy\/io\/votable\/exceptions.py:    message_template = 'The DEFINITIONS element is deprecated in VOTable 1.1.  Ignoring'\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:utype>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/ivoa.net\/Documents\/latest\/VOTableSTC.html>`__.\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC54>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC58>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:    value must be specified in the FIELD descriptor to support reading\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:    Each field in a table must have a unique ID.  If two or more fields\nastropy\/io\/votable\/exceptions.py:    have the same ID, some will be renamed to ensure that all IDs are\nastropy\/io\/votable\/exceptions.py:        The ``ID`` and ``ref`` attributes are defined as XML types\nastropy\/io\/votable\/exceptions.py:        ``ID`` and ``IDREF`` respectively. This means that the\nastropy\/io\/votable\/exceptions.py:        contents of ``ID`` is an identifier which must be unique\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:name>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:name>`__\nastropy\/io\/votable\/exceptions.py:    message_template = \"Duplicate ID '{}' renamed to '{}' to ensure uniqueness\"\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:name>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:name>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.w3.org\/TR\/2000\/WD-xml-2e-20000814#NT-Nmtoken>`__.\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC54>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC32>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:values>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:values>`__\nastropy\/io\/votable\/exceptions.py:    vo.table are ``TABLEDATA``, ``BINARY`` and ``FITS``.\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:data>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:data>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:       In VOTable1.2, it is further recommended to place the ID\nastropy\/io\/votable\/exceptions.py:        ``ID`` attribute. When specified, the ``ref`` attribute\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC54>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC58>`__\nastropy\/io\/votable\/exceptions.py:        <FIELD name=\"unboundedString\" datatype=\"char\" arraysize=\"*\"\/>\nastropy\/io\/votable\/exceptions.py:    A 1D array of strings can be represented as a 2D array of\nastropy\/io\/votable\/exceptions.py:    in the FIELD specifier.\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:    insensitive) in the ``TABLEDATA`` format::\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:datatypes>`__\nastropy\/io\/votable\/exceptions.py:# E07: Deprecated\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:values>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:values>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:values>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:values>`__\nastropy\/io\/votable\/exceptions.py:    From VOTable 1.1 and later, ``FIELD`` and ``PARAM`` elements must have\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#elem:FIELD>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#elem:FIELD>`__\nastropy\/io\/votable\/exceptions.py:    default_args = ('FIELD',)\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:form>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:form>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:form>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:form>`__\nastropy\/io\/votable\/exceptions.py:        point in a 3D space can be defined by the following::\nastropy\/io\/votable\/exceptions.py:            <FIELD ID=\"point_3D\" datatype=\"double\" arraysize=\"3\"\/>\nastropy\/io\/votable\/exceptions.py:            <FIELD ID=\"values\" datatype=\"int\" arraysize=\"100*\"\/>\nastropy\/io\/votable\/exceptions.py:            <FIELD ID=\"thumbs\" datatype=\"unsignedByte\" arraysize=\"64\u00d764\u00d710*\"\/>\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#sec:dim>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#sec:dim>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#elem:FIELD>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#elem:FIELD>`__\nastropy\/io\/votable\/exceptions.py:    All ``COOSYS`` elements must have an ``ID`` attribute.\nastropy\/io\/votable\/exceptions.py:    message_template = \"ID attribute is required for all COOSYS elements\"\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#elem:COOSYS>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC54>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC58>`__\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20040811\/REC-VOTable-1.1-20040811.html#ToC54>`__,\nastropy\/io\/votable\/exceptions.py:    <http:\/\/www.ivoa.net\/Documents\/VOTable\/20091130\/REC-VOTable-1.2.html#ToC58>`__\nastropy\/io\/votable\/exceptions.py:    message_template = \"Data has more columns than are defined in the header ({})\"\nastropy\/io\/votable\/exceptions.py:    message_template = \"Data has fewer columns ({}) than are defined in the header ({})\"\nastropy\/io\/votable\/tree.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tree.py:# TODO: Test FITS parsing\nastropy\/io\/votable\/tree.py:# STDLIB\nastropy\/io\/votable\/tree.py:# THIRD-PARTY\nastropy\/io\/votable\/tree.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/io\/votable\/tree.py:from ...utils.misc import InheritDocstrings\nastropy\/io\/votable\/tree.py:DEFAULT_CHUNK_SIZE = 256\nastropy\/io\/votable\/tree.py:    Like `_lookup_by_attr_factory`, but looks in both the \"ID\" and\nastropy\/io\/votable\/tree.py:        with the attribute ID == *ref* or name == *ref*.  If *before*\nastropy\/io\/votable\/tree.py:                if ref in (element.ID, element.name):\nastropy\/io\/votable\/tree.py:            if ref in (element.ID, element.name):\nastropy\/io\/votable\/tree.py:            \"No {} with ID or name '{}' found before the referencing {}\".format(\nastropy\/io\/votable\/tree.py:def resolve_id(ID, id, config=None, pos=None):\nastropy\/io\/votable\/tree.py:    if ID is None and id is not None:\nastropy\/io\/votable\/tree.py:    return ID\nastropy\/io\/votable\/tree.py:        A UCD string.\nastropy\/io\/votable\/tree.py:class _IDProperty:\nastropy\/io\/votable\/tree.py:    def ID(self):\nastropy\/io\/votable\/tree.py:        The XML ID_ of the element.  May be `None` or a string\nastropy\/io\/votable\/tree.py:        conforming to XML ID_ syntax.\nastropy\/io\/votable\/tree.py:        return self._ID\nastropy\/io\/votable\/tree.py:    @ID.setter\nastropy\/io\/votable\/tree.py:    def ID(self, ID):\nastropy\/io\/votable\/tree.py:        xmlutil.check_id(ID, 'ID', self._config, self._pos)\nastropy\/io\/votable\/tree.py:        self._ID = ID\nastropy\/io\/votable\/tree.py:    @ID.deleter\nastropy\/io\/votable\/tree.py:    def ID(self):\nastropy\/io\/votable\/tree.py:        self._ID = None\nastropy\/io\/votable\/tree.py:class _DescriptionProperty:\nastropy\/io\/votable\/tree.py:        DESCRIPTION_ element.\nastropy\/io\/votable\/tree.py:class Element(metaclass=InheritDocstrings):\nastropy\/io\/votable\/tree.py:    A base class for simple elements, such as FIELD, PARAM and INFO\nastropy\/io\/votable\/tree.py:    A base class for simple elements, such as FIELD, PARAM and INFO\nastropy\/io\/votable\/tree.py:class Link(SimpleElement, _IDProperty):\nastropy\/io\/votable\/tree.py:    _attr_list = ['ID', 'content_role', 'content_type', 'title', 'value',\nastropy\/io\/votable\/tree.py:    def __init__(self, ID=None, title=None, value=None, href=None, action=None,\nastropy\/io\/votable\/tree.py:        self.ID = resolve_id(ID, id, config, pos)\nastropy\/io\/votable\/tree.py:        Defines the MIME role of the referenced object.  Must be one of:\nastropy\/io\/votable\/tree.py:        \"\"\"Defines the MIME content type of the referenced object.\"\"\"\nastropy\/io\/votable\/tree.py:class Info(SimpleElementWithContent, _IDProperty, _XtypeProperty,\nastropy\/io\/votable\/tree.py:    _attr_list_11 = ['ID', 'name', 'value']\nastropy\/io\/votable\/tree.py:    def __init__(self, ID=None, name=None, value=None, id=None, xtype=None,\nastropy\/io\/votable\/tree.py:        self.ID = (resolve_id(ID, id, config, pos) or\nastropy\/io\/votable\/tree.py:        Refer to another INFO_ element by ID_, defined previously in\nastropy\/io\/votable\/tree.py:        # TODO: actually apply the reference\nastropy\/io\/votable\/tree.py:class Values(Element, _IDProperty):\nastropy\/io\/votable\/tree.py:    VALUES_ element: used within FIELD_ and PARAM_ elements to define the domain of values.\nastropy\/io\/votable\/tree.py:    def __init__(self, votable, field, ID=None, null=None, ref=None,\nastropy\/io\/votable\/tree.py:        self.ID = resolve_id(ID, id, config, pos)\nastropy\/io\/votable\/tree.py:        [*required*] Defines the applicability of the domain defined\nastropy\/io\/votable\/tree.py:        Refer to another VALUES_ element by ID_, defined previously in\nastropy\/io\/votable\/tree.py:        return (self.ref is None and self.null is None and self.ID is None and\nastropy\/io\/votable\/tree.py:                           self, ['ID', 'null', 'ref'])):\nastropy\/io\/votable\/tree.py:        for key in ['ID', 'null']:\nastropy\/io\/votable\/tree.py:        for key in ['ID', 'null']:\nastropy\/io\/votable\/tree.py:class Field(SimpleElement, _IDProperty, _NameProperty, _XtypeProperty,\nastropy\/io\/votable\/tree.py:    FIELD_ element: describes the datatype of a particular column of data.\nastropy\/io\/votable\/tree.py:    If *ID* is provided, it is used for the column name in the\nastropy\/io\/votable\/tree.py:    resulting recarray of the table.  If no *ID* is provided, *name*\nastropy\/io\/votable\/tree.py:    _attr_list_11 = ['ID', 'name', 'datatype', 'arraysize', 'ucd',\nastropy\/io\/votable\/tree.py:    _element_name = 'FIELD'\nastropy\/io\/votable\/tree.py:    def __init__(self, votable, ID=None, name=None, datatype=None,\nastropy\/io\/votable\/tree.py:        # TODO: REMOVE ME ----------------------------------------\nastropy\/io\/votable\/tree.py:            ID == 'cprojection' and ucd == 'VOX:WCS_CoordProjection' and\nastropy\/io\/votable\/tree.py:        self.ID = (resolve_id(ID, id, config, pos) or\nastropy\/io\/votable\/tree.py:            self.name = self.ID\nastropy\/io\/votable\/tree.py:        if self._ID is None and name is None:\nastropy\/io\/votable\/tree.py:            new_id = field.ID\nastropy\/io\/votable\/tree.py:                new_id = field.ID + \"_{:d}\".format(i)\nastropy\/io\/votable\/tree.py:            if new_id != field.ID:\nastropy\/io\/votable\/tree.py:                vo_warn(W32, (field.ID, new_id), field._config, field._pos)\nastropy\/io\/votable\/tree.py:            field.ID = new_id\nastropy\/io\/votable\/tree.py:            unique[new_id] = field.ID\nastropy\/io\/votable\/tree.py:                new_name = field.ID\nastropy\/io\/votable\/tree.py:            if new_name != field.ID:\nastropy\/io\/votable\/tree.py:            vo_raise(E06, (datatype, self.ID), self._config, self._pos)\nastropy\/io\/votable\/tree.py:    # ref on FIELD and PARAM behave differently than elsewhere -- here\nastropy\/io\/votable\/tree.py:        On FIELD_ elements, ref is used only for informational\nastropy\/io\/votable\/tree.py:        \"\"\"A string specifying the units_ for the FIELD_.\"\"\"\nastropy\/io\/votable\/tree.py:        FIELD_ contains more than a single value.\nastropy\/io\/votable\/tree.py:        The type attribute on FIELD_ elements is reserved for future\nastropy\/io\/votable\/tree.py:        details about the meaning of the FIELD_.  This is purely\nastropy\/io\/votable\/tree.py:                elif tag == 'DESCRIPTION':\nastropy\/io\/votable\/tree.py:                        'DESCRIPTION', data.keys(), config, pos)\nastropy\/io\/votable\/tree.py:                if tag == 'DESCRIPTION':\nastropy\/io\/votable\/tree.py:                w.element('DESCRIPTION', self.description, wrap=True)\nastropy\/io\/votable\/tree.py:            # TODO: Use units framework when it's available\nastropy\/io\/votable\/tree.py:        # TODO: Use the unit framework when available\nastropy\/io\/votable\/tree.py:        # TODO: Parse format into precision and width\nastropy\/io\/votable\/tree.py:    def __init__(self, votable, ID=None, name=None, value=None, datatype=None,\nastropy\/io\/votable\/tree.py:        Field.__init__(self, votable, ID=ID, name=name, datatype=datatype,\nastropy\/io\/votable\/tree.py:    _attr_list = ['ID', 'equinox', 'epoch', 'system']\nastropy\/io\/votable\/tree.py:    def __init__(self, ID=None, equinox=None, epoch=None, system=None, id=None,\nastropy\/io\/votable\/tree.py:        self.ID = resolve_id(ID, id, config, pos)\nastropy\/io\/votable\/tree.py:    def ID(self):\nastropy\/io\/votable\/tree.py:        [*required*] The XML ID of the COOSYS_ element, used for\nastropy\/io\/votable\/tree.py:        XML ID_ syntax.\nastropy\/io\/votable\/tree.py:        return self._ID\nastropy\/io\/votable\/tree.py:    @ID.setter\nastropy\/io\/votable\/tree.py:    def ID(self, ID):\nastropy\/io\/votable\/tree.py:            if ID is None:\nastropy\/io\/votable\/tree.py:        xmlutil.check_id(ID, 'ID', self._config, self._pos)\nastropy\/io\/votable\/tree.py:        self._ID = ID\nastropy\/io\/votable\/tree.py:    FIELDref_ element: used inside of GROUP_ elements to refer to remote FIELD_ elements.\nastropy\/io\/votable\/tree.py:    _element_name = \"FIELDref\"\nastropy\/io\/votable\/tree.py:        *ref* is the ID to reference a :class:`Field` object defined\nastropy\/io\/votable\/tree.py:        \"\"\"The ID_ of the FIELD_ that this FIELDref_ references.\"\"\"\nastropy\/io\/votable\/tree.py:            if isinstance(field, Field) and field.ID == self.ref:\nastropy\/io\/votable\/tree.py:      *ref*: An XML ID referring to a <PARAM> element.\nastropy\/io\/votable\/tree.py:        \"\"\"The ID_ of the PARAM_ that this PARAMref_ references.\"\"\"\nastropy\/io\/votable\/tree.py:            if isinstance(param, Param) and param.ID == self.ref:\nastropy\/io\/votable\/tree.py:class Group(Element, _IDProperty, _NameProperty, _UtypeProperty,\nastropy\/io\/votable\/tree.py:            _UcdProperty, _DescriptionProperty):\nastropy\/io\/votable\/tree.py:    GROUP_ element: groups FIELD_ and PARAM_ elements.\nastropy\/io\/votable\/tree.py:    def __init__(self, table, ID=None, name=None, ref=None, ucd=None,\nastropy\/io\/votable\/tree.py:        self.ID = (resolve_id(ID, id, config, pos)\nastropy\/io\/votable\/tree.py:            'FIELDref': self._add_fieldref,\nastropy\/io\/votable\/tree.py:            'DESCRIPTION': self._ignore_add}\nastropy\/io\/votable\/tree.py:                if tag == 'DESCRIPTION':\nastropy\/io\/votable\/tree.py:                self, ['ID', 'name', 'ref', 'ucd', 'utype'])):\nastropy\/io\/votable\/tree.py:                w.element(\"DESCRIPTION\", self.description, wrap=True)\nastropy\/io\/votable\/tree.py:class Table(Element, _IDProperty, _NameProperty, _UcdProperty,\nastropy\/io\/votable\/tree.py:            _DescriptionProperty):\nastropy\/io\/votable\/tree.py:        based on the <FIELD> elements of the table.  The mask is\nastropy\/io\/votable\/tree.py:    def __init__(self, votable, ID=None, name=None, ref=None, ucd=None,\nastropy\/io\/votable\/tree.py:        self.ID = (resolve_id(ID, id, config, pos)\nastropy\/io\/votable\/tree.py:        Refer to another TABLE, previously defined, by the *ref* ID_\nastropy\/io\/votable\/tree.py:        for all metadata (FIELD_, PARAM_ etc.) information.\nastropy\/io\/votable\/tree.py:          'tabledata' (TABLEDATA_), 'binary' (BINARY_), 'binary2' (BINARY2_)\nastropy\/io\/votable\/tree.py:                if x._unique_name == x.ID:\nastropy\/io\/votable\/tree.py:                    id = x.ID\nastropy\/io\/votable\/tree.py:                    id = (x._unique_name, x.ID)\nastropy\/io\/votable\/tree.py:            if table_id != self.ID:\nastropy\/io\/votable\/tree.py:                    if tag == 'DATA':\nastropy\/io\/votable\/tree.py:                            'DATA', data.keys(), config, pos)\nastropy\/io\/votable\/tree.py:                    elif tag == 'DESCRIPTION':\nastropy\/io\/votable\/tree.py:                'FIELD': self._add_field,\nastropy\/io\/votable\/tree.py:                'DESCRIPTION': self._ignore_add}\nastropy\/io\/votable\/tree.py:                    if tag == 'DATA':\nastropy\/io\/votable\/tree.py:                            'DATA', data.keys(), config, pos)\nastropy\/io\/votable\/tree.py:                    if tag == 'DESCRIPTION':\nastropy\/io\/votable\/tree.py:                        # contains no DATA section\nastropy\/io\/votable\/tree.py:        names = [x.ID for x in fields]\nastropy\/io\/votable\/tree.py:        # Deal with a subset of the columns, if requested.\nastropy\/io\/votable\/tree.py:                    if tag == 'TABLEDATA':\nastropy\/io\/votable\/tree.py:                            'TABLEDATA', data.keys(), config, pos)\nastropy\/io\/votable\/tree.py:            if not start and tag == 'DATA':\nastropy\/io\/votable\/tree.py:        chunk_size = config.get('chunk_size', DEFAULT_CHUNK_SIZE)\nastropy\/io\/votable\/tree.py:                        if tag == 'TD':\nastropy\/io\/votable\/tree.py:                                                    fields[i].ID))\nastropy\/io\/votable\/tree.py:                                                    fields[i].ID))\nastropy\/io\/votable\/tree.py:            elif not start and tag == 'TABLEDATA':\nastropy\/io\/votable\/tree.py:                                numrows, fields[i].ID))\nastropy\/io\/votable\/tree.py:                ('ID', 'name', 'ref', 'ucd', 'utype', 'nrows'))):\nastropy\/io\/votable\/tree.py:                w.element(\"DESCRIPTION\", self.description, wrap=True)\nastropy\/io\/votable\/tree.py:                group = Group(self, ID=\"_g{0}\".format(index))\nastropy\/io\/votable\/tree.py:                with w.tag('DATA'):\nastropy\/io\/votable\/tree.py:        with w.tag('TABLEDATA'):\nastropy\/io\/votable\/tree.py:                td = indent_spaces + \" <TD>{}<\/TD>\\n\"\nastropy\/io\/votable\/tree.py:                td_empty = indent_spaces + \" <TD\/>\\n\"\nastropy\/io\/votable\/tree.py:                                        row, self.fields[i].ID))\nastropy\/io\/votable\/tree.py:                                    row, fields[i].ID))\nastropy\/io\/votable\/tree.py:           Otherwise (default), use the ID attributes as the column\nastropy\/io\/votable\/tree.py:        for key in ['ID', 'name', 'ref', 'ucd', 'utype', 'description']:\nastropy\/io\/votable\/tree.py:            names = [field.ID for field in self.fields]\nastropy\/io\/votable\/tree.py:        for key in ['ID', 'name', 'ref', 'ucd', 'utype']:\nastropy\/io\/votable\/tree.py:        Recursively iterate over all FIELD and PARAM elements in the\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_fields_and_params', 'FIELD or PARAM',\nastropy\/io\/votable\/tree.py:        Looks up a FIELD or PARAM element by the given ID.\nastropy\/io\/votable\/tree.py:        'iter_fields_and_params', 'FIELD or PARAM',\nastropy\/io\/votable\/tree.py:        Looks up a FIELD or PARAM element by the given ID or name.\nastropy\/io\/votable\/tree.py:        'utype', False, 'iter_fields_and_params', 'FIELD or PARAM',\nastropy\/io\/votable\/tree.py:        Looks up a FIELD or PARAM element by the given utype and\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_groups', 'GROUP',\nastropy\/io\/votable\/tree.py:        Looks up a GROUP element by the given ID.  Used by the group's\nastropy\/io\/votable\/tree.py:class Resource(Element, _IDProperty, _NameProperty, _UtypeProperty,\nastropy\/io\/votable\/tree.py:               _DescriptionProperty):\nastropy\/io\/votable\/tree.py:    def __init__(self, name=None, ID=None, utype=None, type='results',\nastropy\/io\/votable\/tree.py:        self.ID = resolve_id(ID, id, config, pos)\nastropy\/io\/votable\/tree.py:            (FIELD_ elements), but no actual data.\nastropy\/io\/votable\/tree.py:            'DESCRIPTION': self._ignore_add\nastropy\/io\/votable\/tree.py:            elif tag == 'DESCRIPTION':\nastropy\/io\/votable\/tree.py:        attrs = w.object_attrs(self, ('ID', 'type', 'utype'))\nastropy\/io\/votable\/tree.py:                w.element(\"DESCRIPTION\", self.description, wrap=True)\nastropy\/io\/votable\/tree.py:        Recursively iterates over all FIELD_ and PARAM_ elements in\nastropy\/io\/votable\/tree.py:class VOTableFile(Element, _IDProperty, _DescriptionProperty):\nastropy\/io\/votable\/tree.py:    def __init__(self, ID=None, id=None, config=None, pos=None, version=\"1.3\"):\nastropy\/io\/votable\/tree.py:        self.ID = resolve_id(ID, id, config, pos)\nastropy\/io\/votable\/tree.py:            'DEFINITIONS': self._add_definitions,\nastropy\/io\/votable\/tree.py:            'DESCRIPTION': self._ignore_add,\nastropy\/io\/votable\/tree.py:            elif tag == 'DESCRIPTION':\nastropy\/io\/votable\/tree.py:            When `True`, write to a gzip-compressed file.  (Default:\nastropy\/io\/votable\/tree.py:                    w.element(\"DESCRIPTION\", self.description, wrap=True)\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_tables', 'TABLE',\nastropy\/io\/votable\/tree.py:        Looks up a TABLE_ element by the given ID.  Used by the table\nastropy\/io\/votable\/tree.py:        Recursively iterate over all FIELD_ and PARAM_ elements in the\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_fields_and_params', 'FIELD',\nastropy\/io\/votable\/tree.py:        Looks up a FIELD_ element by the given ID_.  Used by the field's\nastropy\/io\/votable\/tree.py:        'utype', False, 'iter_fields_and_params', 'FIELD',\nastropy\/io\/votable\/tree.py:        Looks up a FIELD_ element by the given utype and returns an\nastropy\/io\/votable\/tree.py:        'iter_fields_and_params', 'FIELD',\nastropy\/io\/votable\/tree.py:        Looks up a FIELD_ element by the given ID_ or name.\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_values', 'VALUES',\nastropy\/io\/votable\/tree.py:        Looks up a VALUES_ element by the given ID.  Used by the values\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_groups', 'GROUP',\nastropy\/io\/votable\/tree.py:        Looks up a GROUP_ element by the given ID.  Used by the group's\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_coosys', 'COOSYS',\nastropy\/io\/votable\/tree.py:        \"\"\"Looks up a COOSYS_ element by the given ID.\"\"\")\nastropy\/io\/votable\/tree.py:        'ID', True, 'iter_info', 'INFO',\nastropy\/io\/votable\/tree.py:        \"\"\"Looks up a INFO element by the given ID.\"\"\")\nastropy\/io\/votable\/tree.py:            Set the given ID attribute on the returned Table instance.\nastropy\/io\/votable\/tree.py:            votable.ID = table_id\nastropy\/io\/votable\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/setup_package.py:    VO_DIR = 'astropy\/io\/votable\/src'\nastropy\/io\/votable\/setup_package.py:        [join(VO_DIR, \"tablewriter.c\")],\nastropy\/io\/votable\/setup_package.py:        include_dirs=[VO_DIR])]\nastropy\/io\/votable\/validator\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/connect.py:        The table to read in.  If a `str`, it is an ID corresponding\nastropy\/io\/votable\/connect.py:        to the ID of the table in the file (not all VOTable files\nastropy\/io\/votable\/connect.py:        assign IDs to their tables).  If an `int`, it is the index of\nastropy\/io\/votable\/connect.py:        (default), use the ID attributes as the column names.\nastropy\/io\/votable\/connect.py:            if table.ID is not None:\nastropy\/io\/votable\/connect.py:                table_id_mapping[table.ID] = table\nastropy\/io\/votable\/connect.py:        The table ID to use. If this is not specified, the 'ID' keyword in the\nastropy\/io\/votable\/connect.py:        (text representation), ``binary`` or ``binary2``.  Default is\nastropy\/io\/misc\/pickle_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/pickle_helpers.py:from ...utils.exceptions import AstropyDeprecationWarning, NoValue\nastropy\/io\/misc\/pickle_helpers.py:                      AstropyDeprecationWarning)\nastropy\/io\/misc\/pickle_helpers.py:                      AstropyDeprecationWarning)\nastropy\/visualization\/scripts\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/vo_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/vo_test.py:# STDLIB\nastropy\/io\/votable\/tests\/vo_test.py:# THIRD-PARTY\nastropy\/io\/votable\/tests\/vo_test.py:# Determine the kind of float formatting in this build of Python\nastropy\/io\/votable\/tests\/vo_test.py:            '<PARAM ID=\"awesome\" arraysize=\"*\" datatype=\"float\" name=\"INPUT\" unit=\"deg\" value=\"[0.0 0.0]\"\/>'  # noqa\nastropy\/io\/votable\/tests\/vo_test.py:class TestThroughTableData(TestParse):\nastropy\/io\/votable\/tests\/vo_test.py:    # Define some fields\nastropy\/io\/votable\/tests\/vo_test.py:            Field(votable, ID=\"filename\", datatype=\"char\"),\nastropy\/io\/votable\/tests\/vo_test.py:            Field(votable, ID=\"matrix\", datatype=\"double\", arraysize=\"2x2\")])\nastropy\/io\/votable\/tests\/vo_test.py:    # Define some fields\nastropy\/io\/votable\/tests\/vo_test.py:        tree.Field(votable, ID=\"filename\", datatype=\"char\"),\nastropy\/io\/votable\/tests\/vo_test.py:        tree.Field(votable, ID=\"matrix\", datatype=\"double\", arraysize=\"2x2\")])\nastropy\/io\/votable\/tests\/vo_test.py:    # Define some fields\nastropy\/io\/misc\/asdf\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/__init__.py:so that they can be represented and stored using the Advanced Scientific Data\nastropy\/io\/misc\/asdf\/__init__.py:Format (ASDF). This subpackage defines classes, referred to as **tags**, that\nastropy\/io\/misc\/asdf\/__init__.py:ASDF makes use of abstract data type definitons called **schemas**. The tags\nastropy\/io\/misc\/asdf\/__init__.py:externally by the ASDF Standard. However, it is likely that astropy will\nastropy\/io\/misc\/asdf\/__init__.py:Astropy currently has no ability to read or write ASDF files itself. In order\nastropy\/io\/misc\/asdf\/__init__.py:to process ASDF files it is necessary to make use of the standalone **asdf**\nastropy\/io\/misc\/asdf\/__init__.py:Their presence should be entirely transparent when processing ASDF files.\nastropy\/io\/misc\/asdf\/__init__.py:required in order to process ASDF files. The **asdf** package has been designed\nastropy\/io\/misc\/asdf\/__init__.py:Documentation on the ASDF Standard can be found `here\nastropy\/io\/misc\/asdf\/__init__.py:<https:\/\/asdf-standard.readthedocs.io>`__. Documentation on the ASDF Python\nastropy\/io\/misc\/asdf\/types.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/types.py:    be stored automatically by astropy extensions for ASDF.\nastropy\/io\/misc\/asdf\/types.py:    schemas that are defined by the ASDF standard.\nastropy\/io\/misc\/asdf\/types.py:    This class represents types that have schemas that are defined in the ASDF\nastropy\/io\/votable\/tests\/converter_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/converter_test.py:# THIRD-PARTY\nastropy\/io\/misc\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/table_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/table_test.py:        assert field.ID == name\nastropy\/io\/votable\/tests\/table_test.py:        'Name', 'GLON', 'GLAT', 'RAdeg', 'DEdeg', 'Jmag', 'Hmag', 'Kmag',\nastropy\/io\/votable\/tests\/table_test.py:    assert b'TABLEDATA' not in obuff\nastropy\/io\/votable\/tests\/table_test.py:    assert b'TABLEDATA' not in obuff\nastropy\/io\/misc\/asdf\/tags\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/xmlutil.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/xmlutil.py:def check_id(ID, name='ID', config=None, pos=None):\nastropy\/io\/votable\/xmlutil.py:    Raises a `~astropy.io.votable.exceptions.VOTableSpecError` if *ID*\nastropy\/io\/votable\/xmlutil.py:    is not a valid XML ID_.\nastropy\/io\/votable\/xmlutil.py:    if (ID is not None and not xml_check.check_id(ID)):\nastropy\/io\/votable\/xmlutil.py:        warn_or_raise(W02, W02, (name, ID), config, pos)\nastropy\/io\/votable\/xmlutil.py:def fix_id(ID, config=None, pos=None):\nastropy\/io\/votable\/xmlutil.py:    if ID is None:\nastropy\/io\/votable\/xmlutil.py:    corrected = xml_check.fix_id(ID)\nastropy\/io\/votable\/xmlutil.py:    if corrected != ID:\nastropy\/io\/votable\/xmlutil.py:        vo_warn(W03, (ID, corrected), config, pos)\nastropy\/io\/votable\/xmlutil.py:        For version \\\"1.0\\\", it is checked against a DTD, since that\nastropy\/io\/votable\/table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/table.py:# STDLIB\nastropy\/io\/votable\/table.py:          chunk_size=tree.DEFAULT_CHUNK_SIZE, table_number=None,\nastropy\/io\/votable\/table.py:        The ID of the table in the file to read in.  Should not be\nastropy\/io\/votable\/table.py:        Where to output the report.  Defaults to ``sys.stdout``.\nastropy\/io\/votable\/table.py:        DTD validation.  Requires that ``xmllint`` is installed.  The\nastropy\/io\/misc\/asdf\/tags\/unit\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/unit\/unit.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/validator\/main.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/validator\/main.py:# STDLIB\nastropy\/io\/votable\/validator\/main.py:    Downloads of each given URL will be performed only once and cached\nastropy\/io\/votable\/validator\/main.py:    color_print('Downloading VO files', 'green')\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:    types = ['astropy.io.fits.HDUList']\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:                hdu = fits.PrimaryHDU(data=data, header=header)\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:                hdu = fits.BinTableHDU(data=data, header=header)\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:                hdu = fits.ImageHDU(data=data, header=header)\nastropy\/io\/misc\/asdf\/tags\/fits\/fits.py:        hdulist = fits.HDUList(hdus)\nastropy\/io\/misc\/asdf\/tags\/table\/tests\/test_table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coords\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coords\/coords.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/fits\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/unit\/quantity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/unit\/quantity.py:from asdf.tags.core import NDArrayType\nastropy\/io\/misc\/asdf\/tags\/unit\/quantity.py:        if isinstance(value, NDArrayType):\nastropy\/io\/misc\/asdf\/tags\/table\/table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/table\/table.py:from asdf.tags.core.ndarray import NDArrayType\nastropy\/io\/misc\/asdf\/tags\/table\/table.py:        NDArrayType.assert_equal(np.array(old), np.array(new))\nastropy\/io\/misc\/asdf\/tags\/table\/table.py:        NDArrayType.assert_equal(np.array(old), np.array(new))\nastropy\/io\/misc\/yaml.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/yaml.py:`~astropy.io.misc.yaml.AstropyDumper` and `~astropy.io.misc.yaml.AstropyLoader`\nastropy\/io\/misc\/yaml.py:- `astropy.time.TimeDelta`\nastropy\/io\/misc\/yaml.py:from ...time import Time, TimeDelta\nastropy\/io\/misc\/yaml.py:__all__ = ['AstropyLoader', 'AstropyDumper', 'load', 'load_all', 'dump']\nastropy\/io\/misc\/yaml.py:    return dumper.represent_mapping('!astropy.time.TimeDelta', out)\nastropy\/io\/misc\/yaml.py:    out = TimeDelta.info._construct_from_dict(map)\nastropy\/io\/misc\/yaml.py:    <http:\/\/pyyaml.org\/wiki\/PyYAMLDocumentation>`_ for details of the\nastropy\/io\/misc\/yaml.py:class AstropyDumper(yaml.SafeDumper):\nastropy\/io\/misc\/yaml.py:    Custom SafeDumper that represents astropy core objects as well\nastropy\/io\/misc\/yaml.py:    `PyYaml documentation <http:\/\/pyyaml.org\/wiki\/PyYAMLDocumentation>`_\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(u.IrreducibleUnit, _unit_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(u.CompositeUnit, _unit_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_multi_representer(u.Unit, _unit_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(tuple, AstropyDumper._represent_tuple)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(np.ndarray, _ndarray_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(Time, _time_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(TimeDelta, _timedelta_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(coords.SkyCoord, _skycoord_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(SerializedColumn, _serialized_column_representer)\nastropy\/io\/misc\/yaml.py:AstropyDumper.add_representer(np.bool_,\nastropy\/io\/misc\/yaml.py:    AstropyDumper.add_representer(np_type,\nastropy\/io\/misc\/yaml.py:    AstropyDumper.add_representer(np_type,\nastropy\/io\/misc\/yaml.py:    AstropyDumper.add_representer(np_type,\nastropy\/io\/misc\/yaml.py:AstropyLoader.add_constructor('!astropy.time.TimeDelta', _timedelta_constructor)\nastropy\/io\/misc\/yaml.py:    AstropyDumper.add_multi_representer(cls, _quantity_representer(tag))\nastropy\/io\/misc\/yaml.py:    \"\"\"Serialize a Python object into a YAML stream using the AstropyDumper class.\nastropy\/io\/misc\/yaml.py:    kwargs['Dumper'] = AstropyDumper\nastropy\/io\/misc\/tests\/test_hdf5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/tests\/test_hdf5.py:from ....time import Time, TimeDelta\nastropy\/io\/misc\/tests\/test_hdf5.py:ALL_DTYPES = [np.uint8, np.uint16, np.uint32, np.uint64, np.int8,\nastropy\/io\/misc\/tests\/test_hdf5.py:    assert exc.value.args[0] == 'no table found in HDF5 group \/'\nastropy\/io\/misc\/tests\/test_hdf5.py:@pytest.mark.parametrize(('dtype'), ALL_DTYPES)\nastropy\/io\/misc\/tests\/test_hdf5.py:    for dtype in ALL_DTYPES:\nastropy\/io\/misc\/tests\/test_hdf5.py:    for dtype in ALL_DTYPES:\nastropy\/io\/misc\/tests\/test_hdf5.py:        \"Attributes could not be written to the output HDF5 \"\nastropy\/io\/misc\/tests\/test_hdf5.py:        \"Attribute `f` of type {0} cannot be written to HDF5 files - skipping\".format(type(t1.meta['f'])))\nastropy\/io\/misc\/tests\/test_hdf5.py:    # Regression test - ensure that Datasets are recognized automatically\nastropy\/io\/misc\/tests\/test_hdf5.py:        # Mixin info.meta can None instead of empty OrderedDict(), #6720 would\nastropy\/io\/misc\/tests\/test_hdf5.py:# Testing HDF5 table read\/write with mixins.  This is mostly\nastropy\/io\/misc\/tests\/test_hdf5.py:    'dt': TimeDelta([1, 2] * u.day),\nastropy\/io\/misc\/tests\/test_hdf5.py:            # Downgrade Quantity to Column + unit\nastropy\/io\/misc\/tests\/test_hdf5.py:    assert \"cannot write type SkyCoord column 'col0' to HDF5 without PyYAML\" in str(err)\nastropy\/io\/misc\/tests\/test_yaml.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/votable\/tests\/exception_test.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coords\/tests\/test_coords.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/coords\/tests\/test_coords.py:    reason=\"Compound ICRS coordinates have not been implemented for ASDF yet\")\nastropy\/io\/misc\/asdf\/tags\/fits\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/time\/time.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/time\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/tabular.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/tabular.py:        modeling.models.Tabular2D, modeling.models.Tabular1D\nastropy\/io\/misc\/asdf\/tags\/transform\/tabular.py:            model = modeling.models.Tabular1D(points=points, lookup_table=lookup_table,\nastropy\/io\/misc\/asdf\/tags\/transform\/tabular.py:            model = modeling.models.Tabular2D(points=points, lookup_table=lookup_table,\nastropy\/io\/misc\/asdf\/tags\/unit\/tests\/test_quantity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/extension.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/extension.py:from asdf.resolver import Resolver, DEFAULT_URL_MAPPING\nastropy\/io\/misc\/asdf\/extension.py:# by ASDF, but have tag implementations defined in astropy.\nastropy\/io\/misc\/asdf\/tags\/unit\/tests\/test_unit.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/unit\/tests\/test_unit.py:# TODO: Implement defunit\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:    types = ['astropy.modeling.models.Polynomial1D',\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:             'astropy.modeling.models.Polynomial2D']\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:            model = modeling.models.Polynomial1D(coefficients.size - 1)\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:            model = modeling.models.Polynomial2D(degree, **coeffs)\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:                \"Asdf currently only supports 1D or 2D polynomial transform.\")\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:        if isinstance(model, modeling.models.Polynomial1D):\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:        elif isinstance(model, modeling.models.Polynomial2D):\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:        assert (isinstance(a, (modeling.models.Polynomial1D, modeling.models.Polynomial2D)) and\nastropy\/io\/misc\/asdf\/tags\/transform\/polynomial.py:                isinstance(b, (modeling.models.Polynomial1D, modeling.models.Polynomial2D)))\nastropy\/io\/misc\/asdf\/tags\/fits\/tests\/test_fits.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/fits\/tests\/test_fits.py:    h = fits.HDUList()\nastropy\/io\/misc\/asdf\/tags\/fits\/tests\/test_fits.py:    h.append(fits.BinTableHDU.from_columns(a))\nastropy\/io\/misc\/tests\/test_pickle_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/tests\/test_pickle_helpers.py:from ....utils.exceptions import AstropyDeprecationWarning\nastropy\/io\/misc\/tests\/test_pickle_helpers.py:    with catch_warnings(AstropyDeprecationWarning):\nastropy\/io\/misc\/asdf\/tags\/transform\/compound.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/compound.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:__all__ = ['TransformType', 'IdentityType', 'ConstantType', 'DomainType']\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:        # TODO: Remove domain in a later version.\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:        # TODO: Assert inverses are the same\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:    types = ['astropy.modeling.functional_models.Const1D']\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:        return functional_models.Const1D(node['value'])\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:class DomainType(AstropyAsdfType):\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:    # TODO: Is this used anywhere? Can it be removed?\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:from collections import OrderedDict\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:    newschema = OrderedDict()\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:        # TODO: Simplify?\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:                cursor = cursor.setdefault('items', OrderedDict())\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:                cursor = cursor.setdefault('properties', OrderedDict())\nastropy\/io\/misc\/asdf\/tags\/time\/tests\/test_time.py:                    cursor = cursor.setdefault(part, OrderedDict())\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:        hdu1 = fits.PrimaryHDU()\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:        hdu2 = fits.ImageHDU(data)\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:        hdulist = fits.HDUList([hdu1, hdu2])\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:        hdu1 = fits.PrimaryHDU()\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:        hdu2 = fits.ImageHDU(data)\nastropy\/visualization\/scripts\/tests\/test_fits2bitmap.py:        hdulist = fits.HDUList([hdu1, hdu2])\nastropy\/io\/misc\/asdf\/tags\/transform\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/units.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/table\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    astmodels.Identity(2), astmodels.Polynomial1D(2, c0=1, c1=2, c2=3),\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    astmodels.Polynomial2D(1, c0_0=1, c0_1=2, c1_0=3), astmodels.Shift(2.),\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:            astmodels.Rotation2D() |\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:            astmodels.AffineTransformation2D([[2, 0], [0, 2]], [42, 32]) +\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:            astmodels.Rotation2D(32)\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    rotation = astmodels.Rotation2D(32)\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    rotation.inverse = astmodels.Rotation2D(45)\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    real_rotation = astmodels.Rotation2D(32)\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    tree = {'rot': astmodels.Rotation2D(23, name='foo')}\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    model = astmodels.Tabular1D(points=points, lookup_table=values)\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    model2 = astmodels.Tabular2D(points, lookup_table=table, bounds_error=False,\nastropy\/visualization\/interval.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/interval.py:from ..utils.misc import InheritDocstrings\nastropy\/visualization\/interval.py:class BaseInterval(BaseTransform, metaclass=InheritDocstrings):\nastropy\/visualization\/interval.py:        The minimum value in the scaling.  Defaults to the image\nastropy\/visualization\/interval.py:        The maximum value in the scaling.  Defaults to the image\nastropy\/visualization\/interval.py:        # Determine values at percentiles\nastropy\/visualization\/interval.py:    Licensed under a 3-clause BSD style license (see AURA_LICENSE.rst).\nastropy\/visualization\/interval.py:        scaling factors.  Defaults to 1000.\nastropy\/visualization\/interval.py:        Defaults to 0.25.\nastropy\/visualization\/interval.py:        Defaults to 0.5.\nastropy\/visualization\/interval.py:        Defaults to 5.\nastropy\/visualization\/interval.py:        The number of sigma used for the rejection. Defaults to 2.5.\nastropy\/visualization\/interval.py:        The maximum number of iterations for the rejection. Defaults to\nastropy\/visualization\/interval.py:            # Detect and reject pixels further than k*sigma from the\nastropy\/io\/fits\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/connect.py:from collections import OrderedDict\nastropy\/io\/fits\/connect.py:from . import HDUList, TableHDU, BinTableHDU, GroupsHDU\nastropy\/io\/fits\/connect.py:from .column import KEYWORD_NAMES\nastropy\/io\/fits\/connect.py:REMOVE_KEYWORDS = ['XTENSION', 'BITPIX', 'NAXIS', 'NAXIS1', 'NAXIS2',\nastropy\/io\/fits\/connect.py:                   'PCOUNT', 'GCOUNT', 'TFIELDS', 'THEAP']\nastropy\/io\/fits\/connect.py:COLUMN_KEYWORD_REGEXP = '(' + '|'.join(KEYWORD_NAMES) + ')[0-9]+'\nastropy\/io\/fits\/connect.py:    return re.match(COLUMN_KEYWORD_REGEXP, keyword) is not None\nastropy\/io\/fits\/connect.py:    Determine whether `origin` is a FITS file.\nastropy\/io\/fits\/connect.py:    elif isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU)):\nastropy\/io\/fits\/connect.py:    \"\"\"Decode a Table ``tbl`` that has astropy Columns + appropriate meta-data into\nastropy\/io\/fits\/connect.py:        i0 = tbl.meta['comments'].index('--BEGIN-ASTROPY-SERIALIZED-COLUMNS--')\nastropy\/io\/fits\/connect.py:        i1 = tbl.meta['comments'].index('--END-ASTROPY-SERIALIZED-COLUMNS--')\nastropy\/io\/fits\/connect.py:    input : str or file-like object or compatible `astropy.io.fits` HDU object\nastropy\/io\/fits\/connect.py:        a compatible HDU object, the object to extract the table from. The\nastropy\/io\/fits\/connect.py:        following `astropy.io.fits` HDU objects can be used as input:\nastropy\/io\/fits\/connect.py:        - :class:`~astropy.io.fits.hdu.table.TableHDU`\nastropy\/io\/fits\/connect.py:        - :class:`~astropy.io.fits.hdu.table.BinTableHDU`\nastropy\/io\/fits\/connect.py:        - :class:`~astropy.io.fits.hdu.table.GroupsHDU`\nastropy\/io\/fits\/connect.py:        - :class:`~astropy.io.fits.hdu.hdulist.HDUList`\nastropy\/io\/fits\/connect.py:        The HDU to read the table from.\nastropy\/io\/fits\/connect.py:        of standard Table Column objects. Default is False.\nastropy\/io\/fits\/connect.py:    if isinstance(input, HDUList):\nastropy\/io\/fits\/connect.py:        tables = OrderedDict()\nastropy\/io\/fits\/connect.py:            if isinstance(hdu_item, (TableHDU, BinTableHDU, GroupsHDU)):\nastropy\/io\/fits\/connect.py:            # to the correct HDU index\nastropy\/io\/fits\/connect.py:    elif isinstance(input, (TableHDU, BinTableHDU, GroupsHDU)):\nastropy\/io\/fits\/connect.py:    # TODO: in future, it may make more sense to do this column-by-column,\nastropy\/io\/fits\/connect.py:    # TODO: deal properly with unsigned integers\nastropy\/io\/fits\/connect.py:        elif is_column_keyword(key) or key in REMOVE_KEYWORDS:\nastropy\/io\/fits\/connect.py:    # TODO: implement masking\nastropy\/io\/fits\/connect.py:    # Decode any mixin columns that have been stored as standard Columns.\nastropy\/io\/fits\/connect.py:    encode_tbl.meta['comments'].append('--BEGIN-ASTROPY-SERIALIZED-COLUMNS--')\nastropy\/io\/fits\/connect.py:    encode_tbl.meta['comments'].append('--END-ASTROPY-SERIALIZED-COLUMNS--')\nastropy\/io\/misc\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/file.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/file.py:IO_FITS_MODES = {\nastropy\/io\/fits\/file.py:# IO_FITS_MODES there are overlaps; for example 'readonly' and 'denywrite'\nastropy\/io\/fits\/file.py:FILE_MODES = {\nastropy\/io\/fits\/file.py:MEMMAP_MODES = {'readonly': 'c', 'copyonwrite': 'c', 'update': 'r+',\nastropy\/io\/fits\/file.py:# TODO: Eventually raise a warning, and maybe even later disable the use of\nastropy\/io\/fits\/file.py:    if mode is not None and mode not in IO_FITS_MODES:\nastropy\/io\/fits\/file.py:        new_mode = FILE_MODES.get(mode)\nastropy\/io\/fits\/file.py:        if new_mode not in IO_FITS_MODES:\nastropy\/io\/fits\/file.py:                # TODO: This could be revised when Python 3.5 support is dropped\nastropy\/io\/fits\/file.py:        if mode is not None and mode not in IO_FITS_MODES:\nastropy\/io\/fits\/file.py:                    memmap = Memmap(self._file, mode=MEMMAP_MODES[self.mode],\nastropy\/io\/fits\/file.py:        file (so there is only one, shared by all HDUs that reference this\nastropy\/io\/fits\/file.py:            kwargs = dict(mode=IO_FITS_MODES[mode])\nastropy\/io\/fits\/file.py:        fmode = fileobj_mode(fileobj) or IO_FITS_MODES[mode]\nastropy\/io\/fits\/file.py:            self._file = fileobj_open(self.name, IO_FITS_MODES[mode])\nastropy\/io\/fits\/file.py:            self._file = fileobj_open(self.name, IO_FITS_MODES[mode])\nastropy\/convolution\/tests\/test_pickle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_pickle.py:                          (conv.Gaussian1DKernel, [1.0],\nastropy\/convolution\/tests\/test_pickle.py:                          (conv.Gaussian2DKernel, [1.0],\nastropy\/io\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/frame.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/frame.py:from collections import OrderedDict\nastropy\/visualization\/wcsaxes\/frame.py:from matplotlib.lines import Line2D, Path\nastropy\/visualization\/wcsaxes\/frame.py:            self._pixel = self.parent_axes.transData.transform(self._data)\nastropy\/visualization\/wcsaxes\/frame.py:            self._data = self.parent_axes.transData.inverted().transform(self._data)\nastropy\/visualization\/wcsaxes\/frame.py:            self._pixel = self.parent_axes.transData.transform(self._data)\nastropy\/visualization\/wcsaxes\/frame.py:class BaseFrame(OrderedDict, metaclass=abc.ABCMeta):\nastropy\/visualization\/wcsaxes\/frame.py:        return PathPatch(self._path, transform=self.parent_axes.transData,\nastropy\/visualization\/wcsaxes\/frame.py:            line = Line2D(x, y, linewidth=self._linewidth, color=self._color, zorder=1000)\nastropy\/visualization\/wcsaxes\/frame.py:        spines = OrderedDict()\nastropy\/visualization\/wcsaxes\/frame.py:        line = Line2D(x, y, linewidth=self._linewidth, color=self._color, zorder=1000)\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:__all__ = ['AffineType', 'Rotate2DType', 'Rotate3DType']\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:    types = ['astropy.modeling.projections.AffineTransformation2D']\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:                \"asdf currently only supports 2x2 (2D) rotation transformation \"\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:                \"asdf currently only supports 2D translation transformations.\")\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:        return modeling.projections.AffineTransformation2D(\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:class Rotate2DType(TransformType):\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:    types = ['astropy.modeling.rotations.Rotation2D']\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:        return modeling.rotations.Rotation2D(node['angle'])\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:        assert (isinstance(a, modeling.rotations.Rotation2D) and\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:                isinstance(b, modeling.rotations.Rotation2D))\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:class Rotate3DType(TransformType):\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/io\/misc\/asdf\/tags\/transform\/projections.py:        # TODO: If models become comparable themselves, remove this.\nastropy\/convolution\/tests\/test_convolve_kernels.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_convolve_kernels.py:from ..kernels import Gaussian2DKernel, Box2DKernel, Tophat2DKernel\nastropy\/convolution\/tests\/test_convolve_kernels.py:from ..kernels import Moffat2DKernel\nastropy\/convolution\/tests\/test_convolve_kernels.py:SHAPES_ODD = [[15, 15], [31, 31]]\nastropy\/convolution\/tests\/test_convolve_kernels.py:WIDTHS = [2, 3, 4, 5]\nastropy\/convolution\/tests\/test_convolve_kernels.py:for shape in SHAPES_ODD:\nastropy\/convolution\/tests\/test_convolve_kernels.py:    for width in WIDTHS:\nastropy\/convolution\/tests\/test_convolve_kernels.py:        KERNELS.append(Gaussian2DKernel(width,\nastropy\/convolution\/tests\/test_convolve_kernels.py:        KERNELS.append(Box2DKernel(width,\nastropy\/convolution\/tests\/test_convolve_kernels.py:        KERNELS.append(Tophat2DKernel(width,\nastropy\/convolution\/tests\/test_convolve_kernels.py:        KERNELS.append(Moffat2DKernel(width, 2,\nastropy\/convolution\/tests\/test_convolve_kernels.py:class Test2DConvolutions:\nastropy\/convolution\/tests\/test_convolve_kernels.py:    @pytest.mark.parametrize(('shape', 'width'), list(itertools.product(SHAPES_ODD, WIDTHS)))\nastropy\/convolution\/tests\/test_convolve_kernels.py:    @pytest.mark.parametrize(('shape', 'width'), list(itertools.product(SHAPES_ODD, [1, 3, 5])))\nastropy\/convolution\/tests\/test_convolve_kernels.py:    def test_smallkernel_Box2DKernel(self, shape, width):\nastropy\/convolution\/tests\/test_convolve_kernels.py:        Compares a small uniform kernel to the Box2DKernel\nastropy\/convolution\/tests\/test_convolve_kernels.py:        kernel2 = Box2DKernel(width, mode='oversample', factor=10)\nastropy\/io\/misc\/asdf\/setup_package.py:# Licensed under a 3-clause BSD style license\nastropy\/io\/fits\/card.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/card.py:FIX_FP_TABLE = str.maketrans('de', 'DE')\nastropy\/io\/fits\/card.py:FIX_FP_TABLE2 = str.maketrans('dD', 'eE')\nastropy\/io\/fits\/card.py:CARD_LENGTH = 80\nastropy\/io\/fits\/card.py:BLANK_CARD = ' ' * CARD_LENGTH\nastropy\/io\/fits\/card.py:KEYWORD_LENGTH = 8  # The max length for FITS-standard keywords\nastropy\/io\/fits\/card.py:VALUE_INDICATOR = '= '  # The standard FITS value indicator\nastropy\/io\/fits\/card.py:HIERARCH_VALUE_INDICATOR = '='  # HIERARCH cards may use a shortened indicator\nastropy\/io\/fits\/card.py:UNDEFINED = Undefined()\nastropy\/io\/fits\/card.py:    length = CARD_LENGTH\nastropy\/io\/fits\/card.py:    _keywd_FSC_RE = re.compile(r'^[A-Z0-9_-]{0,%d}$' % KEYWORD_LENGTH)\nastropy\/io\/fits\/card.py:    # NFSC allows lower case of DE for exponent, allows space between sign,\nastropy\/io\/fits\/card.py:    _digits_FSC = r'(\\.\\d+|\\d+(\\.\\d*)?)([DE][+-]?\\d+)?'\nastropy\/io\/fits\/card.py:    _digits_NFSC = r'(\\.\\d+|\\d+(\\.\\d*)?) *([deDE] *[+-]? *\\d+)?'\nastropy\/io\/fits\/card.py:    # record value keyword cards (ex. 'DP1.AXIS.1')\nastropy\/io\/fits\/card.py:    _commentary_keywords = {'', 'COMMENT', 'HISTORY', 'END'}\nastropy\/io\/fits\/card.py:    _value_indicator = VALUE_INDICATOR\nastropy\/io\/fits\/card.py:            if (len(keyword) <= KEYWORD_LENGTH and\nastropy\/io\/fits\/card.py:                if keyword_upper == 'END':\nastropy\/io\/fits\/card.py:                    raise ValueError(\"Keyword 'END' not allowed.\")\nastropy\/io\/fits\/card.py:                self._value_indicator = HIERARCH_VALUE_INDICATOR\nastropy\/io\/fits\/card.py:            except UnicodeDecodeError:\nastropy\/io\/fits\/card.py:            return self._image == BLANK_CARD\nastropy\/io\/fits\/card.py:        if (len(keyword) <= KEYWORD_LENGTH and\nastropy\/io\/fits\/card.py:        Determine whether or not the card is a record-valued keyword card.\nastropy\/io\/fits\/card.py:            self._check_if_rvkc('DP1', 'AXIS.1: 2')\nastropy\/io\/fits\/card.py:            self._check_if_rvkc('DP1.AXIS.1', 2)\nastropy\/io\/fits\/card.py:            self._check_if_rvkc('DP1     = AXIS.1: 2')\nastropy\/io\/fits\/card.py:            eq_idx = image.find(VALUE_INDICATOR)\nastropy\/io\/fits\/card.py:            rest = image[eq_idx + len(VALUE_INDICATOR):]\nastropy\/io\/fits\/card.py:        keyword = self._image[:KEYWORD_LENGTH].strip()\nastropy\/io\/fits\/card.py:        val_ind_idx = self._image.find(VALUE_INDICATOR)\nastropy\/io\/fits\/card.py:        if (0 <= val_ind_idx <= KEYWORD_LENGTH or keyword_upper in special or\nastropy\/io\/fits\/card.py:                rest = self._image[val_ind_idx + len(VALUE_INDICATOR):]\nastropy\/io\/fits\/card.py:              HIERARCH_VALUE_INDICATOR in self._image):\nastropy\/io\/fits\/card.py:            self._value_indicator = HIERARCH_VALUE_INDICATOR\nastropy\/io\/fits\/card.py:            keyword = self._image.split(HIERARCH_VALUE_INDICATOR, 1)[0][9:]\nastropy\/io\/fits\/card.py:            return self._image[KEYWORD_LENGTH:].rstrip()\nastropy\/io\/fits\/card.py:            value = UNDEFINED\nastropy\/io\/fits\/card.py:                keyword = image[:KEYWORD_LENGTH]\nastropy\/io\/fits\/card.py:                valuecomment = image[KEYWORD_LENGTH:]\nastropy\/io\/fits\/card.py:                                         len=KEYWORD_LENGTH)\nastropy\/io\/fits\/card.py:                return '{:{len}}'.format(self.keyword, len=KEYWORD_LENGTH)\nastropy\/io\/fits\/card.py:            return ' ' * KEYWORD_LENGTH\nastropy\/io\/fits\/card.py:        if not self.field_specifier and len(self.keyword) > KEYWORD_LENGTH:\nastropy\/io\/fits\/card.py:        delimiter = VALUE_INDICATOR\nastropy\/io\/fits\/card.py:                headstr = '{:{len}}= '.format(self.keyword, len=KEYWORD_LENGTH)\nastropy\/io\/fits\/card.py:        maxlen = Card.length - KEYWORD_LENGTH\nastropy\/io\/fits\/card.py:        # Don't try to verify cards that already don't meet any recognizable\nastropy\/io\/fits\/__init__.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/__init__.py:# TODO: Make it possible to set these variables via environment variables\nastropy\/io\/fits\/__init__.py:        'If True, use lazy loading of HDUs when opening FITS files by '\nastropy\/io\/fits\/__init__.py:        'default; that is fits.open() will only seek for and read HDUs on '\nastropy\/io\/fits\/__init__.py:        'demand rather than reading all HDUs at once.  See the documentation '\nastropy\/io\/fits\/__init__.py:from .hdu.groups import GroupData\nastropy\/io\/fits\/__init__.py:           ['FITS_record', 'FITS_rec', 'GroupData', 'open', 'Section',\nastropy\/visualization\/hist.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/hdu\/nonstandard.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/nonstandard.py:from .base import NonstandardExtHDU\nastropy\/io\/fits\/hdu\/nonstandard.py:from .hdulist import HDUList\nastropy\/io\/fits\/hdu\/nonstandard.py:class FitsHDU(NonstandardExtHDU):\nastropy\/io\/fits\/hdu\/nonstandard.py:    A non-standard extension HDU for encapsulating entire FITS files within a\nastropy\/io\/fits\/hdu\/nonstandard.py:    single HDU of a container FITS file.  These HDUs have an extension (that is\nastropy\/io\/fits\/hdu\/nonstandard.py:    The FITS file contained in the HDU's data can be accessed by the `hdulist`\nastropy\/io\/fits\/hdu\/nonstandard.py:    attribute which returns the contained FITS file as an `HDUList` object.\nastropy\/io\/fits\/hdu\/nonstandard.py:        return HDUList.fromfile(fileobj, mode='readonly')\nastropy\/io\/fits\/hdu\/nonstandard.py:        Like `FitsHDU.fromhdulist()`, but creates a FitsHDU from a file on\nastropy\/io\/fits\/hdu\/nonstandard.py:            The path to the file to read into a FitsHDU\nastropy\/io\/fits\/hdu\/nonstandard.py:        return cls.fromhdulist(HDUList.fromfile(filename), compress=compress)\nastropy\/io\/fits\/hdu\/nonstandard.py:        Creates a new FitsHDU from a given HDUList object.\nastropy\/io\/fits\/hdu\/nonstandard.py:        hdulist : HDUList\nastropy\/io\/fits\/hdu\/nonstandard.py:        # A proper HDUList should still be padded out to a multiple of 2880\nastropy\/io\/fits\/hdu\/nonstandard.py:        # Add the XINDn keywords proposed by Perry, though nothing is done with\nastropy\/io\/fits\/hdu\/nonstandard.py:                cards.append(('XIND' + str(idx + 1), hdu._header_offset,\nastropy\/io\/fits\/hdu\/nonstandard.py:    # TODO: Add header verification\nastropy\/io\/fits\/hdu\/nonstandard.py:        # TODO: Perhaps make this more descriptive...\nastropy\/io\/fits\/header.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/header.py:from .card import Card, _pad, KEYWORD_LENGTH\nastropy\/io\/fits\/header.py:# This regular expression can match a *valid* END card which just consists of\nastropy\/io\/fits\/header.py:# the string 'END' followed by all spaces, or an *invalid* end card which\nastropy\/io\/fits\/header.py:# consists of END, followed by any character that is *not* a valid character\nastropy\/io\/fits\/header.py:# for a valid FITS keyword (that is, this is not a keyword like 'ENDER' which\nastropy\/io\/fits\/header.py:# starts with 'END' but is not 'END'), followed by any arbitrary bytes.  An\nastropy\/io\/fits\/header.py:# invalid end card may also consist of just 'END' with no trailing bytes.\nastropy\/io\/fits\/header.py:HEADER_END_RE = re.compile(encode_ascii(\nastropy\/io\/fits\/header.py:    r'(?:(?P<valid>END {77}) *)|(?P<invalid>END$|END {0,76}[^A-Z0-9_-])'))\nastropy\/io\/fits\/header.py:VALID_HEADER_CHARS = set(map(chr, range(0x20, 0x7F)))\nastropy\/io\/fits\/header.py:END_CARD = 'END' + ' ' * 77\nastropy\/io\/fits\/header.py:            Default is ``False``.\nastropy\/io\/fits\/header.py:        Creates an HDU header from a byte string containing the entire header\nastropy\/io\/fits\/header.py:        require_full_cardlength = set(sep).issubset(VALID_HEADER_CHARS)\nastropy\/io\/fits\/header.py:                if next_image == END_CARD:\nastropy\/io\/fits\/header.py:                if next_image.split(sep)[0].rstrip() == 'END':\nastropy\/io\/fits\/header.py:            If True (the default) the header must end with an END card in order\nastropy\/io\/fits\/header.py:            to be considered valid.  If an END card is not found an\nastropy\/io\/fits\/header.py:        handling.  Also used by `_BaseHDU.fromstring`.\nastropy\/io\/fits\/header.py:            # TODO: There needs to be error handling at *this* level for\nastropy\/io\/fits\/header.py:        # continue reading header blocks until END card or EOF is reached\nastropy\/io\/fits\/header.py:            # find the END card\nastropy\/io\/fits\/header.py:            # TODO: Pass this error to validation framework as an ERROR,\nastropy\/io\/fits\/header.py:            raise OSError('Header missing END card.')\nastropy\/io\/fits\/header.py:                # TODO: Pass this warning to validation framework\nastropy\/io\/fits\/header.py:                # TODO: Pass this warning to validation framework\nastropy\/io\/fits\/header.py:            # TODO: Pass this error to validation framework\nastropy\/io\/fits\/header.py:        Utility method to search a header block for the END card and handle\nastropy\/io\/fits\/header.py:        invalid END cards.\nastropy\/io\/fits\/header.py:        for mo in HEADER_END_RE.finditer(block):\nastropy\/io\/fits\/header.py:            # Ensure the END card was found, and it started on the\nastropy\/io\/fits\/header.py:                    # TODO: Pass this warning up to the validation framework\nastropy\/io\/fits\/header.py:                        'Unexpected bytes trailing END keyword: {0}; these '\nastropy\/io\/fits\/header.py:                    # TODO: Pass this warning up to the validation framework\nastropy\/io\/fits\/header.py:                        'END keyword; additional spaces will be appended to '\nastropy\/io\/fits\/header.py:                # Sanitize out invalid END card now that the appropriate\nastropy\/io\/fits\/header.py:                block = (block[:offset] + encode_ascii(END_CARD) +\nastropy\/io\/fits\/header.py:                         block[offset + len(END_CARD):])\nastropy\/io\/fits\/header.py:        By default this uses no separator between cards, adds the END card, and\nastropy\/io\/fits\/header.py:            If True (default) adds the END card to the end of the header\nastropy\/io\/fits\/header.py:            s += sep + _pad('END')\nastropy\/io\/fits\/header.py:        FITS file, with the END card included and padding to the next multiple\nastropy\/io\/fits\/header.py:            If `True` (default) adds the END card to the end of the header\nastropy\/io\/fits\/header.py:            ``OSError`` if ``False`` and the output file exists. Default is\nastropy\/io\/fits\/header.py:           standard HDU types, so that this header can be used in a different\nastropy\/io\/fits\/header.py:           HDU.\nastropy\/io\/fits\/header.py:        # Don't try to make a temporary card though if they keyword looks like\nastropy\/io\/fits\/header.py:        if (len(keyword) <= KEYWORD_LENGTH and\nastropy\/io\/fits\/header.py:                # Don't do this unless there is at least one blanks at the end\nastropy\/io\/fits\/header.py:            HDUs, so that only more general keywords are added from extension\nastropy\/io\/fits\/header.py:                        # Dumbly update the first keyword to either SIMPLE or\nastropy\/io\/fits\/header.py:            rather than before it.  Defaults to `False`.\nastropy\/io\/fits\/header.py:            # Don't pass through ints to _cardindex because it will not take\nastropy\/io\/fits\/header.py:            if len(keyword) > KEYWORD_LENGTH or '.' in keyword:\nastropy\/io\/fits\/header.py:        maxlen = Card.length - KEYWORD_LENGTH\nastropy\/io\/fits\/header.py:        # TODO: Previously this only deleted some cards specific to an HDU if\nastropy\/io\/fits\/header.py:        # a way for HDU classes to specify some headers that are specific only\nastropy\/io\/fits\/header.py:        if 'TFIELDS' in self:\nastropy\/io\/fits\/header.py:            tfields = self['TFIELDS']\nastropy\/io\/fits\/header.py:                     'TUNIT', 'TDISP', 'TDIM', 'THEAP', 'TBCOL'):\nastropy\/io\/fits\/header.py:        for name in ('SIMPLE', 'XTENSION', 'BITPIX', 'NAXIS', 'EXTEND',\nastropy\/io\/fits\/header.py:                     'TFIELDS'):\nastropy\/io\/fits\/header.py:    # TODO: Consider giving this dict\/list methods like Header itself\nastropy\/io\/fits\/header.py:        keyword_length = KEYWORD_LENGTH\nastropy\/io\/fits\/header.py:    Determine the size of a FITS header block if a non-blank separator is used\nastropy\/io\/fits\/hdu\/__init__.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/__init__.py:from .base import (register_hdu, unregister_hdu, DELAYED, BITPIX2DTYPE,\nastropy\/io\/fits\/hdu\/__init__.py:                   DTYPE2BITPIX)\nastropy\/io\/fits\/hdu\/__init__.py:from .compressed import CompImageHDU\nastropy\/io\/fits\/hdu\/__init__.py:from .groups import GroupsHDU, GroupData, Group\nastropy\/io\/fits\/hdu\/__init__.py:from .hdulist import HDUList\nastropy\/io\/fits\/hdu\/__init__.py:from .image import PrimaryHDU, ImageHDU\nastropy\/io\/fits\/hdu\/__init__.py:from .nonstandard import FitsHDU\nastropy\/io\/fits\/hdu\/__init__.py:from .streaming import StreamingHDU\nastropy\/io\/fits\/hdu\/__init__.py:from .table import TableHDU, BinTableHDU\nastropy\/io\/fits\/hdu\/__init__.py:__all__ = ['HDUList', 'PrimaryHDU', 'ImageHDU', 'TableHDU', 'BinTableHDU',\nastropy\/io\/fits\/hdu\/__init__.py:           'GroupsHDU', 'GroupData', 'Group', 'CompImageHDU', 'FitsHDU',\nastropy\/io\/fits\/hdu\/__init__.py:           'StreamingHDU', 'register_hdu', 'unregister_hdu', 'DELAYED',\nastropy\/io\/fits\/hdu\/__init__.py:           'BITPIX2DTYPE', 'DTYPE2BITPIX']\nastropy\/visualization\/wcsaxes\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/utils.py:    Determine whether a particular WCS ctype corresponds to an angle or scalar\nastropy\/visualization\/wcsaxes\/utils.py:    elif ctype[:4] in ['DEC-', 'HPLT'] or ctype[1:4] == 'LAT':\nastropy\/io\/registry.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/registry.py:from collections import OrderedDict\nastropy\/io\/registry.py:_readers = OrderedDict()\nastropy\/io\/registry.py:_writers = OrderedDict()\nastropy\/io\/registry.py:_identifiers = OrderedDict()\nastropy\/io\/registry.py:        search for both.  Default is None.\nastropy\/io\/registry.py:        # Indices represent \"Data Class\", \"Deprecated\" and \"Format\".\nastropy\/io\/registry.py:    format_table = Table(data, names=('Data class', 'Format', 'Read', 'Write',\nastropy\/io\/registry.py:                                      'Auto-identify', 'Deprecated'))\nastropy\/io\/registry.py:    if not np.any(format_table['Deprecated'] == 'Yes'):\nastropy\/io\/registry.py:        format_table.remove_column('Deprecated')\nastropy\/io\/registry.py:    # Include only formats that have a reader, and drop the 'Data class' column\nastropy\/io\/registry.py:    format_table.remove_column('Data class')\nastropy\/io\/registry.py:    if 'Deprecated' in format_table.colnames:\nastropy\/io\/registry.py:                          'Deprecated format names like ``aastex`` will be '\nastropy\/io\/registry.py:    # Depending on Python version and whether class_readwrite_func is\nastropy\/io\/registry.py:        Default is ``False``.\nastropy\/io\/registry.py:        Default is ``False``.\nastropy\/io\/registry.py:        Default is ``False``.\nastropy\/io\/registry.py:    format_table.remove_column('Data class')\nastropy\/io\/registry.py:    Determine if class2 is the \"best\" match for class1 in the list\nastropy\/convolution\/tests\/test_kernel_class.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_kernel_class.py:    Gaussian1DKernel, Gaussian2DKernel, Box1DKernel, Box2DKernel,\nastropy\/convolution\/tests\/test_kernel_class.py:    Trapezoid1DKernel, TrapezoidDisk2DKernel, MexicanHat1DKernel,\nastropy\/convolution\/tests\/test_kernel_class.py:    Tophat2DKernel, MexicanHat2DKernel, AiryDisk2DKernel, Ring2DKernel,\nastropy\/convolution\/tests\/test_kernel_class.py:    CustomKernel, Model1DKernel, Model2DKernel, Kernel1D, Kernel2D)\nastropy\/convolution\/tests\/test_kernel_class.py:from ...modeling.models import Box2D, Gaussian1D, Gaussian2D\nastropy\/convolution\/tests\/test_kernel_class.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/convolution\/tests\/test_kernel_class.py:WIDTHS_ODD = [3, 5, 7, 9]\nastropy\/convolution\/tests\/test_kernel_class.py:WIDTHS_EVEN = [2, 4, 8, 16]\nastropy\/convolution\/tests\/test_kernel_class.py:MODES = ['center', 'linear_interp', 'oversample', 'integrate']\nastropy\/convolution\/tests\/test_kernel_class.py:KERNEL_TYPES = [Gaussian1DKernel, Gaussian2DKernel,\nastropy\/convolution\/tests\/test_kernel_class.py:                Box1DKernel, Box2DKernel,\nastropy\/convolution\/tests\/test_kernel_class.py:                Trapezoid1DKernel, TrapezoidDisk2DKernel,\nastropy\/convolution\/tests\/test_kernel_class.py:                MexicanHat1DKernel, Tophat2DKernel, AiryDisk2DKernel, Ring2DKernel]\nastropy\/convolution\/tests\/test_kernel_class.py:delta_pulse_1D = np.zeros(81)\nastropy\/convolution\/tests\/test_kernel_class.py:delta_pulse_1D[40] = 1\nastropy\/convolution\/tests\/test_kernel_class.py:delta_pulse_2D = np.zeros((81, 81))\nastropy\/convolution\/tests\/test_kernel_class.py:delta_pulse_2D[40, 40] = 1\nastropy\/convolution\/tests\/test_kernel_class.py:random_data_1D = np.random.rand(61)\nastropy\/convolution\/tests\/test_kernel_class.py:random_data_2D = np.random.rand(61, 61)\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('width'), WIDTHS_ODD)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_kernel_1D = Gaussian1DKernel(width)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_kernel_1D.normalize()\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_kernel_2D = Gaussian2DKernel(width)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_kernel_2D.normalize()\nastropy\/convolution\/tests\/test_kernel_class.py:        astropy_1D = convolve(delta_pulse_1D, gauss_kernel_1D, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:        astropy_2D = convolve(delta_pulse_2D, gauss_kernel_2D, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:        scipy_1D = filters.gaussian_filter(delta_pulse_1D, width)\nastropy\/convolution\/tests\/test_kernel_class.py:        scipy_2D = filters.gaussian_filter(delta_pulse_2D, width)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert_almost_equal(astropy_1D, scipy_1D, decimal=12)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert_almost_equal(astropy_2D, scipy_2D, decimal=12)\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('width'), WIDTHS_ODD)\nastropy\/convolution\/tests\/test_kernel_class.py:        mexican_kernel_1D = MexicanHat1DKernel(width)\nastropy\/convolution\/tests\/test_kernel_class.py:        mexican_kernel_2D = MexicanHat2DKernel(width)\nastropy\/convolution\/tests\/test_kernel_class.py:        astropy_1D = convolve(delta_pulse_1D, mexican_kernel_1D, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:        astropy_2D = convolve(delta_pulse_2D, mexican_kernel_2D, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            astropy_1D = convolve(delta_pulse_1D, mexican_kernel_1D, boundary='fill', normalize_kernel=True)\nastropy\/convolution\/tests\/test_kernel_class.py:            astropy_2D = convolve(delta_pulse_2D, mexican_kernel_2D, boundary='fill', normalize_kernel=True)\nastropy\/convolution\/tests\/test_kernel_class.py:        scipy_1D = -filters.gaussian_laplace(delta_pulse_1D, width)\nastropy\/convolution\/tests\/test_kernel_class.py:        scipy_2D = -filters.gaussian_laplace(delta_pulse_2D, width)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert_almost_equal(astropy_1D, scipy_1D, decimal=5)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert_almost_equal(astropy_2D, scipy_2D, decimal=5)\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('kernel_type', 'width'), list(itertools.product(KERNEL_TYPES, WIDTHS_ODD)))\nastropy\/convolution\/tests\/test_kernel_class.py:        if kernel_type == AiryDisk2DKernel and not HAS_SCIPY:\nastropy\/convolution\/tests\/test_kernel_class.py:            pytest.skip(\"Omitting AiryDisk2DKernel, which requires SciPy\")\nastropy\/convolution\/tests\/test_kernel_class.py:        if not kernel_type == Ring2DKernel:\nastropy\/convolution\/tests\/test_kernel_class.py:            c1 = convolve_fft(delta_pulse_1D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c2 = convolve(delta_pulse_1D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c1 = convolve_fft(delta_pulse_2D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c2 = convolve(delta_pulse_2D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('kernel_type', 'width'), list(itertools.product(KERNEL_TYPES, WIDTHS_ODD)))\nastropy\/convolution\/tests\/test_kernel_class.py:        if kernel_type == AiryDisk2DKernel and not HAS_SCIPY:\nastropy\/convolution\/tests\/test_kernel_class.py:            pytest.skip(\"Omitting AiryDisk2DKernel, which requires SciPy\")\nastropy\/convolution\/tests\/test_kernel_class.py:        if not kernel_type == Ring2DKernel:\nastropy\/convolution\/tests\/test_kernel_class.py:            c1 = convolve_fft(random_data_1D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c2 = convolve(random_data_1D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c1 = convolve_fft(random_data_2D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c2 = convolve(random_data_2D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('width'), WIDTHS_ODD)\nastropy\/convolution\/tests\/test_kernel_class.py:        c2 = convolve_fft(delta_pulse_2D, kernel, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:        c1 = convolve(delta_pulse_2D, kernel, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('width'), WIDTHS_ODD)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_smallkernel_vs_Box2DKernel(self, width):\nastropy\/convolution\/tests\/test_kernel_class.py:        kernel2 = Box2DKernel(width)\nastropy\/convolution\/tests\/test_kernel_class.py:        c2 = convolve_fft(delta_pulse_2D, kernel2, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:        c1 = convolve_fft(delta_pulse_2D, kernel1, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_convolve_1D_kernels(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_1 = Gaussian1DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_2 = Gaussian1DKernel(4)\nastropy\/convolution\/tests\/test_kernel_class.py:        test_gauss_3 = Gaussian1DKernel(5)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_convolve_2D_kernels(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_1 = Gaussian2DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_2 = Gaussian2DKernel(4)\nastropy\/convolution\/tests\/test_kernel_class.py:        test_gauss_3 = Gaussian2DKernel(5)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian1DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian1DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert type(gauss_new) is Gaussian1DKernel\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian1DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert type(gauss_new) is Gaussian1DKernel\nastropy\/convolution\/tests\/test_kernel_class.py:        \"\"\"Test that multiplying two 1D kernels raises an exception.\"\"\"\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian1DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        \"\"\"Test that multiplying two 2D kernels raises an exception.\"\"\"\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian2DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        Test that multiplying a 1D kernel with a 2D kernel raises an\nastropy\/convolution\/tests\/test_kernel_class.py:            Gaussian1DKernel(3) * Gaussian2DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:            Gaussian1DKernel(3) + 1\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_model_1D_kernel(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check Model1DKernel against Gaussian1Dkernel\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian1D(1. \/ np.sqrt(2 * np.pi * stddev**2), 0, stddev)\nastropy\/convolution\/tests\/test_kernel_class.py:        model_gauss_kernel = Model1DKernel(gauss, x_size=21)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_kernel = Gaussian1DKernel(stddev, x_size=21)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_model_2D_kernel(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check Model2DKernel against Gaussian2Dkernel\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian2D(1. \/ (2 * np.pi * stddev**2), 0, 0, stddev, stddev)\nastropy\/convolution\/tests\/test_kernel_class.py:        model_gauss_kernel = Model2DKernel(gauss, x_size=21)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss_kernel = Gaussian2DKernel(stddev, x_size=21)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_custom_1D_kernel(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check CustomKernel against Box1DKernel.\nastropy\/convolution\/tests\/test_kernel_class.py:        # Define one dimensional array:\nastropy\/convolution\/tests\/test_kernel_class.py:        box = Box1DKernel(5)\nastropy\/convolution\/tests\/test_kernel_class.py:        c2 = convolve(delta_pulse_1D, custom, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:        c1 = convolve(delta_pulse_1D, box, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_custom_2D_kernel(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check CustomKernel against Box2DKernel.\nastropy\/convolution\/tests\/test_kernel_class.py:        # Define one dimensional array:\nastropy\/convolution\/tests\/test_kernel_class.py:        box = Box2DKernel(5)\nastropy\/convolution\/tests\/test_kernel_class.py:        c2 = convolve(delta_pulse_2D, custom, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:        c1 = convolve(delta_pulse_2D, box, boundary='fill')\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_custom_1D_kernel_list(self):\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_custom_2D_kernel_list(self):\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_custom_1D_kernel_zerosum(self):\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_custom_2D_kernel_zerosum(self):\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_add_1D_kernels(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check if adding of two 1D kernels works.\nastropy\/convolution\/tests\/test_kernel_class.py:        box_1 = Box1DKernel(5)\nastropy\/convolution\/tests\/test_kernel_class.py:        box_2 = Box1DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        box_3 = Box1DKernel(1)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_add_2D_kernels(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check if adding of two 1D kernels works.\nastropy\/convolution\/tests\/test_kernel_class.py:        box_1 = Box2DKernel(3)\nastropy\/convolution\/tests\/test_kernel_class.py:        box_2 = Box2DKernel(1)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_Gaussian1DKernel_even_size(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian1DKernel(3, x_size=10)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_Gaussian2DKernel_even_size(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian2DKernel(3, x_size=10, y_size=10)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_Gaussian2DKernel_rotated(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/convolution\/tests\/test_kernel_class.py:            Gaussian2DKernel(stddev=10)\nastropy\/convolution\/tests\/test_kernel_class.py:        gauss = Gaussian2DKernel(\nastropy\/convolution\/tests\/test_kernel_class.py:        box = Box2DKernel(5)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert isinstance(box.model, Box2D)\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('kernel_type', 'mode'), list(itertools.product(KERNEL_TYPES, MODES)))\nastropy\/convolution\/tests\/test_kernel_class.py:        if kernel_type == AiryDisk2DKernel and not HAS_SCIPY:\nastropy\/convolution\/tests\/test_kernel_class.py:            pytest.skip(\"Omitting AiryDisk2DKernel, which requires SciPy\")\nastropy\/convolution\/tests\/test_kernel_class.py:        if not kernel_type == Ring2DKernel:\nastropy\/convolution\/tests\/test_kernel_class.py:            c1 = convolve_fft(delta_pulse_1D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c2 = convolve(delta_pulse_1D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c1 = convolve_fft(delta_pulse_2D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:            c2 = convolve(delta_pulse_2D, kernel, boundary='fill', normalize_kernel=False)\nastropy\/convolution\/tests\/test_kernel_class.py:    @pytest.mark.parametrize(('width'), WIDTHS_EVEN)\nastropy\/convolution\/tests\/test_kernel_class.py:        kernel_1D = Box1DKernel(width)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert kernel_1D.shape[0] % 2 != 0\nastropy\/convolution\/tests\/test_kernel_class.py:        assert kernel_1D.array.sum() == 1.\nastropy\/convolution\/tests\/test_kernel_class.py:        kernel_2D = Box2DKernel(width)\nastropy\/convolution\/tests\/test_kernel_class.py:        assert np.all([_ % 2 != 0 for _ in kernel_2D.shape])\nastropy\/convolution\/tests\/test_kernel_class.py:        assert kernel_2D.array.sum() == 1.\nastropy\/convolution\/tests\/test_kernel_class.py:        Test that an error is raised if ``Kernel1D`` ``x_size`` is not\nastropy\/convolution\/tests\/test_kernel_class.py:            Gaussian1DKernel(3, x_size=1.2)\nastropy\/convolution\/tests\/test_kernel_class.py:        Test that an error is raised if ``Kernel2D`` ``x_size`` is not\nastropy\/convolution\/tests\/test_kernel_class.py:            Gaussian2DKernel(3, x_size=1.2)\nastropy\/convolution\/tests\/test_kernel_class.py:        Test that an error is raised if ``Kernel2D`` ``y_size`` is not\nastropy\/convolution\/tests\/test_kernel_class.py:            Gaussian2DKernel(3, x_size=5, y_size=1.2)\nastropy\/convolution\/tests\/test_kernel_class.py:        specified for ``Kernel1D``.\nastropy\/convolution\/tests\/test_kernel_class.py:            Kernel1D()\nastropy\/convolution\/tests\/test_kernel_class.py:        specified for ``Kernel2D``.\nastropy\/convolution\/tests\/test_kernel_class.py:            Kernel2D()\nastropy\/io\/fits\/convenience.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/convenience.py::class:`astropy.io.fits.HDUList` object and underlying HDU objects.\nastropy\/io\/fits\/convenience.py:special arguments for selecting which extension HDU to use when working with a\nastropy\/io\/fits\/convenience.py:    *not* for selecting the extension HDU should be passed in as keyword\nastropy\/io\/fits\/convenience.py:    extension arguments.  For example, to set NAXIS=1 on the Primary HDU:\nastropy\/io\/fits\/convenience.py:    HDU to blank.  That is, the argument '1' is assumed to specify an extension\nastropy\/io\/fits\/convenience.py:    HDU.\nastropy\/io\/fits\/convenience.py:    This will set the NAXIS keyword to 1 on the primary HDU (the default).  To\nastropy\/io\/fits\/convenience.py:    specify the first extension HDU use::\nastropy\/io\/fits\/convenience.py:from .diff import FITSDiff, HDUDiff\nastropy\/io\/fits\/convenience.py:from .file import FILE_MODES, _File\nastropy\/io\/fits\/convenience.py:from .hdu.base import _BaseHDU, _ValidHDU\nastropy\/io\/fits\/convenience.py:from .hdu.hdulist import fitsopen, HDUList\nastropy\/io\/fits\/convenience.py:from .hdu.image import PrimaryHDU, ImageHDU\nastropy\/io\/fits\/convenience.py:from .hdu.table import BinTableHDU\nastropy\/io\/fits\/convenience.py:        If `True`, return the data and the header of the specified HDU as a\nastropy\/io\/fits\/convenience.py:                raise IndexError('No data in this HDU.')\nastropy\/io\/fits\/convenience.py:            raise IndexError('No data in this HDU.')\nastropy\/io\/fits\/convenience.py:    Delete all instances of keyword from a header in a FITS file.\nastropy\/io\/fits\/convenience.py:        ``OSError`` if ``False`` and the output file exists. Default is\nastropy\/io\/fits\/convenience.py:        If `True`, adds both ``DATASUM`` and ``CHECKSUM`` cards to the\nastropy\/io\/fits\/convenience.py:        headers of all HDU's written to the file.\nastropy\/io\/fits\/convenience.py:    if hdu.is_image and not isinstance(hdu, PrimaryHDU):\nastropy\/io\/fits\/convenience.py:        hdu = PrimaryHDU(data, header=header)\nastropy\/io\/fits\/convenience.py:    `~astropy.io.fits.BinTableHDU`.\nastropy\/io\/fits\/convenience.py:        Whether to return bytes for string columns when accessed from the HDU.\nastropy\/io\/fits\/convenience.py:    table_hdu : `~astropy.io.fits.BinTableHDU`\nastropy\/io\/fits\/convenience.py:        The FITS binary table HDU.\nastropy\/io\/fits\/convenience.py:    from .connect import is_column_keyword, REMOVE_KEYWORDS\nastropy\/io\/fits\/convenience.py:    # Create a new HDU object\nastropy\/io\/fits\/convenience.py:        # TODO: it might be better to construct the FITS table directly from\nastropy\/io\/fits\/convenience.py:        table_hdu = BinTableHDU.from_columns(np.array(table.filled()), header=hdr, character_as_bytes=True)\nastropy\/io\/fits\/convenience.py:            # TODO: Determine a schema for handling non-integer masked columns\nastropy\/io\/fits\/convenience.py:        table_hdu = BinTableHDU.from_columns(np.array(table.filled()), header=hdr, character_as_bytes=character_as_bytes)\nastropy\/io\/fits\/convenience.py:    # Set units for output HDU\nastropy\/io\/fits\/convenience.py:        if is_column_keyword(key.upper()) or key.upper() in REMOVE_KEYWORDS:\nastropy\/io\/fits\/convenience.py:        When `True` adds both ``DATASUM`` and ``CHECKSUM`` cards to the header\nastropy\/io\/fits\/convenience.py:        of the HDU when written to the file.\nastropy\/io\/fits\/convenience.py:        if isinstance(hdu, PrimaryHDU):\nastropy\/io\/fits\/convenience.py:            hdu = ImageHDU(data, header)\nastropy\/io\/fits\/convenience.py:                # Set a flag in the HDU so that only this HDU gets a checksum\nastropy\/io\/fits\/convenience.py:        HDU info.  Writes to ``sys.stdout`` by default.\nastropy\/io\/fits\/convenience.py:    FITS `HDUList` objects and FITS ``HDU`` objects.\nastropy\/io\/fits\/convenience.py:    inputa : str, `HDUList` object, or ``HDU`` object\nastropy\/io\/fits\/convenience.py:        The filename of a FITS file, `HDUList`, or ``HDU``\nastropy\/io\/fits\/convenience.py:    inputb : str, `HDUList` object, or ``HDU`` object\nastropy\/io\/fits\/convenience.py:        The filename of a FITS file, `HDUList`, or ``HDU``\nastropy\/io\/fits\/convenience.py:        ``inputa`` and ``inputb`` are ``HDU`` objects or `HDUList` objects).\nastropy\/io\/fits\/convenience.py:            printdiff('inA.fits', 'inB.fits', 0)      # the primary HDU\nastropy\/io\/fits\/convenience.py:        `~astropy.io.fits.FITSDiff`.\nastropy\/io\/fits\/convenience.py:    To save the diff report to a file please use `~astropy.io.fits.FITSDiff`\nastropy\/io\/fits\/convenience.py:            print(HDUDiff(hdua, hdub, **kwargs).report())\nastropy\/io\/fits\/convenience.py:    # If input is not a string, can feed HDU objects or HDUList directly,\nastropy\/io\/fits\/convenience.py:    elif isinstance(inputa, _ValidHDU) and has_extensions:\nastropy\/io\/fits\/convenience.py:                         \"HDU object.\")\nastropy\/io\/fits\/convenience.py:    elif isinstance(inputa, _ValidHDU) and not has_extensions:\nastropy\/io\/fits\/convenience.py:        print(HDUDiff(inputa, inputb, **kwargs).report())\nastropy\/io\/fits\/convenience.py:    elif isinstance(inputa, HDUList) and has_extensions:\nastropy\/io\/fits\/convenience.py:        raise NotImplementedError(\"Extension specification with HDUList \"\nastropy\/io\/fits\/convenience.py:        print(FITSDiff(inputa, inputb, **kwargs).report())\nastropy\/io\/fits\/convenience.py:    Dump a table HDU to a file in ASCII format.  The table may be\nastropy\/io\/fits\/convenience.py:        The number of the extension containing the table HDU to be\nastropy\/io\/fits\/convenience.py:        ``OSError`` if ``False`` and the output file exists. Default is\nastropy\/io\/fits\/convenience.py:        # Dump the data from the HDU to the files\nastropy\/io\/fits\/convenience.py:    tabledump.__doc__ += BinTableHDU._tdump_file_format.replace('\\n', '\\n    ')\nastropy\/io\/fits\/convenience.py:    return BinTableHDU.load(datafile, cdfile, hfile, replace=True)\nastropy\/io\/fits\/convenience.py:    tableload.__doc__ += BinTableHDU._tdump_file_format.replace('\\n', '\\n    ')\nastropy\/io\/fits\/convenience.py:    Open the input file, return the `HDUList` and the extension.\nastropy\/io\/fits\/convenience.py:    hdu = _BaseHDU(data, header)\nastropy\/io\/fits\/convenience.py:    if hdu.__class__ in (_BaseHDU, _ValidHDU):\nastropy\/io\/fits\/convenience.py:        # The HDU type was unrecognized, possibly due to a\nastropy\/io\/fits\/convenience.py:            hdu = BinTableHDU(data, header=header)\nastropy\/io\/fits\/convenience.py:            hdu = ImageHDU(data, header=header)\nastropy\/io\/fits\/convenience.py:            raise KeyError('Data must be a numpy array.')\nastropy\/io\/fits\/convenience.py:        mode = FILE_MODES.get(fmode)\nastropy\/visualization\/wcsaxes\/tests\/test_display_world_coordinates.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_display_world_coordinates.py:class TestDisplayWorldCoordinate(BaseImageTests):\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:from ....tests.image_tests import IMAGE_REFERENCE_DIR\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR, tolerance=1.5)\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR, tolerance=1.5)\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:        w.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:        w.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:        # TODO: the formatted string should show units\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_images.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/io\/fits\/hdu\/groups.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/groups.py:from .base import DTYPE2BITPIX\nastropy\/io\/fits\/hdu\/groups.py:from .image import PrimaryHDU\nastropy\/io\/fits\/hdu\/groups.py:from .table import _TableLikeHDU\nastropy\/io\/fits\/hdu\/groups.py:from ..column import Column, ColDefs, FITS2NUMPY\nastropy\/io\/fits\/hdu\/groups.py:        # TODO: It would be nice if, instead of requiring a multi-part value to\nastropy\/io\/fits\/hdu\/groups.py:class GroupData(FITS_rec):\nastropy\/io\/fits\/hdu\/groups.py:            unique_parnames = _unique_parnames(parnames + ['DATA'])\nastropy\/io\/fits\/hdu\/groups.py:                bitpix = DTYPE2BITPIX[input.dtype.name]\nastropy\/io\/fits\/hdu\/groups.py:            fits_fmt = GroupsHDU._bitpix2tform[bitpix]  # -32 -> 'E'\nastropy\/io\/fits\/hdu\/groups.py:            coldefs = ColDefs(cols)\nastropy\/io\/fits\/hdu\/groups.py:            # By default the data field will just be 'DATA', but it may be\nastropy\/io\/fits\/hdu\/groups.py:            # uniquified if 'DATA' is already used by one of the group names\nastropy\/io\/fits\/hdu\/groups.py:                # TODO: Find a better way to do this than using this interface\nastropy\/io\/fits\/hdu\/groups.py:        if isinstance(obj, GroupData):\nastropy\/io\/fits\/hdu\/groups.py:        if isinstance(out, GroupData):\nastropy\/io\/fits\/hdu\/groups.py:class GroupsHDU(PrimaryHDU, _TableLikeHDU):\nastropy\/io\/fits\/hdu\/groups.py:    FITS Random Groups HDU class.\nastropy\/io\/fits\/hdu\/groups.py:    details on working with this type of HDU.\nastropy\/io\/fits\/hdu\/groups.py:    _bitpix2tform = {8: 'B', 16: 'I', 32: 'J', 64: 'K', -32: 'E', -64: 'D'}\nastropy\/io\/fits\/hdu\/groups.py:    _data_type = GroupData\nastropy\/io\/fits\/hdu\/groups.py:    _data_field = 'DATA'\nastropy\/io\/fits\/hdu\/groups.py:    for each group; 'DATA' by default, but may be preceded by any number of\nastropy\/io\/fits\/hdu\/groups.py:    underscores if 'DATA' is already a parameter name\nastropy\/io\/fits\/hdu\/groups.py:        # Update the axes; GROUPS HDUs should always have at least one axis\nastropy\/io\/fits\/hdu\/groups.py:        # Now create columns from collected parameters, but first add the DATA\nastropy\/io\/fits\/hdu\/groups.py:        parnames.append('DATA')\nastropy\/io\/fits\/hdu\/groups.py:        coldefs = ColDefs(cols)\nastropy\/io\/fits\/hdu\/groups.py:        # Only really a lazyproperty for symmetry with _TableBaseHDU\nastropy\/io\/fits\/hdu\/groups.py:        Returns the size (in bytes) of the HDU's data part.\nastropy\/io\/fits\/hdu\/groups.py:            if isinstance(self.data, GroupData):\nastropy\/io\/fits\/hdu\/groups.py:            self._header['BITPIX'] = DTYPE2BITPIX[field0_code]\nastropy\/io\/fits\/hdu\/groups.py:        if self._has_data and isinstance(self.data, GroupData):\nastropy\/io\/fits\/hdu\/groups.py:        # Update the position of the EXTEND keyword if it already exists\nastropy\/io\/fits\/hdu\/groups.py:        if 'EXTEND' in self._header:\nastropy\/io\/fits\/hdu\/groups.py:            self._header.set('EXTEND', after=after)\nastropy\/io\/fits\/hdu\/groups.py:        Basically copy\/pasted from `_ImageBaseHDU._writedata_internal()`, but\nastropy\/io\/fits\/hdu\/groups.py:        TODO: Might be nice to store some indication of the data's byte order\nastropy\/io\/fits\/hdu\/groups.py:        Calculate the value for the ``DATASUM`` card in the HDU.\nastropy\/io\/fits\/hdu\/groups.py:            # TODO: Maybe check this on a per-field basis instead of assuming\nastropy\/io\/fits\/hdu\/groups.py:        # Drop the first axis from the shape\nastropy\/visualization\/wcsaxes\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/hdu\/image.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/image.py:from .base import DELAYED, _ValidHDU, ExtensionHDU, BITPIX2DTYPE, DTYPE2BITPIX\nastropy\/io\/fits\/hdu\/image.py:class _ImageBaseHDU(_ValidHDU):\nastropy\/io\/fits\/hdu\/image.py:    \"\"\"FITS image HDU base class.\nastropy\/io\/fits\/hdu\/image.py:        from .groups import GroupsHDU\nastropy\/io\/fits\/hdu\/image.py:                # TODO: Instead maybe try initializing a new Header object from\nastropy\/io\/fits\/hdu\/image.py:        if data is DELAYED:\nastropy\/io\/fits\/hdu\/image.py:            # Presumably if data is DELAYED then this HDU is coming from an\nastropy\/io\/fits\/hdu\/image.py:                raise ValueError('No header to setup HDU.')\nastropy\/io\/fits\/hdu\/image.py:            # TODO: Some of this card manipulation should go into the\nastropy\/io\/fits\/hdu\/image.py:            # PrimaryHDU and GroupsHDU subclasses\nastropy\/io\/fits\/hdu\/image.py:            if isinstance(self, ExtensionHDU):\nastropy\/io\/fits\/hdu\/image.py:            if isinstance(self, GroupsHDU):\nastropy\/io\/fits\/hdu\/image.py:            if isinstance(self, (ExtensionHDU, GroupsHDU)):\nastropy\/io\/fits\/hdu\/image.py:        # Set the name attribute if it was provided (if this is an ImageHDU\nastropy\/io\/fits\/hdu\/image.py:        if data is DELAYED:\nastropy\/io\/fits\/hdu\/image.py:            # Do not provide default values for BZERO and BSCALE here because\nastropy\/io\/fits\/hdu\/image.py:        _ImageBaseHDU is sort of an abstract class for HDUs containing image\nastropy\/io\/fits\/hdu\/image.py:        # Determine from the values read from the header\nastropy\/io\/fits\/hdu\/image.py:        of the order specified in the FITS file.  For example for a 2D image\nastropy\/io\/fits\/hdu\/image.py:            self._bitpix = DTYPE2BITPIX[data.dtype.name]\nastropy\/io\/fits\/hdu\/image.py:        # unsigned. Does not change the values of self._bitpix,\nastropy\/io\/fits\/hdu\/image.py:        # TODO: This routine is repeated in several different classes--it\nastropy\/io\/fits\/hdu\/image.py:        # should probably be made available as a method on all standard HDU\nastropy\/io\/fits\/hdu\/image.py:        Delete BSCALE\/BZERO from header if necessary.\nastropy\/io\/fits\/hdu\/image.py:            # Data is pseudo-unsigned integers, and the scale_back option\nastropy\/io\/fits\/hdu\/image.py:            self._header['BITPIX'] = DTYPE2BITPIX[dtype.name]\nastropy\/io\/fits\/hdu\/image.py:        ``BSCALE`` and ``BZERO`` in the HDU's header.  This method should only\nastropy\/io\/fits\/hdu\/image.py:        # Disable blank support for now\nastropy\/io\/fits\/hdu\/image.py:        TODO: This is only needed for fixing #3865 without introducing any\nastropy\/io\/fits\/hdu\/image.py:        # Determine the destination (numpy) data type\nastropy\/io\/fits\/hdu\/image.py:            type = BITPIX2DTYPE[self._bitpix]\nastropy\/io\/fits\/hdu\/image.py:        # Determine how to scale the data\nastropy\/io\/fits\/hdu\/image.py:        # Do the scaling\nastropy\/io\/fits\/hdu\/image.py:            # TODO: Perhaps check that the requested BLANK value fits in the\nastropy\/io\/fits\/hdu\/image.py:        self._bitpix = DTYPE2BITPIX[self.data.dtype.name]\nastropy\/io\/fits\/hdu\/image.py:        # both when the HDU is created and when written\nastropy\/io\/fits\/hdu\/image.py:        # TODO: Once the FITSSchema framewhere is merged these warnings\nastropy\/io\/fits\/hdu\/image.py:                \"in this HDU.\")\nastropy\/io\/fits\/hdu\/image.py:            self._scale_internal(BITPIX2DTYPE[self._orig_bitpix],\nastropy\/io\/fits\/hdu\/image.py:        Determine the dtype that the data should be converted to depending on\nastropy\/io\/fits\/hdu\/image.py:        code = BITPIX2DTYPE[self._orig_bitpix]\nastropy\/io\/fits\/hdu\/image.py:        Summarize the HDU: name, dimensions, and formats.\nastropy\/io\/fits\/hdu\/image.py:                format = BITPIX2DTYPE[self._bitpix]\nastropy\/io\/fits\/hdu\/image.py:        # Display shape in FITS-order\nastropy\/io\/fits\/hdu\/image.py:        Calculate the value for the ``DATASUM`` card in the HDU.\nastropy\/io\/fits\/hdu\/image.py:            # Only singleton dimensions remain; concatenate in a 1D array.\nastropy\/io\/fits\/hdu\/image.py:class PrimaryHDU(_ImageBaseHDU):\nastropy\/io\/fits\/hdu\/image.py:    FITS primary HDU class.\nastropy\/io\/fits\/hdu\/image.py:        Construct a primary HDU.\nastropy\/io\/fits\/hdu\/image.py:        data : array or DELAYED, optional\nastropy\/io\/fits\/hdu\/image.py:            The data in the HDU.\nastropy\/io\/fits\/hdu\/image.py:        # insert the keywords EXTEND\nastropy\/io\/fits\/hdu\/image.py:            self._header.set('EXTEND', True, after='NAXIS' + str(dim))\nastropy\/io\/fits\/hdu\/image.py:        # Due to problems discussed in #5808, we cannot assume the 'GROUPS'\nastropy\/io\/fits\/hdu\/image.py:        # Update the position of the EXTEND keyword if it already exists\nastropy\/io\/fits\/hdu\/image.py:        if 'EXTEND' in self._header:\nastropy\/io\/fits\/hdu\/image.py:            self._header.set('EXTEND', after=after)\nastropy\/io\/fits\/hdu\/image.py:        # The EXTEND keyword is only mandatory if the HDU has extensions; this\nastropy\/io\/fits\/hdu\/image.py:        # condition is checked by the HDUList object.  However, if we already\nastropy\/io\/fits\/hdu\/image.py:        # have an EXTEND keyword check that its position is correct\nastropy\/io\/fits\/hdu\/image.py:        if 'EXTEND' in self._header:\nastropy\/io\/fits\/hdu\/image.py:            self.req_cards('EXTEND', naxis + 3, lambda v: isinstance(v, bool),\nastropy\/io\/fits\/hdu\/image.py:class ImageHDU(_ImageBaseHDU, ExtensionHDU):\nastropy\/io\/fits\/hdu\/image.py:    FITS image extension HDU class.\nastropy\/io\/fits\/hdu\/image.py:        Construct an image HDU.\nastropy\/io\/fits\/hdu\/image.py:            The data in the HDU.\nastropy\/io\/fits\/hdu\/image.py:            The name of the HDU, will be the value of the keyword\nastropy\/io\/fits\/hdu\/image.py:            The ver of the HDU, will be the value of the keyword ``EXTVER``.\nastropy\/io\/fits\/hdu\/image.py:        ImageHDU verify method.\nastropy\/io\/fits\/hdu\/image.py:        # ExtensionHDU._verify, however ExtensionHDU._verify allows PCOUNT\nastropy\/visualization\/wcsaxes\/tests\/test_utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_utils.py:    assert coord_type_from_ctype('DEC-') == ('latitude', None)\nastropy\/visualization\/wcsaxes\/tests\/datasets.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/datasets.py:\"\"\"Downloads the FITS files that are used in image testing and for building documentation.\nastropy\/visualization\/wcsaxes\/tests\/datasets.py:    Download a FITS file to the cache and open HDU 0.\nastropy\/visualization\/wcsaxes\/tests\/datasets.py:    \"\"\"Fetch the MSX example dataset HDU.\nastropy\/visualization\/wcsaxes\/tests\/datasets.py:    hdu : `~astropy.io.fits.ImageHDU`\nastropy\/visualization\/wcsaxes\/tests\/datasets.py:        Image HDU\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:TARGET_HEADER = fits.Header.fromstring(\"\"\"\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:CDELT1  =                 -0.4\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:CTYPE2  = 'DEC--MOL'\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:CDELT2  =                  0.4\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:COORDSYS= 'icrs    '\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:    ax = plt.subplot(1, 1, 1, projection=WCS(TARGET_HEADER))\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:    ax = plt.subplot(1, 1, 1, projection=WCS(TARGET_HEADER))\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:    ax = plt.subplot(1, 1, 1, projection=WCS(TARGET_HEADER))\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:GAL_HEADER = fits.Header.fromstring(\"\"\"\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:EXTEND  =                    T\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:CTYPE1  = 'DISTMOD '\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:CDELT1  =                  0.5\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:CDELT2  =               -0.125\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:CDELT3  =                0.125\nastropy\/visualization\/wcsaxes\/tests\/test_misc.py:    wcs3d = WCS(GAL_HEADER)\nastropy\/visualization\/wcsaxes\/tests\/test_coordinate_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/coordinate_range.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_formatter_locator.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/hdu\/hdulist.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/hdulist.py:from .base import _BaseHDU, _ValidHDU, _NonstandardHDU, ExtensionHDU\nastropy\/io\/fits\/hdu\/hdulist.py:from .groups import GroupsHDU\nastropy\/io\/fits\/hdu\/hdulist.py:from .image import PrimaryHDU, ImageHDU\nastropy\/io\/fits\/hdu\/hdulist.py:    \"\"\"Factory function to open a FITS file and return an `HDUList` object.\nastropy\/io\/fits\/hdu\/hdulist.py:        By default `~astropy.io.fits.open` will not read all the HDUs and\nastropy\/io\/fits\/hdu\/hdulist.py:        of determining the number and offsets of all the HDUs in a file\nastropy\/io\/fits\/hdu\/hdulist.py:        To disable lazy loading and read all HDUs immediately (the old\nastropy\/io\/fits\/hdu\/hdulist.py:        order to determine the number of HDUs.  ``lazy_load_hdus=False``\nastropy\/io\/fits\/hdu\/hdulist.py:        ensures that all HDUs have already been loaded after the file has\nastropy\/io\/fits\/hdu\/hdulist.py:            Do not issue an exception when opening a file that is\nastropy\/io\/fits\/hdu\/hdulist.py:            missing an ``END`` card in the last header.\nastropy\/io\/fits\/hdu\/hdulist.py:            If `True`, verifies that both ``DATASUM`` and\nastropy\/io\/fits\/hdu\/hdulist.py:            ``CHECKSUM`` card values (when present in the HDU header)\nastropy\/io\/fits\/hdu\/hdulist.py:            match the header and data of all HDU's in the file.  Updates to a\nastropy\/io\/fits\/hdu\/hdulist.py:            'remove', in which case the CHECKSUM and DATASUM values are not\nastropy\/io\/fits\/hdu\/hdulist.py:            If `True`, treats compressed image HDU's like normal\nastropy\/io\/fits\/hdu\/hdulist.py:            binary table HDU's.\nastropy\/io\/fits\/hdu\/hdulist.py:        hdulist : an `HDUList` object\nastropy\/io\/fits\/hdu\/hdulist.py:            `HDUList` containing all of the header data units in the\nastropy\/io\/fits\/hdu\/hdulist.py:    return HDUList.fromfile(name, mode, memmap, save_backup, cache,\nastropy\/io\/fits\/hdu\/hdulist.py:class HDUList(list, _Verify):\nastropy\/io\/fits\/hdu\/hdulist.py:    HDU list class.  This is the top-level FITS object.  When a FITS\nastropy\/io\/fits\/hdu\/hdulist.py:    file is opened, a `HDUList` object is returned.\nastropy\/io\/fits\/hdu\/hdulist.py:        Construct a `HDUList` object.\nastropy\/io\/fits\/hdu\/hdulist.py:        hdus : sequence of HDU objects or single HDU, optional\nastropy\/io\/fits\/hdu\/hdulist.py:            The HDU object(s) to comprise the `HDUList`.  Should be\nastropy\/io\/fits\/hdu\/hdulist.py:            instances of HDU classes like `ImageHDU` or `BinTableHDU`.\nastropy\/io\/fits\/hdu\/hdulist.py:            The opened physical file associated with the `HDUList`\nastropy\/io\/fits\/hdu\/hdulist.py:        # HDUList.fromfile\/string when opening the file\nastropy\/io\/fits\/hdu\/hdulist.py:        # If we have read all the HDUs from the file or not\nastropy\/io\/fits\/hdu\/hdulist.py:        # The assumes that all HDUs have been written when we first opened the\nastropy\/io\/fits\/hdu\/hdulist.py:        # file; we do not currently support loading additional HDUs from a file\nastropy\/io\/fits\/hdu\/hdulist.py:        # existing HDUs.\nastropy\/io\/fits\/hdu\/hdulist.py:            # Should never attempt to read HDUs in ostream mode\nastropy\/io\/fits\/hdu\/hdulist.py:        # can take one HDU, as well as a list of HDU's as input\nastropy\/io\/fits\/hdu\/hdulist.py:        if isinstance(hdus, _ValidHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:        elif not isinstance(hdus, (HDUList, list)):\nastropy\/io\/fits\/hdu\/hdulist.py:            raise TypeError(\"Invalid input for HDUList.\")\nastropy\/io\/fits\/hdu\/hdulist.py:            if not isinstance(hdu, _BaseHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                raise TypeError(\"Element {} in the HDUList input is \"\nastropy\/io\/fits\/hdu\/hdulist.py:                                \"not an HDU.\".format(idx))\nastropy\/io\/fits\/hdu\/hdulist.py:            # Only do this when initializing from an existing list of HDUs\nastropy\/io\/fits\/hdu\/hdulist.py:            # append method after the first HDU is read\nastropy\/io\/fits\/hdu\/hdulist.py:        # In order to correctly repr an HDUList we need to load all the\nastropy\/io\/fits\/hdu\/hdulist.py:        # HDUs as well\nastropy\/io\/fits\/hdu\/hdulist.py:        Get an HDU from the `HDUList`, indexed by number or name.\nastropy\/io\/fits\/hdu\/hdulist.py:        # If the key is a slice we need to make sure the necessary HDUs\nastropy\/io\/fits\/hdu\/hdulist.py:                # We need all of the HDUs, so load them\nastropy\/io\/fits\/hdu\/hdulist.py:                # max_idx. Note we do not try to be clever about skipping HDUs\nastropy\/io\/fits\/hdu\/hdulist.py:                    raise IndexError('HDU not found, possibly because the index '\nastropy\/io\/fits\/hdu\/hdulist.py:                                     'closed before all HDUs were read')\nastropy\/io\/fits\/hdu\/hdulist.py:                return HDUList(hdus)\nastropy\/io\/fits\/hdu\/hdulist.py:        # Originally this used recursion, but hypothetically an HDU with\nastropy\/io\/fits\/hdu\/hdulist.py:        # a very large number of HDUs could blow the stack, so use a loop\nastropy\/io\/fits\/hdu\/hdulist.py:                raise IndexError('HDU not found, possibly because the index '\nastropy\/io\/fits\/hdu\/hdulist.py:                                 'closed before all HDUs were read')\nastropy\/io\/fits\/hdu\/hdulist.py:        Returns `True` if ``HDUList.index_of(item)`` succeeds.\nastropy\/io\/fits\/hdu\/hdulist.py:        Set an HDU to the `HDUList`, indexed by number or name.\nastropy\/io\/fits\/hdu\/hdulist.py:                raise ValueError('An element in the HDUList must be an HDU.')\nastropy\/io\/fits\/hdu\/hdulist.py:                if not isinstance(item, _BaseHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                    raise ValueError('{} is not an HDU.'.format(item))\nastropy\/io\/fits\/hdu\/hdulist.py:            if not isinstance(hdu, _BaseHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                raise ValueError('{} is not an HDU.'.format(hdu))\nastropy\/io\/fits\/hdu\/hdulist.py:        Delete an HDU from the `HDUList`, indexed by number or name.\nastropy\/io\/fits\/hdu\/hdulist.py:        Creates an `HDUList` instance from a file-like object.\nastropy\/io\/fits\/hdu\/hdulist.py:        Creates an `HDUList` instance from a string or other in-memory data\nastropy\/io\/fits\/hdu\/hdulist.py:        :meth:`HDUList.fromfile`, but does not accept the mode or memmap\nastropy\/io\/fits\/hdu\/hdulist.py:            string) the returned :class:`HDUList`'s data portions will also be\nastropy\/io\/fits\/hdu\/hdulist.py:        hdul : HDUList\nastropy\/io\/fits\/hdu\/hdulist.py:            An :class:`HDUList` object representing the in-memory FITS file.\nastropy\/io\/fits\/hdu\/hdulist.py:        of the indexed HDU within any associated file.  The values are\nastropy\/io\/fits\/hdu\/hdulist.py:        no intervening changes to the `HDUList`.\nastropy\/io\/fits\/hdu\/hdulist.py:            Index of HDU for which info is to be returned.\nastropy\/io\/fits\/hdu\/hdulist.py:            the indexed HDU within an associated file.  Returns `None`\nastropy\/io\/fits\/hdu\/hdulist.py:            when the HDU is not associated with a file.\nastropy\/io\/fits\/hdu\/hdulist.py:            Dictionary contents:\nastropy\/io\/fits\/hdu\/hdulist.py:            file       File object associated with the HDU\nastropy\/io\/fits\/hdu\/hdulist.py:            datSpan    Data size including padding\nastropy\/io\/fits\/hdu\/hdulist.py:                # OK, the HDU associated with this index is not yet\nastropy\/io\/fits\/hdu\/hdulist.py:                # tied to the file associated with the HDUList.  The only way\nastropy\/io\/fits\/hdu\/hdulist.py:                # to get the file object is to check each of the HDU's in the\nastropy\/io\/fits\/hdu\/hdulist.py:        Insert an HDU into the `HDUList` at the given ``index``.\nastropy\/io\/fits\/hdu\/hdulist.py:            Index before which to insert the new HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:        hdu : HDU object\nastropy\/io\/fits\/hdu\/hdulist.py:            The HDU object to insert\nastropy\/io\/fits\/hdu\/hdulist.py:        if not isinstance(hdu, _BaseHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:            raise ValueError('{} is not an HDU.'.format(hdu))\nastropy\/io\/fits\/hdu\/hdulist.py:                # We are inserting a new Primary HDU so we need to\nastropy\/io\/fits\/hdu\/hdulist.py:                # make the current Primary HDU into an extension HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:                if isinstance(self[0], GroupsHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                        \"The current Primary HDU is a GroupsHDU.  \"\nastropy\/io\/fits\/hdu\/hdulist.py:                        \"It can't be made into an extension HDU, \"\nastropy\/io\/fits\/hdu\/hdulist.py:                        \"so another HDU cannot be inserted before it.\")\nastropy\/io\/fits\/hdu\/hdulist.py:                hdu1 = ImageHDU(self[0].data, self[0].header)\nastropy\/io\/fits\/hdu\/hdulist.py:                # Insert it into position 1, then delete HDU at position 0.\nastropy\/io\/fits\/hdu\/hdulist.py:            if not isinstance(hdu, (PrimaryHDU, _NonstandardHDU)):\nastropy\/io\/fits\/hdu\/hdulist.py:                # You passed in an Extension HDU but we need a Primary HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:                # If you provided an ImageHDU then we can convert it to\nastropy\/io\/fits\/hdu\/hdulist.py:                # a primary HDU and use that.\nastropy\/io\/fits\/hdu\/hdulist.py:                if isinstance(hdu, ImageHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                    hdu = PrimaryHDU(hdu.data, hdu.header)\nastropy\/io\/fits\/hdu\/hdulist.py:                    # You didn't provide an ImageHDU so we create a\nastropy\/io\/fits\/hdu\/hdulist.py:                    # simple Primary HDU and append that first before\nastropy\/io\/fits\/hdu\/hdulist.py:                    # we append the new Extension HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:                    phdu = PrimaryHDU()\nastropy\/io\/fits\/hdu\/hdulist.py:            if isinstance(hdu, GroupsHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                raise ValueError('A GroupsHDU must be inserted as a '\nastropy\/io\/fits\/hdu\/hdulist.py:                                 'Primary HDU.')\nastropy\/io\/fits\/hdu\/hdulist.py:            if isinstance(hdu, PrimaryHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                # You passed a Primary HDU but we need an Extension HDU\nastropy\/io\/fits\/hdu\/hdulist.py:                # so create an Extension HDU from the input Primary HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:                hdu = ImageHDU(hdu.data, hdu.header)\nastropy\/io\/fits\/hdu\/hdulist.py:        # make sure the EXTEND keyword is in primary HDU if there is extension\nastropy\/io\/fits\/hdu\/hdulist.py:        Append a new HDU to the `HDUList`.\nastropy\/io\/fits\/hdu\/hdulist.py:        hdu : HDU object\nastropy\/io\/fits\/hdu\/hdulist.py:            HDU to add to the `HDUList`.\nastropy\/io\/fits\/hdu\/hdulist.py:        if not isinstance(hdu, _BaseHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:            raise ValueError('HDUList can only append an HDU.')\nastropy\/io\/fits\/hdu\/hdulist.py:            if isinstance(hdu, GroupsHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                    \"Can't append a GroupsHDU to a non-empty HDUList\")\nastropy\/io\/fits\/hdu\/hdulist.py:            if isinstance(hdu, PrimaryHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                # You passed a Primary HDU but we need an Extension HDU\nastropy\/io\/fits\/hdu\/hdulist.py:                # so create an Extension HDU from the input Primary HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:                # TODO: This isn't necessarily sufficient to copy the HDU;\nastropy\/io\/fits\/hdu\/hdulist.py:                hdu = ImageHDU(hdu.data, hdu.header)\nastropy\/io\/fits\/hdu\/hdulist.py:            if not isinstance(hdu, (PrimaryHDU, _NonstandardHDU)):\nastropy\/io\/fits\/hdu\/hdulist.py:                # You passed in an Extension HDU but we need a Primary\nastropy\/io\/fits\/hdu\/hdulist.py:                # HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:                # If you provided an ImageHDU then we can convert it to\nastropy\/io\/fits\/hdu\/hdulist.py:                # a primary HDU and use that.\nastropy\/io\/fits\/hdu\/hdulist.py:                if isinstance(hdu, ImageHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:                    hdu = PrimaryHDU(hdu.data, hdu.header)\nastropy\/io\/fits\/hdu\/hdulist.py:                    # You didn't provide an ImageHDU so we create a\nastropy\/io\/fits\/hdu\/hdulist.py:                    # simple Primary HDU and append that first before\nastropy\/io\/fits\/hdu\/hdulist.py:                    # we append the new Extension HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:                    phdu = PrimaryHDU()\nastropy\/io\/fits\/hdu\/hdulist.py:        # make sure the EXTEND keyword is in primary HDU if there is extension\nastropy\/io\/fits\/hdu\/hdulist.py:        Get the index of an HDU from the `HDUList`.\nastropy\/io\/fits\/hdu\/hdulist.py:           The key identifying the HDU.  If ``key`` is a tuple, it is of the\nastropy\/io\/fits\/hdu\/hdulist.py:           match the HDU being searched for.\nastropy\/io\/fits\/hdu\/hdulist.py:           the duplicate HDU.\nastropy\/io\/fits\/hdu\/hdulist.py:           The index of the HDU in the `HDUList`.\nastropy\/io\/fits\/hdu\/hdulist.py:            # 'PRIMARY' should always work as a reference to the first HDU\nastropy\/io\/fits\/hdu\/hdulist.py:        knowing the length of the HDUList, which in turn means loading\nastropy\/io\/fits\/hdu\/hdulist.py:        all HDUs.  Therefore using negative indices on HDULists is inherently\nastropy\/io\/fits\/hdu\/hdulist.py:        Read data of all HDUs into memory.\nastropy\/io\/fits\/hdu\/hdulist.py:        Force a write of the `HDUList` back to the file (for append and\nastropy\/io\/fits\/hdu\/hdulist.py:                # only append HDU's which are \"new\"\nastropy\/io\/fits\/hdu\/hdulist.py:                            print('append HDU', hdu.name, extver)\nastropy\/io\/fits\/hdu\/hdulist.py:        Make sure that if the primary header needs the keyword ``EXTEND`` that\nastropy\/io\/fits\/hdu\/hdulist.py:        if not isinstance(self[0], PrimaryHDU):\nastropy\/io\/fits\/hdu\/hdulist.py:            # A PrimaryHDU will be automatically inserted at some point, but it\nastropy\/io\/fits\/hdu\/hdulist.py:        if 'EXTEND' in hdr:\nastropy\/io\/fits\/hdu\/hdulist.py:            if not hdr['EXTEND'] and get_first_ext() is not None:\nastropy\/io\/fits\/hdu\/hdulist.py:                hdr['EXTEND'] = True\nastropy\/io\/fits\/hdu\/hdulist.py:                hdr.set('EXTEND', True, after='NAXIS')\nastropy\/io\/fits\/hdu\/hdulist.py:                hdr.set('EXTEND', True, after='NAXIS' + str(n))\nastropy\/io\/fits\/hdu\/hdulist.py:        Write the `HDUList` to a new file.\nastropy\/io\/fits\/hdu\/hdulist.py:            ``OSError`` if ``False`` and the output file exists. Default is\nastropy\/io\/fits\/hdu\/hdulist.py:            When `True` adds both ``DATASUM`` and ``CHECKSUM`` cards\nastropy\/io\/fits\/hdu\/hdulist.py:            to the headers of all HDU's written to the file.\nastropy\/io\/fits\/hdu\/hdulist.py:        # make sure the EXTEND keyword is there if there is extension\nastropy\/io\/fits\/hdu\/hdulist.py:            # Give individual HDUs an opportunity to do on-close cleanup\nastropy\/io\/fits\/hdu\/hdulist.py:        Summarize the info of the HDUs in this `HDUList`.\nastropy\/io\/fits\/hdu\/hdulist.py:            the HDU info.  Writes to ``sys.stdout`` by default.\nastropy\/io\/fits\/hdu\/hdulist.py:            name = '(No file associated with this HDUList)'\nastropy\/io\/fits\/hdu\/hdulist.py:                   'No.    Name      Ver    Type      Cards   Dimensions   Format']\nastropy\/io\/fits\/hdu\/hdulist.py:        Return the file name associated with the HDUList object if one exists.\nastropy\/io\/fits\/hdu\/hdulist.py:                   HDUList object if an association exists.  Otherwise returns\nastropy\/io\/fits\/hdu\/hdulist.py:        Provides the implementations from HDUList.fromfile and\nastropy\/io\/fits\/hdu\/hdulist.py:        HDUList.fromstring, both of which wrap this method, as their\nastropy\/io\/fits\/hdu\/hdulist.py:            # This method is currently only called from HDUList.fromstring and\nastropy\/io\/fits\/hdu\/hdulist.py:            # HDUList.fromfile.  If fileobj is None then this must be the\nastropy\/io\/fits\/hdu\/hdulist.py:            # _BaseHDU.fromstring call.\nastropy\/io\/fits\/hdu\/hdulist.py:            # the HDUs--just writing to the output file\nastropy\/io\/fits\/hdu\/hdulist.py:        # Make sure at least the PRIMARY HDU can be read\nastropy\/io\/fits\/hdu\/hdulist.py:            # Go ahead and load all HDUs\nastropy\/io\/fits\/hdu\/hdulist.py:        Attempt an operation that accesses an HDU by index\/name\nastropy\/io\/fits\/hdu\/hdulist.py:        that can fail if not all HDUs have been read yet.  Keep\nastropy\/io\/fits\/hdu\/hdulist.py:        reading HDUs until the operation succeeds or there are no\nastropy\/io\/fits\/hdu\/hdulist.py:        more HDUs to read.\nastropy\/io\/fits\/hdu\/hdulist.py:        Lazily load a single HDU from the fileobj or data string the `HDUList`\nastropy\/io\/fits\/hdu\/hdulist.py:        was opened from, unless no further HDUs are found.\nastropy\/io\/fits\/hdu\/hdulist.py:        Returns True if a new HDU was loaded, or False otherwise.\nastropy\/io\/fits\/hdu\/hdulist.py:        saved_compression_enabled = compressed.COMPRESSION_ENABLED\nastropy\/io\/fits\/hdu\/hdulist.py:                compressed.COMPRESSION_ENABLED = False\nastropy\/io\/fits\/hdu\/hdulist.py:            # read all HDUs\nastropy\/io\/fits\/hdu\/hdulist.py:                        # HDU\nastropy\/io\/fits\/hdu\/hdulist.py:                        hdu = _BaseHDU.readfrom(fileobj, **kwargs)\nastropy\/io\/fits\/hdu\/hdulist.py:                    hdu = _BaseHDU.fromstring(data, **kwargs)\nastropy\/io\/fits\/hdu\/hdulist.py:                    # Check for an extension HDU and update the EXTEND\nastropy\/io\/fits\/hdu\/hdulist.py:                    # keyword of the primary HDU accordingly\nastropy\/io\/fits\/hdu\/hdulist.py:            # check in the case there is extra space after the last HDU or\nastropy\/io\/fits\/hdu\/hdulist.py:            # corrupted HDU\nastropy\/io\/fits\/hdu\/hdulist.py:                    'Error validating header for HDU #{} (note: Astropy '\nastropy\/io\/fits\/hdu\/hdulist.py:                    'There may be extra bytes after the last HDU or the '\nastropy\/io\/fits\/hdu\/hdulist.py:            compressed.COMPRESSION_ENABLED = saved_compression_enabled\nastropy\/io\/fits\/hdu\/hdulist.py:        errs = _ErrList([], unit='HDU')\nastropy\/io\/fits\/hdu\/hdulist.py:        # the first (0th) element must be a primary HDU\nastropy\/io\/fits\/hdu\/hdulist.py:        if len(self) > 0 and (not isinstance(self[0], PrimaryHDU)) and \\\nastropy\/io\/fits\/hdu\/hdulist.py:                             (not isinstance(self[0], _NonstandardHDU)):\nastropy\/io\/fits\/hdu\/hdulist.py:            err_text = \"HDUList's 0th element is not a primary HDU.\"\nastropy\/io\/fits\/hdu\/hdulist.py:            fix_text = 'Fixed by inserting one as 0th HDU.'\nastropy\/io\/fits\/hdu\/hdulist.py:                self.insert(0, PrimaryHDU())\nastropy\/io\/fits\/hdu\/hdulist.py:        if len(self) > 1 and ('EXTEND' not in self[0].header or\nastropy\/io\/fits\/hdu\/hdulist.py:                              self[0].header['EXTEND'] is not True):\nastropy\/io\/fits\/hdu\/hdulist.py:            err_text = ('Primary HDU does not contain an EXTEND keyword '\nastropy\/io\/fits\/hdu\/hdulist.py:                        'equal to T even though there are extension HDUs.')\nastropy\/io\/fits\/hdu\/hdulist.py:            fix_text = 'Fixed by inserting or updating the EXTEND keyword.'\nastropy\/io\/fits\/hdu\/hdulist.py:                header.set('EXTEND', value=True, after=after)\nastropy\/io\/fits\/hdu\/hdulist.py:            if idx > 0 and (not isinstance(hdu, ExtensionHDU)):\nastropy\/io\/fits\/hdu\/hdulist.py:                err_text = (\"HDUList's element {} is not an \"\nastropy\/io\/fits\/hdu\/hdulist.py:                            \"extension HDU.\".format(str(idx)))\nastropy\/io\/fits\/hdu\/hdulist.py:            # Need to all _prewriteto() for each HDU first to determine if\nastropy\/io\/fits\/hdu\/hdulist.py:            # if the HDUList is resized, need to write out the entire contents of\nastropy\/io\/fits\/hdu\/hdulist.py:        Implements flushing changes in update mode when parts of one or more HDU\nastropy\/io\/fits\/hdu\/hdulist.py:            # The underlying file is an actual file object.  The HDUList is\nastropy\/io\/fits\/hdu\/hdulist.py:                # on each HDU\nastropy\/io\/fits\/hdu\/hdulist.py:        Determine if any changes to the HDUList will require a file resize\nastropy\/io\/fits\/hdu\/hdulist.py:            # determine if any of the HDU is resized\nastropy\/io\/fits\/hdu\/hdulist.py:                # Data:\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:from matplotlib.transforms import Affine2D\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS2D = WCS(naxis=2)\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS2D.wcs.ctype = ['x', 'y']\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS2D.wcs.cunit = ['km', 'km']\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS2D.wcs.crpix = [614.5, 856.5]\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS2D.wcs.cdelt = [6.25, 6.25]\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS2D.wcs.crval = [0., 0.]\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS3D = WCS(naxis=3)\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS3D.wcs.ctype = ['x', 'y', 'z']\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS3D.wcs.cunit = ['km', 'km', 'km']\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS3D.wcs.crpix = [614.5, 856.5, 333]\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS3D.wcs.cdelt = [6.25, 6.25, 23]\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:WCS3D.wcs.crval = [0., 0., 1.]\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:# We add Affine2D to catch the fact that in Matplotlib, having a Composite\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:    w1 = WCSWorld2PixelTransform(WCS2D) + Affine2D()\nastropy\/visualization\/wcsaxes\/tests\/test_transforms.py:    w1 = WCSWorld2PixelTransform(WCS3D, slice=('y', 0, 'x')) + Affine2D()\nastropy\/io\/fits\/hdu\/streaming.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/streaming.py:from .base import _BaseHDU, BITPIX2DTYPE\nastropy\/io\/fits\/hdu\/streaming.py:from .hdulist import HDUList\nastropy\/io\/fits\/hdu\/streaming.py:from .image import PrimaryHDU\nastropy\/io\/fits\/hdu\/streaming.py:class StreamingHDU:\nastropy\/io\/fits\/hdu\/streaming.py:        shdu = astropy.io.fits.StreamingHDU('filename.fits', header)\nastropy\/io\/fits\/hdu\/streaming.py:        Construct a `StreamingHDU` object given a file name and a header.\nastropy\/io\/fits\/hdu\/streaming.py:        header, a default Primary HDU will be inserted at the\nastropy\/io\/fits\/hdu\/streaming.py:            raise TypeError('StreamingHDU not supported for GzipFile objects.')\nastropy\/io\/fits\/hdu\/streaming.py:        # to prepend a default PrimaryHDU to the file before writing the\nastropy\/io\/fits\/hdu\/streaming.py:                hdulist = HDUList([PrimaryHDU()])\nastropy\/io\/fits\/hdu\/streaming.py:        # TODO : Fix this once the HDU writing API is cleaned up\nastropy\/io\/fits\/hdu\/streaming.py:        tmp_hdu = _BaseHDU()\nastropy\/io\/fits\/hdu\/streaming.py:        # Passing self._header as an argument to _BaseHDU() will cause its\nastropy\/io\/fits\/hdu\/streaming.py:            Data to stream to the file.\nastropy\/io\/fits\/hdu\/streaming.py:        if BITPIX2DTYPE[self._header['BITPIX']] != data.dtype.name:\nastropy\/io\/fits\/hdu\/streaming.py:        Return the size (in bytes) of the data portion of the HDU.\nastropy\/visualization\/wcsaxes\/coordinates_map.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/coordinates_map.py:        choose which dimensions are being shown in the 2D image. The slice\nastropy\/visualization\/wcsaxes\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:from ....tests.image_tests import IMAGE_REFERENCE_DIR\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:class DistanceToLonLat(CurvedTransform):\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:        return LonLatToDistance(R=self.R)\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:class LonLatToDistance(CurvedTransform):\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:        return DistanceToLonLat(R=self.R)\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR, filename='coords_overlay.png', tolerance=1.5)\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:        s = DistanceToLonLat(R=6378.273)\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR, filename='coords_overlay_auto_coord_meta.png', tolerance=1.5)\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR, filename='direct_init.png', tolerance=1.5)\nastropy\/visualization\/wcsaxes\/tests\/test_transform_coord_meta.py:        s = DistanceToLonLat(R=6378.273)\nastropy\/visualization\/wcsaxes\/ticks.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/ticks.py:from matplotlib.lines import Path, Line2D\nastropy\/visualization\/wcsaxes\/ticks.py:from matplotlib.transforms import Affine2D\nastropy\/visualization\/wcsaxes\/ticks.py:class Ticks(Line2D):\nastropy\/visualization\/wcsaxes\/ticks.py:    Ticks are derived from Line2D, and note that ticks themselves\nastropy\/visualization\/wcsaxes\/ticks.py:        Line2D.__init__(self, [0.], [0.], **line2d_kwargs)\nastropy\/visualization\/wcsaxes\/ticks.py:        Draw the ticks.\nastropy\/visualization\/wcsaxes\/ticks.py:        Draw the minor ticks.\nastropy\/visualization\/wcsaxes\/ticks.py:        marker_scale = Affine2D().scale(offset, offset)\nastropy\/visualization\/wcsaxes\/ticks.py:        marker_rotation = Affine2D()\nastropy\/visualization\/wcsaxes\/ticks.py:                # Draw the markers\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:from matplotlib.transforms import Affine2D, ScaledTranslation\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        self.dpi_transform = Affine2D()\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        self.ticks = Ticks(transform=parent_axes.transData + self.offset_transform)\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        # Matplotlib's gridlines use Line2D, but ours use PathPatch.\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:                                  'transform': self.parent_axes.transData}\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        # TODO: this method should be optimized for speed\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        transData = self.parent_axes.transData\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        invertedTransLimits = transData.inverted()\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:            # Determine tick rotation in display coordinates and compare to\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:            axes0 = transData.transform(pixel0)\nastropy\/visualization\/wcsaxes\/coordinate_helpers.py:        Display minor ticks for this coordinate.\nastropy\/convolution\/tests\/test_convolve_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_convolve_models.py:class TestConvolve1DModels:\nastropy\/convolution\/tests\/test_convolve_models.py:        kernel = models.Gaussian1D(1, 0, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        model = models.Gaussian1D(1, 0, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        kernel = models.Gaussian1D(1, 0, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        model = models.Gaussian1D(1, 0, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        kernel = models.Gaussian1D(1, 0, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        model = models.Gaussian1D(1, 0, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        kernel = models.Gaussian1D(1 \/ math.sqrt(2 * np.pi), 1, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        model = models.Gaussian1D(1 \/ math.sqrt(2 * np.pi), 3, 1)\nastropy\/convolution\/tests\/test_convolve_models.py:        ans = models.Gaussian1D(1 \/ (2 * math.sqrt(np.pi)), 4, np.sqrt(2))\nastropy\/convolution\/tests\/test_convolve_models.py:        kernel = models.Box1D()\nastropy\/convolution\/tests\/test_convolve_models.py:        model = models.Box1D()\nastropy\/convolution\/tests\/test_convolve_models.py:        b1 = models.Box1D()\nastropy\/convolution\/tests\/test_convolve_models.py:        g1 = models.Gaussian1D()\nastropy\/convolution\/tests\/test_convolve_models.py:        fake_model = models.Gaussian1D(amplitude=10)\nastropy\/visualization\/wcsaxes\/patches.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/patches.py:    # Determine rotation matrix to make it so that the circle is centered\nastropy\/visualization\/wcsaxes\/patches.py:    # Apply 3D rotation\nastropy\/convolution\/tests\/test_convolve_fft.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_convolve_fft.py:VALID_DTYPES = []\nastropy\/convolution\/tests\/test_convolve_fft.py:        VALID_DTYPES.append((dtype_array, dtype_kernel))\nastropy\/convolution\/tests\/test_convolve_fft.py:BOUNDARY_OPTIONS = [None, 'fill', 'wrap']\nastropy\/convolution\/tests\/test_convolve_fft.py:options = list(itertools.product(BOUNDARY_OPTIONS,\nastropy\/convolution\/tests\/test_convolve_fft.py:class TestConvolve1D:\nastropy\/convolution\/tests\/test_convolve_fft.py:    options_unity1withnan = list(itertools.product(BOUNDARY_OPTIONS,\nastropy\/convolution\/tests\/test_convolve_fft.py:class TestConvolve2D:\nastropy\/convolution\/tests\/test_convolve_fft.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/io\/fits\/hdu\/compressed.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/compressed.py:from .base import DELAYED, ExtensionHDU, BITPIX2DTYPE, DTYPE2BITPIX\nastropy\/io\/fits\/hdu\/compressed.py:from .image import ImageHDU\nastropy\/io\/fits\/hdu\/compressed.py:from .table import BinTableHDU\nastropy\/io\/fits\/hdu\/compressed.py:from ..column import Column, ColDefs, TDEF_RE\nastropy\/io\/fits\/hdu\/compressed.py:from ..column import KEYWORD_NAMES as TABLE_KEYWORD_NAMES\nastropy\/io\/fits\/hdu\/compressed.py:from ....utils.exceptions import (AstropyPendingDeprecationWarning,\nastropy\/io\/fits\/hdu\/compressed.py:    COMPRESSION_SUPPORTED = COMPRESSION_ENABLED = True\nastropy\/io\/fits\/hdu\/compressed.py:    COMPRESSION_SUPPORTED = COMPRESSION_ENABLED = False\nastropy\/io\/fits\/hdu\/compressed.py:NO_DITHER = -1\nastropy\/io\/fits\/hdu\/compressed.py:SUBTRACTIVE_DITHER_1 = 1\nastropy\/io\/fits\/hdu\/compressed.py:SUBTRACTIVE_DITHER_2 = 2\nastropy\/io\/fits\/hdu\/compressed.py:QUANTIZE_METHOD_NAMES = {\nastropy\/io\/fits\/hdu\/compressed.py:    NO_DITHER: 'NO_DITHER',\nastropy\/io\/fits\/hdu\/compressed.py:    SUBTRACTIVE_DITHER_1: 'SUBTRACTIVE_DITHER_1',\nastropy\/io\/fits\/hdu\/compressed.py:    SUBTRACTIVE_DITHER_2: 'SUBTRACTIVE_DITHER_2'\nastropy\/io\/fits\/hdu\/compressed.py:DITHER_SEED_CLOCK = 0\nastropy\/io\/fits\/hdu\/compressed.py:DITHER_SEED_CHECKSUM = -1\nastropy\/io\/fits\/hdu\/compressed.py:# Default compression parameter values\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_COMPRESSION_TYPE = 'RICE_1'\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_QUANTIZE_LEVEL = 16.\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_QUANTIZE_METHOD = NO_DITHER\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_DITHER_SEED = DITHER_SEED_CLOCK\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_HCOMP_SCALE = 0\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_HCOMP_SMOOTH = 0\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_BLOCK_SIZE = 32\nastropy\/io\/fits\/hdu\/compressed.py:DEFAULT_BYTE_PIX = 4\nastropy\/io\/fits\/hdu\/compressed.py:if COMPRESSION_SUPPORTED:\nastropy\/io\/fits\/hdu\/compressed.py:        CFITSIO_SUPPORTS_GZIPDATA = compression.CFITSIO_VERSION >= 3.28\nastropy\/io\/fits\/hdu\/compressed.py:        CFITSIO_SUPPORTS_GZIPDATA = True\nastropy\/io\/fits\/hdu\/compressed.py:COMPRESSION_KEYWORDS = {'ZIMAGE', 'ZCMPTYPE', 'ZBITPIX', 'ZNAXIS', 'ZMASKCMP',\nastropy\/io\/fits\/hdu\/compressed.py:                        'ZSIMPLE', 'ZTENSION', 'ZEXTEND'}\nastropy\/io\/fits\/hdu\/compressed.py:    Header object for compressed image HDUs designed to keep the compression\nastropy\/io\/fits\/hdu\/compressed.py:    # TODO: The difficulty of implementing this screams a need to rewrite this\nastropy\/io\/fits\/hdu\/compressed.py:        'NAXIS': 'ZNAXIS', 'EXTEND': 'ZEXTEND', 'BLOCKED': 'ZBLOCKED',\nastropy\/io\/fits\/hdu\/compressed.py:        'DATASUM': 'ZDATASUM'\nastropy\/io\/fits\/hdu\/compressed.py:        ['ZIMAGE', 'ZCMPTYPE', 'ZMASKCMP', 'ZQUANTIZ', 'ZDITHER0'])\nastropy\/io\/fits\/hdu\/compressed.py:    # TODO: Once it place it should be possible to manage some of this through\nastropy\/io\/fits\/hdu\/compressed.py:    # makes more sense to change CompImageHDU to subclass ImageHDU :\/\nastropy\/io\/fits\/hdu\/compressed.py:            # Determine condition to pass through to append\nastropy\/io\/fits\/hdu\/compressed.py:        if keyword == 'TFIELDS':\nastropy\/io\/fits\/hdu\/compressed.py:        m = TDEF_RE.match(keyword)\nastropy\/io\/fits\/hdu\/compressed.py:        if m and m.group('label').upper() in TABLE_KEYWORD_NAMES:\nastropy\/io\/fits\/hdu\/compressed.py:        # the name used for it in the COMPRESSED HDU header\nastropy\/io\/fits\/hdu\/compressed.py:# TODO: Fix this class so that it doesn't actually inherit from BinTableHDU,\nastropy\/io\/fits\/hdu\/compressed.py:# but instead has an internal BinTableHDU reference\nastropy\/io\/fits\/hdu\/compressed.py:class CompImageHDU(BinTableHDU):\nastropy\/io\/fits\/hdu\/compressed.py:    Compressed Image HDU class.\nastropy\/io\/fits\/hdu\/compressed.py:    DEPRECATED_KWARGS = {\nastropy\/io\/fits\/hdu\/compressed.py:                 compression_type=DEFAULT_COMPRESSION_TYPE,\nastropy\/io\/fits\/hdu\/compressed.py:                 hcomp_scale=DEFAULT_HCOMP_SCALE,\nastropy\/io\/fits\/hdu\/compressed.py:                 hcomp_smooth=DEFAULT_HCOMP_SMOOTH,\nastropy\/io\/fits\/hdu\/compressed.py:                 quantize_level=DEFAULT_QUANTIZE_LEVEL,\nastropy\/io\/fits\/hdu\/compressed.py:                 quantize_method=DEFAULT_QUANTIZE_METHOD,\nastropy\/io\/fits\/hdu\/compressed.py:                 dither_seed=DEFAULT_DITHER_SEED,\nastropy\/io\/fits\/hdu\/compressed.py:            Header to be associated with the image; when reading the HDU from a\nastropy\/io\/fits\/hdu\/compressed.py:            file (data=DELAYED), the header read from the file\nastropy\/io\/fits\/hdu\/compressed.py:            input image header then the default name ``COMPRESSED_IMAGE`` is\nastropy\/io\/fits\/hdu\/compressed.py:            Compression tile sizes.  Default treats each row of image as a\nastropy\/io\/fits\/hdu\/compressed.py:            ``NO_DITHER`` (-1), ``SUBTRACTIVE_DITHER_1`` (1; default), or\nastropy\/io\/fits\/hdu\/compressed.py:            ``SUBTRACTIVE_DITHER_2`` (2); see note below\nastropy\/io\/fits\/hdu\/compressed.py:            range 1 to 1000 (inclusive), ``DITHER_SEED_CLOCK`` (0; default), or\nastropy\/io\/fits\/hdu\/compressed.py:            ``DITHER_SEED_CHECKSUM`` (-1); see note below\nastropy\/io\/fits\/hdu\/compressed.py:               the ``_File`` class, not in the `CompImageHDU` class.  The file\nastropy\/io\/fits\/hdu\/compressed.py:            2) The `CompImageHDU` class supports the FITS tiled image\nastropy\/io\/fits\/hdu\/compressed.py:        ``SUBTRACTIVE_DITHER_1`` adds dithering to the zero-point of the\nastropy\/io\/fits\/hdu\/compressed.py:        pixel (see below).  The other method, ``SUBTRACTIVE_DITHER_2``, is\nastropy\/io\/fits\/hdu\/compressed.py:        ``NO_DITHER`` disables dithering entirely.\nastropy\/io\/fits\/hdu\/compressed.py:        ``ZDITHER0`` keyword in the header of the compressed HDU.  In order to\nastropy\/io\/fits\/hdu\/compressed.py:        (``DITHER_SEED_CLOCK``) or based on a checksum of the pixels in the\nastropy\/io\/fits\/hdu\/compressed.py:        image's first tile (``DITHER_SEED_CHECKSUM``).  The clock-based method\nastropy\/io\/fits\/hdu\/compressed.py:        if not COMPRESSION_SUPPORTED:\nastropy\/io\/fits\/hdu\/compressed.py:            # TODO: Raise a more specific Exception type\nastropy\/io\/fits\/hdu\/compressed.py:                            'available.  Creation of compressed image HDUs is '\nastropy\/io\/fits\/hdu\/compressed.py:        for oldarg, newarg in self.DEPRECATED_KWARGS.items():\nastropy\/io\/fits\/hdu\/compressed.py:                              AstropyPendingDeprecationWarning)\nastropy\/io\/fits\/hdu\/compressed.py:        if data is DELAYED:\nastropy\/io\/fits\/hdu\/compressed.py:            # Reading the HDU from a file\nastropy\/io\/fits\/hdu\/compressed.py:            # Create at least a skeleton HDU that matches the input\nastropy\/io\/fits\/hdu\/compressed.py:        # TODO: A lot of this should be passed on to an internal image HDU o\nastropy\/io\/fits\/hdu\/compressed.py:        if xtension not in ('BINTABLE', 'A3DTABLE'):\nastropy\/io\/fits\/hdu\/compressed.py:        if COMPRESSION_SUPPORTED and COMPRESSION_ENABLED:\nastropy\/io\/fits\/hdu\/compressed.py:        elif not COMPRESSION_SUPPORTED:\nastropy\/io\/fits\/hdu\/compressed.py:                          'HDU: The compression module is not available.\\n'\nastropy\/io\/fits\/hdu\/compressed.py:                          'The HDU will be treated as a Binary Table HDU.',\nastropy\/io\/fits\/hdu\/compressed.py:        call this method after assigning new data to the `CompImageHDU`\nastropy\/io\/fits\/hdu\/compressed.py:            input image header then the default name 'COMPRESSED_IMAGE' is used\nastropy\/io\/fits\/hdu\/compressed.py:            NO_DITHER (-1), SUBTRACTIVE_DITHER_1 (1; default), or\nastropy\/io\/fits\/hdu\/compressed.py:            SUBTRACTIVE_DITHER_2 (2)\nastropy\/io\/fits\/hdu\/compressed.py:            range 1 to 1000 (inclusive), DITHER_SEED_CLOCK (0; default), or\nastropy\/io\/fits\/hdu\/compressed.py:            DITHER_SEED_CHECKSUM (-1)\nastropy\/io\/fits\/hdu\/compressed.py:        image_hdu = ImageHDU(data=self.data, header=self._header)\nastropy\/io\/fits\/hdu\/compressed.py:        # Determine based on the size of the input data whether to use the Q\nastropy\/io\/fits\/hdu\/compressed.py:            name = 'COMPRESSED_IMAGE'\nastropy\/io\/fits\/hdu\/compressed.py:                             after='TFIELDS')\nastropy\/io\/fits\/hdu\/compressed.py:                    'Default ({}) compression will be used.'\nastropy\/io\/fits\/hdu\/compressed.py:                            DEFAULT_COMPRESSION_TYPE),\nastropy\/io\/fits\/hdu\/compressed.py:                compression_type = DEFAULT_COMPRESSION_TYPE\nastropy\/io\/fits\/hdu\/compressed.py:                             'compression algorithm', after='TFIELDS')\nastropy\/io\/fits\/hdu\/compressed.py:                                                DEFAULT_COMPRESSION_TYPE)\nastropy\/io\/fits\/hdu\/compressed.py:        self._header.set('TTYPE1', 'COMPRESSED_DATA', 'label for field 1',\nastropy\/io\/fits\/hdu\/compressed.py:                         after='TFIELDS')\nastropy\/io\/fits\/hdu\/compressed.py:            # floating point image has 'COMPRESSED_DATA',\nastropy\/io\/fits\/hdu\/compressed.py:            # 'UNCOMPRESSED_DATA', 'ZSCALE', and 'ZZERO' columns (unless using\nastropy\/io\/fits\/hdu\/compressed.py:            # CFITSIO 3.28 and up automatically use the GZIP_COMPRESSED_DATA\nastropy\/io\/fits\/hdu\/compressed.py:            # of the UNCOMPRESSED_DATA column.  There's no way to control\nastropy\/io\/fits\/hdu\/compressed.py:            if CFITSIO_SUPPORTS_GZIPDATA:\nastropy\/io\/fits\/hdu\/compressed.py:                ttype2 = 'GZIP_COMPRESSED_DATA'\nastropy\/io\/fits\/hdu\/compressed.py:                # The required format for the GZIP_COMPRESSED_DATA is actually\nastropy\/io\/fits\/hdu\/compressed.py:                # Q format is not supported for UNCOMPRESSED_DATA columns.\nastropy\/io\/fits\/hdu\/compressed.py:                ttype2 = 'UNCOMPRESSED_DATA'\nastropy\/io\/fits\/hdu\/compressed.py:                    tform2 = '1QD' if huge_hdu else '1PD'\nastropy\/io\/fits\/hdu\/compressed.py:            self._header.set('TFORM3', '1D',\nastropy\/io\/fits\/hdu\/compressed.py:                             'data format of field: 8-byte DOUBLE',\nastropy\/io\/fits\/hdu\/compressed.py:            self._header.set('TFORM4', '1D',\nastropy\/io\/fits\/hdu\/compressed.py:                             'data format of field: 8-byte DOUBLE',\nastropy\/io\/fits\/hdu\/compressed.py:            # Create the ColDefs object for the table\nastropy\/io\/fits\/hdu\/compressed.py:            cols = ColDefs([col1, col2, col3, col4])\nastropy\/io\/fits\/hdu\/compressed.py:            # default table has just one 'COMPRESSED_DATA' column\nastropy\/io\/fits\/hdu\/compressed.py:            # Create the ColDefs object for the table\nastropy\/io\/fits\/hdu\/compressed.py:            cols = ColDefs([col1])\nastropy\/io\/fits\/hdu\/compressed.py:        # image HDU, the data type of the image data and the number of\nastropy\/io\/fits\/hdu\/compressed.py:        self._header.set('TFIELDS', ncols, 'number of fields in each row',\nastropy\/io\/fits\/hdu\/compressed.py:        # size to match the HDU's data.\nastropy\/io\/fits\/hdu\/compressed.py:                          'Default tile size will be used.', AstropyUserWarning)\nastropy\/io\/fits\/hdu\/compressed.py:                # The Hcompress algorithm is inherently 2D in nature, so the\nastropy\/io\/fits\/hdu\/compressed.py:                    # Default tile size\nastropy\/io\/fits\/hdu\/compressed.py:            quantize_level = DEFAULT_QUANTIZE_LEVEL\nastropy\/io\/fits\/hdu\/compressed.py:            hcomp_scale = DEFAULT_HCOMP_SCALE\nastropy\/io\/fits\/hdu\/compressed.py:            hcomp_smooth = DEFAULT_HCOMP_SCALE\nastropy\/io\/fits\/hdu\/compressed.py:            self._header.set('ZVAL1', DEFAULT_BLOCK_SIZE, 'pixels per block',\nastropy\/io\/fits\/hdu\/compressed.py:                bytepix = DEFAULT_BYTE_PIX\nastropy\/io\/fits\/hdu\/compressed.py:                if quantize_method not in [NO_DITHER, SUBTRACTIVE_DITHER_1,\nastropy\/io\/fits\/hdu\/compressed.py:                                           SUBTRACTIVE_DITHER_2]:\nastropy\/io\/fits\/hdu\/compressed.py:                    name = QUANTIZE_METHOD_NAMES[DEFAULT_QUANTIZE_METHOD]\nastropy\/io\/fits\/hdu\/compressed.py:                                  'Default method ({}) used.'.format(name))\nastropy\/io\/fits\/hdu\/compressed.py:                    quantize_method = DEFAULT_QUANTIZE_METHOD\nastropy\/io\/fits\/hdu\/compressed.py:                if quantize_method == NO_DITHER:\nastropy\/io\/fits\/hdu\/compressed.py:                                 QUANTIZE_METHOD_NAMES[quantize_method],\nastropy\/io\/fits\/hdu\/compressed.py:                # no dithering, rather than whatever DEFAULT_QUANTIZE_METHOD\nastropy\/io\/fits\/hdu\/compressed.py:                quantize_method = self._header.get('ZQUANTIZ', NO_DITHER)\nastropy\/io\/fits\/hdu\/compressed.py:                    for k, v in QUANTIZE_METHOD_NAMES.items():\nastropy\/io\/fits\/hdu\/compressed.py:                        quantize_method = NO_DITHER\nastropy\/io\/fits\/hdu\/compressed.py:            if quantize_method == NO_DITHER:\nastropy\/io\/fits\/hdu\/compressed.py:                if 'ZDITHER0' in self._header:\nastropy\/io\/fits\/hdu\/compressed.py:                    # keep the ZDITHER0 keyword\nastropy\/io\/fits\/hdu\/compressed.py:                    del self._header['ZDITHER0']\nastropy\/io\/fits\/hdu\/compressed.py:                elif 'ZDITHER0' in self._header:\nastropy\/io\/fits\/hdu\/compressed.py:                    dither_seed = self._header['ZDITHER0']\nastropy\/io\/fits\/hdu\/compressed.py:                            DEFAULT_DITHER_SEED)\nastropy\/io\/fits\/hdu\/compressed.py:                self._header.set('ZDITHER0', dither_seed,\nastropy\/io\/fits\/hdu\/compressed.py:            # Move EXTEND card from the image header to the\nastropy\/io\/fits\/hdu\/compressed.py:            # table header as ZEXTEND card.\nastropy\/io\/fits\/hdu\/compressed.py:            if 'EXTEND' in image_header:\nastropy\/io\/fits\/hdu\/compressed.py:                self._header.set('ZEXTEND', image_header['EXTEND'],\nastropy\/io\/fits\/hdu\/compressed.py:                                 image_header.comments['EXTEND'])\nastropy\/io\/fits\/hdu\/compressed.py:            # Move BLOCKED card from the image header to the\nastropy\/io\/fits\/hdu\/compressed.py:            # table header as ZBLOCKED card.\nastropy\/io\/fits\/hdu\/compressed.py:            if 'BLOCKED' in image_header:\nastropy\/io\/fits\/hdu\/compressed.py:                self._header.set('ZBLOCKED', image_header['BLOCKED'],\nastropy\/io\/fits\/hdu\/compressed.py:                                 image_header.comments['BLOCKED'])\nastropy\/io\/fits\/hdu\/compressed.py:            # Move CHECKSUM and DATASUM cards from the image header to the\nastropy\/io\/fits\/hdu\/compressed.py:            # table header as XHECKSUM and XDATASUM cards.\nastropy\/io\/fits\/hdu\/compressed.py:            if 'DATASUM' in image_header:\nastropy\/io\/fits\/hdu\/compressed.py:                self._header.set('ZDATASUM', image_header['DATASUM'],\nastropy\/io\/fits\/hdu\/compressed.py:                                 image_header.comments['DATASUM'])\nastropy\/io\/fits\/hdu\/compressed.py:        # Right out of _ImageBaseHDU.data\nastropy\/io\/fits\/hdu\/compressed.py:            raise TypeError('CompImageHDU data has incorrect type:{}; '\nastropy\/io\/fits\/hdu\/compressed.py:        # Deleting the compressed_data attribute has to be handled\nastropy\/io\/fits\/hdu\/compressed.py:        # Determine from the values read from the header\nastropy\/io\/fits\/hdu\/compressed.py:        # Delete cards that are related to the table.  And move\nastropy\/io\/fits\/hdu\/compressed.py:        # Delete any other spurious NAXISn keywords:\nastropy\/io\/fits\/hdu\/compressed.py:        # Although PCOUNT and GCOUNT are considered mandatory for IMAGE HDUs,\nastropy\/io\/fits\/hdu\/compressed.py:        # ZPCOUNT and ZGCOUNT are optional, probably because for IMAGE HDUs\nastropy\/io\/fits\/hdu\/compressed.py:        if 'ZEXTEND' in self._header:\nastropy\/io\/fits\/hdu\/compressed.py:            image_header.set('EXTEND', self._header['ZEXTEND'],\nastropy\/io\/fits\/hdu\/compressed.py:                             self._header.comments['ZEXTEND'])\nastropy\/io\/fits\/hdu\/compressed.py:        if 'ZBLOCKED' in self._header:\nastropy\/io\/fits\/hdu\/compressed.py:            image_header.set('BLOCKED', self._header['ZBLOCKED'],\nastropy\/io\/fits\/hdu\/compressed.py:                             self._header.comments['ZBLOCKED'])\nastropy\/io\/fits\/hdu\/compressed.py:        # Move the ZHECKSUM and ZDATASUM cards to the image header\nastropy\/io\/fits\/hdu\/compressed.py:        # as CHECKSUM and DATASUM\nastropy\/io\/fits\/hdu\/compressed.py:        if 'ZDATASUM' in self._header:\nastropy\/io\/fits\/hdu\/compressed.py:            image_header.set('DATASUM', self._header['ZDATASUM'],\nastropy\/io\/fits\/hdu\/compressed.py:                             self._header.comments['ZDATASUM'])\nastropy\/io\/fits\/hdu\/compressed.py:        # is the default value of COMPRESSED_IMAGE.\nastropy\/io\/fits\/hdu\/compressed.py:                self._header['EXTNAME'] == 'COMPRESSED_IMAGE'):\nastropy\/io\/fits\/hdu\/compressed.py:        Summarize the HDU: name, dimensions, and formats.\nastropy\/io\/fits\/hdu\/compressed.py:            _format = BITPIX2DTYPE[self.header['BITPIX']]\nastropy\/io\/fits\/hdu\/compressed.py:        image_bitpix = DTYPE2BITPIX[self.data.dtype.name]\nastropy\/io\/fits\/hdu\/compressed.py:        # TODO: This is copied right out of _ImageBaseHDU._writedata_internal;\nastropy\/io\/fits\/hdu\/compressed.py:        # it would be cool if we could use an internal ImageHDU and use that to\nastropy\/io\/fits\/hdu\/compressed.py:        # Determine the destination (numpy) data type\nastropy\/io\/fits\/hdu\/compressed.py:            type = BITPIX2DTYPE[self._bitpix]\nastropy\/io\/fits\/hdu\/compressed.py:        # Determine how to scale the data\nastropy\/io\/fits\/hdu\/compressed.py:        # Do the scaling\nastropy\/io\/fits\/hdu\/compressed.py:            # Delete from both headers\nastropy\/io\/fits\/hdu\/compressed.py:        self._bitpix = DTYPE2BITPIX[self.data.dtype.name]\nastropy\/io\/fits\/hdu\/compressed.py:        # TODO: Make this more clear by using self._image_header, but only once\nastropy\/io\/fits\/hdu\/compressed.py:            self.scale(BITPIX2DTYPE[self._orig_bitpix])\nastropy\/io\/fits\/hdu\/compressed.py:            # Shove the image header and data into a new ImageHDU and use that\nastropy\/io\/fits\/hdu\/compressed.py:            image_hdu = ImageHDU(data=self.data, header=self.header)\nastropy\/io\/fits\/hdu\/compressed.py:                # ZDATASUM keyword\nastropy\/io\/fits\/hdu\/compressed.py:            if 'DATASUM' in image_hdu.header:\nastropy\/io\/fits\/hdu\/compressed.py:                self._image_header.set('DATASUM', image_hdu.header['DATASUM'],\nastropy\/io\/fits\/hdu\/compressed.py:                                       image_hdu.header.comments['DATASUM'])\nastropy\/io\/fits\/hdu\/compressed.py:            # the .data attribute on the HDU so that the call to _writedata\nastropy\/io\/fits\/hdu\/compressed.py:        Bypasses `BinTableHDU._writeheader()` which updates the header with\nastropy\/io\/fits\/hdu\/compressed.py:        why this class maybe shouldn't inherit directly from BinTableHDU...\nastropy\/io\/fits\/hdu\/compressed.py:        return ExtensionHDU._writeheader(self, fileobj)\nastropy\/io\/fits\/hdu\/compressed.py:    # TODO: This was copied right out of _ImageBaseHDU; get rid of it once we\nastropy\/io\/fits\/hdu\/compressed.py:    # ImageHDU\nastropy\/io\/fits\/hdu\/compressed.py:        Determine the dtype that the data should be converted to depending on\nastropy\/io\/fits\/hdu\/compressed.py:                self.header['BITPIX'] = DTYPE2BITPIX[dtype.name]\nastropy\/io\/fits\/hdu\/compressed.py:        if seed == DITHER_SEED_CHECKSUM:\nastropy\/io\/fits\/hdu\/compressed.py:            # Determine the tile dimensions from the ZTILEn keywords\nastropy\/io\/fits\/hdu\/compressed.py:        elif seed == DITHER_SEED_CLOCK:\nastropy\/io\/fits\/hdu\/compressed.py:            # is that CFITSIO incorporates the HDU number into the result in\nastropy\/io\/fits\/hdu\/compressed.py:            # generated for two HDUs at the same time.  Here instead we just\nastropy\/io\/fits\/hdu\/compressed.py:            # add in the HDU object's id\nastropy\/convolution\/tests\/test_convolve_nddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_convolve_nddata.py:from ..kernels import Gaussian2DKernel\nastropy\/convolution\/tests\/test_convolve_nddata.py:from ...nddata import NDData\nastropy\/convolution\/tests\/test_convolve_nddata.py:    ndd = NDData(arr)\nastropy\/convolution\/tests\/test_convolve_nddata.py:    test_kernel = Gaussian2DKernel(1)\nastropy\/convolution\/tests\/test_convolve_nddata.py:    ndd_base = NDData(arr)\nastropy\/convolution\/tests\/test_convolve_nddata.py:    ndd_mask = NDData(arr, mask=mask)\nastropy\/convolution\/tests\/test_convolve_nddata.py:    ndd_nan = NDData(arrnan)\nastropy\/convolution\/tests\/test_convolve_nddata.py:    test_kernel = Gaussian2DKernel(1)\nastropy\/io\/fits\/fitstime.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/fitstime.py:from collections import defaultdict, OrderedDict\nastropy\/io\/fits\/fitstime.py:from ...time import Time, TimeDelta\nastropy\/io\/fits\/fitstime.py:from ...time.formats import FITS_DEPRECATED_SCALES\nastropy\/io\/fits\/fitstime.py:TIME_KEYWORDS = ('TIMESYS', 'MJDREF', 'JDREF', 'DATEREF',\nastropy\/io\/fits\/fitstime.py:                 'TREFPOS', 'TREFDIR', 'TIMEUNIT', 'TIMEOFFS',\nastropy\/io\/fits\/fitstime.py:                 'OBSGEO-L', 'OBSGEO-B', 'OBSGEO-H', 'DATE',\nastropy\/io\/fits\/fitstime.py:                 'DATE-OBS', 'DATE-AVG', 'DATE-BEG', 'DATE-END',\nastropy\/io\/fits\/fitstime.py:                 'MJD-OBS', 'MJD-AVG', 'MJD-BEG', 'MJD-END')\nastropy\/io\/fits\/fitstime.py:COLUMN_TIME_KEYWORDS = ('TCTYP', 'TCUNI', 'TRPOS')\nastropy\/io\/fits\/fitstime.py:COLUMN_TIME_KEYWORD_REGEXP = '({0})[0-9]+'.format(\nastropy\/io\/fits\/fitstime.py:    '|'.join(COLUMN_TIME_KEYWORDS))\nastropy\/io\/fits\/fitstime.py:    return re.match(COLUMN_TIME_KEYWORD_REGEXP, keyword) is not None\nastropy\/io\/fits\/fitstime.py:GLOBAL_TIME_INFO = {'TIMESYS': ('UTC', 'Default time scale'),\nastropy\/io\/fits\/fitstime.py:                    'JDREF': (0.0, 'Time columns are jd = jd1 + jd2'),\nastropy\/io\/fits\/fitstime.py:    global_info['scale'] = FITS_DEPRECATED_SCALES.get(global_info['TIMESYS'],\nastropy\/io\/fits\/fitstime.py:            # Default scale 'UTC'\nastropy\/io\/fits\/fitstime.py:    for key, format_ in (('MJDREF', 'mjd'), ('JDREF', 'jd'), ('DATEREF', 'fits')):\nastropy\/io\/fits\/fitstime.py:        # If none of the three keywords is present, MJDREF = 0.0 must be assumed\nastropy\/io\/fits\/fitstime.py:        elif scale in FITS_DEPRECATED_SCALES.keys():\nastropy\/io\/fits\/fitstime.py:            column_info['scale'] = FITS_DEPRECATED_SCALES[scale]\nastropy\/io\/fits\/fitstime.py:        # FITS uses a subset of ISO-8601 for DATE-xxx\nastropy\/io\/fits\/fitstime.py:        if key.startswith('DATE'):\nastropy\/io\/fits\/fitstime.py:                scale = 'utc' if key == 'DATE' else global_info['scale']\nastropy\/io\/fits\/fitstime.py:        # MJD-xxx in MJD according to TIMESYS\nastropy\/io\/fits\/fitstime.py:        elif key.startswith('MJD-'):\nastropy\/io\/fits\/fitstime.py:            # [+\/-C]CCYY-MM-DD[Thh:mm:ss[.s...]] where the number of characters\nastropy\/io\/fits\/fitstime.py:        # If reference value is 0 for JD or MJD, the column values can be\nastropy\/io\/fits\/fitstime.py:            delta_time = TimeDelta(col[..., 0], col[..., 1])\nastropy\/io\/fits\/fitstime.py:            delta_time = TimeDelta(col)\nastropy\/io\/fits\/fitstime.py:    time_columns = defaultdict(OrderedDict)\nastropy\/io\/fits\/fitstime.py:        if key in TIME_KEYWORDS:\nastropy\/io\/fits\/fitstime.py:    jd = jd1 + jd2 represents time in the Julian Date format with\nastropy\/io\/fits\/fitstime.py:    newtable.meta['__coordinate_columns__'] = defaultdict(OrderedDict)\nastropy\/io\/fits\/hdu\/table.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/table.py:from .base import DELAYED, _ValidHDU, ExtensionHDU\nastropy\/io\/fits\/hdu\/table.py:from ..column import (FITS2NUMPY, KEYWORD_NAMES, KEYWORD_TO_ATTRIBUTE,\nastropy\/io\/fits\/hdu\/table.py:                      ATTRIBUTE_TO_KEYWORD, TDEF_RE, Column, ColDefs,\nastropy\/io\/fits\/hdu\/table.py:                      _AsciiColDefs, _FormatP, _FormatQ, _makep,\nastropy\/io\/fits\/hdu\/table.py:class FITSTableDumpDialect(csv.excel):\nastropy\/io\/fits\/hdu\/table.py:class _TableLikeHDU(_ValidHDU):\nastropy\/io\/fits\/hdu\/table.py:    A class for HDUs that have table-like data.  This is used for both\nastropy\/io\/fits\/hdu\/table.py:    Binary\/ASCII tables as well as Random Access Group HDUs (which are\nastropy\/io\/fits\/hdu\/table.py:    otherwise too dissimilar for tables to use _TableBaseHDU directly).\nastropy\/io\/fits\/hdu\/table.py:    _columns_type = ColDefs\nastropy\/io\/fits\/hdu\/table.py:    # TODO: Temporary flag representing whether uints are enabled; remove this\nastropy\/io\/fits\/hdu\/table.py:        This is an abstract HDU type for HDUs that contain table-like data.\nastropy\/io\/fits\/hdu\/table.py:        This is even more abstract than _TableBaseHDU which is specifically for\nastropy\/io\/fits\/hdu\/table.py:        Given either a `ColDefs` object, a sequence of `Column` objects,\nastropy\/io\/fits\/hdu\/table.py:        or another table HDU or table data (a `FITS_rec` or multi-field\nastropy\/io\/fits\/hdu\/table.py:        `numpy.ndarray` or `numpy.recarray` object, return a new table HDU of\nastropy\/io\/fits\/hdu\/table.py:        columns : sequence of `Column`, `ColDefs`, or other\nastropy\/io\/fits\/hdu\/table.py:            a column-like structure from which a `ColDefs` can be instantiated.\nastropy\/io\/fits\/hdu\/table.py:            This includes an existing `BinTableHDU` or `TableHDU`, or a\nastropy\/io\/fits\/hdu\/table.py:            An optional `Header` object to instantiate the new HDU yet.  Header\nastropy\/io\/fits\/hdu\/table.py:            HDU. By default this is `False` and (unicode) strings are returned,\nastropy\/io\/fits\/hdu\/table.py:        Any additional keyword arguments accepted by the HDU class's\nastropy\/io\/fits\/hdu\/table.py:        The :class:`ColDefs` objects describing the columns in this table.\nastropy\/io\/fits\/hdu\/table.py:        # definitions come from, so just return an empty ColDefs\nastropy\/io\/fits\/hdu\/table.py:        return ColDefs([])\nastropy\/io\/fits\/hdu\/table.py:        Table-like HDUs must provide an attribute that specifies the number of\nastropy\/io\/fits\/hdu\/table.py:        rows in the HDU's table.\nastropy\/io\/fits\/hdu\/table.py:        \"\"\"Get the table data from an input HDU object.\"\"\"\nastropy\/io\/fits\/hdu\/table.py:        # TODO: Details related to variable length arrays need to be dealt with\nastropy\/io\/fits\/hdu\/table.py:        # specifically in the BinTableHDU class, since they're a detail\nastropy\/io\/fits\/hdu\/table.py:                # This can happen when a brand new table HDU is being created\nastropy\/io\/fits\/hdu\/table.py:        Update the data upon addition of a new column through the `ColDefs`\nastropy\/io\/fits\/hdu\/table.py:        # TODO: It's not clear that this actually works--it probably does not.\nastropy\/io\/fits\/hdu\/table.py:        Update the data upon removal of a column through the `ColDefs`\nastropy\/io\/fits\/hdu\/table.py:class _TableBaseHDU(ExtensionHDU, _TableLikeHDU):\nastropy\/io\/fits\/hdu\/table.py:    FITS table extension base HDU class.\nastropy\/io\/fits\/hdu\/table.py:        Data to be used.\nastropy\/io\/fits\/hdu\/table.py:        The ver of the HDU, will be the value of the keyword ``EXTVER``.\nastropy\/io\/fits\/hdu\/table.py:    This is included primarily as an optimization for compressed image HDUs\nastropy\/io\/fits\/hdu\/table.py:        if data is DELAYED:\nastropy\/io\/fits\/hdu\/table.py:                raise ValueError('No header to setup HDU.')\nastropy\/io\/fits\/hdu\/table.py:                ('TFIELDS', 0, 'number of table fields')]\nastropy\/io\/fits\/hdu\/table.py:                    # TODO: I need to read this code a little more closely\nastropy\/io\/fits\/hdu\/table.py:                # TODO: Too much of the code in this class uses header keywords\nastropy\/io\/fits\/hdu\/table.py:                self._header['TFIELDS'] = len(self.data._coldefs)\nastropy\/io\/fits\/hdu\/table.py:                    # Make the ndarrays in the Column objects of the ColDefs\nastropy\/io\/fits\/hdu\/table.py:                    # object of the HDU reference the same ndarray as the HDU's\nastropy\/io\/fits\/hdu\/table.py:                    # Delete the _arrays attribute so that it is recreated to\nastropy\/io\/fits\/hdu\/table.py:        the ASCII and Binary Table HDU types, which should be used instead of\nastropy\/io\/fits\/hdu\/table.py:        The :class:`ColDefs` objects describing the columns in this table.\nastropy\/io\/fits\/hdu\/table.py:                # Make the ndarrays in the Column objects of the ColDefs\nastropy\/io\/fits\/hdu\/table.py:                # object of the HDU reference the same ndarray as the HDU's\nastropy\/io\/fits\/hdu\/table.py:                # Delete the _arrays attribute so that it is recreated to\nastropy\/io\/fits\/hdu\/table.py:    # TODO: Need to either rename this to update_header, for symmetry with the\nastropy\/io\/fits\/hdu\/table.py:    # Image HDUs, or just at some point deprecate it and remove it altogether,\nastropy\/io\/fits\/hdu\/table.py:        self._header.set('TFIELDS', len(self.columns), after='GCOUNT')\nastropy\/io\/fits\/hdu\/table.py:        Make a copy of the table HDU, both header and data are copied.\nastropy\/io\/fits\/hdu\/table.py:            # check TFIELDS and NAXIS2\nastropy\/io\/fits\/hdu\/table.py:            self._header['TFIELDS'] = len(self.data._coldefs)\nastropy\/io\/fits\/hdu\/table.py:        _TableBaseHDU verify method.\nastropy\/io\/fits\/hdu\/table.py:        self.req_cards('TFIELDS', 7,\nastropy\/io\/fits\/hdu\/table.py:        tfields = self._header['TFIELDS']\nastropy\/io\/fits\/hdu\/table.py:        Summarize the HDU: name, dimensions, and formats.\nastropy\/io\/fits\/hdu\/table.py:            ncols = self._header['TFIELDS']\nastropy\/io\/fits\/hdu\/table.py:        # base_keyword is the keyword without the index such as TDIM\nastropy\/io\/fits\/hdu\/table.py:        # while keyword is like TDIM1\nastropy\/io\/fits\/hdu\/table.py:        base_keyword = ATTRIBUTE_TO_KEYWORD[attr]\nastropy\/io\/fits\/hdu\/table.py:            keyword_idx = KEYWORD_NAMES.index(base_keyword)\nastropy\/io\/fits\/hdu\/table.py:            # Determine the appropriate keyword to insert this one before\/after\nastropy\/io\/fits\/hdu\/table.py:            for before_keyword in reversed(KEYWORD_NAMES[:keyword_idx]):\nastropy\/io\/fits\/hdu\/table.py:                for after_keyword in KEYWORD_NAMES[keyword_idx + 1:]:\nastropy\/io\/fits\/hdu\/table.py:            match = TDEF_RE.match(keyword)\nastropy\/io\/fits\/hdu\/table.py:            if base_keyword in KEYWORD_TO_ATTRIBUTE:\nastropy\/io\/fits\/hdu\/table.py:            # Also decrement TFIELDS\nastropy\/io\/fits\/hdu\/table.py:            if 'TFIELDS' in self._header:\nastropy\/io\/fits\/hdu\/table.py:                self._header['TFIELDS'] -= 1\nastropy\/io\/fits\/hdu\/table.py:            for keyword, attr in KEYWORD_TO_ATTRIBUTE.items():\nastropy\/io\/fits\/hdu\/table.py:class TableHDU(_TableBaseHDU):\nastropy\/io\/fits\/hdu\/table.py:    FITS ASCII table extension HDU class.\nastropy\/io\/fits\/hdu\/table.py:        Data to be used.\nastropy\/io\/fits\/hdu\/table.py:        The ver of the HDU, will be the value of the keyword ``EXTVER``.\nastropy\/io\/fits\/hdu\/table.py:    _columns_type = _AsciiColDefs\nastropy\/io\/fits\/hdu\/table.py:        r'(?P<code>[ADEFIJ])(?P<width>\\d+)(?:\\.(?P<prec>\\d+))?')\nastropy\/io\/fits\/hdu\/table.py:            raise ValueError(\"Duplicate field names: {}\".format(dup))\nastropy\/io\/fits\/hdu\/table.py:        # TODO: Determine if this extra logic is necessary--I feel like the\nastropy\/io\/fits\/hdu\/table.py:        # _AsciiColDefs class should be responsible for telling the table what\nastropy\/io\/fits\/hdu\/table.py:        Calculate the value for the ``DATASUM`` card in the HDU.\nastropy\/io\/fits\/hdu\/table.py:        `TableHDU` verify method.\nastropy\/io\/fits\/hdu\/table.py:        tfields = self._header['TFIELDS']\nastropy\/io\/fits\/hdu\/table.py:class BinTableHDU(_TableBaseHDU):\nastropy\/io\/fits\/hdu\/table.py:    Binary table HDU class.\nastropy\/io\/fits\/hdu\/table.py:        Data to be used.\nastropy\/io\/fits\/hdu\/table.py:        The ver of the HDU, will be the value of the keyword ``EXTVER``.\nastropy\/io\/fits\/hdu\/table.py:                xtension in (cls._extension, 'A3DTABLE'))\nastropy\/io\/fits\/hdu\/table.py:        Calculate the value for the ``DATASUM`` card given the input data\nastropy\/io\/fits\/hdu\/table.py:            # TODO: The following code may no longer be necessary since it is\nastropy\/io\/fits\/hdu\/table.py:        Calculate the value for the ``DATASUM`` card in the HDU.\nastropy\/io\/fits\/hdu\/table.py:          (``TDISPn``).  The fourth field provides the physical units\nastropy\/io\/fits\/hdu\/table.py:          multidimensional array (``TDIMn``).  The sixth field provides the\nastropy\/io\/fits\/hdu\/table.py:          definition of a single HDU header card as represented by the card\nastropy\/io\/fits\/hdu\/table.py:        Dump the table HDU to a file in ASCII format.  The table may be dumped\nastropy\/io\/fits\/hdu\/table.py:            fits file associated with this HDU appended with the\nastropy\/io\/fits\/hdu\/table.py:            ``OSError`` if ``False`` and the output file exists. Default is\nastropy\/io\/fits\/hdu\/table.py:            the creation of the new table and HDU.  Otherwise this Header\nastropy\/io\/fits\/hdu\/table.py:            coldefs = ColDefs(data)\nastropy\/io\/fits\/hdu\/table.py:        # Create a new HDU using the supplied header and data\nastropy\/io\/fits\/hdu\/table.py:        Write the table data in the ASCII format read by BinTableHDU.load()\nastropy\/io\/fits\/hdu\/table.py:        linewriter = csv.writer(fileobj, dialect=FITSTableDumpDialect)\nastropy\/io\/fits\/hdu\/table.py:        BinTableHDU.load() to fileobj.\nastropy\/io\/fits\/hdu\/table.py:        Read the table data from the ASCII file output by BinTableHDU.dump().\nastropy\/io\/fits\/hdu\/table.py:        linereader = csv.reader(fileobj, dialect=FITSTableDumpDialect)\nastropy\/io\/fits\/hdu\/table.py:        # TODO: The handling of VLAs could probably be simplified a bit\nastropy\/io\/fits\/hdu\/table.py:        # TODO: In the future maybe enable loading a bit at a time so that we\nastropy\/io\/fits\/hdu\/table.py:        hdu = BinTableHDU.from_columns(np.recarray(shape=1, dtype=dtype),\nastropy\/io\/fits\/hdu\/table.py:        # TODO: It seems to me a lot of this could\/should be handled from\nastropy\/io\/fits\/hdu\/table.py:        linereader = csv.reader(fileobj, dialect=FITSTableDumpDialect)\nastropy\/io\/fits\/hdu\/table.py:        BinTableHDU.dump().\nastropy\/io\/fits\/hdu\/table.py:        return ColDefs(columns)\nastropy\/convolution\/tests\/test_convolve.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_convolve.py:VALID_DTYPES = []\nastropy\/convolution\/tests\/test_convolve.py:        VALID_DTYPES.append((dtype_array, dtype_kernel))\nastropy\/convolution\/tests\/test_convolve.py:BOUNDARY_OPTIONS = [None, 'fill', 'wrap', 'extend']\nastropy\/convolution\/tests\/test_convolve.py:NANHANDLING_OPTIONS = ['interpolate', 'fill']\nastropy\/convolution\/tests\/test_convolve.py:BOUNDARIES_AND_CONVOLUTIONS = (list(zip(itertools.cycle((convolve,)),\nastropy\/convolution\/tests\/test_convolve.py:                                        BOUNDARY_OPTIONS)) + [(convolve_fft,\nastropy\/convolution\/tests\/test_convolve.py:class TestConvolve1D:\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('dtype_array', 'dtype_kernel'), VALID_DTYPES)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('convfunc', 'boundary',), BOUNDARIES_AND_CONVOLUTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:                             itertools.product(BOUNDARY_OPTIONS,\nastropy\/convolution\/tests\/test_convolve.py:                                               NANHANDLING_OPTIONS,\nastropy\/convolution\/tests\/test_convolve.py:                             itertools.product(BOUNDARY_OPTIONS,\nastropy\/convolution\/tests\/test_convolve.py:                                               NANHANDLING_OPTIONS,\nastropy\/convolution\/tests\/test_convolve.py:class TestConvolve2D:\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('dtype_array', 'dtype_kernel'), VALID_DTYPES)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    def test_non_normalized_kernel_2D(self, boundary):\nastropy\/convolution\/tests\/test_convolve.py:class TestConvolve3D:\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('dtype_array', 'dtype_kernel'), VALID_DTYPES)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:                             itertools.product(BOUNDARY_OPTIONS,\nastropy\/convolution\/tests\/test_convolve.py:                                               NANHANDLING_OPTIONS))\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:    @pytest.mark.parametrize(('boundary'), BOUNDARY_OPTIONS)\nastropy\/convolution\/tests\/test_convolve.py:@pytest.mark.parametrize(('convfunc', 'boundary'), BOUNDARIES_AND_CONVOLUTIONS)\nastropy\/visualization\/wcsaxes\/axislabels.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/grid_paths.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/grid_paths.py:ROUND_TRIP_TOL = 1e-1\nastropy\/visualization\/wcsaxes\/grid_paths.py:DISCONT_FACTOR = 10.\nastropy\/visualization\/wcsaxes\/grid_paths.py:    Draw a curve, taking into account discontinuities.\nastropy\/visualization\/wcsaxes\/grid_paths.py:        mask = np.abs(sep > ROUND_TRIP_TOL)\nastropy\/visualization\/wcsaxes\/grid_paths.py:    # discontinuous = step > DISCONT_FACTOR * np.median(step)\nastropy\/visualization\/wcsaxes\/grid_paths.py:    discontinuous = step[1:] > DISCONT_FACTOR * step[:-1]\nastropy\/visualization\/wcsaxes\/grid_paths.py:    if step[0] > DISCONT_FACTOR * step[1]:\nastropy\/visualization\/wcsaxes\/grid_paths.py:    Draw a grid line\nastropy\/io\/fits\/hdu\/base.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/hdu\/base.py:class _Delayed:\nastropy\/io\/fits\/hdu\/base.py:DELAYED = _Delayed()\nastropy\/io\/fits\/hdu\/base.py:BITPIX2DTYPE = {8: 'uint8', 16: 'int16', 32: 'int32', 64: 'int64',\nastropy\/io\/fits\/hdu\/base.py:DTYPE2BITPIX = {'uint8': 8, 'int16': 16, 'uint16': 16, 'int32': 32,\nastropy\/io\/fits\/hdu\/base.py:class InvalidHDUException(Exception):\nastropy\/io\/fits\/hdu\/base.py:    A custom exception class used mainly to signal to _BaseHDU.__new__ that\nastropy\/io\/fits\/hdu\/base.py:    an HDU cannot possibly be considered valid, and must be assumed to be\nastropy\/io\/fits\/hdu\/base.py:    Used primarily by _BaseHDU.__new__ to find an appropriate HDU class to use\nastropy\/io\/fits\/hdu\/base.py:    based on values in the header.  See the _BaseHDU.__new__ docstring.\nastropy\/io\/fits\/hdu\/base.py:                # HDU classes built into astropy.io.fits are always considered,\nastropy\/io\/fits\/hdu\/base.py:                # but extension HDUs must be explicitly registered\nastropy\/io\/fits\/hdu\/base.py:                    'An exception occurred matching an HDU header to the '\nastropy\/io\/fits\/hdu\/base.py:                    'appropriate HDU type: {0}'.format(exc),\nastropy\/io\/fits\/hdu\/base.py:                warnings.warn('The HDU will be treated as corrupted.',\nastropy\/io\/fits\/hdu\/base.py:                klass = _CorruptedHDU\nastropy\/io\/fits\/hdu\/base.py:class _BaseHDUMeta(type):\nastropy\/io\/fits\/hdu\/base.py:        # data.deleter to all HDUs with a data property.\nastropy\/io\/fits\/hdu\/base.py:                # Don't do anything if the class has already explicitly\nastropy\/io\/fits\/hdu\/base.py:                        # Don't even do this unless the *only* reference to the\nastropy\/io\/fits\/hdu\/base.py:# TODO: Come up with a better __repr__ for HDUs (and for HDULists, for that\nastropy\/io\/fits\/hdu\/base.py:class _BaseHDU(metaclass=_BaseHDUMeta):\nastropy\/io\/fits\/hdu\/base.py:    \"\"\"Base class for all HDU (header data unit) classes.\"\"\"\nastropy\/io\/fits\/hdu\/base.py:    # This HDU type is part of the FITS standard\nastropy\/io\/fits\/hdu\/base.py:        Iterates through the subclasses of _BaseHDU and uses that class's\nastropy\/io\/fits\/hdu\/base.py:        depth-last order.  Each match_header() should identify an HDU type as\nastropy\/io\/fits\/hdu\/base.py:        match_header(), the type is taken to be _CorruptedHDU.\nastropy\/io\/fits\/hdu\/base.py:        # still points to the same data array as when the HDU was originally\nastropy\/io\/fits\/hdu\/base.py:        if 'DATASUM' in self._header and 'CHECKSUM' not in self._header:\nastropy\/io\/fits\/hdu\/base.py:        return ('data' in self.__dict__ and self.data is not DELAYED)\nastropy\/io\/fits\/hdu\/base.py:        Creates a new HDU object of the appropriate type from a string\nastropy\/io\/fits\/hdu\/base.py:        containing the HDU's entire header and, optionally, its data.\nastropy\/io\/fits\/hdu\/base.py:        Note: When creating a new HDU from a string without a backing file\nastropy\/io\/fits\/hdu\/base.py:        object, the data of that HDU may be read-only.  It depends on whether\nastropy\/io\/fits\/hdu\/base.py:           A byte string containing the HDU's header and data.\nastropy\/io\/fits\/hdu\/base.py:           Check the HDU's checksum and\/or datasum.\nastropy\/io\/fits\/hdu\/base.py:           corrupt HDU.  In this case the assumption is that the first 2880\nastropy\/io\/fits\/hdu\/base.py:           May consist of additional keyword arguments specific to an HDU\nastropy\/io\/fits\/hdu\/base.py:           different HDU classes such as `PrimaryHDU`, `ImageHDU`, or\nastropy\/io\/fits\/hdu\/base.py:           `BinTableHDU`.  Any unrecognized keyword arguments are simply\nastropy\/io\/fits\/hdu\/base.py:        Read the HDU from a file.  Normally an HDU should be opened with\nastropy\/io\/fits\/hdu\/base.py:        :func:`open` which reads the entire HDU list in a FITS file.  But this\nastropy\/io\/fits\/hdu\/base.py:            beginning of the HDU.\nastropy\/io\/fits\/hdu\/base.py:            If `True`, verifies that both ``DATASUM`` and ``CHECKSUM`` card\nastropy\/io\/fits\/hdu\/base.py:            values (when present in the HDU header) match the header and data\nastropy\/io\/fits\/hdu\/base.py:            of all HDU's in the file.\nastropy\/io\/fits\/hdu\/base.py:            Do not issue an exception when opening a file that is missing an\nastropy\/io\/fits\/hdu\/base.py:            ``END`` card in the last header.\nastropy\/io\/fits\/hdu\/base.py:        # TODO: Figure out a way to make it possible for the _File\nastropy\/io\/fits\/hdu\/base.py:        Write the HDU to a new file. This is a convenience method to\nastropy\/io\/fits\/hdu\/base.py:        provide a user easier output interface if only one HDU needs\nastropy\/io\/fits\/hdu\/base.py:            ``OSError`` if ``False`` and the output file exists. Default is\nastropy\/io\/fits\/hdu\/base.py:            When `True` adds both ``DATASUM`` and ``CHECKSUM`` cards\nastropy\/io\/fits\/hdu\/base.py:            to the header of the HDU when written to the file.\nastropy\/io\/fits\/hdu\/base.py:        from .hdulist import HDUList\nastropy\/io\/fits\/hdu\/base.py:        hdulist = HDUList([self])\nastropy\/io\/fits\/hdu\/base.py:        # Determine the appropriate arguments to pass to the constructor from\nastropy\/io\/fits\/hdu\/base.py:        # that may or may not be valid depending on the HDU type\nastropy\/io\/fits\/hdu\/base.py:        if Parameter.VAR_KEYWORD not in (x.kind for x in sig.parameters.values()):\nastropy\/io\/fits\/hdu\/base.py:        hdu = cls(data=DELAYED, header=header, **new_kwargs)\nastropy\/io\/fits\/hdu\/base.py:        # Checksums are not checked on invalid HDU types\nastropy\/io\/fits\/hdu\/base.py:        if checksum and checksum != 'remove' and isinstance(hdu, _ValidHDU):\nastropy\/io\/fits\/hdu\/base.py:        Return raw array from either the HDU's memory buffer or underlying\nastropy\/io\/fits\/hdu\/base.py:    # TODO: Rework checksum handling so that it's not necessary to add a\nastropy\/io\/fits\/hdu\/base.py:    # TODO: The BaseHDU class shouldn't even handle checksums since they're\nastropy\/io\/fits\/hdu\/base.py:    # only implemented on _ValidHDU...\nastropy\/io\/fits\/hdu\/base.py:            # CompImageHDUs need TFIELDS immediately after GCOUNT,\nastropy\/io\/fits\/hdu\/base.py:            # so BSCALE has to go after TFIELDS if it exists.\nastropy\/io\/fits\/hdu\/base.py:            if 'TFIELDS' in self._header:\nastropy\/io\/fits\/hdu\/base.py:                self._header.set('BSCALE', 1, after='TFIELDS')\nastropy\/io\/fits\/hdu\/base.py:                         datasum_keyword='DATASUM'):\nastropy\/io\/fits\/hdu\/base.py:        \"\"\"Update the 'CHECKSUM' and 'DATASUM' keywords in the header (or\nastropy\/io\/fits\/hdu\/base.py:        and ``datasum_keyword`` arguments--see for example ``CompImageHDU``\nastropy\/io\/fits\/hdu\/base.py:                               'DATASUM' not in self._header or\nastropy\/io\/fits\/hdu\/base.py:        # TODO: A lot of the simulateonly stuff should be moved back into the\nastropy\/io\/fits\/hdu\/base.py:                # TODO: Not that this is ever likely, but if for some odd\nastropy\/io\/fits\/hdu\/base.py:        HDU types, so that should be implemented in this method.\nastropy\/io\/fits\/hdu\/base.py:    # TODO: This is the start of moving HDU writing out of the _File class;\nastropy\/io\/fits\/hdu\/base.py:    # HDUList, eventually the plan is to have this be moved into writeto()\nastropy\/io\/fits\/hdu\/base.py:            # Set the various data location attributes on newly-written HDUs\nastropy\/io\/fits\/hdu\/base.py:            # different from before depending on if previous HDUs were resized\nastropy\/io\/fits\/hdu\/base.py:_AllHDU = _BaseHDU\nastropy\/io\/fits\/hdu\/base.py:# TODO: register_hdu could be made into a class decorator which would be pretty\nastropy\/io\/fits\/hdu\/base.py:register_hdu = _BaseHDU.register_hdu\nastropy\/io\/fits\/hdu\/base.py:unregister_hdu = _BaseHDU.unregister_hdu\nastropy\/io\/fits\/hdu\/base.py:class _CorruptedHDU(_BaseHDU):\nastropy\/io\/fits\/hdu\/base.py:    A Corrupted HDU class.\nastropy\/io\/fits\/hdu\/base.py:    ``END`` cards.  A corrupted HDU usually means that the data size\nastropy\/io\/fits\/hdu\/base.py:    cannot be calculated or the ``END`` card is not found.  In the case\nastropy\/io\/fits\/hdu\/base.py:    of a missing ``END`` card, the `Header` may also contain the binary\nastropy\/io\/fits\/hdu\/base.py:       extension is a `TableHDU` containing ASCII data.\nastropy\/io\/fits\/hdu\/base.py:        Returns the size (in bytes) of the HDU's data part.\nastropy\/io\/fits\/hdu\/base.py:        return (self.name, self.ver, 'CorruptedHDU')\nastropy\/io\/fits\/hdu\/base.py:class _NonstandardHDU(_BaseHDU, _Verify):\nastropy\/io\/fits\/hdu\/base.py:    A Non-standard HDU class.\nastropy\/io\/fits\/hdu\/base.py:    This class is used for a Primary HDU when the ``SIMPLE`` Card has\nastropy\/io\/fits\/hdu\/base.py:    a value of `False`.  A non-standard HDU comes from a file that\nastropy\/io\/fits\/hdu\/base.py:    in the DEC VAX internal storage format rather than the standard\nastropy\/io\/fits\/hdu\/base.py:    FITS most significant byte first.  The header for this HDU should\nastropy\/io\/fits\/hdu\/base.py:    be valid.  The data for this HDU is read from the file as a byte\nastropy\/io\/fits\/hdu\/base.py:    stream that begins at the first byte after the header ``END`` card\nastropy\/io\/fits\/hdu\/base.py:        Matches any HDU that has the 'SIMPLE' keyword but is not a standard\nastropy\/io\/fits\/hdu\/base.py:        Primary or Groups HDU.\nastropy\/io\/fits\/hdu\/base.py:        # match_header for GroupsHDU will always be called before this one.\nastropy\/io\/fits\/hdu\/base.py:                raise InvalidHDUException\nastropy\/io\/fits\/hdu\/base.py:        Returns the size (in bytes) of the HDU's data part.\nastropy\/io\/fits\/hdu\/base.py:        Differs from the base class :class:`_writedata` in that it doesn't\nastropy\/io\/fits\/hdu\/base.py:        return (self.name, self.ver, 'NonstandardHDU', len(self._header))\nastropy\/io\/fits\/hdu\/base.py:class _ValidHDU(_BaseHDU, _Verify):\nastropy\/io\/fits\/hdu\/base.py:    Base class for all HDUs which are not corrupted.\nastropy\/io\/fits\/hdu\/base.py:        Matches any HDU that is not recognized as having either the SIMPLE or\nastropy\/io\/fits\/hdu\/base.py:        TODO: Maybe it would make more sense to use _NonstandardHDU in this\nastropy\/io\/fits\/hdu\/base.py:        Size (in bytes) of the data portion of the HDU.\nastropy\/io\/fits\/hdu\/base.py:        Calculates and returns the number of bytes that this HDU will write to\nastropy\/io\/fits\/hdu\/base.py:        # TODO: Fix this once new HDU writing API is settled on\nastropy\/io\/fits\/hdu\/base.py:        of this HDU within any associated file.  The values are only\nastropy\/io\/fits\/hdu\/base.py:        intervening changes to the `HDUList`.\nastropy\/io\/fits\/hdu\/base.py:           this HDU within an associated file.  Returns `None` when\nastropy\/io\/fits\/hdu\/base.py:           the HDU is not associated with a file.\nastropy\/io\/fits\/hdu\/base.py:           Dictionary contents:\nastropy\/io\/fits\/hdu\/base.py:           file       File object associated with the HDU\nastropy\/io\/fits\/hdu\/base.py:           datSpan    Data size including padding\nastropy\/io\/fits\/hdu\/base.py:        Make a copy of the HDU, both header and data are copied.\nastropy\/io\/fits\/hdu\/base.py:        is_valid = BITPIX2DTYPE.__contains__\nastropy\/io\/fits\/hdu\/base.py:        # Do the first card here, instead of in the respective HDU classes, so\nastropy\/io\/fits\/hdu\/base.py:        if isinstance(self, ExtensionHDU):\nastropy\/io\/fits\/hdu\/base.py:                                            fix=fix, fix_text=\"Deleted.\"))\nastropy\/io\/fits\/hdu\/base.py:    # TODO: Improve this API a little bit--for one, most of these arguments\nastropy\/io\/fits\/hdu\/base.py:            multiple HDUs and multiple calls to `req_cards`.\nastropy\/io\/fits\/hdu\/base.py:    def add_datasum(self, when=None, datasum_keyword='DATASUM'):\nastropy\/io\/fits\/hdu\/base.py:        Add the ``DATASUM`` card to this HDU with the value set to the\nastropy\/io\/fits\/hdu\/base.py:            this is typically 'DATASUM' per convention, but there exist\nastropy\/io\/fits\/hdu\/base.py:                     checksum_keyword='CHECKSUM', datasum_keyword='DATASUM'):\nastropy\/io\/fits\/hdu\/base.py:        Add the ``CHECKSUM`` and ``DATASUM`` cards to this HDU with\nastropy\/io\/fits\/hdu\/base.py:        the values set to the checksum calculated for the HDU and the\nastropy\/io\/fits\/hdu\/base.py:        data respectively.  The addition of the ``DATASUM`` card may\nastropy\/io\/fits\/hdu\/base.py:            when = 'HDU checksum updated {}'.format(self._get_timestamp())\nastropy\/io\/fits\/hdu\/base.py:        Verify that the value in the ``DATASUM`` keyword matches the value\nastropy\/io\/fits\/hdu\/base.py:        calculated for the ``DATASUM`` of the current HDU data.\nastropy\/io\/fits\/hdu\/base.py:           - 2 - no ``DATASUM`` keyword present\nastropy\/io\/fits\/hdu\/base.py:        if 'DATASUM' in self._header:\nastropy\/io\/fits\/hdu\/base.py:            if datasum == int(self._header['DATASUM']):\nastropy\/io\/fits\/hdu\/base.py:        value calculated for the current HDU CHECKSUM.\nastropy\/io\/fits\/hdu\/base.py:            if 'DATASUM' in self._header:\nastropy\/io\/fits\/hdu\/base.py:                    'Checksum verification failed for HDU {0}.\\n'.format(\nastropy\/io\/fits\/hdu\/base.py:        if 'DATASUM' in self._header:\nastropy\/io\/fits\/hdu\/base.py:            self._datasum = self._header['DATASUM']\nastropy\/io\/fits\/hdu\/base.py:                    'Datasum verification failed for HDU {0}.\\n'.format(\nastropy\/io\/fits\/hdu\/base.py:        Calculate the value for the ``DATASUM`` card in the HDU.\nastropy\/io\/fits\/hdu\/base.py:        Calculate the value of the ``CHECKSUM`` card in the HDU.\nastropy\/io\/fits\/hdu\/base.py:    # _MASK and _EXCLUDE used for encoding the checksum value into a character\nastropy\/io\/fits\/hdu\/base.py:    _EXCLUDE = [0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,\nastropy\/io\/fits\/hdu\/base.py:            for x in self._EXCLUDE:\nastropy\/io\/fits\/hdu\/base.py:class ExtensionHDU(_ValidHDU):\nastropy\/io\/fits\/hdu\/base.py:    An extension HDU class.\nastropy\/io\/fits\/hdu\/base.py:    This class is the base class for the `TableHDU`, `ImageHDU`, and\nastropy\/io\/fits\/hdu\/base.py:    `BinTableHDU` classes.\nastropy\/io\/fits\/hdu\/base.py:        extension HDU type should be used for a specific extension, or\nastropy\/io\/fits\/hdu\/base.py:        NonstandardExtHDU should be used.\nastropy\/io\/fits\/hdu\/base.py:        `PrimaryHDU` are required by extension HDUs (which cannot stand on\nastropy\/io\/fits\/hdu\/base.py:        from .hdulist import HDUList\nastropy\/io\/fits\/hdu\/base.py:        from .image import PrimaryHDU\nastropy\/io\/fits\/hdu\/base.py:        hdulist = HDUList([PrimaryHDU(), self])\nastropy\/io\/fits\/hdu\/base.py:# TODO: Mark this as deprecated\nastropy\/io\/fits\/hdu\/base.py:_ExtensionHDU = ExtensionHDU\nastropy\/io\/fits\/hdu\/base.py:class NonstandardExtHDU(ExtensionHDU):\nastropy\/io\/fits\/hdu\/base.py:    A Non-standard Extension HDU class.\nastropy\/io\/fits\/hdu\/base.py:    This class is used for an Extension HDU when the ``XTENSION``\nastropy\/io\/fits\/hdu\/base.py:    out how big the data is but not what it is.  The data for this HDU\nastropy\/io\/fits\/hdu\/base.py:    byte after the header ``END`` card and continues until the\nastropy\/io\/fits\/hdu\/base.py:        Matches any extension HDU that is not one of the standard extension HDU\nastropy\/io\/fits\/hdu\/base.py:        # A3DTABLE is not really considered a 'standard' extension, as it was\nastropy\/io\/fits\/hdu\/base.py:        # implementation handles A3DTABLE HDUs it is listed here.\nastropy\/io\/fits\/hdu\/base.py:        standard_xtensions = ('IMAGE', 'TABLE', 'BINTABLE', 'A3DTABLE')\nastropy\/io\/fits\/hdu\/base.py:        return (self.name, self.ver, 'NonstandardExtHDU', len(self._header))\nastropy\/io\/fits\/hdu\/base.py:# TODO: Mark this as deprecated\nastropy\/io\/fits\/hdu\/base.py:_NonstandardExtHDU = NonstandardExtHDU\nastropy\/io\/fits\/_numpy_hacks.py:            \"Dtype must be a structured dtype, and length of offsets list \"\nastropy\/io\/fits\/scripts\/fitsheader.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/scripts\/fitsheader.py:1. Print the header of all the HDUs of a .fits file::\nastropy\/io\/fits\/scripts\/fitsheader.py:2. Print the header of the third and fifth HDU extension::\nastropy\/io\/fits\/scripts\/fitsheader.py:3. Print the header of a named extension, e.g. select the HDU containing\nastropy\/io\/fits\/scripts\/fitsheader.py:6. Dump the header keywords of all the files in the current directory into a\nastropy\/io\/fits\/scripts\/fitsheader.py:Note that compressed images (HDUs of type\nastropy\/io\/fits\/scripts\/fitsheader.py::class:`~astropy.io.fits.CompImageHDU`) really have two headers: a real\nastropy\/io\/fits\/scripts\/fitsheader.py:    \"\"\"Raised if an HDU extension requested by the user does not exist.\"\"\"\nastropy\/io\/fits\/scripts\/fitsheader.py:    `fitsheader` tool; essentially a wrapper around a `HDUList` object.\nastropy\/io\/fits\/scripts\/fitsheader.py:            Format only specific HDU(s), identified by number or name.\nastropy\/io\/fits\/scripts\/fitsheader.py:            containing `CompImageHDU` extensions only.)\nastropy\/io\/fits\/scripts\/fitsheader.py:        # `hdukeys` will hold the keys of the HDUList items to display\nastropy\/io\/fits\/scripts\/fitsheader.py:            hdukeys = range(len(self._hdulist))  # Display all by default\nastropy\/io\/fits\/scripts\/fitsheader.py:                    # HDU may be specified by number\nastropy\/io\/fits\/scripts\/fitsheader.py:        # Having established which HDUs the user wants, we now format these:\nastropy\/io\/fits\/scripts\/fitsheader.py:            if idx > 0:  # Separate HDUs by a blank line\nastropy\/io\/fits\/scripts\/fitsheader.py:            result.append('# HDU {} in {}:\\n'.format(hdu, self.filename))\nastropy\/io\/fits\/scripts\/fitsheader.py:            Key of a single HDU in the HDUList.\nastropy\/io\/fits\/scripts\/fitsheader.py:                    log.warning('{filename} (HDU {hdukey}): '\nastropy\/io\/fits\/scripts\/fitsheader.py:    parser.add_argument('-e', '--extension', metavar='HDU',\nastropy\/io\/fits\/scripts\/fitsheader.py:    parser.add_argument('-k', '--keyword', metavar='KEYWORD',\nastropy\/io\/fits\/column.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/column.py:from collections import OrderedDict\nastropy\/io\/fits\/column.py:from .card import Card, CARD_LENGTH\nastropy\/io\/fits\/column.py:__all__ = ['Column', 'ColDefs', 'Delayed']\nastropy\/io\/fits\/column.py:# D: Double-precision Floating Point\nastropy\/io\/fits\/column.py:# M: Double-precision Complex\nastropy\/io\/fits\/column.py:              'D': 'f8', 'C': 'c8', 'M': 'c16', 'A': 'a'}\nastropy\/io\/fits\/column.py:FORMATORDER = ['L', 'B', 'I', 'J', 'K', 'D', 'M', 'A']\nastropy\/io\/fits\/column.py:FITSUPCONVERTERS = {'E': 'D', 'C': 'M'}\nastropy\/io\/fits\/column.py:# D: Float (64-bit; exponential notation, always 64-bit by convention)\nastropy\/io\/fits\/column.py:ASCII2NUMPY = {'A': 'a', 'I': 'i4', 'J': 'i8', 'F': 'f8', 'E': 'f8', 'D': 'f8'}\nastropy\/io\/fits\/column.py:ASCII2STR = {'A': '', 'I': 'd', 'J': 'd', 'F': 'f', 'E': 'E', 'D': 'E'}\nastropy\/io\/fits\/column.py:ASCII_DEFAULT_WIDTHS = {'A': (1, 0), 'I': (10, 0), 'J': (15, 0),\nastropy\/io\/fits\/column.py:                        'E': (15, 7), 'F': (16, 7), 'D': (25, 17)}\nastropy\/io\/fits\/column.py:KEYWORD_NAMES = ('TTYPE', 'TFORM', 'TUNIT', 'TNULL', 'TSCAL', 'TZERO',\nastropy\/io\/fits\/column.py:                 'TDISP', 'TBCOL', 'TDIM', 'TCTYP', 'TCUNI', 'TCRPX',\nastropy\/io\/fits\/column.py:                 'TCRVL', 'TCDLT', 'TRPOS')\nastropy\/io\/fits\/column.py:KEYWORD_ATTRIBUTES = ('name', 'format', 'unit', 'null', 'bscale', 'bzero',\nastropy\/io\/fits\/column.py:KEYWORD_TO_ATTRIBUTE = OrderedDict(zip(KEYWORD_NAMES, KEYWORD_ATTRIBUTES))\nastropy\/io\/fits\/column.py:ATTRIBUTE_TO_KEYWORD = OrderedDict(zip(KEYWORD_ATTRIBUTES, KEYWORD_NAMES))\nastropy\/io\/fits\/column.py:# TODO: Define a list of default comments to associate with each table keyword\nastropy\/io\/fits\/column.py:TFORMAT_RE = re.compile(r'(?P<repeat>^[0-9]*)(?P<format>[LXBIJKAEDCMPQ])'\nastropy\/io\/fits\/column.py:                              r'(?:(?P<formatf>[FED])'\nastropy\/io\/fits\/column.py:TDEF_RE = re.compile(r'(?P<label>^T[A-Z]*)(?P<num>[1-9][0-9 ]*$)')\nastropy\/io\/fits\/column.py:TDIM_RE = re.compile(r'\\(\\s*(?P<dims>(?:\\d+,\\s*)+\\s*\\d+)\\s*\\)\\s*')\nastropy\/io\/fits\/column.py:DEFAULT_ASCII_TNULL = '---'\nastropy\/io\/fits\/column.py:class Delayed:\nastropy\/io\/fits\/column.py:    \"\"\"Delayed file-reading data.\"\"\"\nastropy\/io\/fits\/column.py:        # This forces the data for the HDU to be read, which will replace\nastropy\/io\/fits\/column.py:        # the corresponding Delayed objects in the Tables Columns to be\nastropy\/io\/fits\/column.py:            # TODO: There should be a generic factory that returns either\nastropy\/io\/fits\/column.py:        and 'D' only).\nastropy\/io\/fits\/column.py:        if self.format in ('E', 'F', 'D'):\nastropy\/io\/fits\/column.py:# TODO: Table column formats need to be verified upon first reading the file;\nastropy\/io\/fits\/column.py:    _format_re_template = (r'(?P<repeat>\\d+)?{}(?P<dtype>[LXBIJKAEDCM])'\nastropy\/io\/fits\/column.py:    Descriptor for attributes of `Column` that are associated with keywords\nastropy\/io\/fits\/column.py:    HDU this column is attached to in order to reflect the change.  The\nastropy\/io\/fits\/column.py:        # determined from the KEYWORD_NAMES\/ATTRIBUTES lists.  This could be\nastropy\/io\/fits\/column.py:        self._attr = '_' + KEYWORD_TO_ATTRIBUTE[self._keyword]\nastropy\/io\/fits\/column.py:            display format, corresponding to ``TDISP`` keyword\nastropy\/io\/fits\/column.py:            column dimension corresponding to ``TDIM`` keyword\nastropy\/io\/fits\/column.py:            coordinate increment at reference point corresponding to ``TCDLT``\nastropy\/io\/fits\/column.py:        for attr in KEYWORD_ATTRIBUTES:\nastropy\/io\/fits\/column.py:        for attr in KEYWORD_ATTRIBUTES:\nastropy\/io\/fits\/column.py:        # TODO: Try to eliminate the following two special cases\nastropy\/io\/fits\/column.py:                          (np.ndarray, chararray.chararray, Delayed)):\nastropy\/io\/fits\/column.py:                        raise ValueError('Data is inconsistent with the '\nastropy\/io\/fits\/column.py:        for attr in KEYWORD_ATTRIBUTES:\nastropy\/io\/fits\/column.py:        later added to a table, such as via `BinTableHDU.from_columns` as\nastropy\/io\/fits\/column.py:        # reference cycle was created.  This is because the code in BinTableHDU\nastropy\/io\/fits\/column.py:        # data._coldefs = columns  # The ColDefs object holding this Column\nastropy\/io\/fits\/column.py:                    isinstance(base._coldefs, ColDefs)):\nastropy\/io\/fits\/column.py:                or len(str(Card('TTYPE', name))) != CARD_LENGTH):\nastropy\/io\/fits\/column.py:    @ColumnAttribute('TCDLT')\nastropy\/io\/fits\/column.py:    disp = ColumnAttribute('TDISP')\nastropy\/io\/fits\/column.py:    dim = ColumnAttribute('TDIM')\nastropy\/io\/fits\/column.py:        TODO: There should be an abc base class for column format classes\nastropy\/io\/fits\/column.py:        # TODO: Add validation for these keywords, obviously\nastropy\/io\/fits\/column.py:                    # TODO: We should also check that TNULLn's integer value\nastropy\/io\/fits\/column.py:        # TODO: Add full parsing and validation of TDISPn keywords\nastropy\/io\/fits\/column.py:                    'Column disp option (TDISPn) must be a string (got {!r}).'\nastropy\/io\/fits\/column.py:                    \"Column disp option (TDISPn) may not use the 'L' format \"\nastropy\/io\/fits\/column.py:        # Process TDIMn options\nastropy\/io\/fits\/column.py:        # ASCII table columns can't have a TDIMn keyword associated with it;\nastropy\/io\/fits\/column.py:        # TODO: This should be checked by the FITS verification code\nastropy\/io\/fits\/column.py:                    'Column dim option (TDIMn) is not allowed for ASCII table '\nastropy\/io\/fits\/column.py:                    \"for the TDIMn header keyword associated with this column, \"\nastropy\/io\/fits\/column.py:                        \"is fewer than the number of elements per the TDIM \"\nastropy\/io\/fits\/column.py:                        \"argument {!r}.  The invalid TDIMn value will be ignored \"\nastropy\/io\/fits\/column.py:                        \"the data in this column.\".format(k, ATTRIBUTE_TO_KEYWORD[k], v))\nastropy\/io\/fits\/column.py:                '(TDIMn) option, since the former is only applies to '\nastropy\/io\/fits\/column.py:        if isinstance(array, Delayed):\nastropy\/io\/fits\/column.py:                        # in the TDIMn keyword itself) is the number of\nastropy\/io\/fits\/column.py:class ColDefs(NotifierMixin):\nastropy\/io\/fits\/column.py:    (e.g. `ColDefs` has the attribute ``names`` while `Column`\nastropy\/io\/fits\/column.py:    has ``name``). Each attribute in `ColDefs` is a list of\nastropy\/io\/fits\/column.py:                issubclass(input._columns_type, ColDefs)):\nastropy\/io\/fits\/column.py:            klass = _AsciiColDefs\nastropy\/io\/fits\/column.py:            klass = _AsciiColDefs\nastropy\/io\/fits\/column.py:        input : sequence of `Column`, `ColDefs`, other\nastropy\/io\/fits\/column.py:            An existing table HDU, an existing `ColDefs`, or any multi-field\nastropy\/io\/fits\/column.py:        from .hdu.table import _TableBaseHDU\nastropy\/io\/fits\/column.py:        if isinstance(input, ColDefs):\nastropy\/io\/fits\/column.py:        elif isinstance(input, _TableBaseHDU):\nastropy\/io\/fits\/column.py:            # Construct columns from fields in an HDU header\nastropy\/io\/fits\/column.py:            raise TypeError('Input to ColDefs must be a table HDU, a list '\nastropy\/io\/fits\/column.py:        \"\"\"Initialize from an existing ColDefs object (just copy the\nastropy\/io\/fits\/column.py:                raise TypeError('Element {} in the ColDefs input is not a '\nastropy\/io\/fits\/column.py:            # Determine the appropriate dimensions for items in the column\nastropy\/io\/fits\/column.py:            # (typically just 1D)\nastropy\/io\/fits\/column.py:        nfields = hdr['TFIELDS']\nastropy\/io\/fits\/column.py:            key = TDEF_RE.match(keyword)\nastropy\/io\/fits\/column.py:            if keyword in KEYWORD_NAMES:\nastropy\/io\/fits\/column.py:                    attr = KEYWORD_TO_ATTRIBUTE[keyword]\nastropy\/io\/fits\/column.py:            # TODO: Try to eliminate the need for these special cases\nastropy\/io\/fits\/column.py:            col_keywords[col]['array'] = Delayed(table, col)\nastropy\/io\/fits\/column.py:        # Add the table HDU is a listener to changes to the columns\nastropy\/io\/fits\/column.py:        # TODO: Catch exceptions here and raise an explicit error about\nastropy\/io\/fits\/column.py:        # TODO: This is sort of hacked in right now; we really need\nastropy\/io\/fits\/column.py:                new_column.null = DEFAULT_ASCII_TNULL\nastropy\/io\/fits\/column.py:                # for now just drop the TDISPn option for this column as we\nastropy\/io\/fits\/column.py:        if cname in KEYWORD_ATTRIBUTES and name[-1] == 's':\nastropy\/io\/fits\/column.py:        # field *shapes* as provided by TDIMn keywords.\nastropy\/io\/fits\/column.py:        # Now this incorporates TDIMn from the start, which makes *this* method\nastropy\/io\/fits\/column.py:        \"\"\"Returns the values of the TDIMn keywords parsed into tuples.\"\"\"\nastropy\/io\/fits\/column.py:            return ColDefs(x)\nastropy\/io\/fits\/column.py:        rep = 'ColDefs('\nastropy\/io\/fits\/column.py:        elif isinstance(other, ColDefs):\nastropy\/io\/fits\/column.py:        return ColDefs(tmp)\nastropy\/io\/fits\/column.py:        return ColDefs(tmp)\nastropy\/io\/fits\/column.py:        members of this `ColDefs`.\nastropy\/io\/fits\/column.py:        `ColDefs` itself does not currently do anything with this, and just\nastropy\/io\/fits\/column.py:        bubbles the notification up to any listening table HDUs that may need\nastropy\/io\/fits\/column.py:        # If this ColDefs is being tracked by a Table, inform the\nastropy\/io\/fits\/column.py:        Delete (the definition of) one `Column`.\nastropy\/io\/fits\/column.py:        # If this ColDefs is being tracked by a table HDU, inform the HDU (or\nastropy\/io\/fits\/column.py:        Change an attribute (in the ``KEYWORD_ATTRIBUTES`` list) of a `Column`.\nastropy\/io\/fits\/column.py:            ``astropy.io.fits.column.KEYWORD_ATTRIBUTES``.  The default is\nastropy\/io\/fits\/column.py:            lst = KEYWORD_ATTRIBUTES\nastropy\/io\/fits\/column.py:                if attr not in KEYWORD_ATTRIBUTES:\nastropy\/io\/fits\/column.py:class _AsciiColDefs(ColDefs):\nastropy\/io\/fits\/column.py:    \"\"\"ColDefs implementation for ASCII tables.\"\"\"\nastropy\/io\/fits\/column.py:        if not isinstance(input, _AsciiColDefs):\nastropy\/io\/fits\/column.py:    # TODO: A great deal of this is redundant with FITS_rec._convert_p; see if\nastropy\/io\/fits\/column.py:        # TODO: Maybe catch this error use a default type (bytes, maybe?) for\nastropy\/io\/fits\/column.py:    'F', or 'D').\nastropy\/io\/fits\/column.py:        width, precision = ASCII_DEFAULT_WIDTHS[format]\nastropy\/io\/fits\/column.py:    \"\"\"Parse the ``TDIM`` value into a tuple (may return an empty tuple if\nastropy\/io\/fits\/column.py:    the value ``TDIM`` value is empty or invalid).\nastropy\/io\/fits\/column.py:    m = tdim and TDIM_RE.match(tdim)\nastropy\/io\/fits\/column.py:    FORMATORDER.\nastropy\/io\/fits\/column.py:    Compares two numpy recformats using the ordering given by FORMATORDER.\nastropy\/io\/fits\/column.py:        return cmp(FORMATORDER.index(f1), FORMATORDER.index(f2))\nastropy\/io\/fits\/column.py:        # use a TDIM keyword to fix this, declaring as (slength,\nastropy\/io\/fits\/column.py:    Convert FITS format spec to record format spec.  Do the opposite if\nastropy\/io\/fits\/column.py:            width = max(width, ASCII_DEFAULT_WIDTHS['I'][0])\nastropy\/io\/fits\/column.py:            # This is tricky, but go ahead and use D if float-64, and E\nastropy\/io\/fits\/column.py:                format = 'D'\nastropy\/io\/fits\/column.py:            width = '.'.join(str(w) for w in ASCII_DEFAULT_WIDTHS[format])\nastropy\/io\/fits\/column.py:        # TODO: There may be reasonable ways to represent other Numpy types so\nastropy\/io\/fits\/scripts\/fitscheck.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/scripts\/fitscheck.py:and updating the CHECKSUM and DATASUM keywords of .fits files.  ``fitscheck``\nastropy\/io\/fits\/scripts\/fitscheck.py:6. Delete checksum keywords::\nastropy\/io\/fits\/scripts\/fitscheck.py:        Verifies and optionally re-writes the CHECKSUM and DATASUM keywords\nastropy\/io\/fits\/scripts\/fitscheck.py:        help='Choose FITS checksum mode or none.  Defaults standard.',\nastropy\/io\/fits\/scripts\/fitscheck.py:        help='Do file update even if original checksum was bad.',\nastropy\/io\/fits\/scripts\/fitscheck.py:        help='Do FITS compliance checking; fix if possible.',\nastropy\/io\/fits\/scripts\/fitscheck.py:    Prints a message if any HDU in `filename` has a bad checksum or datasum.\nastropy\/io\/fits\/scripts\/fitscheck.py:                # looping on HDUs is needed to read them and verify the\nastropy\/io\/fits\/scripts\/fitscheck.py:                                    'in HDU #{}'.format(filename, i))\nastropy\/io\/fits\/scripts\/fitscheck.py:                        log.warning('MISSING {!r} .. Datasum not found '\nastropy\/io\/fits\/scripts\/fitscheck.py:                                    'in HDU #{}'.format(filename, i))\nastropy\/io\/fits\/scripts\/fitscheck.py:                                      'Datasum verification failed')):\nastropy\/io\/fits\/scripts\/fitscheck.py:            log.warning('BAD %r %s', filename, str(w.message))\nastropy\/io\/fits\/scripts\/fitscheck.py:    Sets the ``CHECKSUM`` and ``DATASUM`` keywords for each HDU of `filename`.\nastropy\/io\/fits\/scripts\/fitscheck.py:    or update FITS DATASUM and CHECKSUM keywords for the specified files.\nastropy\/io\/fits\/diff.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/diff.py:FITS files, individual HDUs, FITS headers, or just FITS data.\nastropy\/io\/fits\/diff.py:from .card import Card, BLANK_CARD\nastropy\/io\/fits\/diff.py:# HDUList is used in one of the doctests\nastropy\/io\/fits\/diff.py:from .hdu.table import _TableLikeHDU\nastropy\/io\/fits\/diff.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/io\/fits\/diff.py:__all__ = ['FITSDiff', 'HDUDiff', 'HeaderDiff', 'ImageDataDiff', 'RawDataDiff',\nastropy\/io\/fits\/diff.py:           'TableDataDiff']\nastropy\/io\/fits\/diff.py:class _BaseDiff:\nastropy\/io\/fits\/diff.py:    Instantiating a ``_BaseDiff`` also causes the diff itself to be executed.\nastropy\/io\/fits\/diff.py:    The returned ``_BaseDiff`` instance has a number of attribute that describe\nastropy\/io\/fits\/diff.py:    The most basic attribute, present on all ``_BaseDiff`` instances, is\nastropy\/io\/fits\/diff.py:        The ``_BaseDiff`` class does not implement a ``_diff`` method and\nastropy\/io\/fits\/diff.py:        appropriate subclass of ``_BaseDiff`` for the objects being compared\nastropy\/io\/fits\/diff.py:        (for example, use `HeaderDiff` to compare two `Header` objects.\nastropy\/io\/fits\/diff.py:        A ``_BaseDiff`` object acts as `True` in a boolean context if the two\nastropy\/io\/fits\/diff.py:        Returns a new Diff object of a specific subclass from an existing diff\nastropy\/io\/fits\/diff.py:            >>> hdul1, hdul2 = fits.HDUList(), fits.HDUList()\nastropy\/io\/fits\/diff.py:            >>> fd = fits.FITSDiff(hdul1, hdul2, ignore_keywords=['*'])\nastropy\/io\/fits\/diff.py:            >>> hd = fits.HeaderDiff.fromdiff(fd, headera, headerb)\nastropy\/io\/fits\/diff.py:        # The first 3 arguments of any Diff initializer are self, a, and b.\nastropy\/io\/fits\/diff.py:        Any subclass of ``_BaseDiff`` must have at least one ``.diff_*``\nastropy\/io\/fits\/diff.py:            ``OSError`` if ``False`` and the output file exists. Default is\nastropy\/io\/fits\/diff.py:class FITSDiff(_BaseDiff):\nastropy\/io\/fits\/diff.py:    \"\"\"Diff two FITS files by filename, or two `HDUList` objects.\nastropy\/io\/fits\/diff.py:    `FITSDiff` objects have the following diff attributes:\nastropy\/io\/fits\/diff.py:      numbers of HDUs, this contains a 2-tuple of the number of HDUs in each\nastropy\/io\/fits\/diff.py:    - ``diff_hdus``: If any HDUs with the same index are different, this\nastropy\/io\/fits\/diff.py:      contains a list of 2-tuples of the HDU index and the `HDUDiff` object\nastropy\/io\/fits\/diff.py:      representing the differences between the two HDUs.\nastropy\/io\/fits\/diff.py:        a : str or `HDUList`\nastropy\/io\/fits\/diff.py:            The filename of a FITS file on disk, or an `HDUList` object.\nastropy\/io\/fits\/diff.py:        b : str or `HDUList`\nastropy\/io\/fits\/diff.py:            The filename of a FITS file on disk, or an `HDUList` object to\nastropy\/io\/fits\/diff.py:            The number of pixel\/table values to output when reporting HDU data\nastropy\/io\/fits\/diff.py:                AstropyDeprecationWarning)\nastropy\/io\/fits\/diff.py:        # TODO: Somehow or another simplify the passing around of diff\nastropy\/io\/fits\/diff.py:            hdu_diff = HDUDiff.fromdiff(self, self.a[idx], self.b[idx])\nastropy\/io\/fits\/diff.py:            self._writeln('Files contain different numbers of HDUs:')\nastropy\/io\/fits\/diff.py:                self._writeln('No differences found between common HDUs.')\nastropy\/io\/fits\/diff.py:                self._writeln('Primary HDU:')\nastropy\/io\/fits\/diff.py:                self._writeln('Extension HDU {}:'.format(idx))\nastropy\/io\/fits\/diff.py:class HDUDiff(_BaseDiff):\nastropy\/io\/fits\/diff.py:    Diff two HDU objects, including their headers and their data (but only if\nastropy\/io\/fits\/diff.py:    both HDUs contain the same type of data (image, table, or unknown).\nastropy\/io\/fits\/diff.py:    `HDUDiff` objects have the following diff attributes:\nastropy\/io\/fits\/diff.py:    - ``diff_extnames``: If the two HDUs have different EXTNAME values, this\nastropy\/io\/fits\/diff.py:    - ``diff_extvers``: If the two HDUS have different EXTVER values, this\nastropy\/io\/fits\/diff.py:    - ``diff_extlevels``: If the two HDUs have different EXTLEVEL values, this\nastropy\/io\/fits\/diff.py:    - ``diff_extension_types``: If the two HDUs have different XTENSION values,\nastropy\/io\/fits\/diff.py:    - ``diff_headers``: Contains a `HeaderDiff` object for the headers of the\nastropy\/io\/fits\/diff.py:      two HDUs. This will always contain an object--it may be determined\nastropy\/io\/fits\/diff.py:    - ``diff_data``: Contains either a `ImageDataDiff`, `TableDataDiff`, or\nastropy\/io\/fits\/diff.py:      `RawDataDiff` as appropriate for the data in the HDUs, and only if the\nastropy\/io\/fits\/diff.py:      two HDUs have non-empty data of the same type (`RawDataDiff` is used for\nastropy\/io\/fits\/diff.py:      HDUs containing non-empty data of an indeterminate type).\nastropy\/io\/fits\/diff.py:        See `FITSDiff` for explanations of the initialization parameters.\nastropy\/io\/fits\/diff.py:                AstropyDeprecationWarning)\nastropy\/io\/fits\/diff.py:        self.diff_headers = HeaderDiff.fromdiff(self, self.a.header.copy(),\nastropy\/io\/fits\/diff.py:            # TODO: Perhaps have some means of marking this case\nastropy\/io\/fits\/diff.py:            self.diff_data = ImageDataDiff.fromdiff(self, self.a.data,\nastropy\/io\/fits\/diff.py:        elif (isinstance(self.a, _TableLikeHDU) and\nastropy\/io\/fits\/diff.py:              isinstance(self.b, _TableLikeHDU)):\nastropy\/io\/fits\/diff.py:            # TODO: Replace this if\/when _BaseHDU grows a .is_table property\nastropy\/io\/fits\/diff.py:            self.diff_data = TableDataDiff.fromdiff(self, self.a.data,\nastropy\/io\/fits\/diff.py:            # Don't diff the data for unequal extension types that are not\nastropy\/io\/fits\/diff.py:            self.diff_data = RawDataDiff.fromdiff(self, self.a.data,\nastropy\/io\/fits\/diff.py:            self._writeln(\" Data contains differences:\")\nastropy\/io\/fits\/diff.py:class HeaderDiff(_BaseDiff):\nastropy\/io\/fits\/diff.py:    Diff two `Header` objects.\nastropy\/io\/fits\/diff.py:    `HeaderDiff` objects have the following diff attributes:\nastropy\/io\/fits\/diff.py:    `HeaderDiff` objects also have a ``common_keywords`` attribute that lists\nastropy\/io\/fits\/diff.py:        See `FITSDiff` for explanations of the initialization parameters.\nastropy\/io\/fits\/diff.py:                AstropyDeprecationWarning)\nastropy\/io\/fits\/diff.py:        # TODO: Implement this\nastropy\/io\/fits\/diff.py:            raise TypeError('HeaderDiff can only diff astropy.io.fits.Header '\nastropy\/io\/fits\/diff.py:    # TODO: This doesn't pay much attention to the *order* of the keywords,\nastropy\/io\/fits\/diff.py:            cardsa = [c for c in self.a.cards if str(c) != BLANK_CARD]\nastropy\/io\/fits\/diff.py:            cardsb = [c for c in self.b.cards if str(c) != BLANK_CARD]\nastropy\/io\/fits\/diff.py:        # TODO: HIERARCH keywords should be handled case-sensitively I think\nastropy\/io\/fits\/diff.py:# TODO: It might be good if there was also a threshold option for percentage of\nastropy\/io\/fits\/diff.py:class ImageDataDiff(_BaseDiff):\nastropy\/io\/fits\/diff.py:    Diff two image data arrays (really any array from a PRIMARY HDU or an IMAGE\nastropy\/io\/fits\/diff.py:    extension HDU, though the data unit is assumed to be \"pixels\").\nastropy\/io\/fits\/diff.py:    `ImageDataDiff` objects have the following diff attributes:\nastropy\/io\/fits\/diff.py:        See `FITSDiff` for explanations of the initialization parameters.\nastropy\/io\/fits\/diff.py:                AstropyDeprecationWarning)\nastropy\/io\/fits\/diff.py:            # Don't do any further comparison if the dimensions differ\nastropy\/io\/fits\/diff.py:            # TODO: Perhaps we could, however, diff just the intersection\nastropy\/io\/fits\/diff.py:            self._writeln(' Data dimensions differ:')\nastropy\/io\/fits\/diff.py:            self._writeln(' Data differs at {}:'.format(index))\nastropy\/io\/fits\/diff.py:class RawDataDiff(ImageDataDiff):\nastropy\/io\/fits\/diff.py:    `RawDataDiff` is just a special case of `ImageDataDiff` where the images\nastropy\/io\/fits\/diff.py:    non-standard extension HDUs that were not recognized as containing image or\nastropy\/io\/fits\/diff.py:    `ImageDataDiff` objects have the following diff attributes:\nastropy\/io\/fits\/diff.py:      `ImageDataDiff` objects. Though the \"dimension\" of each array is just an\nastropy\/io\/fits\/diff.py:    - ``diff_bytes``: Like the ``diff_pixels`` attribute of `ImageDataDiff`\nastropy\/io\/fits\/diff.py:    - ``diff_total`` and ``diff_ratio``: Same as `ImageDataDiff`.\nastropy\/io\/fits\/diff.py:        See `FITSDiff` for explanations of the initialization parameters.\nastropy\/io\/fits\/diff.py:            self._writeln(' Data sizes differ:')\nastropy\/io\/fits\/diff.py:            self._writeln(' Data differs at byte {}:'.format(index))\nastropy\/io\/fits\/diff.py:class TableDataDiff(_BaseDiff):\nastropy\/io\/fits\/diff.py:    Diff two table data arrays. It doesn't matter whether the data originally\nastropy\/io\/fits\/diff.py:    `TableDataDiff` objects have the following diff attributes:\nastropy\/io\/fits\/diff.py:      have different secondary attributes, such as TUNIT or TDISP.  The format\nastropy\/io\/fits\/diff.py:    - ``diff_values``: `TableDataDiff` compares the data in each table on a\nastropy\/io\/fits\/diff.py:      attribute on `ImageDataDiff` objects, though the \"index\" consists of a\nastropy\/io\/fits\/diff.py:    - ``diff_total`` and ``diff_ratio``: Same as `ImageDataDiff`.\nastropy\/io\/fits\/diff.py:    `TableDataDiff` objects also have a ``common_columns`` attribute that lists\nastropy\/io\/fits\/diff.py:        See `FITSDiff` for explanations of the initialization parameters.\nastropy\/io\/fits\/diff.py:                AstropyDeprecationWarning)\nastropy\/io\/fits\/diff.py:        # TODO: It might be nice to optionally compare the first n rows where n\nastropy\/io\/fits\/diff.py:                    # Don't save any more diff values\nastropy\/io\/fits\/diff.py:    Diff two scalar values.  If both values are floats they are compared to\nastropy\/io\/fits\/scripts\/fitsinfo.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/scripts\/fitsinfo.py:printing a summary of the HDUs in one or more FITS files(s) to the\nastropy\/io\/fits\/scripts\/fitsinfo.py:1. Print a summary of the HDUs in a FITS file::\nastropy\/io\/fits\/scripts\/fitsinfo.py:    No.    Name         Type      Cards   Dimensions   Format\nastropy\/io\/fits\/scripts\/fitsinfo.py:    0    PRIMARY     PrimaryHDU     138   ()\nastropy\/io\/fits\/scripts\/fitsinfo.py:    1    SCI         ImageHDU        61   (800, 800)   int16\nastropy\/io\/fits\/scripts\/fitsinfo.py:    2    SCI         ImageHDU        61   (800, 800)   int16\nastropy\/io\/fits\/scripts\/fitsinfo.py:    3    SCI         ImageHDU        61   (800, 800)   int16\nastropy\/io\/fits\/scripts\/fitsinfo.py:    4    SCI         ImageHDU        61   (800, 800)   int16\nastropy\/io\/fits\/scripts\/fitsinfo.py:2. Print a summary of HDUs of all the FITS files in the current directory::\nastropy\/io\/fits\/scripts\/fitsinfo.py:    Print a summary of the HDUs in a FITS file.\nastropy\/io\/fits\/scripts\/fitsinfo.py:        description=('Print a summary of the HDUs in a FITS file(s).'))\nastropy\/io\/fits\/verify.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/verify.py:            # Don't print out fixable issues; the first element of each verify\nastropy\/io\/fits\/verify.py:            # Don't print *unfixable* issues, but do print fixed issues; this\nastropy\/io\/fits\/util.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/util.py:            self._listeners = weakref.WeakValueDictionary()\nastropy\/io\/fits\/util.py:        # TODO: This hasn't come up often, but if anyone needs to pickle HDU\nastropy\/io\/fits\/util.py:        # objects it will be necessary when HDU objects' states are restored to\nastropy\/io\/fits\/util.py:    >>> class D(B,C): pass\nastropy\/io\/fits\/util.py:    >>> class E(D): pass\nastropy\/io\/fits\/util.py:    D\nastropy\/io\/fits\/util.py:        # Define new signal interput handler\nastropy\/io\/fits\/util.py:                    signal.signal(signal.SIGINT, signal.SIG_DFL)\nastropy\/io\/fits\/util.py:        except UnicodeDecodeError:\nastropy\/io\/fits\/util.py:        # Don't silently pass through on non-string arrays; we don't want\nastropy\/io\/fits\/util.py:    # Doesn't look like a file-like object, for example strings, urls or paths.\nastropy\/io\/fits\/util.py:        if mode == gzip.READ:\nastropy\/io\/fits\/util.py:CHUNKED_FROMFILE = None\nastropy\/io\/fits\/util.py:        global CHUNKED_FROMFILE\nastropy\/io\/fits\/util.py:        if CHUNKED_FROMFILE is None:\nastropy\/io\/fits\/util.py:                CHUNKED_FROMFILE = True\nastropy\/io\/fits\/util.py:                CHUNKED_FROMFILE = False\nastropy\/io\/fits\/util.py:        if CHUNKED_FROMFILE:\nastropy\/io\/fits\/util.py:    # on a 1-D version of the array; large memory may still be needed in the\nastropy\/io\/fits\/util.py:    # be represented as a contiguous 1-D array in memory).\nastropy\/io\/fits\/util.py:    # Attempt to have the strings as a 1-D array to give the chunk known size.\nastropy\/io\/fits\/setup_package.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/setup_package.py:    cfg = setup_helpers.DistutilsExtensionArgs()\nastropy\/io\/fits\/setup_package.py:                ['\/D', '\"WIN32\"',\nastropy\/io\/fits\/setup_package.py:                 '\/D', '\"_WINDOWS\"',\nastropy\/io\/fits\/setup_package.py:                 '\/D', '\"_MBCS\"',\nastropy\/io\/fits\/setup_package.py:                 '\/D', '\"_USRDLL\"',\nastropy\/io\/fits\/setup_package.py:                 '\/D', '\"_CRT_SECURE_NO_DEPRECATE\"',\nastropy\/io\/fits\/setup_package.py:                 '\/D', '\"FF_NO_UNISTD_H\"'])\nastropy\/visualization\/wcsaxes\/formatter_locator.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/formatter_locator.py:DMS_RE = re.compile('^dd(:mm(:ss(.(s)+)?)?)?$')\nastropy\/visualization\/wcsaxes\/formatter_locator.py:DDEC_RE = re.compile('^d(.(d)+)?$')\nastropy\/visualization\/wcsaxes\/formatter_locator.py:DMIN_RE = re.compile('^m(.(m)+)?$')\nastropy\/visualization\/wcsaxes\/formatter_locator.py:DSEC_RE = re.compile('^s(.(s)+)?$')\nastropy\/visualization\/wcsaxes\/formatter_locator.py:        if DMS_RE.match(value) is not None:\nastropy\/visualization\/wcsaxes\/formatter_locator.py:        elif DDEC_RE.match(value) is not None:\nastropy\/visualization\/wcsaxes\/formatter_locator.py:        elif DMIN_RE.match(value) is not None:\nastropy\/visualization\/wcsaxes\/formatter_locator.py:        elif DSEC_RE.match(value) is not None:\nastropy\/visualization\/wcsaxes\/tests\/test_frame.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/tests\/test_frame.py:from ....tests.image_tests import IMAGE_REFERENCE_DIR\nastropy\/visualization\/wcsaxes\/tests\/test_frame.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_frame.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_frame.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/visualization\/wcsaxes\/tests\/test_frame.py:    @pytest.mark.mpl_image_compare(baseline_dir=IMAGE_REFERENCE_DIR,\nastropy\/io\/fits\/scripts\/fitsdiff.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/scripts\/fitsdiff.py:from ....utils.exceptions import AstropyDeprecationWarning\nastropy\/io\/fits\/scripts\/fitsdiff.py:FITSDIFF_SETTINGS.  If the FITSDIFF_SETTINGS environment variable is present,\nastropy\/io\/fits\/scripts\/fitsdiff.py:command-line unless the --exact option is specified.  The FITSDIFF_SETTINGS\nastropy\/io\/fits\/scripts\/fitsdiff.py:        help='DEPRECATED. Alias for \"--relative-tolerance\". '\nastropy\/io\/fits\/scripts\/fitsdiff.py:             'Deprecated, provided for backward compatibility (default %default).')\nastropy\/io\/fits\/scripts\/fitsdiff.py:        help=\"Don't ignore trailing blanks (whitespace) in string values.  \"\nastropy\/io\/fits\/scripts\/fitsdiff.py:             \"without this option 'ABCDEF   ' and 'ABCDEF' are considered \"\nastropy\/io\/fits\/scripts\/fitsdiff.py:        help=\"Don't ignore entirely blank cards in headers.  Normally fitsdiff \"\nastropy\/io\/fits\/scripts\/fitsdiff.py:             \"overriding command-line options and FITSDIFF_SETTINGS. \")\nastropy\/io\/fits\/scripts\/fitsdiff.py:        metavar='KEYWORDS',\nastropy\/io\/fits\/scripts\/fitsdiff.py:        metavar='KEYWORDS',\nastropy\/io\/fits\/scripts\/fitsdiff.py:    # Determine which filenames to compare\nastropy\/io\/fits\/scripts\/fitsdiff.py:    if 'FITSDIFF_SETTINGS' in os.environ:\nastropy\/io\/fits\/scripts\/fitsdiff.py:        args = os.environ['FITSDIFF_SETTINGS'].split() + args\nastropy\/io\/fits\/scripts\/fitsdiff.py:            AstropyDeprecationWarning)\nastropy\/io\/fits\/scripts\/fitsdiff.py:            # TODO: pass in any additional arguments here too\nastropy\/io\/fits\/scripts\/fitsdiff.py:            diff = fits.diff.FITSDiff(\nastropy\/convolution\/tests\/test_convolve_speeds.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_convolve_speeds.py:        print(\"\\n{}-dimensional arrays ('n' is the size of the image AND \"\nastropy\/convolution\/tests\/test_convolve_speeds.py:            # test ODD sizes too\nastropy\/convolution\/tests\/test_convolve_speeds.py:1-dimensional arrays ('n' is the size of the image AND the kernel)\nastropy\/convolution\/tests\/test_convolve_speeds.py:2-dimensional arrays ('n' is the size of the image AND the kernel)\nastropy\/convolution\/tests\/test_convolve_speeds.py:3-dimensional arrays ('n' is the size of the image AND the kernel)\nastropy\/convolution\/tests\/test_convolve_speeds.py:1-dimensional arrays ('n' is the size of the image AND the kernel)\nastropy\/convolution\/tests\/test_convolve_speeds.py:2-dimensional arrays ('n' is the size of the image AND the kernel)\nastropy\/convolution\/tests\/test_convolve_speeds.py:3-dimensional arrays ('n' is the size of the image AND the kernel)\nastropy\/io\/fits\/scripts\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_nonstandard.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_nonstandard.py:        A round trip test of creating a FitsHDU, adding a FITS file to it,\nastropy\/io\/fits\/tests\/test_nonstandard.py:        writing the FitsHDU out as part of a new FITS file, and then reading\nastropy\/io\/fits\/tests\/test_nonstandard.py:        \"\"\"Regression test on `FitsHDU.fromfile`\"\"\"\nastropy\/io\/fits\/tests\/test_nonstandard.py:        phdu = fits.PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_nonstandard.py:        imghdu = fits.ImageHDU(data=a + 1)\nastropy\/io\/fits\/tests\/test_nonstandard.py:        phdu.header['TEST4'] = 'D'\nastropy\/io\/fits\/tests\/test_nonstandard.py:        hdul = fits.HDUList([phdu, imghdu])\nastropy\/io\/fits\/tests\/test_nonstandard.py:        fitshdu = fits.FitsHDU.fromfile(self.temp('test.fits'))\nastropy\/io\/fits\/tests\/test_nonstandard.py:        assert fits.FITSDiff(hdul, hdul2).identical\nastropy\/io\/fits\/tests\/test_nonstandard.py:        fitshdu = fits.FitsHDU.fromhdulist(hdul_orig, compress=compression)\nastropy\/io\/fits\/tests\/test_nonstandard.py:        assert isinstance(hdul[-1], fits.FitsHDU)\nastropy\/io\/fits\/tests\/test_nonstandard.py:        assert isinstance(wrapped, fits.HDUList)\nastropy\/io\/fits\/tests\/test_fitscheck.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_fitscheck.py:            hdul[0].header['DATASUM'] = '1       '\nastropy\/io\/fits\/tests\/test_fitscheck.py:            hdul[1].header['DATASUM'] = '2349680925'\nastropy\/io\/fits\/tests\/test_fitscheck.py:            hdul[1].header['CHECKSUM'] = '11daD8bX98baA8bU'\nastropy\/io\/fits\/tests\/test_fitscheck.py:        assert 'BAD' in stderr\nastropy\/io\/fits\/tests\/test_fitscheck.py:        assert 'BAD' in stderr\nastropy\/visualization\/wcsaxes\/transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_checksum.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_checksum.py:from ..hdu.base import _ValidHDU\nastropy\/io\/fits\/tests\/test_checksum.py:            message='Datasum verification failed')\nastropy\/io\/fits\/tests\/test_checksum.py:        self._old_get_timestamp = _ValidHDU._get_timestamp\nastropy\/io\/fits\/tests\/test_checksum.py:        _ValidHDU._get_timestamp = lambda self: '2013-12-20T13:36:10'\nastropy\/io\/fits\/tests\/test_checksum.py:        _ValidHDU._get_timestamp = self._old_get_timestamp\nastropy\/io\/fits\/tests\/test_checksum.py:        hdu = fits.PrimaryHDU(n)\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert hdul[0].header['DATASUM'] == '4950'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in hdul1[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert hdul1[0].header['DATASUM'] == '1891563534'\nastropy\/io\/fits\/tests\/test_checksum.py:                    assert hdr1['DATASUM'] == hdr2['DATASUM']\nastropy\/io\/fits\/tests\/test_checksum.py:                    assert hdr1['DATASUM'] != hdr3['DATASUM']\nastropy\/io\/fits\/tests\/test_checksum.py:            ('aDcXaCcXaCcXaCcX', '0'), ('oYiGqXi9oXiEoXi9', '1746888714'),\nastropy\/io\/fits\/tests\/test_checksum.py:                    assert 'DATASUM' in hdul[idx].header\nastropy\/io\/fits\/tests\/test_checksum.py:                    assert hdul[idx].header['DATASUM'] == checksums[idx][1]\nastropy\/io\/fits\/tests\/test_checksum.py:        x = fits.hdu.groups.GroupData(imdata, parnames=[str('abc'), str('xyz')],\nastropy\/io\/fits\/tests\/test_checksum.py:        hdu = fits.GroupsHDU(x)\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['CHECKSUM'] == '3eDQAZDO4dDOAZDO'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['DATASUM'] == '2797758084'\nastropy\/io\/fits\/tests\/test_checksum.py:        cols = fits.ColDefs([col1, col2])\nastropy\/io\/fits\/tests\/test_checksum.py:        tbhdu = fits.BinTableHDU.from_columns(cols)\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['CHECKSUM'] == 'D8iBD6ZAD6fAD6ZA'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[1].header['CHECKSUM'] == 'aD1Oa90MaC0Ma90M'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[1].header['DATASUM'] == '1062205743'\nastropy\/io\/fits\/tests\/test_checksum.py:        tbhdu = fits.BinTableHDU.from_columns([c1, c2])\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['CHECKSUM'] == 'D8iBD6ZAD6fAD6ZA'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[1].header['DATASUM'] == '1507485'\nastropy\/io\/fits\/tests\/test_checksum.py:        # too much precision when scaling so it was changed to a D\nastropy\/io\/fits\/tests\/test_checksum.py:        c2 = fits.Column(name='def', format='D', array=r1, bscale=2.3,\nastropy\/io\/fits\/tests\/test_checksum.py:        x = fits.ColDefs([c1, c2, c3])\nastropy\/io\/fits\/tests\/test_checksum.py:        hdu = fits.TableHDU.from_columns(x)\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['CHECKSUM'] == 'D8iBD6ZAD6fAD6ZA'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert hdul[1].header['CHECKSUM'] == '51IDA1G981GCA1G9'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert hdul[1].header['DATASUM'] == '1948208413'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert h2[0].header['CHECKSUM'] == 'D8iBD6ZAD6fAD6ZA'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in h2[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert h2[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in h2[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert h2[1].header['DATASUM'] == '113055149'\nastropy\/io\/fits\/tests\/test_checksum.py:        hdu = fits.ImageHDU(n)\nastropy\/io\/fits\/tests\/test_checksum.py:        comp_hdu = fits.CompImageHDU(hdu.data, hdu.header)\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['CHECKSUM'] == 'D8iBD6ZAD6fAD6ZA'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[1]._header['DATASUM'] == '2453673070'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'ZDATASUM' in header_comp\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in header_uncomp\nastropy\/io\/fits\/tests\/test_checksum.py:                assert header_uncomp['DATASUM'] == '160565700'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert header_comp['ZDATASUM'] == header_uncomp['DATASUM']\nastropy\/io\/fits\/tests\/test_checksum.py:        hdu = fits.ImageHDU(n)\nastropy\/io\/fits\/tests\/test_checksum.py:        comp_hdu = fits.CompImageHDU(hdu.data, hdu.header)\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['CHECKSUM'] == 'D8iBD6ZAD6fAD6ZA'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert hdul[1]._header['DATASUM'] == '1277667818'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'ZDATASUM' in header_comp\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in header_uncomp\nastropy\/io\/fits\/tests\/test_checksum.py:                assert header_uncomp['DATASUM'] == '2393636889'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert header_comp['ZDATASUM'] == header_uncomp['DATASUM']\nastropy\/io\/fits\/tests\/test_checksum.py:        hdu = fits.ImageHDU(n)\nastropy\/io\/fits\/tests\/test_checksum.py:        datasum are added to HDUs that did not previously have one.\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[1].header['CHECKSUM'] == '99daD8bX98baA8bU'\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert hdul[1].header['DATASUM'] == '1829680925'\nastropy\/io\/fits\/tests\/test_checksum.py:        hdu = fits.ImageHDU(n)\nastropy\/io\/fits\/tests\/test_checksum.py:                pytest.fail(msg='Missing DATASUM keyword')\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' in header2\nastropy\/io\/fits\/tests\/test_checksum.py:            assert 'DATASUM' not in header2\nastropy\/io\/fits\/tests\/test_checksum.py:            hdul[0].header['DATASUM'] = '1       '\nastropy\/io\/fits\/tests\/test_checksum.py:            hdul[1].header['DATASUM'] = '2349680925'\nastropy\/io\/fits\/tests\/test_checksum.py:            hdul[1].header['CHECKSUM'] = '11daD8bX98baA8bU'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in hdul[0].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert hdul[0].header['DATASUM'] == '0'\nastropy\/io\/fits\/tests\/test_checksum.py:                assert 'DATASUM' in hdul[1].header\nastropy\/io\/fits\/tests\/test_checksum.py:                assert hdul[1].header['DATASUM'] == ref[1].header['DATASUM']\nastropy\/io\/fits\/tests\/test_checksum.py:            pytest.fail(msg='Missing DATASUM keyword')\nastropy\/visualization\/wcsaxes\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/core.py:from matplotlib.transforms import Affine2D, Bbox, Transform\nastropy\/visualization\/wcsaxes\/core.py:IDENTITY = WCS(naxis=2)\nastropy\/visualization\/wcsaxes\/core.py:IDENTITY.wcs.ctype = [\"X\", \"Y\"]\nastropy\/visualization\/wcsaxes\/core.py:IDENTITY.wcs.crval = [0., 0.]\nastropy\/visualization\/wcsaxes\/core.py:IDENTITY.wcs.crpix = [1., 1.]\nastropy\/visualization\/wcsaxes\/core.py:IDENTITY.wcs.cdelt = [1., 1.]\nastropy\/visualization\/wcsaxes\/core.py:    transData : `~matplotlib.transforms.Transform`, optional\nastropy\/visualization\/wcsaxes\/core.py:        choose which dimensions are being shown in the 2D image. The slice\nastropy\/visualization\/wcsaxes\/core.py:                 transData=None, slices=None, frame_class=RectangularFrame,\nastropy\/visualization\/wcsaxes\/core.py:        if not (transData is None):\nastropy\/visualization\/wcsaxes\/core.py:            self.transData = transData\nastropy\/visualization\/wcsaxes\/core.py:            self.wcs = IDENTITY\nastropy\/visualization\/wcsaxes\/core.py:        This does not include the transData transformation\nastropy\/visualization\/wcsaxes\/core.py:        return self._get_transform_no_transdata(frame).inverted() + self.transData\nastropy\/visualization\/wcsaxes\/core.py:            return Affine2D()\nastropy\/io\/fits\/tests\/test_structured.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/visualization\/wcsaxes\/ticklabels.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/wcsaxes\/ticklabels.py:                # TODO: the problem here is that we might get rid of a label\nastropy\/visualization\/tests\/test_norm.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_norm.py:DATA = np.linspace(0., 15., 6)\nastropy\/visualization\/tests\/test_norm.py:DATA2 = np.arange(3)\nastropy\/visualization\/tests\/test_norm.py:DATA2SCL = 0.5 * DATA2\nastropy\/visualization\/tests\/test_norm.py:        norm2 = ImageNormalize(DATA, interval=ManualInterval(2, 10),\nastropy\/visualization\/tests\/test_norm.py:        output = norm(DATA)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(output, norm2(DATA))\nastropy\/visualization\/tests\/test_norm.py:        norm2 = ImageNormalize(DATA, interval=ManualInterval(2, 10),\nastropy\/visualization\/tests\/test_norm.py:        output = norm(DATA)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm.inverse(norm(DATA))[1:], DATA[1:])\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(output, norm2(DATA))\nastropy\/visualization\/tests\/test_norm.py:        norm2 = ImageNormalize(DATA, interval=ManualInterval(None, 10),\nastropy\/visualization\/tests\/test_norm.py:        output = norm(DATA)\nastropy\/visualization\/tests\/test_norm.py:        assert norm.vmin == np.min(DATA)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(output, norm2(DATA))\nastropy\/visualization\/tests\/test_norm.py:        norm2 = ImageNormalize(DATA, interval=ManualInterval(2, None),\nastropy\/visualization\/tests\/test_norm.py:        output = norm(DATA)\nastropy\/visualization\/tests\/test_norm.py:        assert norm.vmax == np.max(DATA)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(output, norm2(DATA))\nastropy\/visualization\/tests\/test_norm.py:        mdata = ma.array(DATA, mask=[0, 0, 1, 0, 0, 0])\nastropy\/visualization\/tests\/test_norm.py:        mdata = ma.array(DATA, mask=[0, 0, 1, 0, 0, 0])\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm.inverse(norm(DATA))[1:], DATA[1:])\nastropy\/visualization\/tests\/test_norm.py:        norm = simple_norm(DATA2, stretch='linear')\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), DATA2SCL, atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:        norm = simple_norm(DATA2, stretch='sqrt')\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), np.sqrt(DATA2SCL), atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:        norm = simple_norm(DATA2, stretch='power', power=power)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), DATA2SCL ** power, atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:        norm = simple_norm(DATA2, stretch='log')\nastropy\/visualization\/tests\/test_norm.py:        ref = np.log10(1000 * DATA2SCL + 1.0) \/ np.log10(1001.0)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), ref, atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:        norm = simple_norm(DATA2, stretch='asinh', asinh_a=a)\nastropy\/visualization\/tests\/test_norm.py:        ref = np.arcsinh(DATA2SCL \/ a) \/ np.arcsinh(1. \/ a)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), ref, atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:        norm = simple_norm(DATA2, stretch='linear', min_cut=1.)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), [0., 0., 1.], atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:        norm = simple_norm(DATA2, stretch='linear', percent=99.)\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), DATA2SCL, atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:        norm2 = simple_norm(DATA2, stretch='linear', min_percent=0.5,\nastropy\/visualization\/tests\/test_norm.py:        assert_allclose(norm(DATA2), norm2(DATA2), atol=0, rtol=1.e-5)\nastropy\/visualization\/tests\/test_norm.py:            simple_norm(DATA2, stretch='invalid')\nastropy\/visualization\/tests\/test_histogram.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/core.py:A filter kernel is mainly characterized by its response function. In the 1D\nastropy\/convolution\/core.py:case we speak of \"impulse response function\", in the 2D case we call it \"point\nastropy\/convolution\/core.py:Currently only symmetric 2D kernels are supported.\nastropy\/convolution\/core.py:from .utils import (discretize_model, add_kernel_arrays_1D,\nastropy\/convolution\/core.py:                    add_kernel_arrays_2D)\nastropy\/convolution\/core.py:__all__ = ['Kernel', 'Kernel1D', 'Kernel2D', 'kernel_arithmetics']\nastropy\/convolution\/core.py:        Deviation from the normalization to one.\nastropy\/convolution\/core.py:        A 2D filter is separable, when its filter array can be written as the\nastropy\/convolution\/core.py:        outer product of two 1D arrays.\nastropy\/convolution\/core.py:        performed by applying the 1D filter array consecutively on every dimension.\nastropy\/convolution\/core.py:class Kernel1D(Kernel):\nastropy\/convolution\/core.py:    Base class for 1D filter kernels.\nastropy\/convolution\/core.py:        Size of the kernel array. Default = 8 * width.\nastropy\/convolution\/core.py:                Discretize model by taking the value\nastropy\/convolution\/core.py:                Discretize model by linearly interpolating\nastropy\/convolution\/core.py:                Discretize model by taking the average\nastropy\/convolution\/core.py:                Discretize model by integrating the\nastropy\/convolution\/core.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/core.py:class Kernel2D(Kernel):\nastropy\/convolution\/core.py:    Base class for 2D filter kernels.\nastropy\/convolution\/core.py:        Size in x direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/core.py:        Size in y direction of the kernel array. Default = 8 * width.\nastropy\/convolution\/core.py:                Discretize model by taking the value\nastropy\/convolution\/core.py:                Discretize model by performing a bilinear interpolation\nastropy\/convolution\/core.py:                Discretize model by taking the average\nastropy\/convolution\/core.py:                Discretize model by integrating the\nastropy\/convolution\/core.py:        Factor of oversampling. Default factor = 10.\nastropy\/convolution\/core.py:    # 1D kernels\nastropy\/convolution\/core.py:    if isinstance(kernel, Kernel1D) and isinstance(value, Kernel1D):\nastropy\/convolution\/core.py:            new_array = add_kernel_arrays_1D(kernel.array, value.array)\nastropy\/convolution\/core.py:            new_array = add_kernel_arrays_1D(kernel.array, -value.array)\nastropy\/convolution\/core.py:        new_kernel = Kernel1D(array=new_array)\nastropy\/convolution\/core.py:    # 2D kernels\nastropy\/convolution\/core.py:    elif isinstance(kernel, Kernel2D) and isinstance(value, Kernel2D):\nastropy\/convolution\/core.py:            new_array = add_kernel_arrays_2D(kernel.array, value.array)\nastropy\/convolution\/core.py:            new_array = add_kernel_arrays_2D(kernel.array, -value.array)\nastropy\/convolution\/core.py:        new_kernel = Kernel2D(array=new_array)\nastropy\/convolution\/core.py:    elif ((isinstance(kernel, Kernel1D) or isinstance(kernel, Kernel2D))\nastropy\/visualization\/tests\/test_lupton_rgb.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_lupton_rgb.py:from ...convolution import convolve, Gaussian2DKernel\nastropy\/visualization\/tests\/test_lupton_rgb.py:    \"\"\"Display an rgb image using matplotlib (useful for debugging)\"\"\"\nastropy\/visualization\/tests\/test_lupton_rgb.py:        psf = Gaussian2DKernel(2.5)\nastropy\/visualization\/tests\/test_lupton_rgb.py:        # TODO: Cannot test with these options yet, as that part of the code is not implemented.\nastropy\/io\/fits\/tests\/test_table.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_table.py:from ....utils.exceptions import AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_table.py:from ..column import Delayed, NUMPY2FITS\nastropy\/io\/fits\/tests\/test_table.py:    Does this field by field, using approximation testing for float columns\nastropy\/io\/fits\/tests\/test_table.py:        Ensure that a header from one HDU is copied when used to initialize new\nastropy\/io\/fits\/tests\/test_table.py:        HDU.\nastropy\/io\/fits\/tests\/test_table.py:        ifd = fits.HDUList([fits.PrimaryHDU(), fits.BinTableHDU()])\nastropy\/io\/fits\/tests\/test_table.py:        thdu = fits.BinTableHDU(header=thdr)\nastropy\/io\/fits\/tests\/test_table.py:        ofd = fits.HDUList(thdu)\nastropy\/io\/fits\/tests\/test_table.py:        # Note that X format must be two-D array\nastropy\/io\/fits\/tests\/test_table.py:        x = fits.ColDefs([c1, c2, c3, c4, c5, c6, c7, c8])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(x)\nastropy\/io\/fits\/tests\/test_table.py:        x2 = fits.ColDefs(tt[1])\nastropy\/io\/fits\/tests\/test_table.py:        t2 = fits.BinTableHDU.from_columns(x2, nrows=2)\nastropy\/io\/fits\/tests\/test_table.py:        # the table HDU's data is a subclass of a record array, so we can\nastropy\/io\/fits\/tests\/test_table.py:        xx = fits.ColDefs(tt[1])\nastropy\/io\/fits\/tests\/test_table.py:        # now we write out the newly created table HDU to a FITS file:\nastropy\/io\/fits\/tests\/test_table.py:        fout = fits.HDUList(fits.PrimaryHDU())\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.TableHDU.from_columns([c2, c1, c3])\nastropy\/io\/fits\/tests\/test_table.py:        cols = fits.ColDefs([col])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(cols)\nastropy\/io\/fits\/tests\/test_table.py:        rfiHDU = hduL['RFI']\nastropy\/io\/fits\/tests\/test_table.py:        data = rfiHDU.data\nastropy\/io\/fits\/tests\/test_table.py:        col1 = fits.Column(name='a', format='D', array=a1)\nastropy\/io\/fits\/tests\/test_table.py:        col2 = fits.Column(name='b', format='D', array=a2)\nastropy\/io\/fits\/tests\/test_table.py:        cols = fits.ColDefs([col1, col2])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(cols)\nastropy\/io\/fits\/tests\/test_table.py:        # Double check that the array is converted to the correct byte-order\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(bright)\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(a)\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(a)\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.TableHDU.from_columns(bright, nrows=2)\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that all ndarray objects within the HDU reference the\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU.from_columns(bright, nrows=2)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU.from_columns(t1[1].columns, nrows=nrows)\nastropy\/io\/fits\/tests\/test_table.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 4, (), '', ''),\nastropy\/io\/fits\/tests\/test_table.py:                (1, '', 1, 'BinTableHDU', 19, '8R x 5C', '[10A, J, 10A, 5E, L]',\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu1 = fits.BinTableHDU.from_columns(coldefs1)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts1', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU.from_columns(t1[1].columns + t2[1].columns)\nastropy\/io\/fits\/tests\/test_table.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 4, (), '', ''),\nastropy\/io\/fits\/tests\/test_table.py:                (1, '', 1, 'BinTableHDU', 30, '4R x 10C',\nastropy\/io\/fits\/tests\/test_table.py:        b = fits.BinTableHDU(data=data)\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(newtbdata)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu1 = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN')\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs, nrows=5)\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that all ndarray objects within the HDU reference the\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu1 = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu2 = fits.BinTableHDU.from_columns(tbhdu1.data, nrows=9)\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that all ndarray objects within the HDU reference the\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that original ColDefs object has independent Column\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that original ColDefs object has independent ndarray\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that original ColDefs object references the same data\nastropy\/io\/fits\/tests\/test_table.py:        # Verify new HDU has an independent ColDefs object.\nastropy\/io\/fits\/tests\/test_table.py:        # Verify new HDU has independent Column objects.\nastropy\/io\/fits\/tests\/test_table.py:        # Verify new HDU has independent ndarray objects.\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that both ColDefs objects in the HDU reference the same\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that all ndarray objects within the HDU reference the\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu1 = fits.BinTableHDU.from_columns(tbhdu.data.view(np.ndarray))\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that all ndarray objects within the HDU reference the\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu1 = fits.BinTableHDU.from_columns(fr)\nastropy\/io\/fits\/tests\/test_table.py:        c2 = fits.Column(name='counts', format='J', unit='DN', array=counts)\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1, c2, c3, c4, c5])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu1 = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(tbhdu1.data)\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that all ndarray objects within the HDU reference the\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that the references in the original HDU are the same as the\nastropy\/io\/fits\/tests\/test_table.py:        # references in the new HDU.\nastropy\/io\/fits\/tests\/test_table.py:        # Verify that a change in the new HDU is reflected in both the new\nastropy\/io\/fits\/tests\/test_table.py:        # and original HDU.\nastropy\/io\/fits\/tests\/test_table.py:        Passing name='...' to the BinTableHDU and TableHDU constructors\nastropy\/io\/fits\/tests\/test_table.py:        for hducls in [fits.BinTableHDU, fits.TableHDU]:\nastropy\/io\/fits\/tests\/test_table.py:        for hducls in [fits.BinTableHDU, fits.TableHDU]:\nastropy\/io\/fits\/tests\/test_table.py:        fits.BinTableHDU.from_columns([col])\nastropy\/io\/fits\/tests\/test_table.py:        coldefs = fits.ColDefs([c1])\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu1 = fits.BinTableHDU.from_columns(coldefs)\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(tbhdu1.data)\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = hdul[2]  # This HDU contains a zero-width column 'ORBPARM'\nastropy\/io\/fits\/tests\/test_table.py:        ahdu = fits.BinTableHDU.from_columns([acol])\nastropy\/io\/fits\/tests\/test_table.py:        ahdu = fits.TableHDU.from_columns([acol])\nastropy\/io\/fits\/tests\/test_table.py:            ahdu = fits.BinTableHDU.from_columns(hdul[1].data.copy())\nastropy\/io\/fits\/tests\/test_table.py:        thdu = fits.BinTableHDU.from_columns(data)\nastropy\/io\/fits\/tests\/test_table.py:        # Modify the TDIM fields to my own specification\nastropy\/io\/fits\/tests\/test_table.py:        thdu.header['TDIM1'] = '(2,3)'\nastropy\/io\/fits\/tests\/test_table.py:        thdu.header['TDIM2'] = '(4,2)'\nastropy\/io\/fits\/tests\/test_table.py:        # Test setting the TDIMn header based on the column data\nastropy\/io\/fits\/tests\/test_table.py:        Tests two ways of creating a new `BinTableHDU` from a column of\nastropy\/io\/fits\/tests\/test_table.py:        both BinTableHDU(data=arr) and BinTableHDU.from_columns(arr) work\nastropy\/io\/fits\/tests\/test_table.py:            tbhdu1 = fits.BinTableHDU(data=arr)\nastropy\/io\/fits\/tests\/test_table.py:                assert tbhdu2.header['TDIM1'] == '(4,2,3)'\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu2 = fits.BinTableHDU.from_columns(arr)\nastropy\/io\/fits\/tests\/test_table.py:            If the number of elements in the array implied by the TDIMn is less\nastropy\/io\/fits\/tests\/test_table.py:        than the number of elements indicated by its TDIM (ex: TDIM1 = '(2,2)',\nastropy\/io\/fits\/tests\/test_table.py:        to take the first 4 elements as implied by the TDIM and ignore the\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU(data=arr)\nastropy\/io\/fits\/tests\/test_table.py:        # Artificially truncate TDIM in the header; this seems to be the\nastropy\/io\/fits\/tests\/test_table.py:            assert tbhdu2.header['TDIM1'] == '(2,2,2)'\nastropy\/io\/fits\/tests\/test_table.py:        t = fits.BinTableHDU(data=recarr)\nastropy\/io\/fits\/tests\/test_table.py:            assert 'TDIM1' in h[1].header\nastropy\/io\/fits\/tests\/test_table.py:            assert h[1].header['TDIM1'] == '(3,3,3)'\nastropy\/io\/fits\/tests\/test_table.py:            assert 'TDIM1' in h[1].header\nastropy\/io\/fits\/tests\/test_table.py:            assert h[1].header['TDIM1'] == '(3,3,3)'\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU.from_columns(fits.ColDefs(cols))\nastropy\/io\/fits\/tests\/test_table.py:        \"\"\"Normally the product of the dimensions listed in a TDIMn keyword\nastropy\/io\/fits\/tests\/test_table.py:        dimensions specified by TDIMn are greater than the repeat count.\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU.from_columns(fits.ColDefs(cols))\nastropy\/io\/fits\/tests\/test_table.py:            assert h[1].header['TDIM1'] == h[1].header['TDIM2'] == '(2,2)'\nastropy\/io\/fits\/tests\/test_table.py:        new_tbhdu = fits.BinTableHDU.load(datafile, cdfile, hfile)\nastropy\/io\/fits\/tests\/test_table.py:        # Double check that the headers are equivalent\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns(data)\nastropy\/io\/fits\/tests\/test_table.py:        new_tbhdu = fits.BinTableHDU.load(datafile, cdfile, hfile)\nastropy\/io\/fits\/tests\/test_table.py:        c6 = fits.Column(name='c6', format='D', array=a6)\nastropy\/io\/fits\/tests\/test_table.py:        tbhdu = fits.BinTableHDU.from_columns([c0, c2, c3, c4, c5, c6, c7, c8])\nastropy\/io\/fits\/tests\/test_table.py:        new_tbhdu = fits.BinTableHDU.load(datafile)\nastropy\/io\/fits\/tests\/test_table.py:        t = fits.BinTableHDU.from_columns([c1, c2, c3])\nastropy\/io\/fits\/tests\/test_table.py:        thdu = fits.BinTableHDU.from_columns(array)\nastropy\/io\/fits\/tests\/test_table.py:        a bool field is used to initialize a `BinTableHDU`.\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(data=arr)\nastropy\/io\/fits\/tests\/test_table.py:        thdu = fits.BinTableHDU.from_columns(fits.ColDefs([c1, c2]))\nastropy\/io\/fits\/tests\/test_table.py:        table = fits.TableHDU.from_columns([c])\nastropy\/io\/fits\/tests\/test_table.py:        table = fits.TableHDU.from_columns([c1])\nastropy\/io\/fits\/tests\/test_table.py:        table = fits.TableHDU.from_columns([c2])\nastropy\/io\/fits\/tests\/test_table.py:            # (Currently it should evaluate to 0.0, but if a TODO in fitsrec is\nastropy\/io\/fits\/tests\/test_table.py:        yet, so new_table has to get at it through the Delayed proxy.\nastropy\/io\/fits\/tests\/test_table.py:        BinTableHDU.from_columns directly, around which new_table is a mere\nastropy\/io\/fits\/tests\/test_table.py:        assert isinstance(hdul[1].columns._arrays[0], Delayed)\nastropy\/io\/fits\/tests\/test_table.py:        t = fits.BinTableHDU.from_columns(hdul[1].columns)\nastropy\/io\/fits\/tests\/test_table.py:        assert not isinstance(hdul[1].columns._arrays[0], Delayed)\nastropy\/io\/fits\/tests\/test_table.py:        \"\"\"Tests initializing a TableHDU with the data from a BinTableHDU.\"\"\"\nastropy\/io\/fits\/tests\/test_table.py:            tbhdu = fits.TableHDU(data=tbdata)\nastropy\/io\/fits\/tests\/test_table.py:            assert isinstance(btb[1].columns._arrays[0], Delayed)\nastropy\/io\/fits\/tests\/test_table.py:            assert not isinstance(btb[1].columns._arrays[0], Delayed)\nastropy\/io\/fits\/tests\/test_table.py:            # Doesn't pickle zero-width (_phanotm) column 'ORBPARM'\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(array)\nastropy\/io\/fits\/tests\/test_table.py:        assert hdu.header['TDIM3'] == '(2,3)'\nastropy\/io\/fits\/tests\/test_table.py:        When creating a table column with non-trivial TDIMn, and\nastropy\/io\/fits\/tests\/test_table.py:        data = fits.getdata(self.data('random_groups.fits'))['DATA']\nastropy\/io\/fits\/tests\/test_table.py:        thdu = fits.BinTableHDU.from_columns([col])\nastropy\/io\/fits\/tests\/test_table.py:        # Double check that the original data1 table hasn't been affected by\nastropy\/io\/fits\/tests\/test_table.py:        # Test update but with a non-trivial TDIMn\nastropy\/io\/fits\/tests\/test_table.py:            assert hdul[1].header['TDIM1'] == '(3,3,2)'\nastropy\/io\/fits\/tests\/test_table.py:            assert hdul[1].header['TDIM1'] == '(3,3,2)'\nastropy\/io\/fits\/tests\/test_table.py:        from .test_connect import TestMultipleHDU\nastropy\/io\/fits\/tests\/test_table.py:        t3 = TestMultipleHDU()\nastropy\/io\/fits\/tests\/test_table.py:            with catch_warnings(AstropyDeprecationWarning) as warning_lines:\nastropy\/io\/fits\/tests\/test_table.py:                assert warning_lines[0].category == AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_table.py:            tb_hdu = fits.BinTableHDU.from_columns([col])\nastropy\/io\/fits\/tests\/test_table.py:            pri_hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_table.py:            hdu_list = fits.HDUList([pri_hdu, tb_hdu])\nastropy\/io\/fits\/tests\/test_table.py:            tb_hdu = fits.BinTableHDU.from_columns([col1, col2], nrows=15)\nastropy\/io\/fits\/tests\/test_table.py:            tbhdu = fits.BinTableHDU.from_columns([acol])\nastropy\/io\/fits\/tests\/test_table.py:                assert tbhdu1[1].columns[0].format.endswith('D(2)')\nastropy\/io\/fits\/tests\/test_table.py:        for code in ('PD()', 'QD()'):\nastropy\/io\/fits\/tests\/test_table.py:            tbhdu = fits.BinTableHDU.from_columns([acol])\nastropy\/io\/fits\/tests\/test_table.py:                assert tbhdu1[1].columns[0].format.endswith('D(2)')\nastropy\/io\/fits\/tests\/test_table.py:        for code in ('PD()', 'QD()'):\nastropy\/io\/fits\/tests\/test_table.py:            tbhdu = fits.BinTableHDU.from_columns([acol])\nastropy\/io\/fits\/tests\/test_table.py:            tbhdu = fits.BinTableHDU.from_columns([acol])\nastropy\/io\/fits\/tests\/test_table.py:            tb_hdu = fits.BinTableHDU.from_columns([col])\nastropy\/io\/fits\/tests\/test_table.py:            pri_hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_table.py:            hdu_list = fits.HDUList([pri_hdu, tb_hdu])\nastropy\/io\/fits\/tests\/test_table.py:        t1 = fits.BinTableHDU.from_columns([c, c1])\nastropy\/io\/fits\/tests\/test_table.py:        t2 = fits.BinTableHDU.from_columns([c, c2])\nastropy\/io\/fits\/tests\/test_table.py:        hdul = fits.HDUList([fits.PrimaryHDU(), t1, t2])\nastropy\/io\/fits\/tests\/test_table.py:            new_hdu = fits.BinTableHDU(data=h[2].data, header=h[2].header)\nastropy\/io\/fits\/tests\/test_table.py:        new_hdul = fits.HDUList([fits.PrimaryHDU()])\nastropy\/io\/fits\/tests\/test_table.py:# These are tests that solely test the Column and ColDefs interfaces and\nastropy\/io\/fits\/tests\/test_table.py:        c = fits.Column('TEST', 'D15.8')\nastropy\/io\/fits\/tests\/test_table.py:        assert c.format.format == 'D'\nastropy\/io\/fits\/tests\/test_table.py:        c = fits.Column('TEST', 'D10.0')\nastropy\/io\/fits\/tests\/test_table.py:        assert c.format.format == 'D'\nastropy\/io\/fits\/tests\/test_table.py:        c = fits.Column('TEST', 'D')\nastropy\/io\/fits\/tests\/test_table.py:        assert c.format == 'D'\nastropy\/io\/fits\/tests\/test_table.py:        c = fits.Column('TEST', 'D', ascii=True)\nastropy\/io\/fits\/tests\/test_table.py:        assert c.format == 'D25.17'\nastropy\/io\/fits\/tests\/test_table.py:        t = fits.TableHDU.from_columns([c])\nastropy\/io\/fits\/tests\/test_table.py:        \"\"\"Test that a TypeError is raised when a ColDefs is instantiated with\nastropy\/io\/fits\/tests\/test_table.py:        pytest.raises(TypeError, fits.ColDefs, [1, 2, 3])\nastropy\/io\/fits\/tests\/test_table.py:            assert isinstance(btb[1].columns._arrays[0], Delayed)\nastropy\/io\/fits\/tests\/test_table.py:            assert not isinstance(btb[1].columns._arrays[0], Delayed)\nastropy\/io\/fits\/tests\/test_table.py:            # Doesn't pickle zero-width (_phanotm) column 'ORBPARM'\nastropy\/io\/fits\/tests\/test_table.py:        \"\"\"Tests that a `ColDefs` can be indexed by column name.\"\"\"\nastropy\/io\/fits\/tests\/test_table.py:        a = fits.Column(name='a', format='D')\nastropy\/io\/fits\/tests\/test_table.py:        b = fits.Column(name='b', format='D')\nastropy\/io\/fits\/tests\/test_table.py:        cols = fits.ColDefs([a, b])\nastropy\/io\/fits\/tests\/test_table.py:        table = fits.BinTableHDU.from_columns([\nastropy\/io\/fits\/tests\/test_table.py:            fits.Column('a', format='D'),\nastropy\/io\/fits\/tests\/test_table.py:            fits.Column('b', format='D')])\nastropy\/io\/fits\/tests\/test_table.py:        table.columns.change_name('a', 'GOODBYE')\nastropy\/io\/fits\/tests\/test_table.py:        assert table.columns['GOODBYE'].name == 'GOODBYE'\nastropy\/io\/fits\/tests\/test_table.py:        assert table.data.dtype.names == ('GOODBYE',)\nastropy\/io\/fits\/tests\/test_table.py:        assert table.columns.names == ['GOODBYE']\nastropy\/io\/fits\/tests\/test_table.py:        assert table.data.columns.names == ['GOODBYE']\nastropy\/io\/fits\/tests\/test_table.py:        table.columns['GOODBYE'].name = 'foo'\nastropy\/io\/fits\/tests\/test_table.py:            table.columns['GOODBYE']\nastropy\/io\/fits\/tests\/test_table.py:        err_msgs = ['keyword arguments to Column were invalid', 'TNULL', 'TDISP',\nastropy\/io\/fits\/tests\/test_table.py:                    'TCTYP', 'TCUNI', 'TCRPX', 'TCRVL', 'TCDLT', 'TRPOS']\nastropy\/io\/fits\/tests\/test_table.py:    hdu = fits.BinTableHDU.from_columns([col])\nastropy\/io\/fits\/tests\/test_table.py:        hdu = fits.BinTableHDU(table, header=fits.Header({'TEST': 1}))\nastropy\/io\/fits\/tests\/test_hdulist.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_hdulist.py:from ....utils.exceptions import AstropyUserWarning, AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_hdulist.py:class TestHDUListFunctions(FitsTestCase):\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.ImageHDU(data=hdul[0].data)\nastropy\/io\/fits\/tests\/test_hdulist.py:        Ensure that a validation error occurs when saving an HDUList containing\nastropy\/io\/fits\/tests\/test_hdulist.py:        multiple PrimaryHDUs.\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList([fits.PrimaryHDU(), fits.PrimaryHDU()])\nastropy\/io\/fits\/tests\/test_hdulist.py:        # Tests appending a Simple PrimaryHDU to an empty HDUList.\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 5, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests appending a Simple ImageHDU to an empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.ImageHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 4, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests appending a Simple Table ExtensionHDU to a empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 4, (), '', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests appending a Simple GroupsHDU to an empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.GroupsHDU()\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'GroupsHDU', 8, (), '',\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests appending a Simple PrimaryHDU to a non-empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 7, (11, 10, 7), 'int32', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'ImageHDU', 6, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests appending a Simple ExtensionHDU to a non-empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 11, (), '', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (2, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests appending a Simple GroupsHDU to an empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.GroupsHDU()\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests inserting a Simple PrimaryHDU to an empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 5, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests inserting a Simple ImageHDU to an empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.ImageHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 4, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests inserting a Simple Table ExtensionHDU to a empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 4, (), '', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests inserting a Simple GroupsHDU to an empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.GroupsHDU()\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'GroupsHDU', 8, (), '',\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests inserting a Simple PrimaryHDU to a non-empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 7, (11, 10, 7), 'int32', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'ImageHDU', 6, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests inserting a Simple ExtensionHDU to a non-empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 11, (), '', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (2, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests inserting a Simple GroupsHDU to an empty HDUList.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.GroupsHDU()\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'GroupsHDU', 8, (), '',\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'ImageHDU', 6, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        Tests inserting a Simple GroupsHDU to the beginning of an HDUList\nastropy\/io\/fits\/tests\/test_hdulist.py:        that that already contains a GroupsHDU.\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.GroupsHDU()\nastropy\/io\/fits\/tests\/test_hdulist.py:        # Tests inserting a Simple ExtensionHDU to a non-empty HDUList.\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 4, (), '', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (2, '', 1, 'ImageHDU', 12, (), '', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (3, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        Tests inserting a Simple Image ExtensionHDU to a non-empty HDUList\nastropy\/io\/fits\/tests\/test_hdulist.py:        as the primary HDU.\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.ImageHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 5, (100,), 'int32', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (1, '', 1, 'ImageHDU', 12, (), '', ''),\nastropy\/io\/fits\/tests\/test_hdulist.py:                (2, '', 1, 'BinTableHDU', 24, '2R x 4C', '[1J, 3A, 1E, 1L]', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        \"\"\"Tests the HDUList filename method.\"\"\"\nastropy\/io\/fits\/tests\/test_hdulist.py:        in HDUList.writeto(), HDULIST.flush() or astropy.io.fits.writeto()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 5, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(np.arange(100, dtype=np.int32))\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 5, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        info = [(0, 'PRIMARY', 1, 'PrimaryHDU', 5, (100,), 'int32', '')]\nastropy\/io\/fits\/tests\/test_hdulist.py:        Tests that new extension HDUs that are added to an HDUList can be\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul.append(fits.ImageHDU(header=f[1].header))\nastropy\/io\/fits\/tests\/test_hdulist.py:        HDU.\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(data=arr)\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul.append(fits.PrimaryHDU())\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdul.append(fits.ImageHDU())\nastropy\/io\/fits\/tests\/test_hdulist.py:        del hdul[0].header['EXTEND']\nastropy\/io\/fits\/tests\/test_hdulist.py:        assert 'EXTEND' in hdul[0].header\nastropy\/io\/fits\/tests\/test_hdulist.py:        assert hdul[0].header['EXTEND'] is True\nastropy\/io\/fits\/tests\/test_hdulist.py:        Tests that adding a PrimaryHDU to a new HDUList object updates the\nastropy\/io\/fits\/tests\/test_hdulist.py:        EXTEND keyword on that HDU.\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(header=h0)\nastropy\/io\/fits\/tests\/test_hdulist.py:        sci = fits.ImageHDU(data=np.array(10))\nastropy\/io\/fits\/tests\/test_hdulist.py:        image = fits.HDUList([hdu, sci])\nastropy\/io\/fits\/tests\/test_hdulist.py:        assert 'EXTEND' in hdu.header\nastropy\/io\/fits\/tests\/test_hdulist.py:        assert hdu.header['EXTEND'] is True\nastropy\/io\/fits\/tests\/test_hdulist.py:            f.seek(0, os.SEEK_END)\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_hdulist.py:        end_card_pos = str(hdu.header).index('END' + ' ' * 77)\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(data=data)\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.PrimaryHDU(data=data)\nastropy\/io\/fits\/tests\/test_hdulist.py:        case of multiple consecutive flush() calls on the same HDUList object,\nastropy\/io\/fits\/tests\/test_hdulist.py:        phdu = fits.PrimaryHDU(data=data1)\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdu = fits.ImageHDU(data=data2)\nastropy\/io\/fits\/tests\/test_hdulist.py:        Test creating the HDUList structure in memory from a string containing\nastropy\/io\/fits\/tests\/test_hdulist.py:        # Tests HDUList.fromstring for all of Astropy's built in test files\nastropy\/io\/fits\/tests\/test_hdulist.py:                hdul2 = fits.HDUList.fromstring(dat)\nastropy\/io\/fits\/tests\/test_hdulist.py:                # TODO: That's probably possible, so one could make it work.\nastropy\/io\/fits\/tests\/test_hdulist.py:        # Test that creating an HDUList from something silly raises a TypeError\nastropy\/io\/fits\/tests\/test_hdulist.py:        pytest.raises(TypeError, fits.HDUList.fromstring, ['a', 'b', 'c'])\nastropy\/io\/fits\/tests\/test_hdulist.py:            hdu_a = fits.PrimaryHDU(data=arr_a)\nastropy\/io\/fits\/tests\/test_hdulist.py:            hdu_b = fits.PrimaryHDU(data=arr_b)\nastropy\/io\/fits\/tests\/test_hdulist.py:            hdu_a = fits.BinTableHDU.from_columns([col_a])\nastropy\/io\/fits\/tests\/test_hdulist.py:            hdu_b = fits.BinTableHDU.from_columns([col_b])\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist = fits.HDUList()\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist.append(fits.ImageHDU(name='a'))\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist = fits.HDUList([fits.PrimaryHDU()])\nastropy\/io\/fits\/tests\/test_hdulist.py:        with catch_warnings(AstropyDeprecationWarning) as warning_lines:\nastropy\/io\/fits\/tests\/test_hdulist.py:            assert warning_lines[0].category == AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist = fits.HDUList(fits.PrimaryHDU())\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist.append(fits.ImageHDU())\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist.append(fits.ImageHDU())\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist = fits.HDUList(fits.PrimaryHDU())\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist.append(fits.ImageHDU(name='SCI'))\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist.append(fits.ImageHDU(name='SCI'))\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist.append(fits.ImageHDU(name='nada'))\nastropy\/io\/fits\/tests\/test_hdulist.py:        hdulist.append(fits.ImageHDU(name='SCI'))\nastropy\/visualization\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_fitsdiff.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_fitsdiff.py:from ..hdu import PrimaryHDU\nastropy\/io\/fits\/tests\/test_fitsdiff.py:from ....utils.exceptions import AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_fitsdiff.py:class TestFITSDiff_script(FitsTestCase):\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:            '     Data differs at [1, 2]:',\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:Primary HDU:\\n\\n   Data contains differences:\nastropy\/io\/fits\/tests\/test_fitsdiff.py:     Data differs at [1, 2]:\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        with catch_warnings(AstropyDeprecationWarning) as warning_lines:\nastropy\/io\/fits\/tests\/test_fitsdiff.py:            assert warning_lines[0].category == AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_a = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_fitsdiff.py:        hdu_b = PrimaryHDU(data=b)\nastropy\/io\/fits\/tests\/test_diff.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_diff.py:from ..diff import (FITSDiff, HeaderDiff, ImageDataDiff, TableDataDiff,\nastropy\/io\/fits\/tests\/test_diff.py:                    HDUDiff, report_diff_values)\nastropy\/io\/fits\/tests\/test_diff.py:from ..hdu import HDUList, PrimaryHDU, ImageHDU\nastropy\/io\/fits\/tests\/test_diff.py:from ..hdu.table import BinTableHDU\nastropy\/io\/fits\/tests\/test_diff.py:from ....utils.exceptions import AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_diff.py:class TestDiff(FitsTestCase):\nastropy\/io\/fits\/tests\/test_diff.py:        assert HeaderDiff(ha, hb).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert HeaderDiff(ha.tostring(), hb.tostring()).identical\nastropy\/io\/fits\/tests\/test_diff.py:            HeaderDiff(1, 2)\nastropy\/io\/fits\/tests\/test_diff.py:        assert not HeaderDiff(ha, hb).identical\nastropy\/io\/fits\/tests\/test_diff.py:        hb['D'] = (5, 'Comment')\nastropy\/io\/fits\/tests\/test_diff.py:        assert HeaderDiff(ha, hb).common_keywords == ['A', 'B', 'C']\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        hb['D'] = (5, 'Comment')\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        assert diff.diff_keywords == (['E', 'F'], ['D'])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, rtol=1e-6)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, rtol=1e-5)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, rtol=1e-6)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, rtol=1e-5)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, atol=1e-6)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, atol=1e-5)  # strict inequality\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, rtol=1e-5, atol=1e-5)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, atol=1.1e-5)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, rtol=1e-6, atol=1e-6)\nastropy\/io\/fits\/tests\/test_diff.py:        with catch_warnings(AstropyDeprecationWarning) as warning_lines:\nastropy\/io\/fits\/tests\/test_diff.py:            diff = HeaderDiff(ha, hb, tolerance=1e-6)\nastropy\/io\/fits\/tests\/test_diff.py:            assert warning_lines[0].category == AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_diff.py:        with catch_warnings(AstropyDeprecationWarning) as warning_lines:\nastropy\/io\/fits\/tests\/test_diff.py:            diff = HeaderDiff(ha, hb, rtol=1e-6, tolerance=1e-5)\nastropy\/io\/fits\/tests\/test_diff.py:            assert warning_lines[0].category == AstropyDeprecationWarning\nastropy\/io\/fits\/tests\/test_diff.py:            diff = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:            # Don't ignore blanks\nastropy\/io\/fits\/tests\/test_diff.py:            diff = HeaderDiff(ha, hb, ignore_blanks=False)\nastropy\/io\/fits\/tests\/test_diff.py:        assert HeaderDiff(ha, hb).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert HeaderDiff(ha, hc).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert HeaderDiff(hb, hc).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert not HeaderDiff(ha, hb, ignore_blank_cards=False).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert not HeaderDiff(ha, hc, ignore_blank_cards=False).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert HeaderDiff(hb, hc, ignore_blank_cards=False).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert not HeaderDiff(hb, hc, ignore_blank_cards=False).identical\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, ignore_keywords=['*'])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, ignore_keywords=['B'])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, ignore_keywords=['b'])\nastropy\/io\/fits\/tests\/test_diff.py:        hb.comments['B'] = 'D'\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, ignore_comments=['*'])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, ignore_comments=['B'])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HeaderDiff(ha, hb, ignore_comments=['b'])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib, rtol=1.0e-4)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib, rtol=1.0e-4)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib, atol=1.0e-4)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib, rtol=1.0e-5, atol=1.0e-5)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib, rtol=1.0e-5, atol=1.0e-6)\nastropy\/io\/fits\/tests\/test_diff.py:        hdu = fits.CompImageHDU(data=data)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = FITSDiff(hdula, hdulb)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib)\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Data dimensions differ' in report\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(ia, ib)\nastropy\/io\/fits\/tests\/test_diff.py:        c4 = Column('D', format='J', bscale=2.0, array=[0, 1])\nastropy\/io\/fits\/tests\/test_diff.py:        c7 = Column('G', format='D', bzero=-0.1, array=[0.0, 1.0])\nastropy\/io\/fits\/tests\/test_diff.py:        ta = BinTableHDU.from_columns(columns)\nastropy\/io\/fits\/tests\/test_diff.py:        tb = BinTableHDU.from_columns([c.copy() for c in columns])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = TableDataDiff(ta.data, tb.data)\nastropy\/io\/fits\/tests\/test_diff.py:        c1 = Column('D', format='J')\nastropy\/io\/fits\/tests\/test_diff.py:        thdu = BinTableHDU.from_columns([c1, c2], nrows=0)\nastropy\/io\/fits\/tests\/test_diff.py:        hdula = fits.HDUList([thdu])\nastropy\/io\/fits\/tests\/test_diff.py:        hdulb = fits.HDUList([thdu])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = FITSDiff(hdula, hdulb)\nastropy\/io\/fits\/tests\/test_diff.py:        ta = BinTableHDU.from_columns([c1, c2, c3])\nastropy\/io\/fits\/tests\/test_diff.py:        tb = BinTableHDU.from_columns([c1, c4, c5])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = TableDataDiff(ta.data, tb.data, ignore_fields=['B', 'C'])\nastropy\/io\/fits\/tests\/test_diff.py:        ta = BinTableHDU.from_columns([ca, cb])\nastropy\/io\/fits\/tests\/test_diff.py:        tb = BinTableHDU.from_columns([ca, cc])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = TableDataDiff(ta.data, tb.data)\nastropy\/io\/fits\/tests\/test_diff.py:        ta = BinTableHDU.from_columns([cb])\nastropy\/io\/fits\/tests\/test_diff.py:        tb = BinTableHDU.from_columns([ca, cb, cc])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = TableDataDiff(ta.data, tb.data)\nastropy\/io\/fits\/tests\/test_diff.py:        ta = BinTableHDU.from_columns([ca1, cb1])\nastropy\/io\/fits\/tests\/test_diff.py:        tb = BinTableHDU.from_columns([ca2, cb2])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = TableDataDiff(ta.data, tb.data)\nastropy\/io\/fits\/tests\/test_diff.py:        ca4 = Column('D', format='J', bscale=2.0, array=[0.0, 2.0])\nastropy\/io\/fits\/tests\/test_diff.py:        ca7 = Column('G', format='D', bzero=-0.1, array=[0.0, 1.0])\nastropy\/io\/fits\/tests\/test_diff.py:        cb4 = Column('D', format='J', bscale=2.0, array=[2.0, 2.0])\nastropy\/io\/fits\/tests\/test_diff.py:        cb7 = Column('G', format='D', bzero=-0.1, array=[2.0, 3.0])\nastropy\/io\/fits\/tests\/test_diff.py:        ta = BinTableHDU.from_columns([ca1, ca2, ca3, ca4, ca5, ca6, ca7,\nastropy\/io\/fits\/tests\/test_diff.py:        tb = BinTableHDU.from_columns([cb1, cb2, cb3, cb4, cb5, cb6, cb7,\nastropy\/io\/fits\/tests\/test_diff.py:        diff = TableDataDiff(ta.data, tb.data, numdiffs=20)\nastropy\/io\/fits\/tests\/test_diff.py:        assert diff.diff_values[3] == (('D', 0), (0, 2.0))\nastropy\/io\/fits\/tests\/test_diff.py:                ' Column D data differs in row 0:') in report\nastropy\/io\/fits\/tests\/test_diff.py:        hdu = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = FITSDiff(self.temp('testa.fits'), self.temp('testb.fits'))\nastropy\/io\/fits\/tests\/test_diff.py:        # Primary HDUs should contain no differences\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Primary HDU' not in report\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Extension HDU' not in report\nastropy\/io\/fits\/tests\/test_diff.py:        ehdu = ImageHDU(data=a)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = HDUDiff(ehdu, ehdu)\nastropy\/io\/fits\/tests\/test_diff.py:        Test files that have some identical HDUs but a different extension\nastropy\/io\/fits\/tests\/test_diff.py:        phdu = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_diff.py:        ehdu = ImageHDU(data=a)\nastropy\/io\/fits\/tests\/test_diff.py:        hdula = HDUList([phdu, ehdu])\nastropy\/io\/fits\/tests\/test_diff.py:        hdulb = HDUList([phdu, ehdu, ehdu])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = FITSDiff(hdula, hdulb)\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Files contain different numbers of HDUs' in report\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'No differences found between common HDUs' in report\nastropy\/io\/fits\/tests\/test_diff.py:        Test files that have some identical HDUs but one different HDU.\nastropy\/io\/fits\/tests\/test_diff.py:        phdu = PrimaryHDU(data=a)\nastropy\/io\/fits\/tests\/test_diff.py:        ehdu = ImageHDU(data=a)\nastropy\/io\/fits\/tests\/test_diff.py:        ehdu2 = ImageHDU(data=(a + 1))\nastropy\/io\/fits\/tests\/test_diff.py:        hdula = HDUList([phdu, ehdu, ehdu])\nastropy\/io\/fits\/tests\/test_diff.py:        hdulb = HDUList([phdu, ehdu2, ehdu])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = FITSDiff(hdula, hdulb)\nastropy\/io\/fits\/tests\/test_diff.py:        assert isinstance(datadiff, ImageDataDiff)\nastropy\/io\/fits\/tests\/test_diff.py:        # Primary HDU and 2nd extension HDU should have no differences\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Primary HDU' not in report\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Extension HDU 2' not in report\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Extension HDU 1' in report\nastropy\/io\/fits\/tests\/test_diff.py:        assert 'Data contains differences' in report\nastropy\/io\/fits\/tests\/test_diff.py:            assert 'Data differs at [{}, 1]'.format(y + 1) in report\nastropy\/io\/fits\/tests\/test_diff.py:        Test files that have some identical HDUs but a different extension\nastropy\/io\/fits\/tests\/test_diff.py:        phdu = PrimaryHDU()\nastropy\/io\/fits\/tests\/test_diff.py:        ehdu = ImageHDU(name='FOO')\nastropy\/io\/fits\/tests\/test_diff.py:        hdula = HDUList([phdu, ehdu])\nastropy\/io\/fits\/tests\/test_diff.py:        ehdu = BinTableHDU(name='BAR')\nastropy\/io\/fits\/tests\/test_diff.py:        hdulb = HDUList([phdu, ehdu])\nastropy\/io\/fits\/tests\/test_diff.py:        diff = FITSDiff(hdula, hdulb)\nastropy\/io\/fits\/tests\/test_diff.py:        assert ImageDataDiff(arr, arr2).identical\nastropy\/io\/fits\/tests\/test_diff.py:        assert TableDataDiff(table, table2).identical\nastropy\/io\/fits\/tests\/test_diff.py:        diff = ImageDataDiff(arr, arr2)\nastropy\/io\/fits\/tests\/test_diff.py:        diff = TableDataDiff(table, table2)\nastropy\/io\/fits\/tests\/test_diff.py:        diffobj = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diffobj = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diffobj = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        diffobj = HeaderDiff(ha, hb)\nastropy\/io\/fits\/tests\/test_diff.py:        with catch_warnings(AstropyDeprecationWarning) as warning_lines:\nastropy\/io\/fits\/tests\/test_diff.py:            assert warning_lines[0].category == AstropyDeprecationWarning\nastropy\/visualization\/tests\/test_interval.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_interval.py:class TestInterval2D(TestInterval):\nastropy\/visualization\/tests\/test_interval.py:    # Don't accept integer array in output\nastropy\/io\/fits\/tests\/test_core.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_core.py:from ..diff import FITSDiff\nastropy\/io\/fits\/tests\/test_core.py:        p = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_core.py:        l = fits.HDUList()\nastropy\/io\/fits\/tests\/test_core.py:        t = fits.BinTableHDU.from_columns([c])\nastropy\/io\/fits\/tests\/test_core.py:        assert FITSDiff(hdulist2, hdulist).identical is True\nastropy\/io\/fits\/tests\/test_core.py:        p = fits.ColDefs([])\nastropy\/io\/fits\/tests\/test_core.py:            # TODO: The warning raised by this test is actually indication of a\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        class TestHDU(fits.hdu.base.NonstandardExtHDU):\nastropy\/io\/fits\/tests\/test_core.py:                # Since creating this HDU class adds it to the registry we\nastropy\/io\/fits\/tests\/test_core.py:                # HDU from a file should be handled by this class\nastropy\/io\/fits\/tests\/test_core.py:        hdu = TestHDU(header=fits.Header())\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:            hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        # silentfix+warn should be quiet about the fixed HDU and only warn\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:            hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        Tests creating a fully-formed HDU object from a string containing the\nastropy\/io\/fits\/tests\/test_core.py:        bytes of the HDU.\nastropy\/io\/fits\/tests\/test_core.py:            hdu = fits.PrimaryHDU.fromstring(dat[:hdulen])\nastropy\/io\/fits\/tests\/test_core.py:            assert isinstance(hdu, fits.PrimaryHDU)\nastropy\/io\/fits\/tests\/test_core.py:            assert isinstance(hdu, fits.PrimaryHDU)\nastropy\/io\/fits\/tests\/test_core.py:                hdu = fits.ImageHDU.fromstring(dat[offset:offset + hdulen])\nastropy\/io\/fits\/tests\/test_core.py:                assert isinstance(hdu, fits.ImageHDU)\nastropy\/io\/fits\/tests\/test_core.py:        Tests that \"Nonstandard\" HDUs with SIMPLE = F are read and written\nastropy\/io\/fits\/tests\/test_core.py:        without prepending a superfluous and unwanted standard primary HDU.\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.PrimaryHDU(data=data)\nastropy\/io\/fits\/tests\/test_core.py:        info = [(0, '', 1, 'NonstandardHDU', 5, (), '', '')]\nastropy\/io\/fits\/tests\/test_core.py:            # NonstandardHDUs just treat the data as an unspecified array of\nastropy\/io\/fits\/tests\/test_core.py:        \"\"\"Test getting\/setting the EXTNAME of an HDU.\"\"\"\nastropy\/io\/fits\/tests\/test_core.py:        h1 = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_core.py:        # Normally a PRIMARY HDU should not have an EXTNAME, though it should\nastropy\/io\/fits\/tests\/test_core.py:        # The current version of the FITS standard does allow PRIMARY HDUs to\nastropy\/io\/fits\/tests\/test_core.py:        # If we delete an EXTNAME keyword from a PRIMARY HDU it should go back\nastropy\/io\/fits\/tests\/test_core.py:        # For extension HDUs the situation is a bit simpler:\nastropy\/io\/fits\/tests\/test_core.py:        h2 = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        h2.header['EXTNAME'] = 'GOODBYE'\nastropy\/io\/fits\/tests\/test_core.py:        assert h2.name == 'GOODBYE'\nastropy\/io\/fits\/tests\/test_core.py:        \"\"\"Test getting\/setting the EXTVER and EXTLEVEL of and HDU.\"\"\"\nastropy\/io\/fits\/tests\/test_core.py:        h1 = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_core.py:        HDUList could write a corrupted file.\nastropy\/io\/fits\/tests\/test_core.py:        h = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_core.py:        h = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_core.py:        h = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.PrimaryHDU(data=data)\nastropy\/io\/fits\/tests\/test_core.py:        hdul = [fits.PrimaryHDU(), fits.ImageHDU()]\nastropy\/io\/fits\/tests\/test_core.py:        hdul = fits.HDUList(hdul)\nastropy\/io\/fits\/tests\/test_core.py:        hdul.insert(1, fits.ImageHDU())\nastropy\/io\/fits\/tests\/test_core.py:                pytest.raises(ValueError, fits.HDUList.fromfile, f)\nastropy\/io\/fits\/tests\/test_core.py:            with fits.HDUList.fromfile(f) as h:\nastropy\/io\/fits\/tests\/test_core.py:                with fits.HDUList.fromfile(f) as h:\nastropy\/io\/fits\/tests\/test_core.py:            with fits.HDUList.fromfile(f) as h:\nastropy\/io\/fits\/tests\/test_core.py:                # are no HDUs\nastropy\/io\/fits\/tests\/test_core.py:            with fits.HDUList.fromfile(f) as h:\nastropy\/io\/fits\/tests\/test_core.py:            with fits.HDUList.fromfile(f) as h:\nastropy\/io\/fits\/tests\/test_core.py:            # Double check that writing without mmap still worked\nastropy\/io\/fits\/tests\/test_core.py:        HDU data references left.\nastropy\/io\/fits\/tests\/test_core.py:        # The HDUList is closed; in fact, get rid of it completely\nastropy\/io\/fits\/tests\/test_core.py:        Demonstrates that FITS files can still be read from \"file-like\" objects\nastropy\/io\/fits\/tests\/test_core.py:        Demonstrates that writing an HDU containing a discontiguous Numpy array\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.PrimaryHDU(data=data)\nastropy\/io\/fits\/tests\/test_core.py:        hdu = fits.PrimaryHDU(data=np.arange(10))\nastropy\/io\/fits\/tests\/test_core.py:            monkeypatch.setattr(fits.hdu.base._BaseHDU, \"_writeto\", _writeto)\nastropy\/io\/fits\/tests\/test_core.py:            hdu = fits.PrimaryHDU(n)\nastropy\/io\/fits\/tests\/test_core.py:            hdulist = fits.HDUList(hdu)\nastropy\/io\/fits\/tests\/test_core.py:        hdul = [fits.PrimaryHDU(), fits.ImageHDU()]\nastropy\/io\/fits\/tests\/test_core.py:        hdul = fits.HDUList(hdul)\nastropy\/io\/fits\/tests\/test_core.py:        monkeypatch.setattr(fits.hdu.base._BaseHDU, \"_writedata\", _writedata)\nastropy\/io\/fits\/tests\/test_core.py:                hdul.insert(1, fits.ImageHDU())\nastropy\/io\/fits\/tests\/test_core.py:            hdul2 = fits.HDUList.fromstring(fileobj.getvalue())\nastropy\/io\/fits\/tests\/test_core.py:            assert FITSDiff(hdul, hdul2).identical\nastropy\/io\/fits\/tests\/test_core.py:    \"\"\"Test functionality of the StreamingHDU class.\"\"\"\nastropy\/io\/fits\/tests\/test_core.py:        Test that streaming an HDU to a file opened in the wrong mode fails as\nastropy\/io\/fits\/tests\/test_core.py:            fits.StreamingHDU(f, header)\nastropy\/io\/fits\/tests\/test_core.py:        \"\"\"Test streaming an HDU to an open file object.\"\"\"\nastropy\/io\/fits\/tests\/test_core.py:        \"\"\"Test streaming an HDU to an open file-like object.\"\"\"\nastropy\/io\/fits\/tests\/test_core.py:        # The file-like object underlying a StreamingHDU must be in binary mode\nastropy\/io\/fits\/tests\/test_core.py:        # Doing this again should update the file with an extension\nastropy\/io\/fits\/tests\/test_core.py:        phdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_core.py:        ihdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_core.py:        hdul = fits.HDUList([phdu, ihdu])\nastropy\/io\/fits\/tests\/test_core.py:        hd['EXTEND'] = True\nastropy\/io\/fits\/tests\/test_core.py:        return fits.StreamingHDU(fileobj, hd)\nastropy\/io\/fits\/tests\/test_convenience.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_convenience.py:        assert isinstance(hdu, fits.BinTableHDU)\nastropy\/io\/fits\/tests\/test_convenience.py:        hdus = [fits.PrimaryHDU(np.zeros((10, 10))),\nastropy\/io\/fits\/tests\/test_convenience.py:                fits.ImageHDU(np.zeros((10, 10)))]\nastropy\/io\/fits\/tests\/test_convenience.py:        fits.HDUList(hdus).writeto(filename)\nastropy\/io\/fits\/tests\/test_convenience.py:        Test that FITSDiff can run the different inputs without crashing.\nastropy\/io\/fits\/tests\/test_convenience.py:        # Test HDU object inputs\nastropy\/io\/tests\/test_registry.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/tests\/test_registry.py:_READERS_ORIGINAL = copy(_readers)\nastropy\/io\/tests\/test_registry.py:_IDENTIFIERS_ORIGINAL = copy(_identifiers)\nastropy\/io\/tests\/test_registry.py:class TestData:\nastropy\/io\/tests\/test_registry.py:    return TestData()\nastropy\/io\/tests\/test_registry.py:        io_registry.get_reader('test', TestData)\nastropy\/io\/tests\/test_registry.py:        \"No reader defined for format 'test' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:        io_registry.get_writer('test', TestData)\nastropy\/io\/tests\/test_registry.py:        \"No writer defined for format 'test' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test1', TestData, empty_reader)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test2', TestData, empty_reader)\nastropy\/io\/tests\/test_registry.py:    assert io_registry.get_reader('test1', TestData) == empty_reader\nastropy\/io\/tests\/test_registry.py:    assert io_registry.get_reader('test2', TestData) == empty_reader\nastropy\/io\/tests\/test_registry.py:    io_registry.unregister_reader('test1', TestData)\nastropy\/io\/tests\/test_registry.py:        io_registry.get_reader('test1', TestData)\nastropy\/io\/tests\/test_registry.py:    assert io_registry.get_reader('test2', TestData) == empty_reader\nastropy\/io\/tests\/test_registry.py:    io_registry.unregister_reader('test2', TestData)\nastropy\/io\/tests\/test_registry.py:        io_registry.get_reader('test2', TestData)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_writer('test1', TestData, empty_writer)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_writer('test2', TestData, empty_writer)\nastropy\/io\/tests\/test_registry.py:    assert io_registry.get_writer('test1', TestData) == empty_writer\nastropy\/io\/tests\/test_registry.py:    assert io_registry.get_writer('test2', TestData) == empty_writer\nastropy\/io\/tests\/test_registry.py:    io_registry.unregister_writer('test1', TestData)\nastropy\/io\/tests\/test_registry.py:        io_registry.get_writer('test1', TestData)\nastropy\/io\/tests\/test_registry.py:    assert io_registry.get_writer('test2', TestData) == empty_writer\nastropy\/io\/tests\/test_registry.py:    io_registry.unregister_writer('test2', TestData)\nastropy\/io\/tests\/test_registry.py:        io_registry.get_writer('test2', TestData)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test1', TestData, empty_identifier)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test2', TestData, empty_identifier)\nastropy\/io\/tests\/test_registry.py:    io_registry.unregister_identifier('test1', TestData)\nastropy\/io\/tests\/test_registry.py:    io_registry.unregister_identifier('test2', TestData)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test', TestData, empty_reader)\nastropy\/io\/tests\/test_registry.py:        io_registry.register_reader('test', TestData, empty_reader)\nastropy\/io\/tests\/test_registry.py:    assert (str(exc.value) == \"Reader for format 'test' and class 'TestData' \"\nastropy\/io\/tests\/test_registry.py:    io_registry.register_writer('test', TestData, empty_writer)\nastropy\/io\/tests\/test_registry.py:        io_registry.register_writer('test', TestData, empty_writer)\nastropy\/io\/tests\/test_registry.py:    assert (str(exc.value) == \"Writer for format 'test' and class 'TestData' \"\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test', TestData, empty_identifier)\nastropy\/io\/tests\/test_registry.py:        io_registry.register_identifier('test', TestData, empty_identifier)\nastropy\/io\/tests\/test_registry.py:                              \"'TestData' is already defined\")\nastropy\/io\/tests\/test_registry.py:        io_registry.unregister_reader('test', TestData)\nastropy\/io\/tests\/test_registry.py:    assert str(exc.value) == \"No reader defined for format 'test' and class 'TestData'\"\nastropy\/io\/tests\/test_registry.py:        io_registry.unregister_writer('test', TestData)\nastropy\/io\/tests\/test_registry.py:    assert str(exc.value) == \"No writer defined for format 'test' and class 'TestData'\"\nastropy\/io\/tests\/test_registry.py:        io_registry.unregister_identifier('test', TestData)\nastropy\/io\/tests\/test_registry.py:    assert str(exc.value) == \"No identifier defined for format 'test' and class 'TestData'\"\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test', TestData, empty_reader)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test', TestData, empty_reader, force=True)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_writer('test', TestData, empty_writer)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_writer('test', TestData, empty_writer, force=True)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test', TestData, empty_identifier)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test', TestData, empty_identifier, force=True)\nastropy\/io\/tests\/test_registry.py:        TestData.read()\nastropy\/io\/tests\/test_registry.py:        TestData().write()\nastropy\/io\/tests\/test_registry.py:    _identifiers.update(_IDENTIFIERS_ORIGINAL)\nastropy\/io\/tests\/test_registry.py:        TestData.read(object())\nastropy\/io\/tests\/test_registry.py:    _readers.update(_READERS_ORIGINAL)\nastropy\/io\/tests\/test_registry.py:    _identifiers.update(_IDENTIFIERS_ORIGINAL)\nastropy\/io\/tests\/test_registry.py:        TestData().write(object())\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test1', TestData, lambda o, *x, **y: True)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test2', TestData, lambda o, *x, **y: True)\nastropy\/io\/tests\/test_registry.py:        TestData.read()\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test1', TestData, lambda o, *x, **y: True)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test2', TestData, lambda o, *x, **y: True)\nastropy\/io\/tests\/test_registry.py:        TestData().write()\nastropy\/io\/tests\/test_registry.py:        TestData.read(format='test')\nastropy\/io\/tests\/test_registry.py:        \"No reader defined for format 'test' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:        TestData().write(format='test')\nastropy\/io\/tests\/test_registry.py:        \"No writer defined for format 'test' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:        'test1', TestData,\nastropy\/io\/tests\/test_registry.py:        'test2', TestData,\nastropy\/io\/tests\/test_registry.py:        TestData.read(filename)\nastropy\/io\/tests\/test_registry.py:        \"No reader defined for format 'test1' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:        TestData.read(filename)\nastropy\/io\/tests\/test_registry.py:        \"No reader defined for format 'test2' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test1', TestData, lambda o, *x, **y: x[0].startswith('a'))\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test2', TestData, lambda o, *x, **y: x[0].startswith('b'))\nastropy\/io\/tests\/test_registry.py:        TestData().write('abc')\nastropy\/io\/tests\/test_registry.py:        \"No writer defined for format 'test1' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:        TestData().write('bac')\nastropy\/io\/tests\/test_registry.py:        \"No writer defined for format 'test2' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test1', TestData, lambda o, *x, **y: o == 'read')\nastropy\/io\/tests\/test_registry.py:    io_registry.register_identifier('test2', TestData, lambda o, *x, **y: o == 'write')\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test1', TestData, empty_reader)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_writer('test2', TestData, empty_writer)\nastropy\/io\/tests\/test_registry.py:    TestData.read()\nastropy\/io\/tests\/test_registry.py:    TestData().write()\nastropy\/io\/tests\/test_registry.py:        TestData.read(format='test2')\nastropy\/io\/tests\/test_registry.py:        \"No reader defined for format 'test2' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:        TestData().write(format='test1')\nastropy\/io\/tests\/test_registry.py:        \"No writer defined for format 'test1' and class 'TestData'\")\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test', TestData, lambda: TestData())\nastropy\/io\/tests\/test_registry.py:    t = TestData.read(format='test')\nastropy\/io\/tests\/test_registry.py:    assert isinstance(t, TestData)\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test', TestData, lambda: 'spam')\nastropy\/io\/tests\/test_registry.py:        TestData.read(format='test')\nastropy\/io\/tests\/test_registry.py:    assert str(exc.value) == \"reader should return a TestData instance\"\nastropy\/io\/tests\/test_registry.py:    io_registry.register_reader('test', TestData, lambda: TestData())\nastropy\/io\/tests\/test_registry.py:    t = TestData.read(format='test')\nastropy\/io\/tests\/test_registry.py:    assert isinstance(t, TestData)\nastropy\/io\/tests\/test_registry.py:    _readers.update(_READERS_ORIGINAL)\nastropy\/io\/tests\/test_registry.py:    _identifiers.update(_IDENTIFIERS_ORIGINAL)\nastropy\/io\/fits\/tests\/test_fitsheader.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_fitsheader.py:        fitsheader.main(['-k', 'RANDOMKEY', self.data('arange.fits')])\nastropy\/io\/fits\/tests\/test_fitsheader.py:        assert err.startswith('WARNING') and 'RANDOMKEY' in err\nastropy\/io\/fits\/tests\/test_fitsheader.py:        fitsheader.main(['-e', '3', '-k', 'BACKGRND', self.data('test0.fits')])\nastropy\/io\/fits\/tests\/test_fitsheader.py:        assert out.splitlines()[1].startswith('BACKGRND=                 312.')\nastropy\/io\/fits\/tests\/test_fitsheader.py:        fitsheader.main(['-e', '0', '-k', 'BACKGRND', self.data('test0.fits')])\nastropy\/io\/fits\/tests\/test_fitsheader.py:        fitsheader.main(['-t', '-k', 'BACKGRND', self.data('test0.fits')])\nastropy\/io\/fits\/tests\/test_fitsheader.py:        assert out[1].endswith('|   1 | BACKGRND | 316.0 |')\nastropy\/io\/fits\/tests\/test_fitsheader.py:        assert out[2].endswith('|   2 | BACKGRND | 351.0 |')\nastropy\/io\/fits\/tests\/test_fitsheader.py:        assert out[3].endswith('|   3 | BACKGRND | 312.0 |')\nastropy\/io\/fits\/tests\/test_fitsheader.py:        assert out[4].endswith('|   4 | BACKGRND | 323.0 |')\nastropy\/io\/fits\/tests\/test_fitsinfo.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_fitsinfo.py:            'No.    Name      Ver    Type      Cards   Dimensions   Format')\nastropy\/io\/fits\/tests\/test_fitsinfo.py:            '  0  PRIMARY       1 PrimaryHDU       7   (11, 10, 7)   int32')\nastropy\/io\/fits\/tests\/test_fitsinfo.py:            'No.    Name      Ver    Type      Cards   Dimensions   Format')\nastropy\/io\/fits\/tests\/test_fitsinfo.py:            '  0  PRIMARY       1 PrimaryHDU       7   (11, 10, 7)   int32')\nastropy\/io\/fits\/tests\/test_fitsinfo.py:            '  1                1 TableHDU        20   5R x 2C   [E10.4, I5]')\nastropy\/io\/fits\/tests\/test_division.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_division.py:class TestDivisionFunctions(FitsTestCase):\nastropy\/io\/fits\/tests\/test_division.py:        h = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_util.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_connect.py:from .. import HDUList, PrimaryHDU, BinTableHDU\nastropy\/io\/fits\/tests\/test_connect.py:from ....time import Time, TimeDelta\nastropy\/io\/fits\/tests\/test_connect.py:DATA = os.path.join(os.path.dirname(__file__), 'data')\nastropy\/io\/fits\/tests\/test_connect.py:        # Disabled for now, as there is no obvious way to handle masking of\nastropy\/io\/fits\/tests\/test_connect.py:        # TODO: Re-enable these tests if some workaround for this can be found\nastropy\/io\/fits\/tests\/test_connect.py:        hdu = BinTableHDU(self.data)\nastropy\/io\/fits\/tests\/test_connect.py:        hdu = BinTableHDU(self.data)\nastropy\/io\/fits\/tests\/test_connect.py:        hdu.columns[0].unit = 'RADIANS'\nastropy\/io\/fits\/tests\/test_connect.py:class TestMultipleHDU:\nastropy\/io\/fits\/tests\/test_connect.py:        hdu1 = PrimaryHDU()\nastropy\/io\/fits\/tests\/test_connect.py:        hdu2 = BinTableHDU(self.data1, name='first')\nastropy\/io\/fits\/tests\/test_connect.py:        hdu3 = BinTableHDU(self.data2, name='second')\nastropy\/io\/fits\/tests\/test_connect.py:        self.hdus = HDUList([hdu1, hdu2, hdu3])\nastropy\/io\/fits\/tests\/test_connect.py:    t = Table.read(os.path.join(DATA, 'tb.fits'))\nastropy\/io\/fits\/tests\/test_connect.py:    filename = os.path.join(DATA, 'stddata.fits')\nastropy\/io\/fits\/tests\/test_connect.py:        # Mixin info.meta can None instead of empty OrderedDict(), #6720 would\nastropy\/io\/fits\/tests\/test_connect.py:    'dt': TimeDelta([1, 2] * u.day),\nastropy\/io\/fits\/tests\/test_connect.py:            # Downgrade Quantity to Column + unit\nastropy\/io\/fits\/tests\/test_groups.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_groups.py:            assert isinstance(hdul[0], fits.GroupsHDU)\nastropy\/io\/fits\/tests\/test_groups.py:            parameters = ['UU', 'VV', 'WW', 'BASELINE', 'DATE']\nastropy\/io\/fits\/tests\/test_groups.py:            info = [(0, 'PRIMARY', 1, 'GroupsHDU', 147, naxes, 'float32',\nastropy\/io\/fits\/tests\/test_groups.py:            assert list(ghdu.data.dtype.names) == parameters + ['DATA']\nastropy\/io\/fits\/tests\/test_groups.py:            assert isinstance(ghdu.data, fits.GroupData)\nastropy\/io\/fits\/tests\/test_groups.py:        Test that opening a file containing a groups HDU in update mode and\nastropy\/io\/fits\/tests\/test_groups.py:        parameters = ['UU', 'VV', 'WW', 'BASELINE', 'DATE']\nastropy\/io\/fits\/tests\/test_groups.py:        A simple test to ensure that slicing GroupData returns a new, smaller\nastropy\/io\/fits\/tests\/test_groups.py:        GroupData object, as is the case with a normal FITS_rec.  This is a\nastropy\/io\/fits\/tests\/test_groups.py:        GroupData returned a single Group record.\nastropy\/io\/fits\/tests\/test_groups.py:            assert isinstance(s, fits.GroupData)\nastropy\/io\/fits\/tests\/test_groups.py:        Basic test for creating GroupData from scratch.\nastropy\/io\/fits\/tests\/test_groups.py:        x = fits.hdu.groups.GroupData(imdata, parnames=['abc', 'xyz'],\nastropy\/io\/fits\/tests\/test_groups.py:        # Test putting the data into a GroupsHDU and round-tripping it\nastropy\/io\/fits\/tests\/test_groups.py:        ghdu = fits.GroupsHDU(data=x)\nastropy\/io\/fits\/tests\/test_groups.py:        x = fits.hdu.groups.GroupData(imdata, parnames=['abc', 'xyz', 'abc'],\nastropy\/io\/fits\/tests\/test_groups.py:        ghdu = fits.GroupsHDU(data=x)\nastropy\/io\/fits\/tests\/test_groups.py:            assert x.dtype.names == ('abc', 'xyz', '_abc', 'DATA')\nastropy\/convolution\/tests\/test_discretize.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/convolution\/tests\/test_discretize.py:    Gaussian1D, Box1D, MexicanHat1D, Gaussian2D, Box2D, MexicanHat2D)\nastropy\/convolution\/tests\/test_discretize.py:from ...modeling.tests.example_models import models_1D, models_2D\nastropy\/convolution\/tests\/test_discretize.py:test_models_1D = [Gaussian1D, Box1D, MexicanHat1D]\nastropy\/convolution\/tests\/test_discretize.py:test_models_2D = [Gaussian2D, Box2D, MexicanHat2D]\nastropy\/convolution\/tests\/test_discretize.py:@pytest.mark.parametrize(('model_class', 'mode'), list(itertools.product(test_models_1D, modes)))\nastropy\/convolution\/tests\/test_discretize.py:def test_pixel_sum_1D(model_class, mode):\nastropy\/convolution\/tests\/test_discretize.py:    if model_class == Box1D and mode == \"center\":\nastropy\/convolution\/tests\/test_discretize.py:    parameters = models_1D[model_class]\nastropy\/convolution\/tests\/test_discretize.py:    values = discretize_model(model, models_1D[model_class]['x_lim'], mode=mode)\nastropy\/convolution\/tests\/test_discretize.py:    assert_allclose(values.sum(), models_1D[model_class]['integral'], atol=0.0001)\nastropy\/convolution\/tests\/test_discretize.py:def test_gaussian_eval_1D(mode):\nastropy\/convolution\/tests\/test_discretize.py:    Discretize Gaussian with different modes and check\nastropy\/convolution\/tests\/test_discretize.py:    if result is at least similar to Gaussian1D.eval().\nastropy\/convolution\/tests\/test_discretize.py:    model = Gaussian1D(1, 0, 20)\nastropy\/convolution\/tests\/test_discretize.py:@pytest.mark.parametrize(('model_class', 'mode'), list(itertools.product(test_models_2D, modes)))\nastropy\/convolution\/tests\/test_discretize.py:def test_pixel_sum_2D(model_class, mode):\nastropy\/convolution\/tests\/test_discretize.py:    if model_class == Box2D and mode == \"center\":\nastropy\/convolution\/tests\/test_discretize.py:    parameters = models_2D[model_class]\nastropy\/convolution\/tests\/test_discretize.py:    values = discretize_model(model, models_2D[model_class]['x_lim'],\nastropy\/convolution\/tests\/test_discretize.py:                              models_2D[model_class]['y_lim'], mode=mode)\nastropy\/convolution\/tests\/test_discretize.py:    assert_allclose(values.sum(), models_2D[model_class]['integral'], atol=0.0001)\nastropy\/convolution\/tests\/test_discretize.py:def test_gaussian_eval_2D(mode):\nastropy\/convolution\/tests\/test_discretize.py:    Discretize Gaussian with different modes and check\nastropy\/convolution\/tests\/test_discretize.py:    if result is at least similar to Gaussian2D.eval()\nastropy\/convolution\/tests\/test_discretize.py:    model = Gaussian2D(0.01, 0, 0, 1, 1)\nastropy\/convolution\/tests\/test_discretize.py:def test_gaussian_eval_2D_integrate_mode():\nastropy\/convolution\/tests\/test_discretize.py:    Discretize Gaussian with integrate mode\nastropy\/convolution\/tests\/test_discretize.py:    model_list = [Gaussian2D(.01, 0, 0, 2, 2),\nastropy\/convolution\/tests\/test_discretize.py:                  Gaussian2D(.01, 0, 0, 1, 2),\nastropy\/convolution\/tests\/test_discretize.py:                  Gaussian2D(.01, 0, 0, 2, 1)]\nastropy\/convolution\/tests\/test_discretize.py:def test_subpixel_gauss_1D():\nastropy\/convolution\/tests\/test_discretize.py:    Test subpixel accuracy of the integrate mode with gaussian 1D model.\nastropy\/convolution\/tests\/test_discretize.py:    gauss_1D = Gaussian1D(1, 0, 0.1)\nastropy\/convolution\/tests\/test_discretize.py:    values = discretize_model(gauss_1D, (-1, 2), mode='integrate', factor=100)\nastropy\/convolution\/tests\/test_discretize.py:def test_subpixel_gauss_2D():\nastropy\/convolution\/tests\/test_discretize.py:    Test subpixel accuracy of the integrate mode with gaussian 2D model.\nastropy\/convolution\/tests\/test_discretize.py:    gauss_2D = Gaussian2D(1, 0, 0, 0.1, 0.1)\nastropy\/convolution\/tests\/test_discretize.py:    values = discretize_model(gauss_2D, (-1, 2), (-1, 2), mode='integrate', factor=100)\nastropy\/visualization\/tests\/test_stretch.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/visualization\/tests\/test_stretch.py:                       PowerDistStretch, SquaredStretch, LogStretch,\nastropy\/visualization\/tests\/test_stretch.py:DATA = np.array([0.00, 0.25, 0.50, 0.75, 1.00])\nastropy\/visualization\/tests\/test_stretch.py:RESULTS[PowerDistStretch()] = np.array([0., 0.004628, 0.030653, 0.177005, 1.])\nastropy\/visualization\/tests\/test_stretch.py:RESULTS[HistEqStretch(DATA)] = DATA\nastropy\/visualization\/tests\/test_stretch.py:RESULTS[HistEqStretch(DATA[::-1])] = DATA\nastropy\/visualization\/tests\/test_stretch.py:RESULTS[HistEqStretch(DATA ** 0.5)] = np.array([0., 0.125, 0.25, 0.5674767,\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch(DATA, clip=False),\nastropy\/visualization\/tests\/test_stretch.py:        new_shape = DATA.shape + (1,) * ndim\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch(DATA.reshape(new_shape),\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch(DATA, clip=True),\nastropy\/visualization\/tests\/test_stretch.py:        data_in = DATA.copy()\nastropy\/visualization\/tests\/test_stretch.py:        result = np.zeros(DATA.shape)\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(data_in, DATA)\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch.inverse(stretch(DATA, clip=False),\nastropy\/visualization\/tests\/test_stretch.py:                                                   clip=False), DATA)\nastropy\/visualization\/tests\/test_stretch.py:        result = np.zeros(DATA.shape)\nastropy\/visualization\/tests\/test_stretch.py:        stretch(DATA, out=result, clip=False)\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(result, DATA)\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch.inverse.inverse(DATA),\nastropy\/visualization\/tests\/test_stretch.py:                                   stretch(DATA), atol=1.e-6)\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch_1(DATA),\nastropy\/visualization\/tests\/test_stretch.py:                                   stretch_2(DATA))\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch_1(DATA),\nastropy\/visualization\/tests\/test_stretch.py:                                   stretch_2(DATA))\nastropy\/visualization\/tests\/test_stretch.py:        np.testing.assert_allclose(stretch_1.inverse(DATA),\nastropy\/visualization\/tests\/test_stretch.py:                                   stretch_3(DATA))\nastropy\/visualization\/mpl_normalize.py:        The pixel value of the minimum cut level.  Data values less than\nastropy\/visualization\/mpl_normalize.py:        The pixel value of the maximum cut level.  Data values greater\nastropy\/utils\/compat\/numpy\/lib\/stride_tricks.py:from ....exceptions import AstropyDeprecationWarning\nastropy\/utils\/compat\/numpy\/lib\/stride_tricks.py:        'numpy.broadcast_arrays directly.', AstropyDeprecationWarning)\nastropy\/utils\/compat\/numpy\/lib\/stride_tricks.py:        'numpy.broadcast_to directly.', AstropyDeprecationWarning)\nastropy\/io\/fits\/tests\/test_fitstime.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/fits\/tests\/test_fitstime.py:from ....time import Time, TimeDelta\nastropy\/io\/fits\/tests\/test_fitstime.py:from ....time.formats import FITS_DEPRECATED_SCALES\nastropy\/io\/fits\/tests\/test_fitstime.py:        t.meta['DATE'] = '1999-01-01T00:00:00'\nastropy\/io\/fits\/tests\/test_fitstime.py:        t.meta['MJD-OBS'] = 56670\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Test DATE\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert isinstance(tm.meta['DATE'], Time)\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['DATE'].value == t.meta['DATE'] + '(UTC)'\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['DATE'].format == 'fits'\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Default time scale according to the FITS standard is UTC\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['DATE'].scale == 'utc'\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Test MJD-xxx\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert isinstance(tm.meta['MJD-OBS'], Time)\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['MJD-OBS'].value == t.meta['MJD-OBS']\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['MJD-OBS'].format == 'mjd'\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['MJD-OBS'].scale == 'utc'\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Test DATE\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert isinstance(tm.meta['DATE'], Time)\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['DATE'].value == t.meta['DATE'] + '(UTC)'\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['DATE'].scale == 'utc'\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Test MJD-xxx\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert isinstance(tm.meta['MJD-OBS'], Time)\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['MJD-OBS'].value == t.meta['MJD-OBS']\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['MJD-OBS'].scale == FITS_DEPRECATED_SCALES[t.meta['TIMESYS']]\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Test DATE\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert not isinstance(tm.meta['DATE'], Time)\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['DATE'] == t.meta['DATE']\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Test MJD-xxx\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert not isinstance(tm.meta['MJD-OBS'], Time)\nastropy\/io\/fits\/tests\/test_fitstime.py:        assert tm.meta['MJD-OBS'] == t.meta['MJD-OBS']\nastropy\/io\/fits\/tests\/test_fitstime.py:        ref_time = Time(non_native.meta['MJDREF'], format='mjd',\nastropy\/io\/fits\/tests\/test_fitstime.py:        delta_time = TimeDelta(non_native['time'])\nastropy\/io\/fits\/tests\/test_fitstime.py:        Test that ISO-8601 Datetime String Columns are read correctly.\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Datetime column\nastropy\/io\/fits\/tests\/test_fitstime.py:        bhdu = fits.BinTableHDU.from_columns([c])\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Datetime column\nastropy\/io\/fits\/tests\/test_fitstime.py:        bhdu = fits.BinTableHDU.from_columns([c], header=fits.Header(cards))\nastropy\/io\/fits\/tests\/test_fitstime.py:        bhdu = fits.BinTableHDU.from_columns([c], header=fits.Header(cards))\nastropy\/io\/fits\/tests\/test_fitstime.py:        c = fits.Column(name='gps_time', format='D', unit='s', coord_type='GPS',\nastropy\/io\/fits\/tests\/test_fitstime.py:        bhdu = fits.BinTableHDU.from_columns([c], header=fits.Header(cards))\nastropy\/io\/fits\/tests\/test_fitstime.py:        c = fits.Column(name='local_time', format='D', unit='d',\nastropy\/io\/fits\/tests\/test_fitstime.py:        bhdu = fits.BinTableHDU.from_columns([c])\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Default scale is UTC\nastropy\/io\/fits\/tests\/test_fitstime.py:        bhdu = fits.BinTableHDU.from_columns([c])\nastropy\/io\/fits\/tests\/test_fitstime.py:        # Default value for time reference position is \"TOPOCENTER\"\nastropy\/io\/fits\/tests\/test_fitstime.py:        bhdu = fits.BinTableHDU.from_columns([c])\nastropy\/visualization\/tests\/test_units.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/cosmology\/core.py:__all__ = [\"FLRW\", \"LambdaCDM\", \"FlatLambdaCDM\", \"wCDM\", \"FlatwCDM\",\nastropy\/cosmology\/core.py:           \"Flatw0waCDM\", \"w0waCDM\", \"wpwaCDM\", \"w0wzCDM\",\nastropy\/cosmology\/core.py:    subclasses such as `LambdaCDM` or `wCDM`.\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:                # FD vs. BE statistics.\nastropy\/cosmology\/core.py:        \"\"\" Does this cosmology have at least one massive neutrino species?\"\"\"\nastropy\/cosmology\/core.py:        \"\"\" Dimensionless Hubble constant: h = H_0 \/ 100 [km\/sec\/Mpc]\"\"\"\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:        the current concordance lambda CDM model).\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:        concordance lambda CDM model).\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:        \"\"\" Distance modulus at redshift ``z``.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Distance modulus at each input redshift, in magnitudes\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:        \"\"\"Differential comoving volume at redshift z.\nastropy\/cosmology\/core.py:          Differential comoving volume per redshift per steradian at\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:          Input redshifts.  Must be 1D or scalar.\nastropy\/cosmology\/core.py:class LambdaCDM(FLRW):\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import LambdaCDM\nastropy\/cosmology\/core.py:    >>> cosmo = LambdaCDM(H0=70, Om0=0.3, Ode0=0.7)\nastropy\/cosmology\/core.py:class FlatLambdaCDM(LambdaCDM):\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import FlatLambdaCDM\nastropy\/cosmology\/core.py:    >>> cosmo = FlatLambdaCDM(H0=70, Om0=0.3)\nastropy\/cosmology\/core.py:        LambdaCDM.__init__(self, H0, Om0, 0.0, Tcmb0, Neff, m_nu, name=name,\nastropy\/cosmology\/core.py:        # Do some twiddling after the fact to get flatness\nastropy\/cosmology\/core.py:class wCDM(FLRW):\nastropy\/cosmology\/core.py:        Dark energy equation of state at all redshifts. This is\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import wCDM\nastropy\/cosmology\/core.py:    >>> cosmo = wCDM(H0=70, Om0=0.3, Ode0=0.7, w0=-0.9)\nastropy\/cosmology\/core.py:        \"\"\" Dark energy equation of state\"\"\"\nastropy\/cosmology\/core.py:class FlatwCDM(wCDM):\nastropy\/cosmology\/core.py:        Dark energy equation of state at all redshifts. This is\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import FlatwCDM\nastropy\/cosmology\/core.py:    >>> cosmo = FlatwCDM(H0=70, Om0=0.3, w0=-0.9)\nastropy\/cosmology\/core.py:        wCDM.__init__(self, H0, Om0, 0.0, w0, Tcmb0, Neff, m_nu,\nastropy\/cosmology\/core.py:        # Do some twiddling after the fact to get flatness\nastropy\/cosmology\/core.py:class w0waCDM(FLRW):\nastropy\/cosmology\/core.py:    D10, 213 (2001) and Linder PRL 90, 91301 (2003):\nastropy\/cosmology\/core.py:        Dark energy equation of state at z=0 (a=1). This is pressure\/density\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import w0waCDM\nastropy\/cosmology\/core.py:    >>> cosmo = w0waCDM(H0=70, Om0=0.3, Ode0=0.7, w0=-0.9, wa=0.2)\nastropy\/cosmology\/core.py:        \"\"\" Dark energy equation of state at z=0\"\"\"\nastropy\/cosmology\/core.py:class Flatw0waCDM(w0waCDM):\nastropy\/cosmology\/core.py:    D10, 213 (2001) and Linder PRL 90, 91301 (2003):\nastropy\/cosmology\/core.py:        Dark energy equation of state at z=0 (a=1). This is pressure\/density\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import Flatw0waCDM\nastropy\/cosmology\/core.py:    >>> cosmo = Flatw0waCDM(H0=70, Om0=0.3, w0=-0.9, wa=0.2)\nastropy\/cosmology\/core.py:        w0waCDM.__init__(self, H0, Om0, 0.0, w0=w0, wa=wa, Tcmb0=Tcmb0,\nastropy\/cosmology\/core.py:        # Do some twiddling after the fact to get flatness\nastropy\/cosmology\/core.py:class wpwaCDM(FLRW):\nastropy\/cosmology\/core.py:    D10, 213 (2001) and Linder PRL 90, 91301 (2003), but modified\nastropy\/cosmology\/core.py:    to have a pivot redshift as in the findings of the Dark Energy\nastropy\/cosmology\/core.py:        Dark energy equation of state at the pivot redshift zp. This is\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import wpwaCDM\nastropy\/cosmology\/core.py:    >>> cosmo = wpwaCDM(H0=70, Om0=0.3, Ode0=0.7, wp=-0.9, wa=0.2, zp=0.4)\nastropy\/cosmology\/core.py:        \"\"\" Dark energy equation of state at the pivot redshift zp\"\"\"\nastropy\/cosmology\/core.py:class w0wzCDM(FLRW):\nastropy\/cosmology\/core.py:        Dark energy equation of state at z=0. This is pressure\/density for\nastropy\/cosmology\/core.py:        Derivative of the dark energy equation of state with respect to z.\nastropy\/cosmology\/core.py:        Default: 0 [K]. Setting this to zero will turn off both photons\nastropy\/cosmology\/core.py:        Effective number of Neutrino species. Default 3.04.\nastropy\/cosmology\/core.py:    >>> from astropy.cosmology import w0wzCDM\nastropy\/cosmology\/core.py:    >>> cosmo = w0wzCDM(H0=70, Om0=0.3, Ode0=0.7, w0=-0.9, wz=0.2)\nastropy\/cosmology\/core.py:        \"\"\" Dark energy equation of state at z=0\"\"\"\nastropy\/cosmology\/core.py:        \"\"\" Derivative of the dark energy equation of state w.r.t. z\"\"\"\nastropy\/cosmology\/core.py:# parameters module and creates a LambdaCDM or FlatLambdaCDM instance\nastropy\/cosmology\/core.py:# Note this assumes all the cosmologies in parameters are LambdaCDM,\nastropy\/cosmology\/core.py:        cosmo = FlatLambdaCDM(par['H0'], par['Om0'], Tcmb0=par['Tcmb0'],\nastropy\/cosmology\/core.py:        docstr = \"{} instance of FlatLambdaCDM cosmology\\n\\n(from {})\"\nastropy\/cosmology\/core.py:        cosmo = LambdaCDM(par['H0'], par['Om0'], par['Ode0'],\nastropy\/cosmology\/core.py:        docstr = \"{} instance of LambdaCDM cosmology\\n\\n(from {})\"\nastropy\/constants\/iau2015.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/iau2015.py:# DISTANCE\nastropy\/constants\/iau2015.py:              \"Derived from au\", system='si')\nastropy\/constants\/iau2015.py:               \"Derived from au\", system='si')\nastropy\/constants\/iau2015.py:                 \"IAU 2015 Resolution B 3 + CODATA 2014\", system='si')\nastropy\/constants\/iau2015.py:                 \"IAU 2015 Resolution B 3 + CODATA 2014\", system='si')\nastropy\/constants\/iau2015.py:                 \"IAU 2015 Resolution B 3 + CODATA 2014\", system='si')\nastropy\/io\/fits\/tests\/test_header.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_header.py:    dict1 = collections.OrderedDict(list1)\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B', 'C'), ('D', 'E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card(\"undef\", fits.card.UNDEFINED)\nastropy\/io\/fits\/tests\/test_header.py:        assert str(c) == _pad(\"UNDEF   =\")\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:                          'ENC=OFFSET+RESOL*acos((WID-(MAX+MIN))\/(MAX-MIN)')\nastropy\/io\/fits\/tests\/test_header.py:                \"'ENC=OFFSET+RESOL*acos((WID-(MAX+MIN))\/(MAX-MIN)'\")\nastropy\/io\/fits\/tests\/test_header.py:                        'ENC=OFFSET+RESOL*acos((WID-(MAX+MIN))\/(MAX-MIN)')\nastropy\/io\/fits\/tests\/test_header.py:                \"'ENC=OFFSET+RESOL*acos((WID-(MAX+MIN))\/(MAX-MIN)'\")\nastropy\/io\/fits\/tests\/test_header.py:            ('EXTEND', True, 'May contain datasets'),\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU(header=header)\nastropy\/io\/fits\/tests\/test_header.py:        assert 'ABCDEFGHI' in header\nastropy\/io\/fits\/tests\/test_header.py:            header.update({'HIERARCH blah blah': 'TESTD'})\nastropy\/io\/fits\/tests\/test_header.py:            assert header['blah blah'], 'TESTD'\nastropy\/io\/fits\/tests\/test_header.py:            header.update({'HIERARCH blah blah blah': 'TESTD'})\nastropy\/io\/fits\/tests\/test_header.py:            assert header['blah blah blah'], 'TESTD'\nastropy\/io\/fits\/tests\/test_header.py:            header.update({'HIERARCH bla bla': 'TESTD'})\nastropy\/io\/fits\/tests\/test_header.py:            assert header['bla bla'], 'TESTD'\nastropy\/io\/fits\/tests\/test_header.py:            header.update({'HIERARCH bla bla': 'TESTD'})\nastropy\/io\/fits\/tests\/test_header.py:            assert header['bla bla'], 'TESTD'\nastropy\/io\/fits\/tests\/test_header.py:        header.set('A', comment='D')\nastropy\/io\/fits\/tests\/test_header.py:        assert header.comments['A'] == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        assert newheader[1] == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('ABC', 0), ('DEF', 1), ('ABD', 2)])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('DATE', 1), ('DATE-OBS', 2), ('DATE-FOO', 3)])\nastropy\/io\/fits\/tests\/test_header.py:        assert len(header['DATE*']) == 3\nastropy\/io\/fits\/tests\/test_header.py:        assert len(header['DATE?*']) == 2\nastropy\/io\/fits\/tests\/test_header.py:        assert len(header['DATE-*']) == 2\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('ABC', 0), ('DEF', 1), ('ABD', 2)])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('ABC', 0), ('DEF', 1), ('ABD', 2)])\nastropy\/io\/fits\/tests\/test_header.py:                              ('DEF', 3), ('HISTORY', 4), ('HISTORY', 5)])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        assert list(header.items()) == [('A', 'B'), ('C', 'D')]\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        for a, b in zip(header.values(), ['B', 'D']):\nastropy\/io\/fits\/tests\/test_header.py:                 'EXTEND'])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F'),\nastropy\/io\/fits\/tests\/test_header.py:        assert mid == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F'),\nastropy\/io\/fits\/tests\/test_header.py:        assert mid == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        assert header.setdefault('C') == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu2 = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:        # Directly append the other header in full--not usually a desirable\nastropy\/io\/fits\/tests\/test_header.py:        # operation when the header is coming from another HDU\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu2 = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu2 = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:                hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:                hdu2 = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu2 = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:                hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:                hdu2 = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        assert header[-2] == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('C', 'D'), ('A', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        assert header[0] == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B', 'C'), ('DEF', 'G', 'H')])\nastropy\/io\/fits\/tests\/test_header.py:                '     DEF  H')\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('AB', 'C', 'D'), ('EF', 'G', 'H'),\nastropy\/io\/fits\/tests\/test_header.py:        assert list(s) == ['K', 'H', 'D']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(s) == ['D', 'K']\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('AB', 'C', 'D'), ('EF', 'G', 'H'),\nastropy\/io\/fits\/tests\/test_header.py:        assert list(header.comments) == ['D', 'L', 'L']\nastropy\/io\/fits\/tests\/test_header.py:        assert header.cards[header.index('AB')].comment == 'D'\nastropy\/io\/fits\/tests\/test_header.py:        assert list(header.comments) == ['L', 'L', 'D']\nastropy\/io\/fits\/tests\/test_header.py:        header.append(('D', 'E', 'F'), end=True)\nastropy\/io\/fits\/tests\/test_header.py:        header['FRED'] = 'BARNEY'\nastropy\/io\/fits\/tests\/test_header.py:        header['HISTORY'] = 'DEF'\nastropy\/io\/fits\/tests\/test_header.py:        assert header['HISTORY'] == ['ABC', 'DEF', 'GHI']\nastropy\/io\/fits\/tests\/test_header.py:        assert header['HISTORY'] == ['FOO', 'DEF', 'GHI']\nastropy\/io\/fits\/tests\/test_header.py:        header['FRED'] = 'BARNEY'\nastropy\/io\/fits\/tests\/test_header.py:        assert list(header)[2] == 'FRED'\nastropy\/io\/fits\/tests\/test_header.py:        header.update({'FRED': 'BARNEY'})\nastropy\/io\/fits\/tests\/test_header.py:        assert header.cards[2].keyword == 'FRED'\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:        # as a PrimaryHDU\nastropy\/io\/fits\/tests\/test_header.py:                          fits.PrimaryHDU)\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_header.py:        header['B'] = ('C', 'D')\nastropy\/io\/fits\/tests\/test_header.py:        header['C'] = ('D', 'E')\nastropy\/io\/fits\/tests\/test_header.py:        Make sure that when a Header is read from a text file that the END card\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B', 'C'), ('D', 'E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:            f.write('\\nEND')\nastropy\/io\/fits\/tests\/test_header.py:        assert 'END' not in new_header\nastropy\/io\/fits\/tests\/test_header.py:        Manually adding an END card to a header should simply result in a\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B', 'C'), ('D', 'E', 'F')])\nastropy\/io\/fits\/tests\/test_header.py:        pytest.raises(ValueError, setitem, 'END', '')\nastropy\/io\/fits\/tests\/test_header.py:        pytest.raises(ValueError, header.append, 'END')\nastropy\/io\/fits\/tests\/test_header.py:        pytest.raises(ValueError, header.append, 'END', end=True)\nastropy\/io\/fits\/tests\/test_header.py:        pytest.raises(ValueError, header.insert, len(header), 'END')\nastropy\/io\/fits\/tests\/test_header.py:        pytest.raises(ValueError, header.set, 'END')\nastropy\/io\/fits\/tests\/test_header.py:        This tests the case where the END card looks like a normal card like\nastropy\/io\/fits\/tests\/test_header.py:        'END = ' and other similar oddities.  As long as a card starts with END\nastropy\/io\/fits\/tests\/test_header.py:        and looks like it was intended to be the END card we allow it, but with\nastropy\/io\/fits\/tests\/test_header.py:        horig = fits.PrimaryHDU(data=np.arange(100)).header\nastropy\/io\/fits\/tests\/test_header.py:        # Basic case motivated by the original issue; it's as if the END card\nastropy\/io\/fits\/tests\/test_header.py:        s = invalid_header('END =', True)\nastropy\/io\/fits\/tests\/test_header.py:                \"Unexpected bytes trailing END keyword: ' ='\")\nastropy\/io\/fits\/tests\/test_header.py:        # A case similar to the last but with more spaces between END and the\nastropy\/io\/fits\/tests\/test_header.py:        s = invalid_header('END     = ', True)\nastropy\/io\/fits\/tests\/test_header.py:                \"Unexpected bytes trailing END keyword: '     ='\")\nastropy\/io\/fits\/tests\/test_header.py:        # END card with trailing gibberish\nastropy\/io\/fits\/tests\/test_header.py:        s = invalid_header('END$%&%^*%*', True)\nastropy\/io\/fits\/tests\/test_header.py:                \"Unexpected bytes trailing END keyword: '$%&%^*%*'\")\nastropy\/io\/fits\/tests\/test_header.py:        # 'END' at the very end of a truncated file without padding; the way\nastropy\/io\/fits\/tests\/test_header.py:        # the block reader works currently this can only happen if the 'END'\nastropy\/io\/fits\/tests\/test_header.py:        s = invalid_header('END', False)\nastropy\/io\/fits\/tests\/test_header.py:            # Don't raise an exception on missing padding, but still produce a\nastropy\/io\/fits\/tests\/test_header.py:            # warning that the END card is incomplete\nastropy\/io\/fits\/tests\/test_header.py:        hdul = fits.PrimaryHDU(header=h, data=np.arange(5))\nastropy\/io\/fits\/tests\/test_header.py:        header = fits.Header([('A', 'B'), ('B', 'C'), ('C', 'D')])\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:        # message (HDU 0, Card 4).  I'm still not sure things like that\nastropy\/io\/fits\/tests\/test_header.py:        h = fits.Header([('abC', 1), ('Def', 2), ('GeH', 3)])\nastropy\/io\/fits\/tests\/test_header.py:        assert list(h) == ['ABC', 'DEF', 'GEH']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(h) == ['ABC', 'DEF']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(h) == ['GEH', 'ABC', 'DEF']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(h) == ['GEH', 'DEF', 'ABC']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(h) == ['GEH', 'DEF', 'ABC', 'IJK']\nastropy\/io\/fits\/tests\/test_header.py:        h.remove('Def')\nastropy\/io\/fits\/tests\/test_header.py:        Tests a case where the comment of a card ends with END, and is followed\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU(data=data)\nastropy\/io\/fits\/tests\/test_header.py:        hdu.header['TESTKW'] = ('Test val', 'This is the END')\nastropy\/io\/fits\/tests\/test_header.py:        # Add a couple blanks after the END string\nastropy\/io\/fits\/tests\/test_header.py:        When creating a new HDU from an existing Header read from an existing\nastropy\/io\/fits\/tests\/test_header.py:        history = ['CCD parameters table ...',\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:        new_hdu = fits.PrimaryHDU(header=hdu.header)\nastropy\/io\/fits\/tests\/test_header.py:        # Create a header containing a few different types of BAD headers.\nastropy\/io\/fits\/tests\/test_header.py:        c1 = fits.Card.fromstring('CLFIND2D: contour = 0.30')\nastropy\/io\/fits\/tests\/test_header.py:        hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_header.py:                assert 'CLFIND2D' in header\nastropy\/io\/fits\/tests\/test_header.py:                assert header['CLFIND2D'] == ': contour = 0.30'\nastropy\/io\/fits\/tests\/test_header.py:                pytest.raises(ValueError, header.set, 'CLFIND2D', 'foo')\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card.fromstring('HIERARCH ESO DET CHIP PXSPACE = 5e6')\nastropy\/io\/fits\/tests\/test_header.py:        assert str(c) == _pad('HIERARCH ESO DET CHIP PXSPACE = 5E6')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'NAXIS: 2')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'AXIS.1: 1')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'AXIS.2: 2')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'NAUX: 2')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'AUX.1.COEFF.0: 0')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'AUX.1.POWER.0: 1')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'AUX.1.COEFF.1: 0.00048828125')\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'AUX.1.POWER.1: 1')\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card.fromstring(\"DP1     = 'NAXIS: 2' \/ A comment\")\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card.fromstring(\"DP1     = 'NAXIS: 2.1'\")\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card.fromstring(\"DP1     = 'NAXIS: a'\")\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card('DP1', 'NAXIS: 2')\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card('DP1', 'NAXIS: 2.0')\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card('DP1', 'NAXIS: a')\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card('DP1.NAXIS', 2)\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card('DP1.NAXIS', 2.0)\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:            c = fits.Card('DP1.NAXIS', 'a')\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card.fromstring(\"DP1     = 'NAXIS: 2' \/ A comment\")\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card.fromstring(\"DP1     = 'NAXIS: 2' \/ A comment\")\nastropy\/io\/fits\/tests\/test_header.py:        assert c.keyword == 'DP1.NAXIS1'\nastropy\/io\/fits\/tests\/test_header.py:        assert str(c).rstrip() == \"DP1     = 'NAXIS1: 2' \/ A comment\"\nastropy\/io\/fits\/tests\/test_header.py:        header.set('abc.DEF', 2)\nastropy\/io\/fits\/tests\/test_header.py:        assert header['ABC.DEF'] == 2\nastropy\/io\/fits\/tests\/test_header.py:        _test_header['DP1'] to return the parsed float value.\nastropy\/io\/fits\/tests\/test_header.py:        assert self._test_header['DP1'] == 'NAXIS: 2'\nastropy\/io\/fits\/tests\/test_header.py:        assert self._test_header['DP1.NAXIS'] == 2.0\nastropy\/io\/fits\/tests\/test_header.py:        assert isinstance(self._test_header['DP1.NAXIS'], float)\nastropy\/io\/fits\/tests\/test_header.py:        assert self._test_header['DP1.AUX.1.COEFF.1'] == 0.00048828125\nastropy\/io\/fits\/tests\/test_header.py:        pytest.raises(KeyError, lambda k: self._test_header[k], 'DP1.AXIS.3')\nastropy\/io\/fits\/tests\/test_header.py:            self._test_header['DP1.AXIS.3']\nastropy\/io\/fits\/tests\/test_header.py:            assert e.args[0] == \"Keyword 'DP1.AXIS.3' not found.\"\nastropy\/io\/fits\/tests\/test_header.py:        assert self._test_header['DP1.NAXIS'] == 3.0\nastropy\/io\/fits\/tests\/test_header.py:        assert isinstance(self._test_header['DP1.NAXIS'], float)\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header['DP1.AXIS.1'] = 1.1\nastropy\/io\/fits\/tests\/test_header.py:        assert self._test_header['DP1.AXIS.1'] == 1.1\nastropy\/io\/fits\/tests\/test_header.py:        h['D2IM1.EXTVER'] = 1\nastropy\/io\/fits\/tests\/test_header.py:        assert h['D2IM1.EXTVER'] == 1.0\nastropy\/io\/fits\/tests\/test_header.py:        h['D2IM1.EXTVER'] = 2\nastropy\/io\/fits\/tests\/test_header.py:        assert h['D2IM1.EXTVER'] == 2.0\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card.fromstring(\"DP1     = 'NAXIS: 2' \/ A comment\")\nastropy\/io\/fits\/tests\/test_header.py:        assert c.rawkeyword == 'DP1'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card('DP1.NAXIS', 2)\nastropy\/io\/fits\/tests\/test_header.py:        assert c.rawkeyword == 'DP1'\nastropy\/io\/fits\/tests\/test_header.py:        c = fits.Card('DP1.NAXIS', 2.0)\nastropy\/io\/fits\/tests\/test_header.py:        assert c.rawkeyword == 'DP1'\nastropy\/io\/fits\/tests\/test_header.py:        self._test_header.set('DP1', 'AXIS.3: 1', 'a comment',\nastropy\/io\/fits\/tests\/test_header.py:                              after='DP1.AXIS.2')\nastropy\/io\/fits\/tests\/test_header.py:        assert self._test_header['DP1.AXIS.3'] == 1\nastropy\/io\/fits\/tests\/test_header.py:        Deleting a RVKC should work as with a normal card by using the full\nastropy\/io\/fits\/tests\/test_header.py:        del self._test_header['DP1.AXIS.1']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(self._test_header)[0] == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        assert list(self._test_header)[1] == 'DP1.AXIS.2'\nastropy\/io\/fits\/tests\/test_header.py:        del self._test_header['DP1.AXIS.2']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(self._test_header)[0] == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        assert list(self._test_header)[1] == 'DP1.NAUX'\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.AXIS.*']\nastropy\/io\/fits\/tests\/test_header.py:                [\"DP1     = 'AXIS.1: 1'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AXIS.2: 2'\"])\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.N*']\nastropy\/io\/fits\/tests\/test_header.py:                [\"DP1     = 'NAXIS: 2'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'NAUX: 2'\"])\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.AUX...']\nastropy\/io\/fits\/tests\/test_header.py:                [\"DP1     = 'AUX.1.COEFF.0: 0'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.POWER.0: 1'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.COEFF.1: 0.00048828125'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.POWER.1: 1'\"])\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP?.NAXIS']\nastropy\/io\/fits\/tests\/test_header.py:                [\"DP1     = 'NAXIS: 2'\"])\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.A*S.*']\nastropy\/io\/fits\/tests\/test_header.py:                [\"DP1     = 'AXIS.1: 1'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AXIS.2: 2'\"])\nastropy\/io\/fits\/tests\/test_header.py:        \"\"\"Deletion by filter strings should work.\"\"\"\nastropy\/io\/fits\/tests\/test_header.py:        del self._test_header['DP1.A*...']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(self._test_header)[0] == 'DP1.NAXIS'\nastropy\/io\/fits\/tests\/test_header.py:        assert list(self._test_header)[1] == 'DP1.NAUX'\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.A*...']\nastropy\/io\/fits\/tests\/test_header.py:                [\"DP1     = 'AXIS.1: 1'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AXIS.2: 2'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.COEFF.0: 0'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.POWER.0: 1'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.COEFF.1: 0.00048828125'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.POWER.1: 1'\"])\nastropy\/io\/fits\/tests\/test_header.py:                [\"DP1     = 'AUX.1.COEFF.0: 0'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.POWER.0: 1'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.COEFF.1: 0.00048828125'\",\nastropy\/io\/fits\/tests\/test_header.py:                 \"DP1     = 'AUX.1.POWER.1: 1'\"])\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.AXIS.*']\nastropy\/io\/fits\/tests\/test_header.py:        assert list(cl) == ['DP1.AXIS.1', 'DP1.AXIS.2']\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.AXIS.*']\nastropy\/io\/fits\/tests\/test_header.py:        cl = self._test_header['DP1.AXIS.*']\nastropy\/io\/fits\/tests\/test_header.py:        h['HISTORY'] = 'Date: 2012-09-19T13:58:53.756061'\nastropy\/io\/fits\/tests\/test_header.py:        assert 'HISTORY.Date' not in h\nastropy\/io\/fits\/tests\/test_header.py:        assert str(h.cards[0]) == _pad('HISTORY Date: 2012-09-19T13:58:53.756061')\nastropy\/io\/fits\/tests\/test_header.py:            \"        'Date: 2012-09-19T13:58:53.756061'\")\nastropy\/io\/fits\/tests\/test_header.py:        assert c.value == \"'Date: 2012-09-19T13:58:53.756061'\"\nastropy\/io\/fits\/tests\/test_header.py:        h['FOO'] = 'Date: 2012-09-19T13:58:53.756061'\nastropy\/io\/fits\/tests\/test_header.py:        assert 'FOO.Date' not in h\nastropy\/io\/fits\/tests\/test_header.py:                _pad(\"FOO     = 'Date: 2012-09-19T13:58:53.756061'\"))\nastropy\/io\/fits\/tests\/test_header.py:        # Does the table contain the expected number of rows?\nastropy\/io\/fits\/tests\/test_header.py:        # Repeat the above test when multiple HDUs are requested\nastropy\/io\/fits\/tests\/test_header.py:        mytable = formatter.parse(extensions=['DOES_NOT_EXIST'])\nastropy\/io\/fits\/tests\/test_header.py:                                  keywords=['DOES_NOT_EXIST'])\nastropy\/io\/ascii\/daophot.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/daophot.py:Classes to read DAOphot table format\nastropy\/io\/ascii\/daophot.py:from collections import defaultdict, OrderedDict\nastropy\/io\/ascii\/daophot.py:class DaophotHeader(core.BaseHeader):\nastropy\/io\/ascii\/daophot.py:    Read the header from a file produced by the IRAF DAOphot routine.\nastropy\/io\/ascii\/daophot.py:        #N ID    XCENTER   YCENTER   MAG         MERR          MSKY           NITER\nastropy\/io\/ascii\/daophot.py:            # Database contains multi-aperture data.\nastropy\/io\/ascii\/daophot.py:        row_short = Daophot.table_width - row_widths\nastropy\/io\/ascii\/daophot.py:        Extract table-level keywords for DAOphot table.  These are indicated by\nastropy\/io\/ascii\/daophot.py:            # Dict of line groups keyed by line identifiers\nastropy\/io\/ascii\/daophot.py:                keywords = OrderedDict(map(self.extract_keyword_line, grouped_lines_dict['#K']))\nastropy\/io\/ascii\/daophot.py:        Initialize the header Column objects from the table ``lines`` for a DAOphot\nastropy\/io\/ascii\/daophot.py:        header.  The DAOphot header is specialized so that we just copy the entire BaseHeader\nastropy\/io\/ascii\/daophot.py:            raise core.InconsistentTableError('No column names found in DAOphot header')\nastropy\/io\/ascii\/daophot.py:        # INDEF is the missing value marker\nastropy\/io\/ascii\/daophot.py:        self.data.fill_values.append(('INDEF', '0'))\nastropy\/io\/ascii\/daophot.py:class DaophotData(core.BaseData):\nastropy\/io\/ascii\/daophot.py:        core.BaseData.__init__(self)\nastropy\/io\/ascii\/daophot.py:        core.BaseData.get_data_lines(self, lines)\nastropy\/io\/ascii\/daophot.py:class DaophotInputter(core.ContinuationLinesInputter):\nastropy\/io\/ascii\/daophot.py:class Daophot(core.BaseReader):\nastropy\/io\/ascii\/daophot.py:    Read a DAOphot file.\nastropy\/io\/ascii\/daophot.py:      #K MERGERAD   = INDEF                   scaleunit  %-23.7g\nastropy\/io\/ascii\/daophot.py:      #N ID    XCENTER   YCENTER   MAG         MERR          MSKY           NITER    \\\\\nastropy\/io\/ascii\/daophot.py:      14       138.538     INDEF   15.461      0.003         34.85955       4        \\\\\nastropy\/io\/ascii\/daophot.py:      MERGERAD INDEF scaleunit %-23.7g\nastropy\/io\/ascii\/daophot.py:      ID None %-9d\nastropy\/io\/ascii\/daophot.py:    Any column values of INDEF are interpreted as a missing value and will be\nastropy\/io\/ascii\/daophot.py:    _description = 'IRAF DAOphot format table'\nastropy\/io\/ascii\/daophot.py:    header_class = DaophotHeader\nastropy\/io\/ascii\/daophot.py:    data_class = DaophotData\nastropy\/io\/ascii\/daophot.py:    inputter_class = DaophotInputter\nastropy\/io\/ascii\/daophot.py:        # The inputter needs to know about the data (see DaophotInputter.process_lines)\nastropy\/io\/ascii\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/__init__.py:                   BaseData,\nastropy\/io\/ascii\/__init__.py:                   BaseSplitter, DefaultSplitter, WhitespaceSplitter,\nastropy\/io\/ascii\/__init__.py:from .basic import (Basic, BasicHeader, BasicData,\nastropy\/io\/ascii\/__init__.py:from .daophot import Daophot\nastropy\/io\/ascii\/__init__.py:                         FixedWidthHeader, FixedWidthData)\nastropy\/io\/fits\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/__init__.py:        # TODO: Replace this when there's a better way to in the config API to\nastropy\/io\/fits\/tests\/__init__.py:        os.chmod(self.temp(filename), stat.S_IREAD | stat.S_IWRITE)\nastropy\/io\/ascii\/cds.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/cds.py:  Classes to read CDS \/ Vizier table format\nastropy\/io\/ascii\/cds.py:            raise ValueError('Unrecognized CDS format \"{}\" for column \"{}\"'.format(\nastropy\/io\/ascii\/cds.py:        Initialize the header Column objects from the table ``lines`` for a CDS\nastropy\/io\/ascii\/cds.py:                    match = re.match(r'Byte-by-byte Description of file: (?P<name>.+)$',\nastropy\/io\/ascii\/cds.py:            if re.match(r'Byte-by-byte Description', line, re.IGNORECASE):\nastropy\/io\/ascii\/cds.py:                    col.unit = None  # \"---\" is the marker for no unit in CDS table\nastropy\/io\/ascii\/cds.py:                        # CDS tables can use -, --, ---, or ---- to mark missing values\nastropy\/io\/ascii\/cds.py:                    raise ValueError('Line \"{}\" not parsable as CDS header'.format(line))\nastropy\/io\/ascii\/cds.py:class CdsData(core.BaseData):\nastropy\/io\/ascii\/cds.py:    \"\"\"CDS table data reader\nastropy\/io\/ascii\/cds.py:        \"\"\"Skip over CDS header by finding the last section delimiter\"\"\"\nastropy\/io\/ascii\/cds.py:            raise core.InconsistentTableError('No CDS section delimiter found')\nastropy\/io\/ascii\/cds.py:    \"\"\"Read a CDS format table.  See http:\/\/vizier.u-strasbg.fr\/doc\/catstd.htx.\nastropy\/io\/ascii\/cds.py:      ADC_Keywords: Keyword ; Another keyword ; etc\nastropy\/io\/ascii\/cds.py:      Description:\nastropy\/io\/ascii\/cds.py:      Byte-by-byte Description of file: datafile3.txt\nastropy\/io\/ascii\/cds.py:      Note (1): A CDS file can contain sections with various metadata.\nastropy\/io\/ascii\/cds.py:    **About parsing the CDS format**\nastropy\/io\/ascii\/cds.py:    The CDS format consists of a table description and the table data.  These\nastropy\/io\/ascii\/cds.py:    combined in a single file.  Different subsections within the description\nastropy\/io\/ascii\/cds.py:    starting with \"Byte-by-byte Description of file:\".\nastropy\/io\/ascii\/cds.py:    parameter indicating the CDS ReadMe file.  If not supplied it is assumed that\nastropy\/io\/ascii\/cds.py:    The table name and the CDS ReadMe file can be entered as URLs.  This can be used\nastropy\/io\/ascii\/cds.py:    CDS::\nastropy\/io\/ascii\/cds.py:    data table matches expectation based on the input CDS file.\nastropy\/io\/ascii\/cds.py:      InconsistentTableError: No CDS section delimiter found\nastropy\/io\/ascii\/cds.py:    _description = 'CDS format table'\nastropy\/io\/ascii\/cds.py:    data_class = CdsData\nastropy\/table\/bst.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/bst.py:        Decrement all rows larger than the given row.\nastropy\/table\/bst.py:                raise ValueError(\"Data does not belong to correct node\")\nastropy\/table\/bst.py:                raise ValueError(\"Data does not belong to correct node\")\nastropy\/table\/bst.py:        Decrement rows larger than the given row.\nastropy\/table\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/rst.py:# Licensed under a 3-clause BSD style license\nastropy\/io\/ascii\/rst.py:from .core import DefaultSplitter\nastropy\/io\/ascii\/rst.py:                         FixedWidthData,\nastropy\/io\/ascii\/rst.py:                         FixedWidthTwoLineDataSplitter)\nastropy\/io\/ascii\/rst.py:    splitter_class = DefaultSplitter\nastropy\/io\/ascii\/rst.py:class SimpleRSTData(FixedWidthData):\nastropy\/io\/ascii\/rst.py:    splitter_class = FixedWidthTwoLineDataSplitter\nastropy\/io\/ascii\/rst.py:    data_class = SimpleRSTData\nastropy\/utils\/data_info.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/data_info.py:\"\"\"This module contains functions and methods that relate to the DataInfo class\nastropy\/utils\/data_info.py:A DataInfo object is attached to the Quantity, SkyCoord, and Time classes in\nastropy\/utils\/data_info.py:from collections import OrderedDict\nastropy\/utils\/data_info.py:           'DataInfo', 'MixinInfo', 'ParentDtypeInfo']\nastropy\/utils\/data_info.py:                        'Mean of empty slice|Degrees of freedom <= 0'),)\nastropy\/utils\/data_info.py:        return OrderedDict(zip(names, outs))\nastropy\/utils\/data_info.py:class DataInfo:\nastropy\/utils\/data_info.py:    Descriptor that data classes use to add an ``info`` attribute for storing\nastropy\/utils\/data_info.py:    called ``info`` so that the DataInfo() object can be stored in the\nastropy\/utils\/data_info.py:        is a DataInfo() object that is bound to a data object instance. Default is False.\nastropy\/utils\/data_info.py:        if isinstance(value, DataInfo):\nastropy\/utils\/data_info.py:            raise TypeError('info must be set with a DataInfo instance')\nastropy\/utils\/data_info.py:        OrderedDict containing the information attributes.\nastropy\/utils\/data_info.py:            OrderedDict with information attributes is returned\nastropy\/utils\/data_info.py:        info : OrderedDict if out==None else None\nastropy\/utils\/data_info.py:        info = OrderedDict()\nastropy\/utils\/data_info.py:class BaseColumnInfo(DataInfo):\nastropy\/utils\/data_info.py:    attr_names = DataInfo.attr_names.union(['parent_table', 'indices'])\nastropy\/utils\/data_info.py:class ParentDtypeInfo(MixinInfo):\nastropy\/table\/jsviewer.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/jsviewer.py:EXTERN_JS_DIR = abspath(join(dirname(extern.__file__), 'js'))\nastropy\/table\/jsviewer.py:EXTERN_CSS_DIR = abspath(join(dirname(extern.__file__), 'css'))\nastropy\/table\/jsviewer.py:        columnDefs: [{{targets: {sort_columns}, type: \"optionalnum\"}}]\nastropy\/table\/jsviewer.py:        columnDefs: [{{targets: {sort_columns}, type: \"optionalnum\"}}]\nastropy\/table\/jsviewer.py:# Default CSS for the JSViewer writer\nastropy\/table\/jsviewer.py:DEFAULT_CSS = \"\"\"\\\nastropy\/table\/jsviewer.py:# Default CSS used when rendering a table in the IPython notebook\nastropy\/table\/jsviewer.py:DEFAULT_CSS_NB = \"\"\"\\\nastropy\/table\/jsviewer.py:    This class provides an interface to the `DataTables\nastropy\/table\/jsviewer.py:        Use local files or a CDN for JavaScript libraries. Default False.\nastropy\/table\/jsviewer.py:        Number or rows to show. Default to 50.\nastropy\/table\/jsviewer.py:            return ['file:\/\/' + join(EXTERN_JS_DIR, 'jquery-3.1.1.min.js'),\nastropy\/table\/jsviewer.py:                    'file:\/\/' + join(EXTERN_JS_DIR, 'jquery.dataTables.min.js')]\nastropy\/table\/jsviewer.py:            return ['file:\/\/' + join(EXTERN_CSS_DIR,\nastropy\/table\/jsviewer.py:            return 'file:\/\/' + join(EXTERN_JS_DIR, 'jquery.dataTables.min')\nastropy\/table\/jsviewer.py:                                           else DEFAULT_CSS_NB)\nastropy\/table\/jsviewer.py:                         css=DEFAULT_CSS, htmldict=None):\nastropy\/io\/fits\/tests\/test_compression_failures.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        assert 'CompImageHDU.data must be a numpy.ndarray' in str(exc)\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)), quantize_method=1)\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu._header['ZDITHER0'] = 'a'\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:    @pytest.mark.parametrize('kw', ['NAXIS1', 'NAXIS2', 'TFIELDS', 'PCOUNT'])\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:         ('TFIELDS', 999)])\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10)))\nastropy\/io\/fits\/tests\/test_compression_failures.py:        hdu = fits.CompImageHDU(np.ones((10, 10), dtype=np.int32))\nastropy\/table\/sorted_array.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/sorted_array.py:        Decrement all row numbers greater than the input row.\nastropy\/table\/table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/table.py:from collections import OrderedDict, Mapping\nastropy\/table\/table.py:from ..utils import isiterable, ShapedLikeNDArray\nastropy\/table\/table.py:from ..utils.metadata import MetaData\nastropy\/table\/table.py:from ..utils.data_info import BaseColumnInfo, MixinInfo, ParentDtypeInfo, DataInfo\nastropy\/table\/table.py:from ..utils.exceptions import AstropyDeprecationWarning, NoValue\nastropy\/table\/table.py:class TableColumns(OrderedDict):\nastropy\/table\/table.py:    \"\"\"OrderedDict subclass for a set of columns.\nastropy\/table\/table.py:            return OrderedDict.__getitem__(self, item)\nastropy\/table\/table.py:    # Define keys and values for Python 2 and 3 source compatibility\nastropy\/table\/table.py:        return list(OrderedDict.keys(self))\nastropy\/table\/table.py:        return list(OrderedDict.values(self))\nastropy\/table\/table.py:    `Table` differs from `~astropy.nddata.NDData` by the assumption that the\nastropy\/table\/table.py:        Data to initialize table.\nastropy\/table\/table.py:        Default is True.\nastropy\/table\/table.py:        Copy any indices in the input data. Default is True.\nastropy\/table\/table.py:    meta = MetaData()\nastropy\/table\/table.py:    # Define class attributes for core container objects to allow for subclass\nastropy\/table\/table.py:            # Data object implements the __astropy_table__ interface method.\nastropy\/table\/table.py:            raise ValueError('Data type {0} not allowed to init Table'\nastropy\/table\/table.py:        columns = OrderedDict((key, col if isinstance(col, BaseColumn) else col_copy(col))\nastropy\/table\/table.py:        # Dynamic view of available masks\nastropy\/table\/table.py:            Whether the values of the index must be unique. Default is False.\nastropy\/table\/table.py:            raise ValueError('Datatype coercion is not allowed')\nastropy\/table\/table.py:        # TODO: is this restriction still needed with no ndarray?\nastropy\/table\/table.py:        # Deduplicate indices.  It may happen that after pickling or when\nastropy\/table\/table.py:            raise ValueError('Duplicate column names')\nastropy\/table\/table.py:        Determine if ``col`` should be added to the table directly as\nastropy\/table\/table.py:            Include a header row for column names. Default is True.\nastropy\/table\/table.py:            Include a header row for unit.  Default is to show a row\nastropy\/table\/table.py:            Include a header row for column dtypes. Default is True.\nastropy\/table\/table.py:            Left\/right alignment of columns. Default is right (None) for all\nastropy\/table\/table.py:            An html ID tag for the table.  Default is ``table{id}-XXX``, where\nastropy\/table\/table.py:            A valid CSS string declaring the formatting for the table. Defaults\nastropy\/table\/table.py:            to ``astropy.table.jsviewer.DEFAULT_CSS_NB``.\nastropy\/table\/table.py:            Number or rows to show. Defaults to 50.\nastropy\/table\/table.py:            ignored. Defaults to \"idx\".\nastropy\/table\/table.py:            rendered as a `DataTables <https:\/\/datatables.net>`_ data table.\nastropy\/table\/table.py:            Passed to the `astropy.table.JSViewer` init. Defaults to\nastropy\/table\/table.py:            An html ID tag for the table.  Default is ``table{id}``, where id\nastropy\/table\/table.py:            Default is \"display compact\", and other possible values can be\nastropy\/table\/table.py:            A valid CSS string declaring the formatting for the table. Defaults\nastropy\/table\/table.py:            to ``astropy.table.jsviewer.DEFAULT_CSS``.\nastropy\/table\/table.py:            ignored. Defaults to \"idx\".\nastropy\/table\/table.py:        from .jsviewer import DEFAULT_CSS\nastropy\/table\/table.py:            css = DEFAULT_CSS\nastropy\/table\/table.py:            Include a header row for column names. Default is True.\nastropy\/table\/table.py:            Include a header row for unit.  Default is to show a row\nastropy\/table\/table.py:            Include a header row for column dtypes. Default is True.\nastropy\/table\/table.py:            Format the output as an HTML table. Default is False.\nastropy\/table\/table.py:            An ID tag for the table; only used if html is set.  Default is\nastropy\/table\/table.py:            Left\/right alignment of columns. Default is right (None) for all\nastropy\/table\/table.py:            CSS classes for the table; only used if html is set.  Default is\nastropy\/table\/table.py:            Include a header row for column names. Default is True.\nastropy\/table\/table.py:            Include a header row for unit.  Default is to show a row\nastropy\/table\/table.py:            Include a header row for column dtypes. Default is True.\nastropy\/table\/table.py:                    elif isinstance(value, ShapedLikeNDArray):\nastropy\/table\/table.py:            Uniquify column name if it already exist. Default is False.\nastropy\/table\/table.py:            Make a copy of the new column. Default is True.\nastropy\/table\/table.py:            Make a copy of the new columns. Default is True.\nastropy\/table\/table.py:            Default is False.\nastropy\/table\/table.py:            # Did reference count change?\nastropy\/table\/table.py:            # Check base DataInfo attributes that any column will have\nastropy\/table\/table.py:            for attr in DataInfo.attr_names:\nastropy\/table\/table.py:        cols = OrderedDict(self.columns)\nastropy\/table\/table.py:                          AstropyDeprecationWarning)\nastropy\/table\/table.py:                          AstropyDeprecationWarning)\nastropy\/table\/table.py:        TODO: this won't work for mixins\nastropy\/table\/table.py:        Return a :class:`pandas.DataFrame` instance\nastropy\/table\/table.py:        dataframe : :class:`pandas.DataFrame`\nastropy\/table\/table.py:            A pandas :class:`pandas.DataFrame` instance\nastropy\/table\/table.py:        from pandas import DataFrame\nastropy\/table\/table.py:            raise ValueError(\"Cannot convert a table with mixin columns to a pandas DataFrame\")\nastropy\/table\/table.py:            raise ValueError(\"Cannot convert a table with multi-dimensional columns to a pandas DataFrame\")\nastropy\/table\/table.py:        out = OrderedDict()\nastropy\/table\/table.py:        return DataFrame(out)\nastropy\/table\/table.py:        Create a `Table` from a :class:`pandas.DataFrame` instance\nastropy\/table\/table.py:        dataframe : :class:`pandas.DataFrame`\nastropy\/table\/table.py:            The pandas :class:`pandas.DataFrame` instance\nastropy\/table\/table.py:        out = OrderedDict()\nastropy\/table\/table.py:        Data to initialize table.\nastropy\/table\/table.py:        Copy the input data. Default is True.\nastropy\/table\/table.py:        Copy any indices in the input data. Default is True.\nastropy\/table\/table.py:        Determine if ``col`` should be added to the table directly as\nastropy\/table\/table.py:    info = ParentDtypeInfo()\nastropy\/io\/ascii\/sextractor.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/sextractor.py:    comment = r'^\\s*#\\s*\\S\\D.*'  # Find lines that don't have \"# digit\"\nastropy\/io\/ascii\/sextractor.py:        # header comment string of the format: \"# 1 ID short description [unit]\"\nastropy\/io\/ascii\/sextractor.py:        # E.g. '# 1 ID identification number' (without units) or '# 2 MAGERR magnitude of error [mag]'\nastropy\/io\/ascii\/sextractor.py:class SExtractorData(core.BaseData):\nastropy\/io\/ascii\/sextractor.py:      # 3 DELTA_J2000\nastropy\/io\/ascii\/sextractor.py:      # 4 FLUX_RADIUS\nastropy\/io\/ascii\/sextractor.py:    Note the skipped numbers since flux_radius has 3 columns.  The three FLUX_RADIUS\nastropy\/io\/ascii\/sextractor.py:    columns will be named FLUX_RADIUS, FLUX_RADIUS_1, FLUX_RADIUS_2\nastropy\/io\/ascii\/sextractor.py:    Also note that a post-ID description (e.g. \"Variance along x\") is\nastropy\/io\/ascii\/sextractor.py:    data_class = SExtractorData\nastropy\/table\/info.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/info.py:from ..utils.data_info import DataInfo\nastropy\/table\/info.py:    column as its single argument.  The function must return an OrderedDict\nastropy\/table\/info.py:class TableInfo(DataInfo):\nastropy\/io\/ascii\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/core.py:from collections import OrderedDict\nastropy\/io\/ascii\/core.py:    Describes floating-point data.\nastropy\/io\/ascii\/core.py:    Describes boolean data.\nastropy\/io\/ascii\/core.py:    Describes integer data.\nastropy\/io\/ascii\/core.py:class DefaultSplitter(BaseSplitter):\nastropy\/io\/ascii\/core.py:    \"\"\"Default class to split strings into columns using python csv.  The class\nastropy\/io\/ascii\/core.py:    attributes are taken from the csv Dialect class.\nastropy\/io\/ascii\/core.py:      splitter = ascii.DefaultSplitter()\nastropy\/io\/ascii\/core.py:    splitter_class = DefaultSplitter\nastropy\/io\/ascii\/core.py:        the table ``lines`` and update the OrderedDict ``meta`` in place.  This base\nastropy\/io\/ascii\/core.py:class BaseData:\nastropy\/io\/ascii\/core.py:    splitter_class = DefaultSplitter\nastropy\/io\/ascii\/core.py:        else:  # Don't copy entire data lines unless necessary\nastropy\/io\/ascii\/core.py:        \"\"\"Set the fill values of the individual cols based on fill_values of BaseData\nastropy\/io\/ascii\/core.py:    # Derived classes must define default_converters and __call__\nastropy\/io\/ascii\/core.py:    data_class = BaseData\nastropy\/io\/ascii\/core.py:        # Data and Header instances benefit from a little cross-coupling.  Header may need to\nastropy\/io\/ascii\/core.py:        # know about number of data columns for auto-column name generation and Data may\nastropy\/io\/ascii\/core.py:        self.meta = OrderedDict(table=OrderedDict(),\nastropy\/io\/ascii\/core.py:                                cols=OrderedDict())\nastropy\/io\/ascii\/core.py:                              'Data values: {}'.format(\nastropy\/io\/ascii\/core.py:    # to line continuation.  The initial use case here is Daophot.  In this\nastropy\/io\/ascii\/core.py:class WhitespaceSplitter(DefaultSplitter):\nastropy\/io\/ascii\/html.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/html.py:class HTMLData(core.BaseData):\nastropy\/io\/ascii\/html.py:    **htmldict** : Dictionary of parameters for HTML input\/output.\nastropy\/io\/ascii\/html.py:        * table_id : ID for the input table\nastropy\/io\/ascii\/html.py:    data_class = HTMLData\nastropy\/io\/ascii\/html.py:                # Declare encoding and set CSS style for table\nastropy\/table\/table_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/table_helpers.py:from ..utils.data_info import ParentDtypeInfo\nastropy\/table\/table_helpers.py:        Number of table columns. Defaults to number of kinds.\nastropy\/table\/table_helpers.py:    info = ParentDtypeInfo()\nastropy\/io\/fits\/tests\/test_image.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_image.py:from ....utils.exceptions import AstropyPendingDeprecationWarning\nastropy\/io\/fits\/tests\/test_image.py:from ..hdu.compressed import SUBTRACTIVE_DITHER_1, DITHER_SEED_CHECKSUM\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(name='FOO')\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(header=hdr, name='FOO')\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(ver=2)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(header=hdr, ver=4)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(header=hdr, ver=None)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(header=hdr)\nastropy\/io\/fits\/tests\/test_image.py:        Ensure that a header from one HDU is copied when used to initialize new\nastropy\/io\/fits\/tests\/test_image.py:        HDU.\nastropy\/io\/fits\/tests\/test_image.py:        ifd = fits.HDUList(fits.PrimaryHDU())\nastropy\/io\/fits\/tests\/test_image.py:        primary_hdu = fits.PrimaryHDU(header=phdr)\nastropy\/io\/fits\/tests\/test_image.py:        ofd = fits.HDUList(primary_hdu)\nastropy\/io\/fits\/tests\/test_image.py:        # The function \"open\" reads a FITS file into an HDUList object.  There\nastropy\/io\/fits\/tests\/test_image.py:        # data parts are latent instantiation, so if we close the HDUList\nastropy\/io\/fits\/tests\/test_image.py:        assert str(exc_info.value) == ('HDU not found, possibly because the index '\nastropy\/io\/fits\/tests\/test_image.py:                                       'closed before all HDUs were read')\nastropy\/io\/fits\/tests\/test_image.py:        info = ([(0, 'PRIMARY', 1, 'PrimaryHDU', 138, (), '', '')] +\nastropy\/io\/fits\/tests\/test_image.py:                [(x, 'SCI', x, 'ImageHDU', 61, (40, 40), 'int16', '')\nastropy\/io\/fits\/tests\/test_image.py:        # Test that HDUs cannot be accessed after the file was closed\nastropy\/io\/fits\/tests\/test_image.py:        assert str(exc_info.value) == ('HDU not found, possibly because the index '\nastropy\/io\/fits\/tests\/test_image.py:                                       'closed before all HDUs were read')\nastropy\/io\/fits\/tests\/test_image.py:        # Test that HDUs can be accessed with lazy_load_hdus=False\nastropy\/io\/fits\/tests\/test_image.py:        assert isinstance(r[1], fits.ImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:            assert isinstance(r[1], fits.ImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:        Tests that the EXTNAME keyword works with Primary HDUs as well, and\nastropy\/io\/fits\/tests\/test_image.py:        hdulist['PRIMARY'] will still refer to the first HDU even if it has an\nastropy\/io\/fits\/tests\/test_image.py:        hdul = fits.HDUList([fits.PrimaryHDU(header=prihdr)])\nastropy\/io\/fits\/tests\/test_image.py:        info = [(0, 'XPRIMARY', 1, 'PrimaryHDU', 5, (), '', '')]\nastropy\/io\/fits\/tests\/test_image.py:                # The flush method will write the current HDUList object back\nastropy\/io\/fits\/tests\/test_image.py:                # to the newly created file on disk.  The HDUList is still open\nastropy\/io\/fits\/tests\/test_image.py:                # extension(s) since last flush() will be appended, but any HDU\nastropy\/io\/fits\/tests\/test_image.py:            # readonly mode, the HDU's will be read into the HDUList which can\nastropy\/io\/fits\/tests\/test_image.py:            # file.  A file opened with append mode can only add new HDU's.\nastropy\/io\/fits\/tests\/test_image.py:            # When changes are made to an HDUList which was opened with\nastropy\/io\/fits\/tests\/test_image.py:                # original (or since last flush) HDUList, the changes are\nastropy\/io\/fits\/tests\/test_image.py:                # deleting HDU(s), header was expanded or reduced beyond\nastropy\/io\/fits\/tests\/test_image.py:                # change the data size, the HDUList is written to a temporary\nastropy\/io\/fits\/tests\/test_image.py:                # the write method in HDUList class writes the current HDUList,\nastropy\/io\/fits\/tests\/test_image.py:                # works the same disregard the mode the HDUList was opened\nastropy\/io\/fits\/tests\/test_image.py:        # Another useful new HDUList method is readall.  It will \"touch\" the\nastropy\/io\/fits\/tests\/test_image.py:        # data parts in all HDUs, so even if the HDUList is closed, we can\nastropy\/io\/fits\/tests\/test_image.py:        # create an HDU with data only\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(data=data, name='SCI')\nastropy\/io\/fits\/tests\/test_image.py:        # create an HDU with header and data\nastropy\/io\/fits\/tests\/test_image.py:        # with ImageHDU\nastropy\/io\/fits\/tests\/test_image.py:        hdu2 = fits.ImageHDU(header=r[1].header, data=np.array([1, 2],\nastropy\/io\/fits\/tests\/test_image.py:        # make a defect HDUList first\nastropy\/io\/fits\/tests\/test_image.py:        x = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.HDUList(x)  # HDUList can take a list or one single HDU\nastropy\/io\/fits\/tests\/test_image.py:        text = \"HDUList's 0th element is not a primary HDU.\"\nastropy\/io\/fits\/tests\/test_image.py:        text = (\"HDUList's 0th element is not a primary HDU.  \"\nastropy\/io\/fits\/tests\/test_image.py:                \"Fixed by inserting one as 0th HDU.\")\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(a)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(a)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(a)\nastropy\/io\/fits\/tests\/test_image.py:        # TODO: Generate these perumtions instead of having them all written\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(a)\nastropy\/io\/fits\/tests\/test_image.py:        hdu1 = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_image.py:        hdu2 = fits.ImageHDU(np.random.rand(100,100))\nastropy\/io\/fits\/tests\/test_image.py:        This ensures that an HDU containing unsigned integer data always has\nastropy\/io\/fits\/tests\/test_image.py:            uint_hdu = fits.PrimaryHDU(data=arr)\nastropy\/io\/fits\/tests\/test_image.py:            tmp_uint = fits.PrimaryHDU(arr)\nastropy\/io\/fits\/tests\/test_image.py:            uint_hdu = fits.PrimaryHDU(arr,\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(data=arr)\nastropy\/io\/fits\/tests\/test_image.py:        HDU data.\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(data=arr)\nastropy\/io\/fits\/tests\/test_image.py:            # Allow the HDU to be written, but there should be a warning\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(data=arr)\nastropy\/io\/fits\/tests\/test_image.py:        # TODO: Rewrite this test when scaling with blank support is better\nastropy\/io\/fits\/tests\/test_image.py:        \"\"\"Test use of the BZERO keyword in an image HDU containing float\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.ImageHDU(data=arr)\nastropy\/io\/fits\/tests\/test_image.py:        Replacing the original header to an image HDU and saving should update\nastropy\/io\/fits\/tests\/test_image.py:        (Don't update scaled image data if the data is not read)\nastropy\/io\/fits\/tests\/test_image.py:        The scale_back feature for image HDUs.\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(data)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.PrimaryHDU(data=a.copy())\nastropy\/io\/fits\/tests\/test_image.py:        hdul = fits.HDUList.fromstring(file_data)\nastropy\/io\/fits\/tests\/test_image.py:        im = fits.ImageHDU()\nastropy\/io\/fits\/tests\/test_image.py:        hdu1 = fits.PrimaryHDU(data=a.copy())\nastropy\/io\/fits\/tests\/test_image.py:        hdu2 = fits.PrimaryHDU(data=a.copy())\nastropy\/io\/fits\/tests\/test_image.py:        fits.PrimaryHDU(a).writeto(self.temp('test.fits'))\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.CompImageHDU()\nastropy\/io\/fits\/tests\/test_image.py:            assert isinstance(hdul[1], fits.CompImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:            assert isinstance(hdul[1], fits.CompImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:        primary_hdu = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_image.py:        ofd = fits.HDUList(primary_hdu)\nastropy\/io\/fits\/tests\/test_image.py:        chdu = fits.CompImageHDU(data, name='SCI',\nastropy\/io\/fits\/tests\/test_image.py:        fits.ImageHDU(data).writeto(self.temp('im1.fits'))\nastropy\/io\/fits\/tests\/test_image.py:        fits.CompImageHDU(data, compression_type='RICE_1', quantize_method=1,\nastropy\/io\/fits\/tests\/test_image.py:        fits.CompImageHDU(data, compression_type='RICE_1', quantize_method=1,\nastropy\/io\/fits\/tests\/test_image.py:    @ignore_warnings(AstropyPendingDeprecationWarning)\nastropy\/io\/fits\/tests\/test_image.py:        not 2D and has a non-2D tile size.\nastropy\/io\/fits\/tests\/test_image.py:        pytest.raises(ValueError, fits.CompImageHDU,\nastropy\/io\/fits\/tests\/test_image.py:    @ignore_warnings(AstropyPendingDeprecationWarning)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.CompImageHDU(data=cube, name='SCI',\nastropy\/io\/fits\/tests\/test_image.py:        SUBTRACTIVE_DITHER_1 quantization method that the correct ZDITHER0 seed\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.CompImageHDU(data=array,\nastropy\/io\/fits\/tests\/test_image.py:                                quantize_method=SUBTRACTIVE_DITHER_1,\nastropy\/io\/fits\/tests\/test_image.py:                                dither_seed=DITHER_SEED_CHECKSUM)\nastropy\/io\/fits\/tests\/test_image.py:            assert isinstance(hdul[1], fits.CompImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:            assert hdul[1]._header['ZQUANTIZ'] == 'SUBTRACTIVE_DITHER_1'\nastropy\/io\/fits\/tests\/test_image.py:            assert 'ZDITHER0' in hdul[1]._header\nastropy\/io\/fits\/tests\/test_image.py:            assert hdul[1]._header['ZDITHER0'] == csum\nastropy\/io\/fits\/tests\/test_image.py:                # The compressed image HDU should show up as a BinTableHDU, but\nastropy\/io\/fits\/tests\/test_image.py:                # *not* a CompImageHDU\nastropy\/io\/fits\/tests\/test_image.py:                assert isinstance(hdul[1], fits.BinTableHDU)\nastropy\/io\/fits\/tests\/test_image.py:                assert not isinstance(hdul[1], fits.CompImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:            assert isinstance(hdul[1], fits.CompImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:            chdu = fits.CompImageHDU(data=hdul[0].data,\nastropy\/io\/fits\/tests\/test_image.py:            chdu = fits.CompImageHDU(data=hdul[0].data,\nastropy\/io\/fits\/tests\/test_image.py:            chdu = fits.CompImageHDU(data=hdul[0].data,\nastropy\/io\/fits\/tests\/test_image.py:        chdu1 = fits.CompImageHDU(data=noise, compressionType='GZIP_1')\nastropy\/io\/fits\/tests\/test_image.py:        chdu2 = fits.CompImageHDU(data=noise, compressionType='GZIP_1',\nastropy\/io\/fits\/tests\/test_image.py:        chdu = fits.CompImageHDU(data1, compressionType='RICE_1',\nastropy\/io\/fits\/tests\/test_image.py:            assert isinstance(hdul[1], fits.CompImageHDU)\nastropy\/io\/fits\/tests\/test_image.py:        structure on CompImageHDU image headers fails.\nastropy\/io\/fits\/tests\/test_image.py:            test_set_keyword(hdr, 'TFIELDS', 8)\nastropy\/io\/fits\/tests\/test_image.py:            test_set_keyword(hdr, 'ZCMPTYPE', 'ASDF')\nastropy\/io\/fits\/tests\/test_image.py:                imghdr.append('TFIELDS')\nastropy\/io\/fits\/tests\/test_image.py:                assert 'TFIELDS' not in imghdr\nastropy\/io\/fits\/tests\/test_image.py:            header.append((\"Q1_OSSTD\", 1, \"[adu] quadrant 1 overscan stddev\"))\nastropy\/io\/fits\/tests\/test_image.py:            header.append((\"Q1_OSMED\", 1, \"[adu] quadrant 1 overscan median\"))\nastropy\/io\/fits\/tests\/test_image.py:                imghdr.insert(1000, 'TFIELDS')\nastropy\/io\/fits\/tests\/test_image.py:                assert 'TFIELDS' not in imghdr\nastropy\/io\/fits\/tests\/test_image.py:                assert tblhdr.count('TFIELDS') == 1\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.CompImageHDU(np.array([0], dtype=np.int32))\nastropy\/io\/fits\/tests\/test_image.py:        # result in use of a GZIP_COMPRESSED_DATA column\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.CompImageHDU(data=arr)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.CompImageHDU(data=arr)\nastropy\/io\/fits\/tests\/test_image.py:        hdu1 = fits.CompImageHDU(data=a.copy())\nastropy\/io\/fits\/tests\/test_image.py:        hdu2 = fits.CompImageHDU(data=a.copy())\nastropy\/io\/fits\/tests\/test_image.py:        fits.CompImageHDU(a).writeto(self.temp('test.fits'))\nastropy\/io\/fits\/tests\/test_image.py:        comp_hdu = fits.CompImageHDU(a)\nastropy\/io\/fits\/tests\/test_image.py:        comp_hdu = fits.CompImageHDU(a)\nastropy\/io\/fits\/tests\/test_image.py:        hdu = fits.CompImageHDU(np.arange(0, 10, dtype=dtype))\nastropy\/io\/fits\/tests\/test_image.py:    that got turned into CompImageHDU to end up with BZERO\/BSCALE before the\nastropy\/io\/fits\/tests\/test_image.py:    TFIELDS.\nastropy\/io\/fits\/tests\/test_image.py:    x0 = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_image.py:    x1 = fits.ImageHDU(np.array(x-50, dtype=int), uint=True)\nastropy\/io\/fits\/tests\/test_image.py:    hdus = fits.HDUList([x0, x1])\nastropy\/io\/fits\/tests\/test_image.py:    # first HDU.\nastropy\/io\/fits\/tests\/test_image.py:    hdus[1] = fits.CompImageHDU(data=hdus[1].data.astype(np.uint32),\nastropy\/io\/fits\/tests\/test_image.py:    hdu = fits.ImageHDU(np.array([1], dtype=np.int32))\nastropy\/io\/fits\/tests\/test_image.py:    # Calling HDUList.info() on a dataset which applies a zeropoint\nastropy\/io\/fits\/tests\/test_image.py:    hdu = fits.ImageHDU(np.zeros((10, 10)))\nastropy\/io\/fits\/tests\/test_image.py:    ghdu = fits.ImageHDU(data=x)\nastropy\/io\/fits\/tests\/test_image.py:    # Same for compressed HDU\nastropy\/io\/fits\/tests\/test_image.py:    ghdu = fits.CompImageHDU(data=x)\nastropy\/io\/fits\/tests\/test_image.py:    # add_datasum does not work for CompImageHDU\nastropy\/table\/tests\/conftest.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/conftest.py:from collections import OrderedDict\nastropy\/table\/tests\/conftest.py:    class TableData:\nastropy\/table\/tests\/conftest.py:            self.DATA = self.Table(self.COLS)\nastropy\/table\/tests\/conftest.py:    return TableData(request)\nastropy\/table\/tests\/conftest.py:    cols = OrderedDict()\nastropy\/table\/tests\/test_groups.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/pprint.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/pprint.py:        Hashable object to identify column like id or name. Default is None.\nastropy\/table\/pprint.py:                    # Does this string format method work?\nastropy\/table\/pprint.py:            Include column name. Default is True.\nastropy\/table\/pprint.py:            Include a header row for unit.  Default is to show a row\nastropy\/table\/pprint.py:            Include column dtype. Default is False.\nastropy\/table\/pprint.py:            Include column length at end.  Default is to show this only\nastropy\/table\/pprint.py:            Left\/right alignment of columns. Default is '>' (right) for all\nastropy\/table\/pprint.py:            Dict which is used to pass back additional values\nastropy\/table\/pprint.py:            Include column name. Default is True.\nastropy\/table\/pprint.py:            Include a header row for unit.  Default is to show a row\nastropy\/table\/pprint.py:            Include column dtype. Default is False.\nastropy\/table\/pprint.py:            Include column length at end.  Default is to show this only\nastropy\/table\/pprint.py:            Include a header row for column names. Default is True.\nastropy\/table\/pprint.py:            Include a header row for unit.  Default is to show a row\nastropy\/table\/pprint.py:            Include a header row for column dtypes. Default is False.\nastropy\/table\/pprint.py:            Format the output as an HTML table. Default is False.\nastropy\/table\/pprint.py:            An ID tag for the table; only used if html is set.  Default is\nastropy\/table\/pprint.py:            CSS classes for the table; only used if html is set.  Default is\nastropy\/table\/pprint.py:            Left\/right alignment of columns. Default is '>' (right) for all\nastropy\/table\/pprint.py:            Dict which is used to pass back additional values\nastropy\/table\/pprint.py:            Include a header row for column names. Default is True.\nastropy\/table\/pprint.py:            Include a header row for unit.  Default is to show a row\nastropy\/table\/pprint.py:            Include a header row for column dtypes. Default is False.\nastropy\/table\/pprint.py:            if showlines:  # Don't always show the table (e.g. after help)\nastropy\/table\/operations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/operations.py:from collections import OrderedDict, Counter\nastropy\/table\/operations.py:        Default is to use all columns which are common to both tables.\nastropy\/table\/operations.py:    col_name_map = OrderedDict()\nastropy\/table\/operations.py:        Default is to use all columns in ``table1``.\nastropy\/table\/operations.py:    # Dummy column to recover rows after join\nastropy\/table\/operations.py:        # Define bool mask of table1 rows not in table2\nastropy\/table\/operations.py:    col_name_map = OrderedDict()\nastropy\/table\/operations.py:    col_name_map = OrderedDict()\nastropy\/table\/operations.py:        Default is to use all columns.\nastropy\/table\/operations.py:        Default is 'first'.\nastropy\/table\/operations.py:        Default is `False`.\nastropy\/table\/operations.py:    col_name_map = OrderedDict((name, col_name_map[name]) for name in col_name_list)\nastropy\/table\/operations.py:        Default is to use all columns which are common to both tables.\nastropy\/table\/operations.py:        col_name_map = OrderedDict((name, in_names) for name, in_names in col_name_map.items()\nastropy\/table\/tests\/test_index.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_index.py:from .test_table import SetupData\nastropy\/table\/tests\/test_index.py:class TestIndex(SetupData):\nastropy\/table\/tests\/test_table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_table.py:from collections import OrderedDict\nastropy\/table\/tests\/test_table.py:    with ignore_warnings(DeprecationWarning):\nastropy\/table\/tests\/test_table.py:        # Ignore DeprecationWarning on pandas import in Python 3.5--see\nastropy\/table\/tests\/test_table.py:    HAS_PANDAS = False\nastropy\/table\/tests\/test_table.py:    HAS_PANDAS = True\nastropy\/table\/tests\/test_table.py:class SetupData:\nastropy\/table\/tests\/test_table.py:class TestSetTableColumn(SetupData):\nastropy\/table\/tests\/test_table.py:class TestEmptyData():\nastropy\/table\/tests\/test_table.py:class TestAddLength(SetupData):\nastropy\/table\/tests\/test_table.py:class TestAddPosition(SetupData):\nastropy\/table\/tests\/test_table.py:class TestAddName(SetupData):\nastropy\/table\/tests\/test_table.py:class TestInitFromTable(SetupData):\nastropy\/table\/tests\/test_table.py:class TestAddColumns(SetupData):\nastropy\/table\/tests\/test_table.py:class TestAddRow(SetupData):\nastropy\/table\/tests\/test_table.py:class TestTableColumn(SetupData):\nastropy\/table\/tests\/test_table.py:class TestArrayColumns(SetupData):\nastropy\/table\/tests\/test_table.py:class TestRemove(SetupData):\nastropy\/table\/tests\/test_table.py:class TestKeep(SetupData):\nastropy\/table\/tests\/test_table.py:class TestRename(SetupData):\nastropy\/table\/tests\/test_table.py:    # Define unicode literals\nastropy\/table\/tests\/test_table.py:@pytest.mark.skipif('not HAS_PANDAS')\nastropy\/table\/tests\/test_table.py:        assert exc.value.args[0] == \"Cannot convert a table with multi-dimensional columns to a pandas DataFrame\"\nastropy\/table\/tests\/test_table.py:        assert exc.value.args[0] == \"Cannot convert a table with mixin columns to a pandas DataFrame\"\nastropy\/table\/tests\/test_table.py:class TestReplaceColumn(SetupData):\nastropy\/table\/tests\/test_table.py:            self.meta = OrderedDict([('a', 1), ('b', 2)])\nastropy\/table\/tests\/test_table.py:        t = table.Table(st, dtype=dtypes, names=names, meta=OrderedDict([('c', 3)]))\nastropy\/io\/fits\/tests\/test_uint.py:# Licensed under a 3-clause BSD style license - see PYFITS.rst\nastropy\/io\/fits\/tests\/test_uint.py:                hdu = fits.CompImageHDU(np.array([-3, -2, -1, 0, 1, 2, 3], dtype=np.int64))\nastropy\/io\/fits\/tests\/test_uint.py:                hdu = fits.PrimaryHDU(np.array([-3, -2, -1, 0, 1, 2, 3], dtype=np.int64))\nastropy\/io\/fits\/tests\/test_uint.py:                        # TODO: Enable these lines if CompImageHDUs ever grow\nastropy\/io\/fits\/tests\/test_uint.py:            table = fits.BinTableHDU.from_columns([col])\nastropy\/io\/fits\/tests\/test_uint.py:            # a BinTableHDU it gets stored as a view of the original table,\nastropy\/io\/fits\/tests\/test_uint.py:            hdu0 = fits.PrimaryHDU()\nastropy\/io\/fits\/tests\/test_uint.py:            hdulist = fits.HDUList([hdu0, table])\nastropy\/table\/tests\/test_info.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_info.py:from collections import OrderedDict\nastropy\/table\/tests\/test_info.py:        assert cinfo == OrderedDict([('name', 'name'),\nastropy\/table\/tests\/test_info.py:        assert cinfo == OrderedDict([('name', 'name'),\nastropy\/table\/tests\/test_info.py:        assert cinfo == OrderedDict([('dtype', 'int64'),\nastropy\/table\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_array.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_pprint.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_pprint.py:BIG_WIDE_ARR = np.arange(2000, dtype=np.float64).reshape(100, 20)\nastropy\/table\/tests\/test_pprint.py:class TestMultiD():\nastropy\/table\/tests\/test_pprint.py:        self.tb = table_type(BIG_WIDE_ARR)\nastropy\/table\/tests\/test_pprint.py:        \"\"\"Do not include the name header row\"\"\"\nastropy\/table\/tests\/test_pprint.py:    def test_column_format_func_multiD(self, table_type):\nastropy\/table\/tests\/test_pprint.py:    def test_column_format_func_multiD(self):\nastropy\/table\/tests\/test_pprint.py:    decoding to utf-8 and gets replaced by U+FFFD.  See\nastropy\/table\/tests\/test_bst.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_init_table.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_init_table.py:from collections import OrderedDict, Mapping, UserDict\nastropy\/table\/tests\/test_init_table.py:class BaseInitFromDictLike(BaseInitFrom):\nastropy\/table\/tests\/test_init_table.py:class TestInitFromListOfDicts(BaseInitFromListLike):\nastropy\/table\/tests\/test_init_table.py:class TestInitFromNdarrayStruct(BaseInitFromDictLike):\nastropy\/table\/tests\/test_init_table.py:class TestInitFromDict(BaseInitFromDictLike):\nastropy\/table\/tests\/test_init_table.py:class TestInitFromMapping(BaseInitFromDictLike):\nastropy\/table\/tests\/test_init_table.py:        self.data = UserDict([('a', Column([1, 3], name='x')),\nastropy\/table\/tests\/test_init_table.py:class TestInitFromOrderedDict(BaseInitFromDictLike):\nastropy\/table\/tests\/test_init_table.py:        self.data = OrderedDict([('a', Column(name='x', data=[1, 3])),\nastropy\/table\/tests\/test_init_table.py:class TestInitFromRow(BaseInitFromDictLike):\nastropy\/table\/tests\/test_init_table.py:class TestInitFromTable(BaseInitFromDictLike):\nastropy\/table\/tests\/test_init_table.py:    # Note table_table.TestEmptyData tests initializing a completely empty\nastropy\/table\/tests\/test_operations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_operations.py:from collections import OrderedDict\nastropy\/table\/tests\/test_operations.py:        self.t1.meta.update(OrderedDict([('b', [1, 2]), ('c', {'a': 1}), ('d', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t2.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t3.meta.update(OrderedDict([('b', 3), ('c', [1, 2]), ('d', 2), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.meta_merge = OrderedDict([('b', [1, 2, 3, 4]),\nastropy\/table\/tests\/test_operations.py:        meta1 = OrderedDict([('b', [1, 2]), ('c', {'a': 1}), ('d', 1)])\nastropy\/table\/tests\/test_operations.py:        meta2 = OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)])\nastropy\/table\/tests\/test_operations.py:        self.t1.meta.update(OrderedDict([('b', [1, 2]), ('c', {'a': 1}), ('d', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t2.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t4.meta.update(OrderedDict([('b', [5, 6]), ('c', {'c': 1}), ('e', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t5.meta.update(OrderedDict([('b', 3), ('c', 'k'), ('d', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.meta_merge = OrderedDict([('b', [1, 2, 3, 4, 5, 6]),\nastropy\/table\/tests\/test_operations.py:        t1['a'].info.meta.update(OrderedDict([('b', [1, 2]), ('c', {'a': 1}), ('d', 1)]))\nastropy\/table\/tests\/test_operations.py:        t2['a'].info.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        t4['a'].info.meta.update(OrderedDict([('b', [5, 6]), ('c', {'c': 1}), ('e', 1)]))\nastropy\/table\/tests\/test_operations.py:        t2['b'].info.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        assert out['b'].info.meta == OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)])\nastropy\/table\/tests\/test_operations.py:        t1['a'].info.meta.update(OrderedDict([('b', [1, 2]), ('c', {'a': 1}), ('d', 1)]))\nastropy\/table\/tests\/test_operations.py:        t2['a'].info.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        t4['a'].info.meta.update(OrderedDict([('b', [5, 6]), ('c', {'c': 1}), ('e', 1)]))\nastropy\/table\/tests\/test_operations.py:        t2['b'].info.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        assert out['b'].info.meta == OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)])\nastropy\/table\/tests\/test_operations.py:        self.t1.meta.update(OrderedDict([('b', [1, 2]), ('c', {'a': 1}), ('d', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t2.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t4.meta.update(OrderedDict([('b', [5, 6]), ('c', {'c': 1}), ('e', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.t5.meta.update(OrderedDict([('b', 3), ('c', 'k'), ('d', 1)]))\nastropy\/table\/tests\/test_operations.py:        self.meta_merge = OrderedDict([('b', [1, 2, 3, 4, 5, 6]),\nastropy\/table\/tests\/test_operations.py:        meta1 = OrderedDict([('b', [1, 2]), ('c', {'a': 1}), ('d', 1)])\nastropy\/table\/tests\/test_operations.py:        t3['d'].info.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/tests\/test_operations.py:        t4['g'].info.meta.update(OrderedDict([('b', [5, 6]), ('c', {'c': 1}), ('e', 1)]))\nastropy\/table\/tests\/test_operations.py:        t3['e'].info.meta.update(OrderedDict([('b', [3, 4]), ('c', {'b': 1}), ('a', 1)]))\nastropy\/table\/scripts\/showtable.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/scripts\/showtable.py:``astropy.table`` for printing ASCII, FITS, HDF5 or VOTable files(s) to the\nastropy\/table\/scripts\/showtable.py:            Print tables from ASCII, FITS, HDF5, VOTable file(s).  The tables\nastropy\/table\/scripts\/showtable.py:    addarg('--hdu', help='name of the HDU to show')\nastropy\/table\/scripts\/showtable.py:    # HDF5-specific arguments\nastropy\/table\/scripts\/showtable.py:    hdf5_args = parser.add_argument_group('HDF5 arguments')\nastropy\/table\/tests\/test_mixin.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_mixin.py:    io.votable.  Note that FITS and HDF5 mixin support are tested (much more\nastropy\/table\/tests\/test_row.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_item_access.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_item_access.py:        assert np.all(t2['a'] == table_data.DATA['a'][1:3])\nastropy\/table\/tests\/test_item_access.py:        assert np.all(t2['a'] == table_data.DATA['a'][slice])\nastropy\/table\/tests\/test_item_access.py:        assert np.all(self.t.as_array() == table_data.DATA)\nastropy\/table\/tests\/test_item_access.py:        assert np.any(t2['a'] != table_data.DATA['a'][slice])\nastropy\/table\/tests\/test_item_access.py:        assert np.all(t2['a'] == table_data.DATA['a'][slice])\nastropy\/table\/tests\/test_item_access.py:        assert np.all(self.t.as_array() == table_data.DATA)\nastropy\/table\/tests\/test_item_access.py:        assert np.any(t2['a'] != table_data.DATA['a'][slice])\nastropy\/table\/tests\/test_item_access.py:            assert np.all(t2['a'] == table_data.DATA['a'])\nastropy\/table\/tests\/test_item_access.py:            assert np.all(t2['c'] == table_data.DATA['c'])\nastropy\/table\/tests\/test_item_access.py:            assert np.all(self.t.as_array() == table_data.DATA)\nastropy\/table\/tests\/test_item_access.py:            assert np.any(t2['a'] != table_data.DATA['a'])\nastropy\/table\/serialize.py:                             'astropy.time.core.TimeDelta',\nastropy\/table\/serialize.py:                             'astropy.coordinates.distances.Distance',\nastropy\/table\/serialize.py:    # - name: handled directly [DON'T store]\nastropy\/table\/serialize.py:    # - unit: DON'T store if this is a parent attribute\nastropy\/table\/serialize.py:    # - dtype: captured in plain Column if relevant [DON'T store]\nastropy\/table\/serialize.py:    # - format: possibly irrelevant but settable post-object creation [DO store]\nastropy\/table\/serialize.py:    # - description: DO store\nastropy\/table\/serialize.py:    # - meta: DO store\nastropy\/table\/serialize.py:            # TODO masking, MaskedColumn\nastropy\/table\/serialize.py:    # Don't know final output class but assume QTable so no columns get\nastropy\/table\/tests\/test_masked.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_masked.py:class SetupData:\nastropy\/table\/tests\/test_masked.py:class TestPprint(SetupData):\nastropy\/table\/tests\/test_masked.py:class TestFillValue(SetupData):\nastropy\/table\/tests\/test_masked.py:        c.fill_value = 'ABCDEF'\nastropy\/table\/tests\/test_masked.py:        assert c.fill_value == 'ABCD'  # string truncated to dtype length\nastropy\/table\/tests\/test_masked.py:        assert np.all(c.filled() == ['ABCD', 'yyyy'])\nastropy\/table\/tests\/test_masked.py:class TestMaskedColumnInit(SetupData):\nastropy\/table\/tests\/test_masked.py:class TestTableInit(SetupData):\nastropy\/table\/tests\/test_masked.py:        # Do not convert to masked table, if new column has no masked value.\nastropy\/table\/tests\/test_showtable.py:            '  TIME   SOURCE ID ANTENNA NO. SUBARRAY FREQ ID ANT FLAG STATUS 1\\n'\nastropy\/table\/tests\/test_showtable.py:            '  DAYS                                                           \\n'\nastropy\/table\/tests\/test_showtable.py:            '   TIME    SOURCE ID ANTENNA NO. SUBARRAY FREQ ID ANT FLAG STATUS 1\\n'\nastropy\/table\/tests\/test_showtable.py:            '   DAYS                                                            \\n'\nastropy\/table\/tests\/test_showtable.py:        'Index RAh RAm  RAs  DE- DEd  DEm    DEs   Match Class  AK Fit ',\nastropy\/table\/tests\/test_showtable.py:        'Index RAh RAm  RAs  DE- DEd DEm DEs Match Class  AK Fit ',\nastropy\/table\/np_utils.py:from collections import OrderedDict, Counter\nastropy\/table\/np_utils.py:    col_name_map = OrderedDict((name, col_name_map[name]) for name in col_name_list)\nastropy\/table\/row.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/row.py:            raise ValueError('Datatype coercion is not allowed')\nastropy\/table\/row.py:        Display row as a single-line table but with appropriate header line.\nastropy\/io\/ascii\/fastbasic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/fastbasic.py:from collections import OrderedDict\nastropy\/io\/ascii\/fastbasic.py:        meta = OrderedDict()\nastropy\/io\/ascii\/fastbasic.py:        meta = OrderedDict()\nastropy\/io\/ascii\/fastbasic.py:            raise ValueError('RDB header requires 2 lines')\nastropy\/io\/ascii\/fastbasic.py:            raise ValueError('RDB header mismatch between number of '\nastropy\/io\/ascii\/fastbasic.py:            raise ValueError('RDB type definitions do not all match '\nastropy\/table\/column.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/column.py:from ..utils.metadata import MetaData\nastropy\/table\/column.py:        Data shape\nastropy\/table\/column.py:    meta = MetaData()\nastropy\/table\/column.py:            arguments.)  Default is 'C'.\nastropy\/table\/column.py:            reference.  Default is True.\nastropy\/table\/column.py:        # Define Column-specific attrs and meta that gets added to state.\nastropy\/table\/column.py:            Include column name. Default is True.\nastropy\/table\/column.py:            Include a header row for unit. Default is False.\nastropy\/table\/column.py:            Include column dtype. Default is False.\nastropy\/table\/column.py:            Format the output as an HTML table. Default is False.\nastropy\/table\/column.py:            Include column name. Default is True.\nastropy\/table\/column.py:            Include a header row for unit. Default is False.\nastropy\/table\/column.py:            Include column dtype. Default is True.\nastropy\/table\/column.py:            Include a header row for column names. Default is True.\nastropy\/table\/column.py:            Include a header row for unit. Default is False.\nastropy\/table\/column.py:    \"\"\"Define a data column for use in a Table object.\nastropy\/table\/column.py:        Data type for column\nastropy\/table\/column.py:        Dimensions of a single row element in the column data\nastropy\/table\/column.py:            the column array is flattened before insertion.  Default is 0,\nastropy\/table\/column.py:    \"\"\"Define a masked data column for use in a Table object.\nastropy\/table\/column.py:        Data type for column\nastropy\/table\/column.py:        Dimensions of a single row element in the column data\nastropy\/table\/column.py:            the column array is flattened before insertion.  Default is 0,\nastropy\/io\/ascii\/fixedwidth.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/fixedwidth.py:from .core import InconsistentTableError, DefaultSplitter\nastropy\/io\/ascii\/fixedwidth.py:class FixedWidthHeaderSplitter(DefaultSplitter):\nastropy\/io\/ascii\/fixedwidth.py:                # Define self.col_starts and self.col_ends so that the call to\nastropy\/io\/ascii\/fixedwidth.py:class FixedWidthData(basic.BasicData):\nastropy\/io\/ascii\/fixedwidth.py:    data_class = FixedWidthData\nastropy\/io\/ascii\/fixedwidth.py:class FixedWidthNoHeaderData(FixedWidthData):\nastropy\/io\/ascii\/fixedwidth.py:    '''Data reader for fixed width tables with no header line'''\nastropy\/io\/ascii\/fixedwidth.py:    data_class = FixedWidthNoHeaderData\nastropy\/io\/ascii\/fixedwidth.py:    splitter_class = DefaultSplitter\nastropy\/io\/ascii\/fixedwidth.py:class FixedWidthTwoLineDataSplitter(FixedWidthSplitter):\nastropy\/io\/ascii\/fixedwidth.py:class FixedWidthTwoLineData(FixedWidthData):\nastropy\/io\/ascii\/fixedwidth.py:    '''Data reader for fixed with tables with two header lines.'''\nastropy\/io\/ascii\/fixedwidth.py:    splitter_class = FixedWidthTwoLineDataSplitter\nastropy\/io\/ascii\/fixedwidth.py:    data_class = FixedWidthTwoLineData\nastropy\/io\/ascii\/ecsv.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/ecsv.py:Define the Enhanced Character-Separated-Values (ECSV) which allows for reading and\nastropy\/io\/ascii\/ecsv.py:from collections import OrderedDict\nastropy\/io\/ascii\/ecsv.py:DELIMITERS = (' ', ',')\nastropy\/io\/ascii\/ecsv.py:        if self.splitter.delimiter not in DELIMITERS:\nastropy\/io\/ascii\/ecsv.py:            if delimiter not in DELIMITERS:\nastropy\/io\/ascii\/ecsv.py:        header_cols = OrderedDict((x['name'], x) for x in header['datatype'])\nastropy\/io\/ascii\/ipac.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/ipac.py:from collections import defaultdict, OrderedDict\nastropy\/io\/ascii\/ipac.py:class IpacFormatErrorDBMS(Exception):\nastropy\/io\/ascii\/ipac.py:            'http:\/\/irsa.ipac.caltech.edu\/applications\/DDGEN\/Doc\/DBMSrestriction.html')\nastropy\/io\/ascii\/ipac.py:            'http:\/\/irsa.ipac.caltech.edu\/applications\/DDGEN\/Doc\/ipac_tbl.html')\nastropy\/io\/ascii\/ipac.py:    # Defined ordered list of possible types.  Ordering is needed to\nastropy\/io\/ascii\/ipac.py:        http:\/\/irsa.ipac.caltech.edu\/applications\/DDGEN\/Doc\/ipac_tbl.html#kw\nastropy\/io\/ascii\/ipac.py:        table_meta['keywords'] = OrderedDict()\nastropy\/io\/ascii\/ipac.py:        if self.DBMS:\nastropy\/io\/ascii\/ipac.py:            IpacFormatE = IpacFormatErrorDBMS\nastropy\/io\/ascii\/ipac.py:        if self.DBMS:\nastropy\/io\/ascii\/ipac.py:                raise IpacFormatE('IPAC DBMS tables are not case sensitive. '\nastropy\/io\/ascii\/ipac.py:            if self.DBMS and not(name[0].isalpha() or (name[0] == '_')):\nastropy\/io\/ascii\/ipac.py:            if self.DBMS:\nastropy\/io\/ascii\/ipac.py:class IpacDataSplitter(fixedwidth.FixedWidthSplitter):\nastropy\/io\/ascii\/ipac.py:class IpacData(fixedwidth.FixedWidthData):\nastropy\/io\/ascii\/ipac.py:    splitter_class = IpacDataSplitter\nastropy\/io\/ascii\/ipac.py:    http:\/\/irsa.ipac.caltech.edu\/applications\/DDGEN\/Doc\/ipac_tbl.html::\nastropy\/io\/ascii\/ipac.py:    DBMS : bool, optional\nastropy\/io\/ascii\/ipac.py:        to the `IPAC\/DBMS <http:\/\/irsa.ipac.caltech.edu\/applications\/DDGEN\/Doc\/DBMSrestriction.html>`_\nastropy\/io\/ascii\/ipac.py:        `IPAC <http:\/\/irsa.ipac.caltech.edu\/applications\/DDGEN\/Doc\/ipac_tbl.html>`_\nastropy\/io\/ascii\/ipac.py:    data_class = IpacData\nastropy\/io\/ascii\/ipac.py:    def __init__(self, definition='ignore', DBMS=False):\nastropy\/io\/ascii\/ipac.py:        self.header.DBMS = DBMS\nastropy\/table\/tests\/test_subclass.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/setup_package.py:# Licensed under a 3-clause BSD style license\nastropy\/table\/tests\/test_jsviewer.py:EXTERN_DIR = abspath(dirname(extern.__file__))\nastropy\/table\/tests\/test_jsviewer.py:        columnDefs: [{targets: [0], type: \"optionalnum\"}]\nastropy\/table\/tests\/test_jsviewer.py:        datatables_css_url='file:\/\/' + join(EXTERN_DIR, 'css', 'jquery.dataTables.css'),\nastropy\/table\/tests\/test_jsviewer.py:        datatables_js_url='file:\/\/' + join(EXTERN_DIR, 'js', 'jquery.dataTables.min.js'),\nastropy\/table\/tests\/test_jsviewer.py:        jquery_url='file:\/\/' + join(EXTERN_DIR, 'js', 'jquery-3.1.1.min.js')\nastropy\/io\/ascii\/connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/connect.py:    out = Table(list(zip(*rows)), names=('Format', 'Suffix', 'Write', 'Description'))\nastropy\/io\/ascii\/connect.py:    for colname in ('Format', 'Description'):\nastropy\/table\/index.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/ply\/__init__.py:# Author: David Beazley (dave@dabeaz.com)\nastropy\/io\/ascii\/tests\/test_ecsv.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_ecsv.py:from ....time import Time, TimeDelta\nastropy\/io\/ascii\/tests\/test_ecsv.py:from ..ecsv import DELIMITERS\nastropy\/io\/ascii\/tests\/test_ecsv.py:DTYPES = ['bool', 'int8', 'int16', 'int32', 'int64', 'uint8', 'uint16', 'uint32',\nastropy\/io\/ascii\/tests\/test_ecsv.py:    DTYPES.remove('float128')\nastropy\/io\/ascii\/tests\/test_ecsv.py:T_DTYPES = Table()\nastropy\/io\/ascii\/tests\/test_ecsv.py:for dtype in DTYPES:\nastropy\/io\/ascii\/tests\/test_ecsv.py:    T_DTYPES[dtype] = c\nastropy\/io\/ascii\/tests\/test_ecsv.py:T_DTYPES.meta['comments'] = ['comment1', 'comment2']\nastropy\/io\/ascii\/tests\/test_ecsv.py:    t = T_DTYPES['bool', 'int64', 'float64', 'str']\nastropy\/io\/ascii\/tests\/test_ecsv.py:    t = T_DTYPES\nastropy\/io\/ascii\/tests\/test_ecsv.py:    for delimiter in DELIMITERS:\nastropy\/io\/ascii\/tests\/test_ecsv.py:        T_DTYPES.write(out, format='ascii.ecsv', delimiter='|')\nastropy\/io\/ascii\/tests\/test_ecsv.py:    'dt': TimeDelta([1, 2] * u.day),\nastropy\/io\/ascii\/tests\/test_ecsv.py:            # Downgrade Quantity to Column + unit\nastropy\/table\/groups.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/groups.py:        # 'mergesort' for all data types.  MacOSX (Darwin) doesn't have a stable\nastropy\/table\/groups.py:        stable_sort = platform.system() not in ('Darwin', 'Windows')\nastropy\/io\/ascii\/basic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/basic.py:class BasicData(core.BaseData):\nastropy\/io\/ascii\/basic.py:    Basic table Data Reader\nastropy\/io\/ascii\/basic.py:      # Default delimiter is the space character.\nastropy\/io\/ascii\/basic.py:      # Data starts after the header column definition, blank lines ignored\nastropy\/io\/ascii\/basic.py:    data_class = BasicData\nastropy\/io\/ascii\/basic.py:class NoHeaderData(BasicData):\nastropy\/io\/ascii\/basic.py:    Data starts at first uncommented line since there is no header line.\nastropy\/io\/ascii\/basic.py:    data_class = NoHeaderData\nastropy\/io\/ascii\/basic.py:    data_class = NoHeaderData\nastropy\/io\/ascii\/basic.py:class TabHeaderSplitter(core.DefaultSplitter):\nastropy\/io\/ascii\/basic.py:class TabDataSplitter(TabHeaderSplitter):\nastropy\/io\/ascii\/basic.py:    Don't strip data value whitespace since that is significant in TSV tables\nastropy\/io\/ascii\/basic.py:class TabData(BasicData):\nastropy\/io\/ascii\/basic.py:    splitter_class = TabDataSplitter\nastropy\/io\/ascii\/basic.py:    data_class = TabData\nastropy\/io\/ascii\/basic.py:class CsvSplitter(core.DefaultSplitter):\nastropy\/io\/ascii\/basic.py:class CsvData(BasicData):\nastropy\/io\/ascii\/basic.py:    Data that uses the :class:`astropy.io.ascii.basic.CsvSplitter`\nastropy\/io\/ascii\/basic.py:    data_class = CsvData\nastropy\/io\/ascii\/basic.py:    Header for RDB tables\nastropy\/io\/ascii\/basic.py:        This is a specialized get_cols for the RDB type:\nastropy\/io\/ascii\/basic.py:        Line 0: RDB col names\nastropy\/io\/ascii\/basic.py:        Line 1: RDB col definitions\nastropy\/io\/ascii\/basic.py:        Line 2+: RDB data rows\nastropy\/io\/ascii\/basic.py:            raise ValueError('RDB header requires 2 lines')\nastropy\/io\/ascii\/basic.py:            raise ValueError('RDB header mismatch between number of column names and column types')\nastropy\/io\/ascii\/basic.py:            raise ValueError('RDB types definitions do not all match [num](N|S): {}'.format(raw_types))\nastropy\/io\/ascii\/basic.py:class RdbData(TabData):\nastropy\/io\/ascii\/basic.py:    Data reader for RDB data. Starts reading at line 2.\nastropy\/io\/ascii\/basic.py:    line.  The RDB format meets this definition.  Example::\nastropy\/io\/ascii\/basic.py:    data_class = RdbData\nastropy\/config\/affiliated.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_write.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_write.py:from ....utils.exceptions import AstropyWarning, AstropyDeprecationWarning\nastropy\/io\/ascii\/tests\/test_write.py:ID XCENTER YCENTER MAG MERR MSKY NITER SHARPNESS CHI PIER PERROR\nastropy\/io\/ascii\/tests\/test_write.py:ID XCENTER YCENTER MAG MERR MSKY NITER SHARPNESS CHI PIER PERROR\nastropy\/io\/ascii\/tests\/test_write.py:ID\\tXCENTER\\tYCENTER\\tMAG\\tMERR\\tMSKY\\tNITER\\tSHARPNESS\\tPIER\\tPERROR\nastropy\/io\/ascii\/tests\/test_write.py:ID\\tXCENTER\\tYCENTER\\tMAG\\tMERR\\tMSKY\\tNITER\\tSHARPNESS\\tCHI\\tPIER\\tPERROR\nastropy\/io\/ascii\/tests\/test_write.py:ID,XCENTER,YCENTER,MAG,MERR,MSKY,NITER,SHARPNESS,CHI,PIER,PERROR\nastropy\/io\/ascii\/tests\/test_write.py:# ID XCENTER YCENTER MAG MERR MSKY NITER SHARPNESS CHI PIER PERROR\nastropy\/io\/ascii\/tests\/test_write.py:&ID XCENTER YCENTER MAG MERR MSKY NITER SHARPNESS CHI PIER PERROR\nastropy\/io\/ascii\/tests\/test_write.py:ID & XCENTER & YCENTER & MAG & MERR & MSKY & NITER & SHARPNESS & CHI & PIER & PERROR \\\\\\\\\nastropy\/io\/ascii\/tests\/test_write.py:\\\\tablehead{\\\\colhead{ID} & \\\\colhead{XCENTER} & \\\\colhead{YCENTER} & \\\\colhead{MAG} & \\\\colhead{MERR} & \\\\colhead{MSKY} & \\\\colhead{NITER} & \\\\colhead{SHARPNESS} & \\\\colhead{CHI} & \\\\colhead{PIER} & \\\\colhead{PERROR}\\\\\\\\ \\\\colhead{ } & \\\\colhead{pixels} & \\\\colhead{pixels} & \\\\colhead{magnitudes} & \\\\colhead{magnitudes} & \\\\colhead{counts} & \\\\colhead{ } & \\\\colhead{ } & \\\\colhead{ } & \\\\colhead{ } & \\\\colhead{perrors}}\nastropy\/io\/ascii\/tests\/test_write.py:\\\\tablehead{\\\\colhead{ID} & \\\\colhead{XCENTER} & \\\\colhead{YCENTER} & \\\\colhead{MAG} & \\\\colhead{MERR} & \\\\colhead{MSKY} & \\\\colhead{NITER} & \\\\colhead{SHARPNESS} & \\\\colhead{CHI} & \\\\colhead{PIER} & \\\\colhead{PERROR}\\\\\\\\ \\\\colhead{ } & \\\\colhead{[pixel]} & \\\\colhead{pixels} & \\\\colhead{[mag]} & \\\\colhead{magnitudes} & \\\\colhead{counts} & \\\\colhead{ } & \\\\colhead{ } & \\\\colhead{ } & \\\\colhead{ } & \\\\colhead{perrors}}\nastropy\/io\/ascii\/tests\/test_write.py:ID & XCENTER & YCENTER & MAG & MERR & MSKY & NITER & SHARPNESS & CHI & PIER & PERROR \\\\\\\\\nastropy\/io\/ascii\/tests\/test_write.py:ID & XCENTER & YCENTER & MAG & MERR & MSKY & NITER & SHARPNESS & CHI & PIER & PERROR \\\\\\\\\nastropy\/io\/ascii\/tests\/test_write.py:ID & XCENTER & YCENTER & MAG & MERR & MSKY & NITER & SHARPNESS & CHI & PIER & PERROR \\\\\\\\\nastropy\/io\/ascii\/tests\/test_write.py:     <th>ID<\/th>\nastropy\/io\/ascii\/tests\/test_write.py:\\\\MERGERAD='INDEF'\nastropy\/io\/ascii\/tests\/test_write.py:\\\\DATE='05-28-93'\nastropy\/io\/ascii\/tests\/test_write.py:\\\\DATAMIN='50.'\nastropy\/io\/ascii\/tests\/test_write.py:\\\\DATAMAX='24500.'\nastropy\/io\/ascii\/tests\/test_write.py:\\\\READNOISE='0.'\nastropy\/io\/ascii\/tests\/test_write.py:\\\\PSFRAD='5.'\nastropy\/io\/ascii\/tests\/test_write.py:\\\\FITRAD='3.'\nastropy\/io\/ascii\/tests\/test_write.py:|       ID|   XCENTER|   YCENTER|         MAG|          MERR|           MSKY| NITER|              SHARPNESS|         CHI|  PIER|       PERROR|\nastropy\/io\/ascii\/tests\/test_write.py:    table = ascii.get_reader(Reader=ascii.Daophot)\nastropy\/io\/ascii\/tests\/test_write.py:    with catch_warnings(AstropyDeprecationWarning) as warning:\nastropy\/table\/tests\/test_column.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/table\/tests\/test_column.py:    assert isinstance(qtab['f'], u.Dex)\nastropy\/config\/paths.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/paths.py:        elif 'HOMEDRIVE' in os.environ and 'HOMEPATH' in os.environ:\nastropy\/config\/paths.py:            homedir = os.path.join(os.environ['HOMEDRIVE'],\nastropy\/config\/paths.py:    Determines the Astropy configuration directory name and creates the\nastropy\/config\/paths.py:    XDG_CONFIG_HOME environment variable is set and the\nastropy\/config\/paths.py:    ``$XDG_CONFIG_HOME\/astropy`` directory exists, it will be that directory.\nastropy\/config\/paths.py:    # first look for XDG_CONFIG_HOME\nastropy\/config\/paths.py:    xch = os.environ.get('XDG_CONFIG_HOME')\nastropy\/config\/paths.py:    Determines the Astropy cache directory name and creates the directory if it\nastropy\/config\/paths.py:    XDG_CACHE_HOME environment variable is set and the\nastropy\/config\/paths.py:    ``$XDG_CACHE_HOME\/astropy`` directory exists, it will be that directory.\nastropy\/config\/paths.py:    # first look for XDG_CACHE_HOME\nastropy\/config\/paths.py:    xch = os.environ.get('XDG_CACHE_HOME')\nastropy\/config\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_rst.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/latex.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/latex.py:    '''Split LaTeX table date. Default delimiter is `&`.\nastropy\/io\/ascii\/latex.py:class LatexData(core.BaseData):\nastropy\/io\/ascii\/latex.py:        core.BaseData.write(self, lines)\nastropy\/io\/ascii\/latex.py:    **latexdict** : Dictionary of extra parameters for the LaTeX output\nastropy\/io\/ascii\/latex.py:    data_class = LatexData\nastropy\/io\/ascii\/latex.py:class AASTexData(LatexData):\nastropy\/io\/ascii\/latex.py:        core.BaseData.write(self, lines)\nastropy\/io\/ascii\/latex.py:    data_class = AASTexData\nastropy\/config\/configuration.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/configuration.py:from ..utils.exceptions import AstropyWarning, AstropyDeprecationWarning\nastropy\/config\/configuration.py:from ..utils.misc import InheritDocstrings\nastropy\/config\/configuration.py:class ConfigurationDefaultMissingError(ValueError):\nastropy\/config\/configuration.py:class ConfigurationDefaultMissingWarning(AstropyWarning):\nastropy\/config\/configuration.py:class ConfigItem(metaclass=InheritDocstrings):\nastropy\/config\/configuration.py:                    AstropyDeprecationWarning)\nastropy\/config\/configuration.py:                AstropyDeprecationWarning)\nastropy\/config\/configuration.py:    Determines if a config file can be safely replaced because it doesn't\nastropy\/config\/configuration.py:    # Don't install template files for dev versions, or we'll end up\nastropy\/io\/ascii\/tests\/test_compressed.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_read.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_read.py:from collections import OrderedDict\nastropy\/io\/ascii\/tests\/test_read.py:        print('\\n\\n******** READING {}'.format(testfile['name']))\nastropy\/io\/ascii\/tests\/test_read.py:        print('\\n\\n******** READING {}'.format(testfile['name']))\nastropy\/io\/ascii\/tests\/test_read.py:        print('\\n\\n******** READING {}'.format(testfile['name']))\nastropy\/io\/ascii\/tests\/test_read.py:    \"\"\"Test that INDEF is correctly interpreted as a missing value\"\"\"\nastropy\/io\/ascii\/tests\/test_read.py:    table = ascii.read('t\/daophot2.dat', Reader=ascii.Daophot)\nastropy\/io\/ascii\/tests\/test_read.py:        # Three columns have all INDEF values and are masked\nastropy\/io\/ascii\/tests\/test_read.py:    inferred automatically based only data values.  DAOphot reader uses\nastropy\/io\/ascii\/tests\/test_read.py:    table = ascii.read('t\/daophot2.dat', Reader=ascii.Daophot)\nastropy\/io\/ascii\/tests\/test_read.py:    assert table['LID'].dtype.char in 'fd'  # float or double\nastropy\/io\/ascii\/tests\/test_read.py:    assert table['ID'].dtype.char in 'il'  # int or long\nastropy\/io\/ascii\/tests\/test_read.py:    table = ascii.read('t\/daophot.dat', Reader=ascii.Daophot)\nastropy\/io\/ascii\/tests\/test_read.py:    table = ascii.read('t\/daophot3.dat', Reader=ascii.Daophot)\nastropy\/io\/ascii\/tests\/test_read.py:    table = ascii.read('t\/daophot4.dat', Reader=ascii.Daophot)\nastropy\/io\/ascii\/tests\/test_read.py:    include_names = ('ID', 'MAG', 'PIER')\nastropy\/io\/ascii\/tests\/test_read.py:    exclude_names = ('ID', 'YCENTER', 'MERR', 'NITER', 'CHI', 'PERROR')\nastropy\/io\/ascii\/tests\/test_read.py:    keywords = OrderedDict((('intval', 1),\nastropy\/io\/ascii\/tests\/test_read.py:    \"\"\"Read RDB data with inconstent data type (except failure)\"\"\"\nastropy\/io\/ascii\/tests\/test_read.py:                  'DE-',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEd',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEm',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEs',\nastropy\/io\/ascii\/tests\/test_read.py:        # Test malformed CDS file (issues #2241 #467)\nastropy\/io\/ascii\/tests\/test_read.py:                  'DE-',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEd',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEm',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEs',\nastropy\/io\/ascii\/tests\/test_read.py:        {'cols': ('ID',\nastropy\/io\/ascii\/tests\/test_read.py:         'opts': {'Reader': ascii.Daophot}},\nastropy\/io\/ascii\/tests\/test_read.py:                  'objID',\nastropy\/io\/ascii\/tests\/test_read.py:                  'SpecObjID',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DE-',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEd',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEm',\nastropy\/io\/ascii\/tests\/test_read.py:                  'DEs',\nastropy\/io\/ascii\/tests\/test_read.py:        {'cols': ('ID',\nastropy\/io\/ascii\/tests\/test_read.py:         'opts': {'Reader': ascii.Daophot}},\nastropy\/io\/ascii\/tests\/test_read.py:                   ascii.BaseReader, ascii.FixedWidthNoHeader, ascii.Cds, ascii.Daophot]:\nastropy\/io\/ascii\/tests\/test_read.py:    expected_columns = ['X_IMAGE', 'Y_IMAGE', 'ALPHA_J2000', 'DELTA_J2000',\nastropy\/io\/ascii\/tests\/test_read.py:                       'Declination of barycenter (J2000)',\nastropy\/io\/ascii\/tests\/test_read.py:             '| r  | rE | rea  | real | D | do | dou | f  | i | l | da| c |',\nastropy\/io\/ascii\/tests\/test_read.py:        if platform.system() == 'Darwin':\nastropy\/io\/ascii\/tests\/test_read.py:            locale.setlocale(locale.LC_ALL, str('de_DE'))\nastropy\/io\/ascii\/tests\/test_read.py:            locale.setlocale(locale.LC_ALL, str('de_DE.utf8'))\nastropy\/io\/ascii\/tests\/test_read.py:# Default delimiter is the space character.\nastropy\/io\/ascii\/tests\/test_read.py:# Data starts after the header column definition, blank lines ignored\nastropy\/io\/ascii\/tests\/test_read.py:    # TO DO commented_header does not currently work due to the special-cased\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:from ..ipac import Ipac, IpacFormatError, IpacFormatErrorDBMS\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:DATA = '''\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    table = read(DATA, Reader=Ipac)\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    table = read(DATA, Reader=Ipac, definition='ignore')\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    table = read(DATA, Reader=Ipac, definition='left')\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    table = read(DATA, Reader=Ipac, definition='right')\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    with pytest.raises(IpacFormatErrorDBMS):\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:        ascii.write(table, out, Writer=Ipac, DBMS=True)\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:        ascii.write(table, out, Writer=Ipac, DBMS=False)\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:@pytest.mark.parametrize((\"strict_\", \"Err\"), [(True, IpacFormatErrorDBMS), (False, IpacFormatError)])\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:        ascii.write(table, out, Writer=Ipac, DBMS=strict_)\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    with pytest.raises(IpacFormatErrorDBMS):\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:        ascii.write(table, out, Writer=Ipac, DBMS=True)\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    table = Table([[3], [1]], names=['DEC', 'dec'])\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    with pytest.raises(IpacFormatErrorDBMS):\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:        ascii.write(table, out, Writer=Ipac, DBMS=True)\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:    with pytest.raises(IpacFormatErrorDBMS):\nastropy\/io\/ascii\/tests\/test_ipac_definitions.py:        ascii.write(table, out, Writer=Ipac, DBMS=True)\nastropy\/io\/ascii\/ui.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/ui.py:from ...utils.exceptions import AstropyWarning, AstropyDeprecationWarning\nastropy\/io\/ascii\/ui.py:# Default setting for guess parameter in read()\nastropy\/io\/ascii\/ui.py:    Determine if ``table`` probably contains HTML content.  See PR #3693 and issue\nastropy\/io\/ascii\/ui.py:        if re.match(r'\\s* <! \\s* DOCTYPE \\s* HTML', table, re.IGNORECASE | re.VERBOSE):\nastropy\/io\/ascii\/ui.py:        # Look for <TABLE .. >, <TR .. >, <TD .. > tag openers.\nastropy\/io\/ascii\/ui.py:        Reader class (DEPRECATED). Default is :class:`Basic`.\nastropy\/io\/ascii\/ui.py:        Dictionary of converters.\nastropy\/io\/ascii\/ui.py:        Try to guess the table format. Defaults to None.\nastropy\/io\/ascii\/ui.py:        Dictionary of converters\nastropy\/io\/ascii\/ui.py:            Fortran-style scientific notation like ``'3.14159D+00'`` (``'E'``, ``'D'``, ``'Q'``),\nastropy\/io\/ascii\/ui.py:            approximately ``chunk_size`` bytes. Default is reading table in one pass.\nastropy\/io\/ascii\/ui.py:        Reader class (DEPRECATED)\nastropy\/io\/ascii\/ui.py:    # Downstream readers might munge kwargs\nastropy\/io\/ascii\/ui.py:        # #2001.  If a `readme` arg was passed that implies CDS format, in\nastropy\/io\/ascii\/ui.py:            # Do guess_kwargs.update(read_kwargs) except that if guess_args has\nastropy\/io\/ascii\/ui.py:    # Define whitelist of exceptions that are expected from readers when\nastropy\/io\/ascii\/ui.py:                              dict(Reader=daophot.Daophot),\nastropy\/io\/ascii\/ui.py:        Writer class (DEPRECATED). Defaults to :class:`Basic`.\nastropy\/io\/ascii\/ui.py:        Dictionary of format specifiers or formatting functions\nastropy\/io\/ascii\/ui.py:        Output [filename, file-like object]. Defaults to``sys.stdout``.\nastropy\/io\/ascii\/ui.py:        Output table format. Defaults to 'basic'.\nastropy\/io\/ascii\/ui.py:        Dictionary of format specifiers or formatting functions\nastropy\/io\/ascii\/ui.py:        Writer class (DEPRECATED).\nastropy\/io\/ascii\/ui.py:                        output), AstropyDeprecationWarning)\nastropy\/io\/ascii\/tests\/common.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/common.py:CWD = os.getcwd()\nastropy\/io\/ascii\/tests\/common.py:TEST_DIR = os.path.dirname(__file__)\nastropy\/io\/ascii\/tests\/common.py:    os.chdir(TEST_DIR)\nastropy\/io\/ascii\/tests\/common.py:    os.chdir(CWD)\nastropy\/io\/ascii\/tests\/test_c_reader.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_c_reader.py:    # TODO: also read from file\nastropy\/io\/ascii\/tests\/test_c_reader.py:A B C D E\nastropy\/io\/ascii\/tests\/test_c_reader.py:    assert_equal(table['D'].dtype.kind, 'f')\nastropy\/io\/ascii\/tests\/test_c_reader.py:    table = read_basic(\"A B C D\\n1 2 3 4\\n5 6 7 8\", include_names=['A', 'D'], parallel=parallel)\nastropy\/io\/ascii\/tests\/test_c_reader.py:    expected = Table([[1, 5], [4, 8]], names=('A', 'D'))\nastropy\/io\/ascii\/tests\/test_c_reader.py:    table = read_basic(\"A B C D\\n1 2 3 4\\n5 6 7 8\", exclude_names=['A', 'D'], parallel=parallel)\nastropy\/io\/ascii\/tests\/test_c_reader.py:A B C D E F G H\nastropy\/io\/ascii\/tests\/test_c_reader.py:    table = read_basic(text, include_names=['A', 'B', 'D', 'F', 'H'],\nastropy\/io\/ascii\/tests\/test_c_reader.py:    expected = Table([[1, 9], [4, 12], [8, 16]], names=('A', 'D', 'H'))\nastropy\/io\/ascii\/tests\/test_c_reader.py:\"A B\" C D\nastropy\/io\/ascii\/tests\/test_c_reader.py:    expected = Table([['1.5', 'a'], ['2.1', 'b'], ['-37.1', 'cd']], names=('A B', 'C', 'D'))\nastropy\/io\/ascii\/tests\/test_c_reader.py:    ('header_Splitter', ascii.DefaultSplitter),  # passing Splitter\nastropy\/io\/ascii\/tests\/test_c_reader.py:    ('data_Splitter', ascii.DefaultSplitter)])\nastropy\/io\/ascii\/tests\/test_c_reader.py:    # make sure data_end works with RDB\nastropy\/io\/ascii\/tests\/test_c_reader.py:    is large (so that each header string is longer than INITIAL_HEADER_SIZE).\nastropy\/io\/ascii\/tests\/test_c_reader.py:    Readers that don't strip whitespace from data (Tab, RDB)\nastropy\/io\/ascii\/tests\/test_c_reader.py:\\tdecDeg\\tRate_pn_offAxis\\tRate_mos2_offAxis\\tObsID\\tSourceID\\tRADeg\\tversion\\tCounts_pn\\tRate_pn\\trun\\tRate_mos1\\tRate_mos2\\tInserted_pn\\tInserted_mos2\\tbeta\\tRate_mos1_offAxis\\trcArcsec\\tname\\tInserted\\tCounts_mos1\\tInserted_mos1\\tCounts_mos2\\ty\\tx\\tCounts\\toffAxis\\tRot\nastropy\/io\/ascii\/tests\/test_c_reader.py:@pytest.mark.skipif(not os.getenv('TEST_READ_HUGE_FILE'),\nastropy\/io\/ascii\/tests\/test_c_reader.py:                    reason='Environment variable TEST_READ_HUGE_FILE must be '\nastropy\/io\/ascii\/tests\/test_c_reader.py:    environment variable ``TEST_READ_HUGE_FILE`` is defined. Note that running\nastropy\/io\/ascii\/tests\/test_c_reader.py:    fields = ['.0101D202', '0.000000314d+314', '1777+305', '-1799E+305', '0.2e-323',\nastropy\/io\/ascii\/tests\/test_c_reader.py:    expstyles = {'e': 4*('E'), 'D': ('D', 'd', 'd', 'D'), 'Q': 2*('q', 'Q'),\nastropy\/io\/ascii\/tests\/test_c_reader.py:                  'fortran': ('D', 'E', 'Q', 'd')}\nastropy\/io\/ascii\/tests\/test_c_reader.py:        ascii.read(text.format(*(4*('D'))), format='basic', guess=False,\nastropy\/io\/ascii\/tests\/test_c_reader.py:                                'parallel': parallel, 'exponent_style': 'D'})\nastropy\/io\/ascii\/tests\/test_types.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/tests\/test_configs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/config\/tests\/test_configs.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/config\/tests\/test_configs.py:    ci = ConfigItem(34, 'this is a Description')\nastropy\/config\/tests\/test_configs.py:    assert ci.description == 'this is a Description'\nastropy\/config\/tests\/test_configs.py:    ci.description = 'updated Descr'\nastropy\/config\/tests\/test_configs.py:    ci.description = 'this is a Description'\nastropy\/config\/tests\/test_configs.py:    monkeypatch.setenv(str('XDG_CONFIG_HOME'), 'foo')\nastropy\/config\/tests\/test_configs.py:    monkeypatch.delenv(str('XDG_CONFIG_HOME'))\nastropy\/config\/tests\/test_configs.py:        tstnm12 = ConfigItem(42, 'this is another Description')\nastropy\/config\/tests\/test_configs.py:        with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/config\/tests\/test_configs.py:    # \"import astropy\" fails when neither $HOME or $XDG_CONFIG_HOME\nastropy\/config\/tests\/test_configs.py:    for val in ['HOME', 'XDG_CONFIG_HOME']:\nastropy\/config\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_cds_header_from_readme.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_cds_header_from_readme.py:        assert_equal(table['Q'].description, 'DAOSPEC quality parameter Q(large values are bad)')\nexamples\/io\/modify-fits-header.py:*License: BSD*\nexamples\/io\/modify-fits-header.py:# Download a FITS file:\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/codata2014.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/codata2014.py:class CODATA2014(Constant):\nastropy\/constants\/codata2014.py:    default_reference = 'CODATA 2014'\nastropy\/constants\/codata2014.py:class EMCODATA2014(CODATA2014, EMConstant):\nastropy\/constants\/codata2014.py:    _registry = CODATA2014._registry\nastropy\/constants\/codata2014.py:h = CODATA2014('h', \"Planck constant\", 6.626070040e-34,\nastropy\/constants\/codata2014.py:hbar = CODATA2014('hbar', \"Reduced Planck constant\", 1.054571800e-34,\nastropy\/constants\/codata2014.py:k_B = CODATA2014('k_B', \"Boltzmann constant\", 1.38064852e-23,\nastropy\/constants\/codata2014.py:c = CODATA2014('c', \"Speed of light in vacuum\", 299792458.,\nastropy\/constants\/codata2014.py:G = CODATA2014('G', \"Gravitational constant\", 6.67408e-11,\nastropy\/constants\/codata2014.py:g0 = CODATA2014('g0', \"Standard acceleration of gravity\", 9.80665,\nastropy\/constants\/codata2014.py:m_p = CODATA2014('m_p', \"Proton mass\", 1.672621898e-27,\nastropy\/constants\/codata2014.py:m_n = CODATA2014('m_n', \"Neutron mass\", 1.674927471e-27,\nastropy\/constants\/codata2014.py:m_e = CODATA2014('m_e', \"Electron mass\", 9.10938356e-31,\nastropy\/constants\/codata2014.py:u = CODATA2014('u', \"Atomic mass\", 1.660539040e-27,\nastropy\/constants\/codata2014.py:sigma_sb = CODATA2014('sigma_sb', \"Stefan-Boltzmann constant\", 5.670367e-8,\nastropy\/constants\/codata2014.py:e = EMCODATA2014('e', 'Electron charge', 1.6021766208e-19,\nastropy\/constants\/codata2014.py:eps0 = EMCODATA2014('eps0', 'Electric constant', 8.854187817e-12,\nastropy\/constants\/codata2014.py:N_A = CODATA2014('N_A', \"Avogadro's number\", 6.022140857e23,\nastropy\/constants\/codata2014.py:R = CODATA2014('R', \"Gas constant\", 8.3144598,\nastropy\/constants\/codata2014.py:Ryd = CODATA2014('Ryd', 'Rydberg constant', 10973731.568508,\nastropy\/constants\/codata2014.py:a0 = CODATA2014('a0', \"Bohr radius\", 0.52917721067e-10,\nastropy\/constants\/codata2014.py:muB = CODATA2014('muB', \"Bohr magneton\", 927.4009994e-26,\nastropy\/constants\/codata2014.py:alpha = CODATA2014('alpha', \"Fine-structure constant\", 7.2973525664e-3,\nastropy\/constants\/codata2014.py:atm = CODATA2014('atm', \"Standard atmosphere\", 101325,\nastropy\/constants\/codata2014.py:mu0 = CODATA2014('mu0', \"Magnetic constant\", 4.0e-7 * np.pi, 'N\/A2', 0.0,\nastropy\/constants\/codata2014.py:sigma_T = CODATA2014('sigma_T', \"Thomson scattering cross-section\",\nastropy\/constants\/codata2014.py:b_wien = CODATA2014('b_wien', 'Wien wavelength displacement law constant',\nastropy\/constants\/codata2014.py:e_esu = EMCODATA2014(e.abbrev, e.name, e.value * c.value * 10.0,\nastropy\/constants\/codata2014.py:e_emu = EMCODATA2014(e.abbrev, e.name, e.value \/ 10, 'abC',\nastropy\/constants\/codata2014.py:e_gauss = EMCODATA2014(e.abbrev, e.name, e.value * c.value * 10.0,\nastropy\/constants\/constant.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/constant.py:from ..utils.misc import InheritDocstrings\nastropy\/constants\/constant.py:class ConstantMeta(InheritDocstrings):\nastropy\/time\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/utils.py:doubles, using the procedure of Shewchuk, 1997, Discrete & Computational\nastropy\/time\/utils.py:    Discrete & Computational Geometry 18(3):305-363\nastropy\/time\/utils.py:    Discrete & Computational Geometry 18(3):305-363\nastropy\/time\/utils.py:    Discrete & Computational Geometry 18(3):305-363\nastropy\/time\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_html.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/io\/ascii\/tests\/test_html.py:    assert html.identify_table(soup, {}, 1) is True  # Default index of 1\nastropy\/io\/ascii\/tests\/test_html.py:    # Test identification by string ID\nastropy\/io\/ascii\/tests\/test_html.py:    # Identification by string ID\nastropy\/io\/ascii\/tests\/test_html.py:            html.SoupString(BeautifulSoup('<table><tr><td>Data 1<\/td><td>Data 2<\/td><\/tr><\/table>').tr)]\nastropy\/io\/ascii\/tests\/test_html.py:    expected_data = [['Col 1', 'Col 2'], ['Data 1', 'Data 2']]\nastropy\/io\/ascii\/tests\/test_html.py:    lines.append('<tr><td>Data 3<\/td><td>Data 4<\/td><\/tr>')\nastropy\/io\/ascii\/tests\/test_html.py:    lines = [html.SoupString(BeautifulSoup('<table><tr><td>Data<\/td><\/tr><\/table>').tr),\nastropy\/io\/ascii\/tests\/test_html.py:    of HTMLData returns the first line of table data. Uses\nastropy\/io\/ascii\/tests\/test_html.py:    data = html.HTMLData()\nastropy\/io\/ascii\/tests\/test_html.py:    lines.append('<tr><td>Data<\/td><\/tr>')\nastropy\/io\/ascii\/tests\/test_html.py:                      'raw_html_clean_kwargs': {'tags': bleach.ALLOWED_TAGS + ['p']}})\nastropy\/io\/ascii\/tests\/test_html.py:    ascii.write(t, buffer_output, fill_values=[(ascii.masked, 'MASKED')],\nastropy\/io\/ascii\/tests\/test_html.py:    t_expected = Table([['MASKED', 'MASKED', 3, 4], ['MASKED', 'MASKED', '--', 'b']], names=('a', 'b'))\nastropy\/utils\/introspection.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/introspection.py:        Defaults to just ``'__version__'``, which should work for most Python\nastropy\/utils\/introspection.py:    Determines the module\/package from which this function is called.\nastropy\/io\/ascii\/tests\/test_connect.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/core.py:UT1) and time representations (e.g. JD, MJD, ISO 8601) that are used in\nastropy\/time\/core.py:from ..utils import ShapedLikeNDArray\nastropy\/time\/core.py:from .formats import (TIME_FORMATS, TIME_DELTA_FORMATS,\nastropy\/time\/core.py:                      TimeJD, TimeUnique, TimeAstropyTime, TimeDatetime)\nastropy\/time\/core.py:__all__ = ['Time', 'TimeDelta', 'TIME_SCALES', 'TIME_DELTA_SCALES',\nastropy\/time\/core.py:TIME_DELTA_TYPES = dict((scale, scales)\nastropy\/time\/core.py:TIME_DELTA_SCALES = TIME_DELTA_TYPES.keys()\nastropy\/time\/core.py:#   \/* L_B = 1 - d(TDB)\/d(TCB), and TDB (s) at TAI 1977\/1\/1.0 *\/\nastropy\/time\/core.py:SIDEREAL_TIME_MODELS = {\nastropy\/time\/core.py:class TimeDeltaInfo(TimeInfo):\nastropy\/time\/core.py:class Time(ShapedLikeNDArray):\nastropy\/time\/core.py:    formats (e.g. JD) where very high precision (better than 64-bit precision)\nastropy\/time\/core.py:        Digits of precision in string representation of time\nastropy\/time\/core.py:    \"\"\"Dict of time formats\"\"\"\nastropy\/time\/core.py:    # Make sure that reverse arithmetic (e.g., TimeDelta.__rmul__)\nastropy\/time\/core.py:    # Declare that Time can be used as a Table column by defining the\nastropy\/time\/core.py:        # Determine the chain of scale transformations to get from the current\nastropy\/time\/core.py:        Decimal precision when outputting seconds as floating point (int\nastropy\/time\/core.py:        First of the two doubles that internally store time value(s) in JD.\nastropy\/time\/core.py:        Second of the two doubles that internally store time value(s) in JD.\nastropy\/time\/core.py:        which is consistent with the JPL DE405 ephemeris to an accuracy of\nastropy\/time\/core.py:        time_offset : `~astropy.time.TimeDelta`\nastropy\/time\/core.py:            in TDB seconds.  Should be added to the original time to get the\nastropy\/time\/core.py:        return TimeDelta(tcor_val, scale='tdb')\nastropy\/time\/core.py:        if kind.lower() not in SIDEREAL_TIME_MODELS.keys():\nastropy\/time\/core.py:                ' or '.join(sorted(SIDEREAL_TIME_MODELS.keys()))))\nastropy\/time\/core.py:        available_models = SIDEREAL_TIME_MODELS[kind.lower()]\nastropy\/time\/core.py:            'apparent', sorted(SIDEREAL_TIME_MODELS['apparent'].keys()),\nastropy\/time\/core.py:            'mean', sorted(SIDEREAL_TIME_MODELS['mean'].keys()))\nastropy\/time\/core.py:        tm._time = TimeJD(jd1, jd2, self.scale, self.precision,\nastropy\/time\/core.py:        the python stdlib to behave like `Time.copy`. Does *not* make a\nastropy\/time\/core.py:        copy of the JD arrays - only copies by reference.\nastropy\/time\/core.py:        in the python stdlib to behave like `Time.copy`. Does make a\nastropy\/time\/core.py:        copy of the JD arrays.\nastropy\/time\/core.py:            which argmin or argmax was used.  Default: ``False``.\nastropy\/time\/core.py:                raise ScaleValueError(\"Cannot convert TimeDelta with \"\nastropy\/time\/core.py:            ``astropy.utils.iers.FROM_IERS_A_PREDICTION``\nastropy\/time\/core.py:            ``astropy.utils.iers.TIME_BEYOND_IERS_RANGE``\nastropy\/time\/core.py:    # Property for ERFA DUT arg = UT1 - UTC\nastropy\/time\/core.py:        Get ERFA DUT arg = UT1 - UTC.  This getter takes optional jd1 and\nastropy\/time\/core.py:        # Sec. 4.3.1: the arg DUT is the quantity delta_UT1 = UT1 - UTC in\nastropy\/time\/core.py:        if hasattr(val, 'to'):  # Matches Quantity but also TimeDelta.\nastropy\/time\/core.py:    # Property for ERFA DTR arg = TDB - TT\nastropy\/time\/core.py:            # attribute access) then require that the time scale is TT or TDB.\nastropy\/time\/core.py:                                     'is only possible for TT or TDB time '\nastropy\/time\/core.py:            # TDB or TT) to an approximate UT1.  Since TT and TDB are\nastropy\/time\/core.py:        if hasattr(val, 'to'):  # Matches Quantity but also TimeDelta.\nastropy\/time\/core.py:    \"\"\"TDB - TT time scale offset\"\"\"\nastropy\/time\/core.py:                other = TimeDelta(other)\nastropy\/time\/core.py:        # Tdelta - something is dealt with in TimeDelta, so we have\nastropy\/time\/core.py:        other_is_delta = isinstance(other, TimeDelta)\nastropy\/time\/core.py:        # TimeDelta, but not for Time (which can be UTC)\nastropy\/time\/core.py:            self_time = (self._time if self.scale in TIME_DELTA_SCALES\nastropy\/time\/core.py:            # set up TimeDelta, subtraction to be done shortly\nastropy\/time\/core.py:            out = TimeDelta(self_time.jd1, self_time.jd2, format='jd',\nastropy\/time\/core.py:                other = TimeDelta(other)\nastropy\/time\/core.py:        # Tdelta + something is dealt with in TimeDelta, so we have\nastropy\/time\/core.py:        if not isinstance(other, TimeDelta):\nastropy\/time\/core.py:        # TimeDelta cannot be converted arbitrarily\nastropy\/time\/core.py:            raise TypeError(\"Cannot compare TimeDelta instances with scales \"\nastropy\/time\/core.py:    to_datetime.__doc__ = TimeDatetime.to_value.__doc__\nastropy\/time\/core.py:class TimeDelta(Time):\nastropy\/time\/core.py:    A TimeDelta object is initialized with one or more times in the ``val``\nastropy\/time\/core.py:    numeric input formats (e.g. JD) where very high precision (better than\nastropy\/time\/core.py:      >>> list(TimeDelta.FORMATS)\nastropy\/time\/core.py:    val : sequence, ndarray, number, or `~astropy.time.TimeDelta` object\nastropy\/time\/core.py:    SCALES = TIME_DELTA_SCALES\nastropy\/time\/core.py:    FORMATS = TIME_DELTA_FORMATS\nastropy\/time\/core.py:    \"\"\"Dict of time delta formats.\"\"\"\nastropy\/time\/core.py:    info = TimeDeltaInfo()\nastropy\/time\/core.py:        if isinstance(val, TimeDelta):\nastropy\/time\/core.py:                self.SCALES = TIME_DELTA_TYPES[scale]\nastropy\/time\/core.py:        # For TimeDelta, there can only be a change in scale factor,\nastropy\/time\/core.py:        # only deal with TimeDelta + TimeDelta\nastropy\/time\/core.py:            if not isinstance(other, TimeDelta):\nastropy\/time\/core.py:                other = TimeDelta(other)\nastropy\/time\/core.py:        # the scales should be compatible (e.g., cannot convert TDB to TAI)\nastropy\/time\/core.py:            raise TypeError(\"Cannot add TimeDelta instances with scales \"\nastropy\/time\/core.py:        # only deal with TimeDelta - TimeDelta\nastropy\/time\/core.py:            if not isinstance(other, TimeDelta):\nastropy\/time\/core.py:                other = TimeDelta(other)\nastropy\/time\/core.py:        # the scales should be compatible (e.g., cannot convert TDB to TAI)\nastropy\/time\/core.py:            raise TypeError(\"Cannot subtract TimeDelta instances with scales \"\nastropy\/time\/core.py:        \"\"\"Negation of a `TimeDelta` object.\"\"\"\nastropy\/time\/core.py:        \"\"\"Absolute value of a `TimeDelta` object.\"\"\"\nastropy\/time\/core.py:        \"\"\"Multiplication of `TimeDelta` objects by numbers\/arrays.\"\"\"\nastropy\/time\/core.py:            out = TimeDelta(jd1, jd2, format='jd', scale=self.scale)\nastropy\/time\/core.py:        \"\"\"Multiplication of numbers\/arrays with `TimeDelta` objects.\"\"\"\nastropy\/time\/core.py:        \"\"\"Division of `TimeDelta` objects by numbers\/arrays.\"\"\"\nastropy\/time\/core.py:        \"\"\"Division by `TimeDelta` objects of numbers\/arrays.\"\"\"\nastropy\/time\/core.py:        \"\"\"Division of `TimeDelta` objects by numbers\/arrays.\"\"\"\nastropy\/time\/core.py:            out = TimeDelta(jd1, jd2, format='jd', scale=self.scale)\nastropy\/time\/core.py:        \"\"\"Division by `TimeDelta` objects of numbers\/arrays.\"\"\"\nastropy\/coordinates\/angle_lextab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angle_lextab.py:_lextokens    = set(('UINT', 'SIMPLE_UNIT', 'DEGREE', 'MINUTE', 'HOUR', 'COLON', 'UFLOAT', 'SIGN', 'SECOND'))\nastropy\/coordinates\/angle_lextab.py:_lexstatere   = {'INITIAL': [('(?P<t_UFLOAT>((\\\\d+\\\\.\\\\d*)|(\\\\.\\\\d+))([eE][+-\u2212]?\\\\d+)?)|(?P<t_UINT>\\\\d+)|(?P<t_SIGN>[+\u2212-])|(?P<t_SIMPLE_UNIT>(?:karcsec)|(?:uarcsec)|(?:Earcmin)|(?:Zdeg)|(?:crad)|(?:cycle)|(?:hectoradian)|(?:Yarcmin)|(?:kiloarcsecond)|(?:zeptoarcminute)|(?:adeg)|(?:darcmin)|(?:ddeg)|(?:exaradian)|(?:parcsec)|(?:yoctoradian)|(?:arcsecond)|(?:petadegree)|(?:petaarcminute)|(?:microarcsecond)|(?:mas)|(?:parcmin)|(?:hdeg)|(?:narcmin)|(?:attodegree)|(?:kilodegree)|(?:zettaradian)|(?:fdeg)|(?:zeptoradian)|(?:microradian)|(?:Gdeg)|(?:hectodegree)|(?:attoarcsecond)|(?:Marcmin)|(?:exadegree)|(?:femtodegree)|(?:yottaradian)|(?:pdeg)|(?:zarcmin)|(?:kiloarcminute)|(?:urad)|(?:teraarcsecond)|(?:nrad)|(?:carcsec)|(?:Pdeg)|(?:Yrad)|(?:yrad)|(?:picoarcsecond)|(?:aarcsec)|(?:dekaradian)|(?:Zrad)|(?:femtoradian)|(?:yarcsec)|(?:arcmin)|(?:arcsec)|(?:yottadegree)|(?:drad)|(?:dekadegree)|(?:zdeg)|(?:zeptoarcsecond)|(?:farcmin)|(?:Parcmin)|(?:decaarcminute)|(?:nanoarcminute)|(?:nanoarcsecond)|(?:Tdeg)|(?:decaarcsecond)|(?:nanodegree)|(?:farcsec)|(?:femtoarcminute)|(?:microdegree)|(?:deciarcsecond)|(?:deciarcminute)|(?:attoradian)|(?:dadeg)|(?:decidegree)|(?:hectoarcminute)|(?:milliarcsecond)|(?:femtoarcsecond)|(?:megaarcminute)|(?:yoctoarcminute)|(?:zrad)|(?:hectoarcsecond)|(?:frad)|(?:centiarcsecond)|(?:carcmin)|(?:Garcmin)|(?:decadegree)|(?:Grad)|(?:petaarcsecond)|(?:gigaarcsecond)|(?:megaradian)|(?:Tarcsec)|(?:Prad)|(?:zettadegree)|(?:yottaarcminute)|(?:mrad)|(?:yottaarcsecond)|(?:exaarcminute)|(?:harcmin)|(?:dekaarcsecond)|(?:cy)|(?:ndeg)|(?:teraradian)|(?:teradegree)|(?:Zarcsec)|(?:gigadegree)|(?:Mdeg)|(?:Mrad)|(?:centiarcminute)|(?:uarcmin)|(?:picoradian)|(?:radian)|(?:ydeg)|(?:milliarcminute)|(?:deciradian)|(?:narcsec)|(?:Trad)|(?:picodegree)|(?:yoctodegree)|(?:zettaarcminute)|(?:daarcmin)|(?:arcminute)|(?:yarcmin)|(?:kdeg)|(?:Earcsec)|(?:Edeg)|(?:harcsec)|(?:rad)|(?:centidegree)|(?:Garcsec)|(?:marcsec)|(?:megaarcsecond)|(?:attoarcminute)|(?:cdeg)|(?:Erad)|(?:kiloradian)|(?:daarcsec)|(?:Parcsec)|(?:megadegree)|(?:millidegree)|(?:centiradian)|(?:uas)|(?:teraarcminute)|(?:prad)|(?:yoctoarcsecond)|(?:hrad)|(?:picoarcminute)|(?:petaradian)|(?:Marcsec)|(?:marcmin)|(?:Tarcmin)|(?:zeptodegree)|(?:Yarcsec)|(?:gigaarcminute)|(?:Zarcmin)|(?:arad)|(?:karcmin)|(?:darcsec)|(?:exaarcsecond)|(?:nanoradian)|(?:udeg)|(?:zarcsec)|(?:Ydeg)|(?:decaradian)|(?:milliradian)|(?:aarcmin)|(?:zettaarcsecond)|(?:darad)|(?:microarcminute)|(?:mdeg)|(?:dekaarcminute)|(?:krad)|(?:gigaradian))|(?P<t_MINUTE>m(in(ute(s)?)?)?|\u2032|\\\\\\'|\u1d50)|(?P<t_SECOND>s(ec(ond(s)?)?)?|\u2033|\\\\\"|\u02e2)|(?P<t_DEGREE>d(eg(ree(s)?)?)?|\u00b0)|(?P<t_HOUR>hour(s)?|h(r)?|\u02b0)|(?P<t_COLON>:)', [None, ('t_UFLOAT', 'UFLOAT'), None, None, None, None, ('t_UINT', 'UINT'), ('t_SIGN', 'SIGN'), ('t_SIMPLE_UNIT', 'SIMPLE_UNIT'), (None, 'MINUTE'), None, None, None, (None, 'SECOND'), None, None, None, (None, 'DEGREE'), None, None, None, (None, 'HOUR'), None, None, (None, 'COLON')])]}\nastropy\/table\/meta.py:from collections import OrderedDict\nastropy\/table\/meta.py:class ColumnDict(dict):\nastropy\/table\/meta.py:    Construct OrderedDict from !!omap in yaml safe load.\nastropy\/table\/meta.py:    except the data type is changed to OrderedDict() and setitem is\nastropy\/table\/meta.py:      OrderedDict([('foo', 'bar'), ('mumble', 'quux'), ('baz', 'gorp')])\nastropy\/table\/meta.py:      OrderedDict([('foo', 'bar'), ('mumble', 'quux'), ('baz', 'gorp')])\nastropy\/table\/meta.py:    omap = OrderedDict()\nastropy\/table\/meta.py:    Represent OrderedDict in yaml dump.\nastropy\/table\/meta.py:    >>> data = OrderedDict([('foo', 'bar'), ('mumble', 'quux'), ('baz', 'gorp')])\nastropy\/table\/meta.py:    Represent ColumnDict in yaml dump.\nastropy\/table\/meta.py:    attrs = ColumnDict()\nastropy\/table\/meta.py:    from ..io.misc.yaml import AstropyDumper\nastropy\/table\/meta.py:    class TableDumper(AstropyDumper):\nastropy\/table\/meta.py:        Custom Dumper that represents OrderedDict as an !!omap object.\nastropy\/table\/meta.py:    TableDumper.add_representer(OrderedDict, _repr_odict)\nastropy\/table\/meta.py:    TableDumper.add_representer(ColumnDict, _repr_column_dict)\nastropy\/table\/meta.py:    header = copy.copy(header)  # Don't overwrite original\nastropy\/table\/meta.py:    lines = yaml.dump(header, Dumper=TableDumper, width=130).splitlines()\nastropy\/table\/meta.py:        Dictionary describing table and column meta\nastropy\/table\/meta.py:        Custom Loader that constructs OrderedDict from an !!omap object.\nastropy\/coordinates\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/formats.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/formats.py:from collections import OrderedDict\nastropy\/time\/formats.py:__all__ = ['TimeFormat', 'TimeJD', 'TimeMJD', 'TimeFromEpoch', 'TimeUnix',\nastropy\/time\/formats.py:           'TimeCxcSec', 'TimeGPS', 'TimeDecimalYear',\nastropy\/time\/formats.py:           'TimePlotDate', 'TimeUnique', 'TimeDatetime', 'TimeString',\nastropy\/time\/formats.py:           'TimeISO', 'TimeISOT', 'TimeFITS', 'TimeYearDayTime',\nastropy\/time\/formats.py:           'TimeEpochDate', 'TimeBesselianEpoch', 'TimeJulianEpoch',\nastropy\/time\/formats.py:           'TimeDeltaFormat', 'TimeDeltaSec', 'TimeDeltaJD',\nastropy\/time\/formats.py:           'TimeEpochDateString', 'TimeBesselianEpochString',\nastropy\/time\/formats.py:           'TimeJulianEpochString', 'TIME_FORMATS', 'TIME_DELTA_FORMATS',\nastropy\/time\/formats.py:__doctest_skip__ = ['TimePlotDate']\nastropy\/time\/formats.py:# Use an OrderedDict to fix the order in which formats are tried.\nastropy\/time\/formats.py:TIME_FORMATS = OrderedDict()\nastropy\/time\/formats.py:TIME_DELTA_FORMATS = OrderedDict()\nastropy\/time\/formats.py:FITS_DEPRECATED_SCALES = {'TDT': 'tt', 'ET': 'tt',\nastropy\/time\/formats.py:    Metaclass that adds `TimeFormat` and `TimeDeltaFormat` to the\nastropy\/time\/formats.py:    `TIME_FORMATS` and `TIME_DELTA_FORMATS` registries, respectively.\nastropy\/time\/formats.py:            scale = 'utc'  # Default scale as of astropy 0.4\nastropy\/time\/formats.py:class TimeJD(TimeFormat):\nastropy\/time\/formats.py:    Julian Date time format.\nastropy\/time\/formats.py:    For example, 2451544.5 in JD is midnight on January 1, 2000.\nastropy\/time\/formats.py:class TimeMJD(TimeFormat):\nastropy\/time\/formats.py:    Modified Julian Date time format.\nastropy\/time\/formats.py:    For example, 51544.0 in MJD is midnight on January 1, 2000.\nastropy\/time\/formats.py:        # TODO - this routine and vals should be Cythonized to follow the ERFA\nastropy\/time\/formats.py:        jd1 += erfa.DJM0  # erfa.DJM0=2400000.5 (from erfam.h)\nastropy\/time\/formats.py:        return (self.jd1 - erfa.DJM0) + self.jd2\nastropy\/time\/formats.py:class TimeDecimalYear(TimeFormat):\nastropy\/time\/formats.py:        # Form new JDs based on epoch time + time from epoch (converted to JD).\nastropy\/time\/formats.py:    unit = 1.0 \/ erfa.DAYSEC  # in days (1 day == 86400 seconds)\nastropy\/time\/formats.py:    unit = 1.0 \/ erfa.DAYSEC  # in days (1 day == 86400 seconds)\nastropy\/time\/formats.py:    unit = 1.0 \/ erfa.DAYSEC  # in days (1 day == 86400 seconds)\nastropy\/time\/formats.py:class TimePlotDate(TimeFromEpoch):\nastropy\/time\/formats.py:class TimeDatetime(TimeUnique):\nastropy\/time\/formats.py:            Offset from UTC in days. Defaults to zero.\nastropy\/time\/formats.py:            Daylight Savings Time offset in days. Defaults to zero\nastropy\/time\/formats.py:        >>> utc = TimezoneInfo()    # Defaults to UTC\nastropy\/time\/formats.py:        # Datetime components required for conversion to JD by ERFA, along\nastropy\/time\/formats.py:        calendar date and time for the internal JD values.\nastropy\/time\/formats.py:        # TODO: fix this ugly hack\nastropy\/time\/formats.py:    ISO 8601 compliant date-time format \"YYYY-MM-DD HH:MM:SS.sss...\".\nastropy\/time\/formats.py:                # XXX To Do - use strftime for output ??\nastropy\/time\/formats.py:    ISO 8601 compliant date-time format \"YYYY-MM-DDTHH:MM:SS.sss...\".\nastropy\/time\/formats.py:class TimeYearDayTime(TimeISO):\nastropy\/time\/formats.py:    Year, day-of-year and time as \"YYYY:DOY:HH:MM:SS.sss...\".\nastropy\/time\/formats.py:    The day-of-year (DOY) goes from 001 to 365 (366 in leap years).\nastropy\/time\/formats.py:    FITS format: \"[\u00b1Y]YYYY-MM-DD[THH:MM:SS[.sss]][(SCALE[(REALIZATION)])]\".\nastropy\/time\/formats.py:            scale = FITS_DEPRECATED_SCALES.get(fits_scale, fits_scale.lower())\nastropy\/time\/formats.py:class TimeEpochDate(TimeFormat):\nastropy\/time\/formats.py:class TimeBesselianEpoch(TimeEpochDate):\nastropy\/time\/formats.py:class TimeJulianEpoch(TimeEpochDate):\nastropy\/time\/formats.py:    unit = erfa.DJY  # 365.25, the Julian year, for conversion to quantities\nastropy\/time\/formats.py:class TimeEpochDateString(TimeString):\nastropy\/time\/formats.py:class TimeBesselianEpochString(TimeEpochDateString):\nastropy\/time\/formats.py:class TimeJulianEpochString(TimeEpochDateString):\nastropy\/time\/formats.py:class TimeDeltaFormatMeta(TimeFormatMeta):\nastropy\/time\/formats.py:    _registry = TIME_DELTA_FORMATS\nastropy\/time\/formats.py:class TimeDeltaFormat(TimeFormat, metaclass=TimeDeltaFormatMeta):\nastropy\/time\/formats.py:        if scale is not None and scale not in TIME_DELTA_SCALES:\nastropy\/time\/formats.py:                                  .format(scale, TIME_DELTA_SCALES))\nastropy\/time\/formats.py:class TimeDeltaSec(TimeDeltaFormat):\nastropy\/time\/formats.py:    unit = 1. \/ erfa.DAYSEC  # for quantity input\nastropy\/time\/formats.py:class TimeDeltaJD(TimeDeltaFormat):\nastropy\/time\/formats.py:from .core import Time, TIME_SCALES, TIME_DELTA_SCALES, ScaleValueError\nastropy\/extern\/configobj\/configobj.py:# Michael Foord: fuzzyman AT voidspace DOT org DOT uk\nastropy\/extern\/configobj\/configobj.py:# Nicola Larosa: nico AT tekNico DOT net\nastropy\/extern\/configobj\/configobj.py:# Rob Dennis: rdennis AT gmail DOT com\nastropy\/extern\/configobj\/configobj.py:# Eli Courtwright: eli AT courtwright DOT org\nastropy\/extern\/configobj\/configobj.py:# This software is licensed under the terms of the BSD license.\nastropy\/extern\/configobj\/configobj.py:# http:\/\/opensource.org\/licenses\/BSD-3-Clause\nastropy\/extern\/configobj\/configobj.py:# https:\/\/github.com\/DiffSK\/configobj\nastropy\/extern\/configobj\/configobj.py:# TODO: the list of aliases is not meant to be exhaustive, is there a\nastropy\/extern\/configobj\/configobj.py:    'DEFAULT_INDENT_TYPE',\nastropy\/extern\/configobj\/configobj.py:    'DEFAULT_INTERPOLATION',\nastropy\/extern\/configobj\/configobj.py:    'DuplicateError',\nastropy\/extern\/configobj\/configobj.py:DEFAULT_INTERPOLATION = 'configparser'\nastropy\/extern\/configobj\/configobj.py:DEFAULT_INDENT_TYPE = '    '\nastropy\/extern\/configobj\/configobj.py:MAX_INTERPOL_DEPTH = 10\nastropy\/extern\/configobj\/configobj.py:OPTION_DEFAULTS = {\nastropy\/extern\/configobj\/configobj.py:    def build_Dict(self, o):\nastropy\/extern\/configobj\/configobj.py:class DuplicateError(ConfigObjError):\nastropy\/extern\/configobj\/configobj.py:            # try \"DEFAULT\" next\nastropy\/extern\/configobj\/configobj.py:            val = current_section.get('DEFAULT', {}).get(key)\nastropy\/extern\/configobj\/configobj.py:    Interpolation is tried first from this object, then from the 'DEFAULT'\nastropy\/extern\/configobj\/configobj.py:    section of this object, next from the parent and its 'DEFAULT' section,\nastropy\/extern\/configobj\/configobj.py:                name = DEFAULT_INTERPOLATION\nastropy\/extern\/configobj\/configobj.py:        'D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\nastropy\/extern\/configobj\/configobj.py:        \"\"\"D.items() -> list of D's (key, value) pairs, as 2-tuples\"\"\"\nastropy\/extern\/configobj\/configobj.py:        \"\"\"D.keys() -> list of D's keys\"\"\"\nastropy\/extern\/configobj\/configobj.py:        \"\"\"D.values() -> list of D's values\"\"\"\nastropy\/extern\/configobj\/configobj.py:        \"\"\"D.iteritems() -> an iterator over the (key, value) items of D\"\"\"\nastropy\/extern\/configobj\/configobj.py:        \"\"\"D.iterkeys() -> an iterator over the keys of D\"\"\"\nastropy\/extern\/configobj\/configobj.py:        \"\"\"D.itervalues() -> an iterator over the values of D\"\"\"\nastropy\/extern\/configobj\/configobj.py:                    # TODO: Why do we raise a KeyError here?\nastropy\/extern\/configobj\/configobj.py:        >>> a.as_float('a')  #doctest: +IGNORE_EXCEPTION_DETAIL\nastropy\/extern\/configobj\/configobj.py:                          DeprecationWarning)\nastropy\/extern\/configobj\/configobj.py:            # TODO: check the values too.\nastropy\/extern\/configobj\/configobj.py:                if entry not in OPTION_DEFAULTS:\nastropy\/extern\/configobj\/configobj.py:            for entry, value in list(OPTION_DEFAULTS.items()):\nastropy\/extern\/configobj\/configobj.py:            options = OPTION_DEFAULTS\nastropy\/extern\/configobj\/configobj.py:        ``UnicodeDecodeError``.\nastropy\/extern\/configobj\/configobj.py:            # TODO: if encoding is just UTF16 - we ought to check for both\nastropy\/extern\/configobj\/configobj.py:            # TODO: big endian and little endian versions.\nastropy\/extern\/configobj\/configobj.py:                        # Don't need to remove BOM\nastropy\/extern\/configobj\/configobj.py:                # If we get this far, will *probably* raise a DecodeError\nastropy\/extern\/configobj\/configobj.py:        \"\"\"Decode ASCII strings to unicode if a self.encoding is specified.\"\"\"\nastropy\/extern\/configobj\/configobj.py:        Decode infile to unicode. Using the specified encoding.\nastropy\/extern\/configobj\/configobj.py:            # NOTE: Could raise a ``UnicodeDecodeError``\nastropy\/extern\/configobj\/configobj.py:                    # NOTE: Or could raise a ``UnicodeDecodeError``\nastropy\/extern\/configobj\/configobj.py:        \"\"\"Decode element to unicode if necessary.\"\"\"\nastropy\/extern\/configobj\/configobj.py:    # TODO: this may need to be modified\nastropy\/extern\/configobj\/configobj.py:                    self._handle_error('Duplicate section name',\nastropy\/extern\/configobj\/configobj.py:                                       DuplicateError, infile, cur_index)\nastropy\/extern\/configobj\/configobj.py:                        'Duplicate keyword name',\nastropy\/extern\/configobj\/configobj.py:                        DuplicateError, infile, cur_index)\nastropy\/extern\/configobj\/configobj.py:        * Don't quote values that don't need it.\nastropy\/extern\/configobj\/configobj.py:        \"\"\"Deal with a comment.\"\"\"\nastropy\/extern\/configobj\/configobj.py:            self.indent_type = DEFAULT_INDENT_TYPE\nastropy\/extern\/configobj\/configobj.py:            # FIXME: this means DEFAULT is not copied in copy mode\nastropy\/extern\/configobj\/configobj.py:            if section is self and entry == 'DEFAULT':\nastropy\/extern\/configobj\/configobj.py:        for entry in OPTION_DEFAULTS:\nastropy\/time\/tests\/test_precision.py:from .. import Time, TimeDelta\nastropy\/time\/tests\/test_precision.py:dt_tiny = TimeDelta(2. ** -52, format='jd')\nastropy\/time\/tests\/test_precision.py:    dt_big = TimeDelta(20000., format='jd')\nastropy\/time\/tests\/test_precision.py:    dt_frac = dt_big_small_by_6 - TimeDelta(3333., format='jd')\nastropy\/stats\/funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/funcs.py:# TODO Note scipy dependency\nastropy\/stats\/funcs.py:        Desired probability content of interval. Default is 0.68269,\nastropy\/stats\/funcs.py:        recommended.  It is provided for comparison purposes.  Default is\nastropy\/stats\/funcs.py:    .. [1] Brown, Lawrence D.; Cai, T. Tony; DasGupta, Anirban (2001).\nastropy\/stats\/funcs.py:# TODO Note scipy dependency (needed in binom_conf_interval)\nastropy\/stats\/funcs.py:        Desired probability content in the confidence\nastropy\/stats\/funcs.py:        interval ``(p - perr[0], p + perr[1])`` in each bin. Default is\nastropy\/stats\/funcs.py:        It is provided for comparison purposes. Default is 'wilson'.\nastropy\/stats\/funcs.py:       plt.title('Detection efficiency vs magnitude')\nastropy\/stats\/funcs.py:       plt.ylabel('Detection efficiency')\nastropy\/stats\/funcs.py:       plt.ylabel('Detection efficiency')\nastropy\/stats\/funcs.py:        Default is ``'root-n'``.\nastropy\/stats\/funcs.py:    matter of debate. The CDF working group [recommends][pois_eb]\nastropy\/stats\/funcs.py:    the CDF working group). It also has the nice feature that\nastropy\/stats\/funcs.py:    Calculate the median absolute deviation (MAD).\nastropy\/stats\/funcs.py:    The MAD is defined as ``median(abs(a - median(a)))``.\nastropy\/stats\/funcs.py:        Axis along which the MADs are computed.  The default (`None`) is\nastropy\/stats\/funcs.py:        to compute the MAD of the flattened array.\nastropy\/stats\/funcs.py:        The function used to compute the median. Defaults to `numpy.ma.median`\nastropy\/stats\/funcs.py:    deviation (MAD)\nastropy\/stats\/funcs.py:        \\sigma \\approx \\frac{\\textrm{MAD}}{\\Phi^{-1}(3\/4)}\nastropy\/stats\/funcs.py:            \\approx 1.4826 \\ \\textrm{MAD}\nastropy\/stats\/funcs.py:        Data array or object that can be converted to an array.\nastropy\/stats\/funcs.py:        The function used to compute the median. Defaults to `numpy.ma.median`\nastropy\/stats\/funcs.py:    MAD = median_absolute_deviation(\nastropy\/stats\/funcs.py:    return MAD * 1.482602218505602\nastropy\/stats\/funcs.py:    optical\/IR using a CCD.\nastropy\/stats\/funcs.py:        CCD integration time in seconds\nastropy\/stats\/funcs.py:        Number of electrons (photons) or DN per second in the aperture from the\nastropy\/stats\/funcs.py:        transmission and the quantum efficiency of the CCD. If the input is in\nastropy\/stats\/funcs.py:        DN, then be sure to set the gain to the proper value for the CCD.\nastropy\/stats\/funcs.py:        Number of electrons (photons) or DN per second per pixel from the sky\nastropy\/stats\/funcs.py:        DN or ADU, then multiply by the gain to get the value in electrons.\nastropy\/stats\/funcs.py:        Read noise of the CCD in electrons. If this is given in\nastropy\/stats\/funcs.py:        DN or ADU, then multiply by the gain to get the value in electrons.\nastropy\/stats\/funcs.py:        Gain of the CCD. In units of electrons per DN.\nastropy\/stats\/funcs.py:        N-D array. The bootstrap resampling will be performed on the first\nastropy\/stats\/funcs.py:def kuiper_false_positive_probability(D, N):\nastropy\/stats\/funcs.py:    D : float\nastropy\/stats\/funcs.py:    if D < 0. or D > 2.:\nastropy\/stats\/funcs.py:        raise ValueError(\"Must have 0<=D<=2 by definition of the Kuiper test\")\nastropy\/stats\/funcs.py:    if D < 2. \/ N:\nastropy\/stats\/funcs.py:        return 1. - factorial(N) * (D - 1. \/ N)**(N - 1)\nastropy\/stats\/funcs.py:    elif D < 3. \/ N:\nastropy\/stats\/funcs.py:        k = -(N * D - 1.) \/ 2.\nastropy\/stats\/funcs.py:        r = np.sqrt(k**2 - (N * D - 2.) \/ 2.)\nastropy\/stats\/funcs.py:    elif (D > 0.5 and N % 2 == 0) or (D > (N - 1.) \/ (2. * N) and N % 2 == 1):\nastropy\/stats\/funcs.py:            y = D + t \/ float(N)\nastropy\/stats\/funcs.py:        for t in range(int(np.floor(N * (1 - D))) + 1):\nastropy\/stats\/funcs.py:            term = T(t) * comb(N, t) * (1 - D - t \/ float(N))**(N - t - 1)\nastropy\/stats\/funcs.py:        z = D * np.sqrt(N)\nastropy\/stats\/funcs.py:        return S1 - 8 * D \/ (3. * np.sqrt(N)) * S2\nastropy\/stats\/funcs.py:    distribution whose CDF is given as ``cdf``.\nastropy\/stats\/funcs.py:        A callable to evaluate the CDF of the distribution being tested\nastropy\/stats\/funcs.py:    D : float\nastropy\/stats\/funcs.py:        The probability of a D this large arising with a sample drawn from\nastropy\/stats\/funcs.py:        the distribution whose CDF is cdf.\nastropy\/stats\/funcs.py:    Returns (D, fpp), where D is the Kuiper D number and fpp is the\nastropy\/stats\/funcs.py:    probability that a value as large as D would occur if data was\nastropy\/stats\/funcs.py:    it will be necessary to do Monte Carlo simulations to interpret D.\nastropy\/stats\/funcs.py:    D should normally be independent of the shape of CDF.\nastropy\/stats\/funcs.py:    D = (np.amax(cdfv - np.arange(N) \/ float(N)) +\nastropy\/stats\/funcs.py:    return D, kuiper_false_positive_probability(D, N)\nastropy\/stats\/funcs.py:    D : float\nastropy\/stats\/funcs.py:    D = (np.amax(cdfv1 - np.arange(len(data1)) \/ float(len(data1))) +\nastropy\/stats\/funcs.py:    return D, kuiper_false_positive_probability(D, Ne)\nastropy\/stats\/funcs.py:    \"\"\"Construct a callable piecewise-linear CDF from a pair of arrays.\nastropy\/stats\/funcs.py:        Endpoints of the intervals in the PDF\nastropy\/coordinates\/sky_coordinate.py:from ..utils.exceptions import AstropyDeprecationWarning\nastropy\/coordinates\/sky_coordinate.py:from ..utils import ShapedLikeNDArray\nastropy\/coordinates\/sky_coordinate.py:from .distances import Distance\nastropy\/coordinates\/sky_coordinate.py:J_PREFIXED_RA_DEC_RE = re.compile(\nastropy\/coordinates\/sky_coordinate.py:    ([0-9]{6,7}\\.?[0-9]{0,2})          # RA as HHMMSS.ss or DDDMMSS.ss, optional decimal digits\nastropy\/coordinates\/sky_coordinate.py:    ([\\+\\-][0-9]{6}\\.?[0-9]{0,2})\\s*$  # Dec as DDMMSS.ss, optional decimal digits\nastropy\/coordinates\/sky_coordinate.py:        # Don't output distance if it is all unitless 1.0\nastropy\/coordinates\/sky_coordinate.py:class SkyCoord(ShapedLikeNDArray):\nastropy\/coordinates\/sky_coordinate.py:      SkyCoord(COORD, [FRAME], keyword_args ...)\nastropy\/coordinates\/sky_coordinate.py:      SkyCoord(LON, LAT, [DISTANCE], frame=FRAME, unit=UNIT, keyword_args ...)\nastropy\/coordinates\/sky_coordinate.py:        Type of coordinate frame this `SkyCoord` should represent. Defaults to\nastropy\/coordinates\/sky_coordinate.py:            RA and Dec for frames where ``ra`` and ``dec`` are keys in the\nastropy\/coordinates\/sky_coordinate.py:    # Declare that SkyCoord can be used as a Table column by defining the\nastropy\/coordinates\/sky_coordinate.py:        are all defined in `~astropy.utils.misc.ShapedLikeNDArray`. It will be\nastropy\/coordinates\/sky_coordinate.py:            if isinstance(value, ShapedLikeNDArray):\nastropy\/coordinates\/sky_coordinate.py:            # TODO: remove this when velocities are supported in SkyCoord\nastropy\/coordinates\/sky_coordinate.py:        # Do the transformation, returning a coordinate frame of the desired\nastropy\/coordinates\/sky_coordinate.py:        sep : `~astropy.coordinates.Distance`\nastropy\/coordinates\/sky_coordinate.py:        return Distance((self.cartesian - other.cartesian).norm())\nastropy\/coordinates\/sky_coordinate.py:            The angular offset in the latitude direction (i.e., Dec for\nastropy\/coordinates\/sky_coordinate.py:            The 3D distance between the closest match for each element\nastropy\/coordinates\/sky_coordinate.py:            The 3D distance between the closest match for each element\nastropy\/coordinates\/sky_coordinate.py:            The 3D distance between the coordinates. Shape matches\nastropy\/coordinates\/sky_coordinate.py:        points within a given 3D radius.\nastropy\/coordinates\/sky_coordinate.py:            The 3D distance between the coordinates. Shape matches\nastropy\/coordinates\/sky_coordinate.py:        Determines the constellation(s) of the coordinates this `SkyCoord`\nastropy\/coordinates\/sky_coordinate.py:        precesses to B1875, and then uses the Delporte boundaries of the 88\nastropy\/coordinates\/sky_coordinate.py:                             re.IGNORECASE | re.UNICODE)\nastropy\/coordinates\/sky_coordinate.py:        Given a name, query the CDS name resolver to attempt to retrieve\nastropy\/coordinates\/sky_coordinate.py:    Determine the coordinate frame from input SkyCoord args and kwargs.  This\nastropy\/coordinates\/sky_coordinate.py:                              \"instead.\", AstropyDeprecationWarning)\nastropy\/coordinates\/sky_coordinate.py:    is_scalar = False  # Differentiate between scalar and list input\nastropy\/coordinates\/sky_coordinate.py:            # Do some basic validation of the list elements: all have a length and all\nastropy\/coordinates\/sky_coordinate.py:    Parse RA and Dec values from a coordinate string. Currently the\nastropy\/coordinates\/sky_coordinate.py:       separation between RA and Dec\nastropy\/coordinates\/sky_coordinate.py:     * JHHMMSS.ss+DDMMSS.ss format, with up to two optional decimal digits\nastropy\/coordinates\/sky_coordinate.py:     * JDDDMMSS.ss+DDMMSS.ss format, with up to two optional decimal digits\nastropy\/coordinates\/sky_coordinate.py:        match_j = J_PREFIXED_RA_DEC_RE.match(coord_str)\nastropy\/time\/tests\/test_quantity_interaction.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_quantity_interaction.py:from .. import Time, TimeDelta, OperandTypeError\nastropy\/time\/tests\/test_quantity_interaction.py:        (even for time-like, since we cannot compare Time to TimeDelta)\"\"\"\nastropy\/time\/tests\/test_quantity_interaction.py:class TestTimeDeltaQuantity():\nastropy\/time\/tests\/test_quantity_interaction.py:    \"\"\"Test interaction of TimeDelta with Quantities\"\"\"\nastropy\/time\/tests\/test_quantity_interaction.py:        \"\"\"Test that TimeDelta can take quantity input.\"\"\"\nastropy\/time\/tests\/test_quantity_interaction.py:        dt1 = TimeDelta(q, format='jd')\nastropy\/time\/tests\/test_quantity_interaction.py:        dt2 = TimeDelta(q, format='sec')\nastropy\/time\/tests\/test_quantity_interaction.py:        dt3 = TimeDelta(q)\nastropy\/time\/tests\/test_quantity_interaction.py:            TimeDelta(2450000.*u.m, format='jd')\nastropy\/time\/tests\/test_quantity_interaction.py:            TimeDelta(100, format='sec') > 10.*u.m\nastropy\/time\/tests\/test_quantity_interaction.py:        dt = TimeDelta(q)\nastropy\/time\/tests\/test_quantity_interaction.py:        with a TimeDelta.  Addition\/subtraction should give TimeDelta\"\"\"\nastropy\/time\/tests\/test_quantity_interaction.py:        t0 = TimeDelta(106400., format='sec')\nastropy\/time\/tests\/test_quantity_interaction.py:        assert isinstance(t1, TimeDelta)\nastropy\/time\/tests\/test_quantity_interaction.py:        \"\"\"Check that TimeDelta is treated as a quantity where possible.\"\"\"\nastropy\/time\/tests\/test_quantity_interaction.py:        t0 = TimeDelta(100000., format='sec')\nastropy\/time\/tests\/test_quantity_interaction.py:        t1 = TimeDelta(np.arange(100000., 100012.).reshape(6, 2), format='sec')\nastropy\/time\/tests\/test_quantity_interaction.py:        \"\"\"Check comparisons of TimeDelta with non-time quantities fails.\"\"\"\nastropy\/time\/tests\/test_quantity_interaction.py:            TimeDelta(100000., format='sec') > 10.*u.m\nastropy\/time\/tests\/test_quantity_interaction.py:        t0 = TimeDelta(np.arange(12.).reshape(4, 3), format='sec')\nastropy\/time\/tests\/test_quantity_interaction.py:class TestDeltaAttributes():\nastropy\/time\/tests\/test_quantity_interaction.py:        # Also check that a TimeDelta works.\nastropy\/time\/tests\/test_quantity_interaction.py:        t.delta_ut1_utc = TimeDelta(0.3, format='sec')\nastropy\/time\/tests\/test_quantity_interaction.py:        t.delta_ut1_utc = TimeDelta(0.5\/24.\/3600., format='jd')\nastropy\/time\/tests\/test_quantity_interaction.py:        # Also check that a TimeDelta works.\nastropy\/time\/tests\/test_quantity_interaction.py:        t.delta_tdb_tt = TimeDelta(40., format='sec')\nastropy\/time\/tests\/test_quantity_interaction.py:        t.delta_tdb_tt = TimeDelta(50.\/24.\/3600., format='jd')\nastropy\/time\/tests\/test_methods.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_methods.py:        # Define arrays with same ordinal properties\nastropy\/coordinates\/calculation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/calculation.py:_VALID_SIGNS = [\"capricorn\", \"aquarius\", \"pisces\", \"aries\", \"taurus\", \"gemini\",\nastropy\/coordinates\/calculation.py:        if zodiac_sign not in _VALID_SIGNS:\nastropy\/coordinates\/errors.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/errors.py:# TODO: consider if this should be used to `units`?\nastropy\/coordinates\/errors.py:            message += \" Did you mean one of: '{0}'?'\".format(\"', '\".join(close_names))\nastropy\/time\/tests\/test_sidereal.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_sidereal.py:from ..core import SIDEREAL_TIME_MODELS\nastropy\/time\/tests\/test_sidereal.py:        for model in SIDEREAL_TIME_MODELS[kind]:\nastropy\/time\/tests\/test_sidereal.py:    # all tests use the following JD inputs\nastropy\/time\/tests\/test_sidereal.py:        assert kind in SIDEREAL_TIME_MODELS.keys()\nastropy\/time\/tests\/test_sidereal.py:        assert model_name in SIDEREAL_TIME_MODELS[kind]\nastropy\/time\/tests\/test_sidereal.py:        model = SIDEREAL_TIME_MODELS[kind][model_name]\nastropy\/time\/tests\/test_sidereal.py:                SIDEREAL_TIME_MODELS[kind].keys(), 2):\nastropy\/time\/tests\/test_sidereal.py:        for model in (set(SIDEREAL_TIME_MODELS[other].keys()) -\nastropy\/time\/tests\/test_sidereal.py:                      set(SIDEREAL_TIME_MODELS[kind].keys())):\nastropy\/stats\/sigma_clipping.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/sigma_clipping.py:        ``sigma_lower`` and ``sigma_upper``, if input. Defaults to 3.\nastropy\/stats\/sigma_clipping.py:        used. Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:        used. Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:        last iteration clips nothing). Defaults to 5.\nastropy\/stats\/sigma_clipping.py:        central value. Defaults to the median (`numpy.ma.median`).\nastropy\/stats\/sigma_clipping.py:        Defaults to the standard deviation (`numpy.std`).\nastropy\/stats\/sigma_clipping.py:        sigma_lower and sigma_upper to get the correct limits. Data\nastropy\/stats\/sigma_clipping.py:            clip over all axes.  Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:            as ``data``.  Defaults to `True`.\nastropy\/stats\/sigma_clipping.py:        ``sigma_lower`` and ``sigma_upper``, if input. Defaults to 3.\nastropy\/stats\/sigma_clipping.py:        used. Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:        used. Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:        last iteration clips nothing). Defaults to 5.\nastropy\/stats\/sigma_clipping.py:        central value. Defaults to the median (`numpy.ma.median`).\nastropy\/stats\/sigma_clipping.py:        Defaults to the standard deviation (`numpy.std`).\nastropy\/stats\/sigma_clipping.py:        Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:        ``data``.  Defaults to `True`.\nastropy\/stats\/sigma_clipping.py:        Data array or object that can be converted to an array.\nastropy\/stats\/sigma_clipping.py:        and ``sigma_upper``, if input. Defaults to 3.\nastropy\/stats\/sigma_clipping.py:        Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:        Defaults to `None`.\nastropy\/stats\/sigma_clipping.py:        Defaults to 5.\nastropy\/stats\/sigma_clipping.py:        central value. Defaults to the median (`numpy.ma.median`).\nastropy\/stats\/sigma_clipping.py:        Defaults to the standard deviation (`numpy.std`).\nastropy\/stats\/sigma_clipping.py:        Defaults to `None`.\nastropy\/modeling\/mappings.py:    >>> from astropy.modeling.models import Polynomial2D, Shift, Mapping\nastropy\/modeling\/mappings.py:    >>> poly1 = Polynomial2D(1, c0_0=1, c1_0=2, c0_1=3)\nastropy\/modeling\/mappings.py:    >>> poly2 = Polynomial2D(1, c0_0=1, c1_0=2.4, c0_1=2.1)\nastropy\/modeling\/mappings.py:        >>> from astropy.modeling.models import (Polynomial1D, Shift, Scale,\nastropy\/stats\/bayesian_blocks.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/bayesian_blocks.py:Dynamic programming algorithm for solving a piecewise-constant model for\nastropy\/stats\/bayesian_blocks.py:# TODO: implement other fitness functions from appendix B of Scargle 2012\nastropy\/stats\/bayesian_blocks.py:    FITNESS_DICT = {'events': Events,\nastropy\/stats\/bayesian_blocks.py:    fitness = FITNESS_DICT.get(fitness, fitness)\nastropy\/stats\/bayesian_blocks.py:    Derived classes should overload the following method:\nastropy\/stats\/bayesian_blocks.py:            # TODO: allow broadcasted x?\nastropy\/stats\/spatial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/spatial.py:    .. [4] Cressie, N.A.C. (1991). Statistics for Spatial Data,\nastropy\/stats\/spatial.py:    .. [5] Stoyan, D., Stoyan, H. (1992). Fractals, Random Shapes and\nastropy\/stats\/spatial.py:        radii : 1D array\nastropy\/stats\/spatial.py:        output : 1D array\nastropy\/stats\/spatial.py:        data : 2D array\nastropy\/stats\/spatial.py:        radii : 1D array\nastropy\/stats\/spatial.py:        ripley : 1D array\nastropy\/stats\/info_theory.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/info_theory.py:    :math:`\\Delta \\mathrm{BIC} = \\mathrm{BIC}_h - \\mathrm{BIC}_l`, in which\nastropy\/stats\/info_theory.py:    the lower BIC. The higher is :math:`\\Delta \\mathrm{BIC}` the stronger is\nastropy\/stats\/info_theory.py:    :math:`0 < \\Delta\\mathrm{BIC} \\leq 2`: weak evidence that model low is\nastropy\/stats\/info_theory.py:    :math:`2 < \\Delta\\mathrm{BIC} \\leq 6`: moderate evidence that model low is\nastropy\/stats\/info_theory.py:    :math:`6 < \\Delta\\mathrm{BIC} \\leq 10`: strong evidence that model low is\nastropy\/stats\/info_theory.py:    :math:`\\Delta\\mathrm{BIC} > 10`: very strong evidence that model low is\nastropy\/stats\/info_theory.py:    .. [1] Richards, D. Maximum Likelihood Estimation and the Bayesian\nastropy\/stats\/info_theory.py:    Consider the simple 1-D fitting example presented in the Astropy\nastropy\/stats\/info_theory.py:    >>> t_init = models.Trapezoid1D(amplitude=1., x_0=0., width=1., slope=0.5)\nastropy\/stats\/info_theory.py:    >>> g_init = models.Gaussian1D(amplitude=1., mean=0, stddev=1.)\nastropy\/stats\/info_theory.py:    :math:`\\Delta\\mathrm{AIC}_i = \\mathrm{AIC}_i - \\mathrm{AIC}_{min}`\nastropy\/stats\/info_theory.py:    :math:`\\Delta\\mathrm{AIC}_i < 2`: substantial support for model i\nastropy\/stats\/info_theory.py:    :math:`3 < \\Delta\\mathrm{AIC}_i < 7`: considerably less support for model i\nastropy\/stats\/info_theory.py:    :math:`\\Delta\\mathrm{AIC}_i > 10`: essentially none support for model i\nastropy\/stats\/info_theory.py:    with five parameters (model 2). Despite of the fact that model 2 has a\nastropy\/stats\/info_theory.py:    >>> g1 = models.Gaussian1D(.1, 0, 0.2) # changed this to noise level\nastropy\/stats\/info_theory.py:    >>> g2 = models.Gaussian1D(.1, 0.3, 0.2) # and added another Gaussian\nastropy\/stats\/info_theory.py:    >>> g3 = models.Gaussian1D(2.5, 0.5, 0.1)\nastropy\/stats\/info_theory.py:    >>> g3_init = (models.Gaussian1D(.1, 0, 0.1)\nastropy\/stats\/info_theory.py:    ...            + models.Gaussian1D(.1, 0.2, 0.15)\nastropy\/stats\/info_theory.py:    ...            + models.Gaussian1D(2., .4, 0.1))\nastropy\/stats\/info_theory.py:    >>> g2_init = (models.Gaussian1D(.1, 0, 0.1) +\nastropy\/stats\/info_theory.py:    ...            models.Gaussian1D(2, 0.5, 0.1))\nastropy\/stats\/info_theory.py:    >>> g1_init = models.Gaussian1D(amplitude=2., mean=0.3, stddev=.5)\nastropy\/modeling\/parameters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/parameters.py:from ..utils import isiterable, OrderedDescriptor\nastropy\/modeling\/parameters.py:class ParameterDefinitionError(ParameterError):\nastropy\/modeling\/parameters.py:            \"Don't know how to convert parameter of {0} to \"\nastropy\/modeling\/parameters.py:                # Because OrderedDescriptor uses __lt__ to work, we need to\nastropy\/modeling\/parameters.py:class Parameter(OrderedDescriptor):\nastropy\/modeling\/parameters.py:    # Settings for OrderedDescriptor\nastropy\/modeling\/parameters.py:                raise ParameterDefinitionError(\nastropy\/modeling\/parameters.py:        # and ordering ID\nastropy\/modeling\/parameters.py:        # TODO: Rather than using self.value this could be determined from the\nastropy\/modeling\/parameters.py:            >>> from astropy.modeling import Fittable1DModel\nastropy\/modeling\/parameters.py:            >>> class TestModel(Fittable1DModel):\nastropy\/modeling\/parameters.py:            >>> m = TestModel(a=1, b=2)  # doctest: +IGNORE_EXCEPTION_DETAIL\nastropy\/modeling\/parameters.py:            >>> m.a = 0  # doctest: +IGNORE_EXCEPTION_DETAIL\nastropy\/modeling\/parameters.py:            >>> m.a.validator(-42)  # doctest: +IGNORE_EXCEPTION_DETAIL\nastropy\/modeling\/parameters.py:    # TODO: These methods should probably be moved to the Model class, since it\nastropy\/modeling\/parameters.py:            # TODO: Maybe handle exception on invalid input shape\nastropy\/modeling\/parameters.py:                    # Don't make a partial function unless we're tied to a\nastropy\/stats\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/representation.py:from collections import OrderedDict\nastropy\/coordinates\/representation.py:from .distances import Distance\nastropy\/coordinates\/representation.py:from ..utils import ShapedLikeNDArray, classproperty\nastropy\/coordinates\/representation.py:from ..utils.misc import InheritDocstrings\nastropy\/coordinates\/representation.py:__all__ = [\"BaseRepresentationOrDifferential\", \"BaseRepresentation\",\nastropy\/coordinates\/representation.py:           \"BaseDifferential\", \"CartesianDifferential\",\nastropy\/coordinates\/representation.py:           \"BaseSphericalDifferential\", \"BaseSphericalCosLatDifferential\",\nastropy\/coordinates\/representation.py:           \"SphericalDifferential\", \"SphericalCosLatDifferential\",\nastropy\/coordinates\/representation.py:           \"UnitSphericalDifferential\", \"UnitSphericalCosLatDifferential\",\nastropy\/coordinates\/representation.py:           \"RadialDifferential\", \"CylindricalDifferential\",\nastropy\/coordinates\/representation.py:           \"PhysicsSphericalDifferential\"]\nastropy\/coordinates\/representation.py:DIFFERENTIAL_CLASSES = {}\nastropy\/coordinates\/representation.py:class BaseRepresentationOrDifferential(ShapedLikeNDArray):\nastropy\/coordinates\/representation.py:    \"\"\"3D coordinate representations and differentials.\nastropy\/coordinates\/representation.py:        The components of the 3D point or differential.  The names are the\nastropy\/coordinates\/representation.py:        `~astropy.coordinates.SphericalDifferential`.)\nastropy\/coordinates\/representation.py:        are all defined in `~astropy.utils.misc.ShapedLikeNDArray`. It will be\nastropy\/coordinates\/representation.py:# be combined with a ShapedLikeNDArray subclass (which is an ABC).  Without it:\nastropy\/coordinates\/representation.py:class MetaBaseRepresentation(InheritDocstrings, abc.ABCMeta):\nastropy\/coordinates\/representation.py:class BaseRepresentation(BaseRepresentationOrDifferential,\nastropy\/coordinates\/representation.py:    \"\"\"Base for representing a point in a 3D coordinate system.\nastropy\/coordinates\/representation.py:        The components of the 3D points.  The names are the keys and the\nastropy\/coordinates\/representation.py:    differentials : dict, `BaseDifferential`, optional\nastropy\/coordinates\/representation.py:        representation. The input must either be a single `BaseDifferential`\nastropy\/coordinates\/representation.py:    and define an ``attr_classes`` attribute, an `~collections.OrderedDict`\nastropy\/coordinates\/representation.py:        elif isinstance(differentials, BaseDifferential):\nastropy\/coordinates\/representation.py:            if (isinstance(differentials, RadialDifferential) and\nastropy\/coordinates\/representation.py:                raise ValueError(\"To attach a RadialDifferential to a \"\nastropy\/coordinates\/representation.py:            if (isinstance(diff, RadialDifferential) and\nastropy\/coordinates\/representation.py:                # We trust the passing of a key for a RadialDifferential\nastropy\/coordinates\/representation.py:                # TODO: message of IncompatibleShapeError is not customizable,\nastropy\/coordinates\/representation.py:        return [DIFFERENTIAL_CLASSES[self.get_name()]]\nastropy\/coordinates\/representation.py:    # they are only necessary if one also defines an associated Differential.\nastropy\/coordinates\/representation.py:                issubclass(differential_class, BaseDifferential)):\nastropy\/coordinates\/representation.py:            # TODO: is there a better way to do this?\nastropy\/coordinates\/representation.py:            ValueError(\"Desired differential classes must be passed in \"\nastropy\/coordinates\/representation.py:                    raise TypeError(\"Desired differential class {0} is not \"\nastropy\/coordinates\/representation.py:        differential_class : dict of `~astropy.coordinates.BaseDifferential`, optional\nastropy\/coordinates\/representation.py:        Differential keys that already exist in this object's differential dict\nastropy\/coordinates\/representation.py:        differentials : Sequence of `~astropy.coordinates.BaseDifferential`\nastropy\/coordinates\/representation.py:        This is not a simple inherit from ``BaseRepresentationOrDifferential``\nastropy\/coordinates\/representation.py:        See docstring for `BaseRepresentationOrDifferential._apply`.\nastropy\/coordinates\/representation.py:    @BaseRepresentationOrDifferential.shape.setter\nastropy\/coordinates\/representation.py:        BaseRepresentationOrDifferential.shape.fset(self, shape)\nastropy\/coordinates\/representation.py:            BaseRepresentationOrDifferential.shape.fset(self, orig_shape)\nastropy\/coordinates\/representation.py:        \"\"\"Dot product of two representations.\nastropy\/coordinates\/representation.py:    Representation of points in 3D cartesian coordinates.\nastropy\/coordinates\/representation.py:    differentials : dict, `CartesianDifferential`, optional\nastropy\/coordinates\/representation.py:        `CartesianDifferential` instance, or a dictionary of\nastropy\/coordinates\/representation.py:        `CartesianDifferential` s with keys set to a string representation of\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('x', u.Quantity),\nastropy\/coordinates\/representation.py:        return OrderedDict(\nastropy\/coordinates\/representation.py:        return OrderedDict((('x', l), ('y', l), ('z', l)))\nastropy\/coordinates\/representation.py:        # TODO: since this is likely to be a widely used function in coordinate\nastropy\/coordinates\/representation.py:            # TODO: speed this up going via d.d_xyz.\nastropy\/coordinates\/representation.py:        \"\"\"Dot product of two representations.\nastropy\/coordinates\/representation.py:    differentials : dict, `BaseDifferential`, optional\nastropy\/coordinates\/representation.py:        representation. The input must either be a single `BaseDifferential`\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('lon', Longitude),\nastropy\/coordinates\/representation.py:        return [UnitSphericalDifferential, UnitSphericalCosLatDifferential,\nastropy\/coordinates\/representation.py:                SphericalDifferential, SphericalCosLatDifferential,\nastropy\/coordinates\/representation.py:                RadialDifferential]\nastropy\/coordinates\/representation.py:        return OrderedDict(\nastropy\/coordinates\/representation.py:        return OrderedDict((('lon', sf_lon),\nastropy\/coordinates\/representation.py:        Converts spherical polar coordinates to 3D rectangular cartesian\nastropy\/coordinates\/representation.py:        Converts 3D rectangular cartesian coordinates to spherical polar\nastropy\/coordinates\/representation.py:        # TODO: this could be optimized to shortcut even if a differential_class\nastropy\/coordinates\/representation.py:            Dimensionless ones, with the same shape as the representation.\nastropy\/coordinates\/representation.py:    differentials : dict, `BaseDifferential`, optional\nastropy\/coordinates\/representation.py:        representation. The input must either be a single `BaseDifferential`\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('distance', u.Quantity)])\nastropy\/coordinates\/representation.py:        return OrderedDict((('distance', l),))\nastropy\/coordinates\/representation.py:        Converts 3D rectangular cartesian coordinates to radial coordinate.\nastropy\/coordinates\/representation.py:            Dimensionless ones, with the same shape as the representation.\nastropy\/coordinates\/representation.py:    Representation of points in 3D spherical coordinates.\nastropy\/coordinates\/representation.py:        passed to the :class:`~astropy.coordinates.Distance` class, otherwise\nastropy\/coordinates\/representation.py:    differentials : dict, `BaseDifferential`, optional\nastropy\/coordinates\/representation.py:        representation. The input must either be a single `BaseDifferential`\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('lon', Longitude),\nastropy\/coordinates\/representation.py:            self._distance = self._distance.view(Distance)\nastropy\/coordinates\/representation.py:        return [UnitSphericalDifferential, UnitSphericalCosLatDifferential,\nastropy\/coordinates\/representation.py:                SphericalDifferential, SphericalCosLatDifferential,\nastropy\/coordinates\/representation.py:                RadialDifferential]\nastropy\/coordinates\/representation.py:        return OrderedDict(\nastropy\/coordinates\/representation.py:        return OrderedDict((('lon', sf_lon),\nastropy\/coordinates\/representation.py:        # TODO: this could be optimized to shortcut even if a differential_class\nastropy\/coordinates\/representation.py:        Converts spherical polar coordinates to 3D rectangular cartesian\nastropy\/coordinates\/representation.py:        # We need to convert Distance to Quantity to allow negative values.\nastropy\/coordinates\/representation.py:        if isinstance(self.distance, Distance):\nastropy\/coordinates\/representation.py:        Converts 3D rectangular cartesian coordinates to spherical polar\nastropy\/coordinates\/representation.py:    Representation of points in 3D spherical coordinates (using the physics\nastropy\/coordinates\/representation.py:        passed to the :class:`~astropy.coordinates.Distance` class, otherwise\nastropy\/coordinates\/representation.py:    differentials : dict, `PhysicsSphericalDifferential`, optional\nastropy\/coordinates\/representation.py:        `PhysicsSphericalDifferential` instance, or a dictionary of of\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('phi', Angle),\nastropy\/coordinates\/representation.py:            self._r = self._r.view(Distance)\nastropy\/coordinates\/representation.py:        return OrderedDict(\nastropy\/coordinates\/representation.py:        return OrderedDict((('phi', r * sintheta),\nastropy\/coordinates\/representation.py:        # TODO: this could be optimized to shortcut even if a differential_class\nastropy\/coordinates\/representation.py:        Converts spherical polar coordinates to 3D rectangular cartesian\nastropy\/coordinates\/representation.py:        # We need to convert Distance to Quantity to allow negative values.\nastropy\/coordinates\/representation.py:        if isinstance(self.r, Distance):\nastropy\/coordinates\/representation.py:        Converts 3D rectangular cartesian coordinates to spherical polar\nastropy\/coordinates\/representation.py:    Representation of points in 3D cylindrical coordinates.\nastropy\/coordinates\/representation.py:    differentials : dict, `CylindricalDifferential`, optional\nastropy\/coordinates\/representation.py:        `CylindricalDifferential` instance, or a dictionary of of differential\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('rho', u.Quantity),\nastropy\/coordinates\/representation.py:        return OrderedDict(\nastropy\/coordinates\/representation.py:        return OrderedDict((('rho', l),\nastropy\/coordinates\/representation.py:        Converts 3D rectangular cartesian coordinates to cylindrical polar\nastropy\/coordinates\/representation.py:        Converts cylindrical polar coordinates to 3D rectangular cartesian\nastropy\/coordinates\/representation.py:class MetaBaseDifferential(InheritDocstrings, abc.ABCMeta):\nastropy\/coordinates\/representation.py:    \"\"\"Set default ``attr_classes`` and component getters on a Differential.\nastropy\/coordinates\/representation.py:        # Don't do anything for base helper classes.\nastropy\/coordinates\/representation.py:        if cls.__name__ in ('BaseDifferential', 'BaseSphericalDifferential',\nastropy\/coordinates\/representation.py:                            'BaseSphericalCosLatDifferential'):\nastropy\/coordinates\/representation.py:            raise NotImplementedError('Differential representations must have a'\nastropy\/coordinates\/representation.py:            cls.attr_classes = OrderedDict([('d_' + c, u.Quantity)\nastropy\/coordinates\/representation.py:        if repr_name in DIFFERENTIAL_CLASSES:\nastropy\/coordinates\/representation.py:            raise ValueError(\"Differential class {0} already defined\"\nastropy\/coordinates\/representation.py:        DIFFERENTIAL_CLASSES[repr_name] = cls\nastropy\/coordinates\/representation.py:                                 doc=(\"Component '{0}' of the Differential.\"\nastropy\/coordinates\/representation.py:class BaseDifferential(BaseRepresentationOrDifferential,\nastropy\/coordinates\/representation.py:                       metaclass=MetaBaseDifferential):\nastropy\/coordinates\/representation.py:        The components of the 3D differentials.  The names are the keys and the\nastropy\/coordinates\/representation.py:            raise TypeError(\"Differential class {0} is not compatible with the \"\nastropy\/coordinates\/representation.py:        \"\"\"Convert the differential to 3D rectangular cartesian coordinates.\nastropy\/coordinates\/representation.py:        This object as a `CartesianDifferential`\nastropy\/coordinates\/representation.py:        \"\"\"Convert the differential from 3D rectangular cartesian coordinates to\nastropy\/coordinates\/representation.py:        if issubclass(other_class, BaseDifferential):\nastropy\/coordinates\/representation.py:        if isinstance(representation, BaseDifferential):\nastropy\/coordinates\/representation.py:class CartesianDifferential(BaseDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differentials in of points in 3D cartesian coordinates.\nastropy\/coordinates\/representation.py:class BaseSphericalDifferential(BaseDifferential):\nastropy\/coordinates\/representation.py:        a `~astropy.coordinates.SphericalDifferential` (e.g., a\nastropy\/coordinates\/representation.py:        `~astropy.coordinates.UnitSphericalDifferential` and a\nastropy\/coordinates\/representation.py:        `~astropy.coordinates.RadialDifferential`), they will combined\nastropy\/coordinates\/representation.py:        if (isinstance(other, BaseSphericalDifferential) and\nastropy\/coordinates\/representation.py:                isinstance(other, RadialDifferential)):\nastropy\/coordinates\/representation.py:            return SphericalDifferential(**result_args)\nastropy\/coordinates\/representation.py:class UnitSphericalDifferential(BaseSphericalDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differential(s) of points on a unit sphere.\nastropy\/coordinates\/representation.py:        return SphericalDifferential\nastropy\/coordinates\/representation.py:        if issubclass(other_class, UnitSphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        if isinstance(representation, SphericalDifferential):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, (SphericalCosLatDifferential,\nastropy\/coordinates\/representation.py:                                         UnitSphericalCosLatDifferential)):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, PhysicsSphericalDifferential):\nastropy\/coordinates\/representation.py:class SphericalDifferential(BaseSphericalDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differential(s) of points in 3D spherical coordinates.\nastropy\/coordinates\/representation.py:    _unit_differential = UnitSphericalDifferential\nastropy\/coordinates\/representation.py:        if issubclass(other_class, UnitSphericalDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, RadialDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, SphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, UnitSphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, PhysicsSphericalDifferential):\nastropy\/coordinates\/representation.py:        if isinstance(representation, SphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, PhysicsSphericalDifferential):\nastropy\/coordinates\/representation.py:class BaseSphericalCosLatDifferential(BaseDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differtials from points on a spherical base representation.\nastropy\/coordinates\/representation.py:        a `~astropy.coordinates.SphericalDifferential` (e.g., a\nastropy\/coordinates\/representation.py:        `~astropy.coordinates.UnitSphericalDifferential` and a\nastropy\/coordinates\/representation.py:        `~astropy.coordinates.RadialDifferential`), they will combined\nastropy\/coordinates\/representation.py:        if (isinstance(other, BaseSphericalCosLatDifferential) and\nastropy\/coordinates\/representation.py:                isinstance(other, RadialDifferential)):\nastropy\/coordinates\/representation.py:            return SphericalCosLatDifferential(**result_args)\nastropy\/coordinates\/representation.py:class UnitSphericalCosLatDifferential(BaseSphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differential(s) of points on a unit sphere.\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('d_lon_coslat', u.Quantity),\nastropy\/coordinates\/representation.py:        return SphericalCosLatDifferential\nastropy\/coordinates\/representation.py:        if issubclass(other_class, UnitSphericalDifferential):\nastropy\/coordinates\/representation.py:        if isinstance(representation, SphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, (SphericalDifferential,\nastropy\/coordinates\/representation.py:                                         UnitSphericalDifferential)):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, PhysicsSphericalDifferential):\nastropy\/coordinates\/representation.py:class SphericalCosLatDifferential(BaseSphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differential(s) of points in 3D spherical coordinates.\nastropy\/coordinates\/representation.py:    _unit_differential = UnitSphericalCosLatDifferential\nastropy\/coordinates\/representation.py:    attr_classes = OrderedDict([('d_lon_coslat', u.Quantity),\nastropy\/coordinates\/representation.py:        if issubclass(other_class, UnitSphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, RadialDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, SphericalDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, UnitSphericalDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, PhysicsSphericalDifferential):\nastropy\/coordinates\/representation.py:        if isinstance(representation, SphericalDifferential):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, PhysicsSphericalDifferential):\nastropy\/coordinates\/representation.py:class RadialDifferential(BaseDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differential(s) of radial distances.\nastropy\/coordinates\/representation.py:        if isinstance(representation, (SphericalDifferential,\nastropy\/coordinates\/representation.py:                                       SphericalCosLatDifferential)):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, PhysicsSphericalDifferential):\nastropy\/coordinates\/representation.py:        elif isinstance(other, (BaseSphericalDifferential,\nastropy\/coordinates\/representation.py:                                BaseSphericalCosLatDifferential)):\nastropy\/coordinates\/representation.py:            return SphericalDifferential(**result_args)\nastropy\/coordinates\/representation.py:class PhysicsSphericalDifferential(BaseDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differential(s) of 3D spherical coordinates using physics convention.\nastropy\/coordinates\/representation.py:        # do the equivalent of self._d_lon_coslat in SphericalDifferential.\nastropy\/coordinates\/representation.py:        if issubclass(other_class, SphericalDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, UnitSphericalDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, SphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, UnitSphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:        elif issubclass(other_class, RadialDifferential):\nastropy\/coordinates\/representation.py:        # do the equivalent of cls._d_lon in SphericalDifferential.\nastropy\/coordinates\/representation.py:        if isinstance(representation, SphericalDifferential):\nastropy\/coordinates\/representation.py:        elif isinstance(representation, SphericalCosLatDifferential):\nastropy\/coordinates\/representation.py:class CylindricalDifferential(BaseDifferential):\nastropy\/coordinates\/representation.py:    \"\"\"Differential(s) of points in cylindrical coordinates.\nastropy\/coordinates\/angles.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angles.py:        # TODO: Numpy array of tuples?\nastropy\/coordinates\/angles.py:        # Do the wrapping, but only if any angles need to be wrapped\nastropy\/coordinates\/matrix_utilities.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/orbital_elements.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/orbital_elements.py:#   D   M   M'  F   l    r\nastropy\/coordinates\/orbital_elements.py:#   D   M   M'  F   b\nastropy\/coordinates\/orbital_elements.py:D : Mean elongation of the Moon\nastropy\/coordinates\/orbital_elements.py:_coD = (2.97850192e+02, 4.45267111e+05, -1.88190000e-03,\nastropy\/coordinates\/orbital_elements.py:    # This should strictly speaking be in Ephemeris Time, but TDB or TT\nastropy\/coordinates\/orbital_elements.py:    D = u.Quantity(polyval(T, _coD), u.deg)\nastropy\/coordinates\/orbital_elements.py:    for DNum, MNum, McNum, FNum, LFac, RFac in _MOON_L_R:\nastropy\/coordinates\/orbital_elements.py:        suml += LFac*corr*np.sin(D*DNum+M*MNum+Mc*McNum+F*FNum)\nastropy\/coordinates\/orbital_elements.py:        sumr += RFac*corr*np.cos(D*DNum+M*MNum+Mc*McNum+F*FNum)\nastropy\/coordinates\/orbital_elements.py:    for DNum, MNum, McNum, FNum, BFac in _MOON_B:\nastropy\/coordinates\/orbital_elements.py:        sumb += BFac*corr*np.sin(D*DNum+M*MNum+Mc*McNum+F*FNum)\nastropy\/coordinates\/solar_system.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/solar_system.py:from collections import OrderedDict\nastropy\/coordinates\/solar_system.py:DEFAULT_JPL_EPHEMERIS = 'de430'\nastropy\/coordinates\/solar_system.py:BODY_NAME_TO_KERNEL_SPEC = OrderedDict(\nastropy\/coordinates\/solar_system.py:PLAN94_BODY_NAME_TO_PLANET_INDEX = OrderedDict(\nastropy\/coordinates\/solar_system.py:    \"\"\"Default ephemerides for calculating positions of Solar-System bodies.\nastropy\/coordinates\/solar_system.py:                    tuple(PLAN94_BODY_NAME_TO_PLANET_INDEX.keys()))\nastropy\/coordinates\/solar_system.py:            return tuple(BODY_NAME_TO_KERNEL_SPEC.keys())\nastropy\/coordinates\/solar_system.py:        value = DEFAULT_JPL_EPHEMERIS\nastropy\/coordinates\/solar_system.py:                    body_index = PLAN94_BODY_NAME_TO_PLANET_INDEX[body]\nastropy\/coordinates\/solar_system.py:                kernel_spec = BODY_NAME_TO_KERNEL_SPEC[body.lower()]\nastropy\/coordinates\/solar_system.py:        # jplephem cannot handle multi-D arrays, so convert to 1D here.\nastropy\/coordinates\/solar_system.py:        # Note that we use the new jd1.shape here to create a 1D result array.\nastropy\/coordinates\/solar_system.py:    Convert Skycoord in GCRS frame into one in which RA and Dec\nastropy\/stats\/lombscargle\/_statistics.py:        raise NotImplementedError(\"Degrees of freedom != 2\")\nastropy\/stats\/lombscargle\/_statistics.py:        raise NotImplementedError(\"Degrees of freedom != 2\")\nastropy\/stats\/lombscargle\/_statistics.py:        raise NotImplementedError(\"Degrees of freedom != 2\")\nastropy\/stats\/lombscargle\/_statistics.py:    \"\"\"tau factor for estimating Davies bound (Baluev 2008, Table 1)\"\"\"\nastropy\/stats\/lombscargle\/_statistics.py:    NH = N - dH  # DOF for null hypothesis\nastropy\/stats\/lombscargle\/_statistics.py:    NK = N - dK  # DOF for periodic hypothesis\nastropy\/stats\/lombscargle\/_statistics.py:    Dt = _weighted_var(t, dy)\nastropy\/stats\/lombscargle\/_statistics.py:    Teff = np.sqrt(4 * np.pi * Dt)  # Effective baseline\nastropy\/stats\/lombscargle\/_statistics.py:    \"\"\"Davies upper-bound to the false alarm probability\nastropy\/stats\/lombscargle\/_statistics.py:METHODS = {'single': fap_single,\nastropy\/stats\/lombscargle\/_statistics.py:    elif method not in METHODS:\nastropy\/stats\/lombscargle\/_statistics.py:    method = METHODS[method]\nastropy\/stats\/lombscargle\/_statistics.py:INV_METHODS = {'single': inv_fap_single,\nastropy\/stats\/lombscargle\/_statistics.py:    elif method not in INV_METHODS:\nastropy\/stats\/lombscargle\/_statistics.py:    method = INV_METHODS[method]\nastropy\/modeling\/projections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/projections.py:    'COD', 'COO', 'BON', 'PCO', 'TSC', 'CSC', 'QSC', 'HPX', 'XPH'\nastropy\/modeling\/projections.py:           'AffineTransformation2D',\nastropy\/modeling\/projections.py:           'Pix2Sky_COD', 'Sky2Pix_COD',\nastropy\/modeling\/projections.py:        Distance from point of projection to center of sphere\nastropy\/modeling\/projections.py:        in spherical radii, \u03bc.  Default is 0.\nastropy\/modeling\/projections.py:        Look angle \u03b3 in degrees.  Default is 0\u00b0.\nastropy\/modeling\/projections.py:        # TODO: Support quantity objects here and in similar contexts\nastropy\/modeling\/projections.py:        Distance from point of projection to center of sphere\nastropy\/modeling\/projections.py:        in spherical radii, \u03bc. Default is 0.\nastropy\/modeling\/projections.py:        Look angle \u03b3 in degrees. Default is 0\u00b0.\nastropy\/modeling\/projections.py:        Distance from point of projection to center of sphere\nastropy\/modeling\/projections.py:        in spherical radii, \u03bc.  Default is 0.\nastropy\/modeling\/projections.py:        The longitude \u03c6\u2080 of the reference point, in degrees.  Default\nastropy\/modeling\/projections.py:        The latitude \u03b8\u2080 of the reference point, in degrees.  Default\nastropy\/modeling\/projections.py:        in spherical radii, \u03bc.  Default is 0.\nastropy\/modeling\/projections.py:        The longitude \u03c6\u2080 of the reference point, in degrees.  Default\nastropy\/modeling\/projections.py:        The latitude \u03b8\u2080 of the reference point, in degrees.  Default\nastropy\/modeling\/projections.py:        Obliqueness parameter, \u03be.  Default is 0.0.\nastropy\/modeling\/projections.py:        Obliqueness parameter, \u03b7.  Default is 0.0.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90\u00b0.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90\u00b0.\nastropy\/modeling\/projections.py:        Distance from center of sphere in the direction opposite the\nastropy\/modeling\/projections.py:        projected surface, in spherical radii, \u03bc. Default is 1.\nastropy\/modeling\/projections.py:        Radius of the cylinder in spherical radii, \u03bb. Default is 1.\nastropy\/modeling\/projections.py:        Distance from center of sphere in the direction opposite the\nastropy\/modeling\/projections.py:        projected surface, in spherical radii, \u03bc.  Default is 0.\nastropy\/modeling\/projections.py:        Radius of the cylinder in spherical radii, \u03bb.  Default is 0.\nastropy\/modeling\/projections.py:        Radius of the cylinder in spherical radii, \u03bb.  Default is 0.\nastropy\/modeling\/projections.py:        Radius of the cylinder in spherical radii, \u03bb.  Default is 0.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:    Corresponds to the ``COD`` projection in FITS WCS.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:Pix2Sky_COD = Pix2Sky_ConicEquidistant\nastropy\/modeling\/projections.py:    Corresponds to the ``COD`` projection in FITS WCS.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:Sky2Pix_COD = Sky2Pix_ConicEquidistant\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:        in degrees.  Default is 90.\nastropy\/modeling\/projections.py:        in degrees.  Default is 0.\nastropy\/modeling\/projections.py:class AffineTransformation2D(Model):\nastropy\/modeling\/projections.py:        A 2D vector (given as either a 2x1 or 1x2 array) specifying a\nastropy\/modeling\/projections.py:        \"\"\"Validates that the input matrix is a 2x2 2D array.\"\"\"\nastropy\/modeling\/projections.py:        Validates that the translation vector is a 2D vector.  This allows\nastropy\/modeling\/projections.py:        Apply the transformation to a set of 2D Cartesian coordinates given as\nastropy\/stats\/lombscargle\/implementations\/slow_impl.py:    .. [2] Scargle, J.D. 1982, ApJ 263:835-853\nastropy\/coordinates\/builtin_frames\/skyoffset.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/skyoffset.py:from ..transformations import DynamicMatrixTransform, FunctionTransform\nastropy\/coordinates\/builtin_frames\/skyoffset.py:                    # TODO: we could support proper motions \/ velocities in sky\nastropy\/coordinates\/builtin_frames\/skyoffset.py:    @frame_transform_graph.transform(DynamicMatrixTransform, framecls, _SkyOffsetFramecls)\nastropy\/coordinates\/builtin_frames\/skyoffset.py:        # Define rotation matrices along the position angle vector, and\nastropy\/coordinates\/builtin_frames\/skyoffset.py:    @frame_transform_graph.transform(DynamicMatrixTransform, _SkyOffsetFramecls, framecls)\nastropy\/coordinates\/builtin_frames\/skyoffset.py:    object's ``lat`` will be pointed in the direction of Dec, while ``lon``\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:ALL_METHODS = LombScargle.available_methods\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:ALL_METHODS_NO_AUTO = [method for method in ALL_METHODS if method != 'auto']\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:FAST_METHODS = [method for method in ALL_METHODS if 'fast' in method]\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:NTERMS_METHODS = [method for method in ALL_METHODS if 'chi2' in method]\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:@pytest.mark.parametrize('method', ALL_METHODS_NO_AUTO)\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:    if method in FAST_METHODS:\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:@pytest.mark.parametrize('method', ALL_METHODS_NO_AUTO)\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:@pytest.mark.parametrize('method', NTERMS_METHODS)\nastropy\/stats\/lombscargle\/tests\/test_lombscargle.py:@pytest.mark.parametrize('method', FAST_METHODS)\nastropy\/coordinates\/angle_parsetab.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angle_parsetab.py:# This file is automatically generated. Do not edit.\nastropy\/coordinates\/angle_parsetab.py:_lr_signature = 'DA395940D76FFEB6A68EA2DB16FC015D'\nastropy\/coordinates\/angle_parsetab.py:_lr_action_items = {'UINT':([0,2,10,12,19,20,22,23,35,36,38,],[-7,12,-6,19,25,27,29,32,25,25,25,]),'MINUTE':([4,6,8,12,13,19,21,24,25,26,27,28,29,31,32,34,40,],[16,-14,-15,-17,-16,-9,-12,-8,-9,-13,-9,-10,36,37,38,39,-11,]),'COLON':([12,27,],[20,35,]),'$end':([1,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,30,31,32,33,34,36,37,38,39,40,41,42,43,44,],[-4,-1,-32,-5,-14,-2,-15,-3,0,-17,-16,-33,-31,-35,-24,-34,-9,-12,-25,-18,-8,-9,-13,-9,-10,-9,-26,-8,-9,-19,-8,-27,-28,-20,-21,-11,-29,-22,-30,-23,]),'SIMPLE_UNIT':([4,6,8,12,13,19,21,24,25,26,27,28,40,],[14,-14,-15,-17,-16,-9,-12,-8,-9,-13,-9,-10,-11,]),'DEGREE':([4,6,8,12,13,19,21,24,25,26,27,28,40,],[15,-14,-15,22,-16,-9,-12,-8,-9,-13,-9,-10,-11,]),'UFLOAT':([0,2,10,12,19,20,22,23,35,36,38,],[-7,13,-6,24,24,24,31,34,24,24,24,]),'HOUR':([4,6,8,12,13,19,21,24,25,26,27,28,40,],[17,-14,-15,23,-16,-9,-12,-8,-9,-13,-9,-10,-11,]),'SECOND':([4,6,8,12,13,19,21,24,25,26,27,28,40,41,42,],[18,-14,-15,-17,-16,-9,-12,-8,-9,-13,-9,-10,-11,43,44,]),'SIGN':([0,],[10,]),}\nastropy\/coordinates\/angle_parsetab.py:  ('hms -> sign UINT HOUR UINT MINUTE ufloat SECOND','hms',7,'p_hms','angle_utilities.py',198),\nastropy\/coordinates\/angle_parsetab.py:  ('dms -> sign UINT DEGREE','dms',3,'p_dms','angle_utilities.py',212),\nastropy\/coordinates\/angle_parsetab.py:  ('dms -> sign UINT DEGREE ufloat','dms',4,'p_dms','angle_utilities.py',213),\nastropy\/coordinates\/angle_parsetab.py:  ('dms -> sign UINT DEGREE UINT MINUTE','dms',5,'p_dms','angle_utilities.py',214),\nastropy\/coordinates\/angle_parsetab.py:  ('dms -> sign UINT DEGREE UFLOAT MINUTE','dms',5,'p_dms','angle_utilities.py',215),\nastropy\/coordinates\/angle_parsetab.py:  ('dms -> sign UINT DEGREE UINT MINUTE ufloat','dms',6,'p_dms','angle_utilities.py',216),\nastropy\/coordinates\/angle_parsetab.py:  ('dms -> sign UINT DEGREE UINT MINUTE ufloat SECOND','dms',7,'p_dms','angle_utilities.py',217),\nastropy\/coordinates\/angle_parsetab.py:  ('dms -> generic DEGREE','dms',2,'p_dms','angle_utilities.py',218),\nastropy\/coordinates\/angle_parsetab.py:  ('arcsecond -> generic SECOND','arcsecond',2,'p_arcsecond','angle_utilities.py',241),\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:                           METHODS)\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:METHOD_KWDS = dict(bootstrap={'n_bootstraps': 20, 'random_seed': 42})\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:    method_kwds = METHOD_KWDS['bootstrap']\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:@pytest.mark.parametrize('method', sorted(set(METHODS) - {'bootstrap'}))\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:    method_kwds = METHOD_KWDS.get(method, None)\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:@pytest.mark.parametrize('method', sorted(METHODS))\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:    kwds = METHOD_KWDS.get(method, None)\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:@pytest.mark.parametrize('method', sorted(METHODS))\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:    # Note: the PSD normalization is not equivalent to the others, in that it\nastropy\/stats\/lombscargle\/tests\/test_statistics.py:    kwds = METHOD_KWDS.get(method, None)\nastropy\/modeling\/polynomial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/polynomial.py:from collections import OrderedDict\nastropy\/modeling\/polynomial.py:    'Chebyshev1D', 'Chebyshev2D', 'Hermite1D', 'Hermite2D',\nastropy\/modeling\/polynomial.py:    'InverseSIP', 'Legendre1D', 'Legendre2D', 'Polynomial1D',\nastropy\/modeling\/polynomial.py:    'Polynomial2D', 'SIP', 'OrthoPolynomialBase',\nastropy\/modeling\/polynomial.py:    # Default _param_names list; this will be filled in by the implementation's\nastropy\/modeling\/polynomial.py:        # TODO: Support a means of specifying default values for coefficients\nastropy\/modeling\/polynomial.py:        # TODO: I wonder if there might be a way around that though...\nastropy\/modeling\/polynomial.py:        return self._format_str([('Degree', self.degree)])\nastropy\/modeling\/polynomial.py:        \"\"\"Degree of polynomial.\"\"\"\nastropy\/modeling\/polynomial.py:            raise ValueError(\"Degree of polynomial must be positive or null\")\nastropy\/modeling\/polynomial.py:    This is a base class for the 2D Chebyshev and Legendre models.\nastropy\/modeling\/polynomial.py:        # TODO: Perhaps some of these other parameters should be properties?\nastropy\/modeling\/polynomial.py:        # TODO: An awful lot of the functionality in this method is still\nastropy\/modeling\/polynomial.py:            [('X-Degree', self.x_degree),\nastropy\/modeling\/polynomial.py:             ('Y-Degree', self.y_degree)])\nastropy\/modeling\/polynomial.py:        Determine how many coefficients are needed\nastropy\/modeling\/polynomial.py:        # TODO: This is a very slow way to do this; fix it and related methods\nastropy\/modeling\/polynomial.py:        # TODO: Write a docstring explaining the actual purpose of this method\nastropy\/modeling\/polynomial.py:class Chebyshev1D(PolynomialModel):\nastropy\/modeling\/polynomial.py:class Hermite1D(PolynomialModel):\nastropy\/modeling\/polynomial.py:class Hermite2D(OrthoPolynomialBase):\nastropy\/modeling\/polynomial.py:        Derivatives with respect to the coefficients.\nastropy\/modeling\/polynomial.py:        Derivative of 1D Hermite series\nastropy\/modeling\/polynomial.py:class Legendre1D(PolynomialModel):\nastropy\/modeling\/polynomial.py:class Polynomial1D(PolynomialModel):\nastropy\/modeling\/polynomial.py:    1D Polynomial model.\nastropy\/modeling\/polynomial.py:        return OrderedDict(mapping)\nastropy\/modeling\/polynomial.py:class Polynomial2D(PolynomialModel):\nastropy\/modeling\/polynomial.py:    2D Polynomial  model.\nastropy\/modeling\/polynomial.py:        return OrderedDict(mapping)\nastropy\/modeling\/polynomial.py:class Chebyshev2D(OrthoPolynomialBase):\nastropy\/modeling\/polynomial.py:        Derivatives with respect to the coefficients.\nastropy\/modeling\/polynomial.py:        Derivative of 1D Chebyshev series\nastropy\/modeling\/polynomial.py:class Legendre2D(OrthoPolynomialBase):\nastropy\/modeling\/polynomial.py:    Defined as:\nastropy\/modeling\/polynomial.py:        Derivatives with respect to the coefficients.\nastropy\/modeling\/polynomial.py:        \"\"\"Derivative of 1D Legendre polynomial\"\"\"\nastropy\/modeling\/polynomial.py:class _SIP1D(PolynomialBase):\nastropy\/modeling\/polynomial.py:    This implements the Simple Imaging Polynomial Model (SIP) in 1D.\nastropy\/modeling\/polynomial.py:    It's unlikely it will be used in 1D so this class is private\nastropy\/modeling\/polynomial.py:        # TODO: Rewrite this so that it uses a simpler method of determining\nastropy\/modeling\/polynomial.py:            raise ValueError(\"Degree of polynomial must be 2< deg < 9\")\nastropy\/modeling\/polynomial.py:    .. [1] `David Shupe, et al, ADASS, ASP Conference Series, Vol. 347, 2005 <http:\/\/adsabs.harvard.edu\/abs\/2005ASPC..347..491S>`_\nastropy\/modeling\/polynomial.py:        self.sip1d_a = _SIP1D(a_order, coeff_prefix='A', n_models=n_models,\nastropy\/modeling\/polynomial.py:        self.sip1d_b = _SIP1D(b_order, coeff_prefix='B', n_models=n_models,\nastropy\/modeling\/polynomial.py:        # define the 0th term in order to use Polynomial2D\nastropy\/modeling\/polynomial.py:        self.sip1d_ap = Polynomial2D(degree=ap_order,\nastropy\/modeling\/polynomial.py:        self.sip1d_bp = Polynomial2D(degree=bp_order,\nastropy\/stats\/lombscargle\/implementations\/fastchi2_impl.py:    .. [3] Scargle, J.D. ApJ 263:835-853 (1982)\nastropy\/coordinates\/baseframe.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/baseframe.py:from collections import namedtuple, OrderedDict, defaultdict\nastropy\/coordinates\/baseframe.py:# Dependencies\nastropy\/coordinates\/baseframe.py:from ..utils import (OrderedDescriptorContainer, ShapedLikeNDArray,\nastropy\/coordinates\/baseframe.py:    **differentials : dict of str or `~astropy.coordinates.BaseDifferentials`\nastropy\/coordinates\/baseframe.py:            differential_cls = r.DIFFERENTIAL_CLASSES.get(base.get_name(), None)\nastropy\/coordinates\/baseframe.py:        elif differential_cls in r.DIFFERENTIAL_CLASSES:\nastropy\/coordinates\/baseframe.py:            differential_cls = r.DIFFERENTIAL_CLASSES[differential_cls]\nastropy\/coordinates\/baseframe.py:               not issubclass(differential_cls, r.BaseDifferential))):\nastropy\/coordinates\/baseframe.py:                'Differential is {0!r} but must be a BaseDifferential class '\nastropy\/coordinates\/baseframe.py:                    differential_cls, list(r.DIFFERENTIAL_CLASSES)))\nastropy\/coordinates\/baseframe.py:# with ShapedLikeNDArray below (which is an ABC); without it, one gets\nastropy\/coordinates\/baseframe.py:class FrameMeta(OrderedDescriptorContainer, abc.ABCMeta):\nastropy\/coordinates\/baseframe.py:        # https:\/\/mail.python.org\/pipermail\/python-list\/2002-December\/167861.html\nastropy\/coordinates\/baseframe.py:class BaseCoordinateFrame(ShapedLikeNDArray, metaclass=FrameMeta):\nastropy\/coordinates\/baseframe.py:        A subclass of `~astropy.coordinates.BaseDifferential` that will be\nastropy\/coordinates\/baseframe.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/baseframe.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/baseframe.py:    frame_attributes = OrderedDict()\nastropy\/coordinates\/baseframe.py:    # Default empty frame_attributes dict\nastropy\/coordinates\/baseframe.py:        # TODO: we should be able to deal with an instance, not just a\nastropy\/coordinates\/baseframe.py:                    issubclass(differential_cls, r.BaseDifferential)):\nastropy\/coordinates\/baseframe.py:                # TODO: assumes the differential class is for the velocity\nastropy\/coordinates\/baseframe.py:            # TODO: possibly generalize this somehow?\nastropy\/coordinates\/baseframe.py:            # Now we handle the Differential data:\nastropy\/coordinates\/baseframe.py:                    differential_cls = r.RadialDifferential\nastropy\/coordinates\/baseframe.py:                # TODO: assumes a velocity unit differential\nastropy\/coordinates\/baseframe.py:    # We have to override the ShapedLikeNDArray definitions, since our shape\nastropy\/coordinates\/baseframe.py:        return OrderedDict((name, getattr(cls, name))\nastropy\/coordinates\/baseframe.py:        representation : `~astropy.coordinates.BaseRepresentation` or `~astropy.coordinates.BaseDifferential`.\nastropy\/coordinates\/baseframe.py:        s : `~astropy.coordinates.BaseDifferential` subclass, optional\nastropy\/coordinates\/baseframe.py:                              list(r.DIFFERENTIAL_CLASSES.values())):\nastropy\/coordinates\/baseframe.py:                # TODO: this provides a layer of backwards compatibility in\nastropy\/coordinates\/baseframe.py:        out = OrderedDict()\nastropy\/coordinates\/baseframe.py:        out = OrderedDict()\nastropy\/coordinates\/baseframe.py:        # TODO: should we expose this, so one has a choice?\nastropy\/coordinates\/baseframe.py:        s : subclass of `~astropy.coordinates.BaseDifferential`, str, optional\nastropy\/coordinates\/baseframe.py:                # TODO NOTE: only supports a single differential\nastropy\/coordinates\/baseframe.py:                diff = data.differentials['s']  # TODO: assumes velocity\nastropy\/coordinates\/baseframe.py:                        # input data has a UnitSphericalDifferential or a\nastropy\/coordinates\/baseframe.py:                        # RadialDifferential. It is re-represented to the\nastropy\/coordinates\/baseframe.py:                        # dimensional Differential), so we don't want to try to\nastropy\/coordinates\/baseframe.py:                                       (r.UnitSphericalDifferential,\nastropy\/coordinates\/baseframe.py:                                        r.UnitSphericalCosLatDifferential)) and\nastropy\/coordinates\/baseframe.py:                        elif (isinstance(data_diff, r.RadialDifferential) and\nastropy\/coordinates\/baseframe.py:                    # the input differential is a RadialDifferential, it usually\nastropy\/coordinates\/baseframe.py:                    # gets turned into a SphericalCosLatDifferential (or\nastropy\/coordinates\/baseframe.py:        Determines if this coordinate frame can be transformed to another\nastropy\/coordinates\/baseframe.py:        Determine whether or not a frame attribute has its value because it's\nastropy\/coordinates\/baseframe.py:                if isinstance(dif_data, (r.UnitSphericalDifferential,\nastropy\/coordinates\/baseframe.py:                                         r.UnitSphericalCosLatDifferential,\nastropy\/coordinates\/baseframe.py:                                         r.RadialDifferential)):\nastropy\/coordinates\/baseframe.py:            data_repr = 'Data:\\n' + data_repr\nastropy\/coordinates\/baseframe.py:        are all defined in `~astropy.utils.misc.ShapedLikeNDArray`. It will be\nastropy\/coordinates\/baseframe.py:        # TODO: expose this trickery in docstring?\nastropy\/coordinates\/baseframe.py:            if isinstance(value, ShapedLikeNDArray):\nastropy\/coordinates\/baseframe.py:        # TODO: change to representation_cls in __init__ - gh-6219.\nastropy\/coordinates\/baseframe.py:        TODO: dynamic representation transforms (i.e. include cylindrical et al.).\nastropy\/coordinates\/baseframe.py:        TODO: We should handle dynamic representation transforms here (e.g.,\nastropy\/coordinates\/baseframe.py:            # TODO: this doesn't work for the case when there is only\nastropy\/coordinates\/baseframe.py:        sep : `~astropy.coordinates.Distance`\nastropy\/coordinates\/baseframe.py:        from .distances import Distance\nastropy\/coordinates\/baseframe.py:        return Distance((self_car - other_car).norm())\nastropy\/coordinates\/baseframe.py:        # TODO: if representations are updated to use a full transform graph,\nastropy\/coordinates\/baseframe.py:        # TODO: if representations are updated to use a full transform graph,\nastropy\/coordinates\/baseframe.py:        `SphericalCosLatDifferential` for the velocity data in this object.\nastropy\/coordinates\/baseframe.py:        # TODO: if representations are updated to use a full transform graph,\nastropy\/coordinates\/baseframe.py:        `CartesianDifferential` object. This is equivalent to calling\nastropy\/coordinates\/baseframe.py:            raise ValueError('Frame has no associated velocity (Differential) '\nastropy\/coordinates\/baseframe.py:            raise ValueError('Frame has no associated velocity (Differential) '\nastropy\/coordinates\/baseframe.py:            raise ValueError('Frame has no associated velocity (Differential) '\nastropy\/coordinates\/baseframe.py:        self.frame_attributes = OrderedDict()\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:from ..transformations import FunctionTransformWithFiniteDifference, AffineTransform\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ICRS, CIRS)\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, CIRS, ICRS)\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, CIRS, CIRS)\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ICRS, GCRS)\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, GCRS, GCRS)\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, GCRS, HCRS)\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:_NEED_ORIGIN_HINT = (\"The input {0} coordinates do not have length units. This \"\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:        raise u.UnitsError(_NEED_ORIGIN_HINT.format(hcrs_coo.__class__.__name__))\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:        raise u.UnitsError(_NEED_ORIGIN_HINT.format(icrs_coo.__class__.__name__))\nastropy\/coordinates\/builtin_frames\/icrs_cirs_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, HCRS, HCRS)\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:from ..transformations import FunctionTransformWithFiniteDifference, DynamicMatrixTransform\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, GeocentricTrueEcliptic, GCRS)\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, ICRS, BarycentricTrueEcliptic)\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, BarycentricTrueEcliptic, ICRS)\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:_NEED_ORIGIN_HINT = (\"The input {0} coordinates do not have length units. This \"\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:        raise UnitsError(_NEED_ORIGIN_HINT.format(from_coo.__class__.__name__))\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/builtin_frames\/ecliptic_transforms.py:        raise UnitsError(_NEED_ORIGIN_HINT.format(from_coo.__class__.__name__))\nastropy\/coordinates\/builtin_frames\/supergalactic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        The Distance for this object along the line-of-sight.\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        The proper motion in Declination for this object (``pm_sgl_cossgb`` must\nastropy\/coordinates\/builtin_frames\/supergalactic.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        r.SphericalCosLatDifferential: [\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        r.SphericalDifferential: [\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        r.CartesianDifferential: [\nastropy\/coordinates\/builtin_frames\/supergalactic.py:    frame_specific_representation_info[r.UnitSphericalCosLatDifferential] = \\\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        frame_specific_representation_info[r.SphericalCosLatDifferential]\nastropy\/coordinates\/builtin_frames\/supergalactic.py:    frame_specific_representation_info[r.UnitSphericalDifferential] = \\\nastropy\/coordinates\/builtin_frames\/supergalactic.py:        frame_specific_representation_info[r.SphericalDifferential]\nastropy\/coordinates\/builtin_frames\/supergalactic.py:    default_differential = r.SphericalCosLatDifferential\nastropy\/coordinates\/builtin_frames\/itrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/itrs.py:from ..representation import CartesianRepresentation, CartesianDifferential\nastropy\/coordinates\/builtin_frames\/itrs.py:from .utils import DEFAULT_OBSTIME\nastropy\/coordinates\/builtin_frames\/itrs.py:    default_differential = CartesianDifferential\nastropy\/coordinates\/builtin_frames\/itrs.py:    obstime = TimeAttribute(default=DEFAULT_OBSTIME)\nastropy\/coordinates\/builtin_frames\/galactic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/galactic.py:    *origin* of this frame in 3D space is the solar system barycenter, not\nastropy\/coordinates\/builtin_frames\/galactic.py:        The Distance for this object along the line-of-sight.\nastropy\/coordinates\/builtin_frames\/galactic.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/builtin_frames\/galactic.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/builtin_frames\/galactic.py:        r.CartesianDifferential: [\nastropy\/coordinates\/builtin_frames\/galactic.py:        r.SphericalCosLatDifferential: [\nastropy\/coordinates\/builtin_frames\/galactic.py:        r.SphericalDifferential: [\nastropy\/coordinates\/builtin_frames\/galactic.py:    frame_specific_representation_info[r.UnitSphericalCosLatDifferential] = \\\nastropy\/coordinates\/builtin_frames\/galactic.py:        frame_specific_representation_info[r.SphericalCosLatDifferential]\nastropy\/coordinates\/builtin_frames\/galactic.py:    frame_specific_representation_info[r.UnitSphericalDifferential] = \\\nastropy\/coordinates\/builtin_frames\/galactic.py:        frame_specific_representation_info[r.SphericalDifferential]\nastropy\/coordinates\/builtin_frames\/galactic.py:    default_differential = r.SphericalCosLatDifferential\nastropy\/coordinates\/builtin_frames\/baseradec.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/baseradec.py:__all__ = ['BaseRADecFrame']\nastropy\/coordinates\/builtin_frames\/baseradec.py:        The Declination for this object (``ra`` must also be given and\nastropy\/coordinates\/builtin_frames\/baseradec.py:        The Distance for this object along the line-of-sight.\nastropy\/coordinates\/builtin_frames\/baseradec.py:        The proper motion in Declination for this object (``pm_ra_cosdec`` must\nastropy\/coordinates\/builtin_frames\/baseradec.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/builtin_frames\/baseradec.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/builtin_frames\/baseradec.py:class BaseRADecFrame(BaseCoordinateFrame):\nastropy\/coordinates\/builtin_frames\/baseradec.py:    represent longitude and latitude as Right Ascension and Declination\nastropy\/coordinates\/builtin_frames\/baseradec.py:        r.SphericalCosLatDifferential: [\nastropy\/coordinates\/builtin_frames\/baseradec.py:        r.SphericalDifferential: [\nastropy\/coordinates\/builtin_frames\/baseradec.py:        r.CartesianDifferential: [\nastropy\/coordinates\/builtin_frames\/baseradec.py:    frame_specific_representation_info[r.UnitSphericalCosLatDifferential] = \\\nastropy\/coordinates\/builtin_frames\/baseradec.py:        frame_specific_representation_info[r.SphericalCosLatDifferential]\nastropy\/coordinates\/builtin_frames\/baseradec.py:    frame_specific_representation_info[r.UnitSphericalDifferential] = \\\nastropy\/coordinates\/builtin_frames\/baseradec.py:        frame_specific_representation_info[r.SphericalDifferential]\nastropy\/coordinates\/builtin_frames\/baseradec.py:    default_differential = r.SphericalCosLatDifferential\nastropy\/coordinates\/builtin_frames\/baseradec.py:BaseRADecFrame.__doc__ = BaseRADecFrame.__doc__.format(\nastropy\/coordinates\/matching.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/matching.py:        If a string, will store the KD-Tree used for the computation\nastropy\/coordinates\/matching.py:        same catalog. If False, the KD-Tree is discarded after use.\nastropy\/coordinates\/matching.py:        The 3D distance between the closest match for each ``matchcoord`` and\nastropy\/coordinates\/matching.py:    if nthneighbor > 1:  # query gives 1D arrays if k=1, 2D arrays otherwise\nastropy\/coordinates\/matching.py:        If a string, will store the KD-Tree used for the computation\nastropy\/coordinates\/matching.py:        same catalog. If False, the KD-Tree is discarded after use.\nastropy\/coordinates\/matching.py:        The 3D distance between the closest match for each ``matchcoord`` and\nastropy\/coordinates\/matching.py:        ``matchcoord`` or ``catalogcoord`` don't have a distance, this is the 3D\nastropy\/coordinates\/matching.py:    # Check for a stored KD-tree on the passed-in coordinate. Normally it will\nastropy\/coordinates\/matching.py:    # have a distinct name from the \"3D\" one, so it's safe to use even though\nastropy\/coordinates\/matching.py:    distance in 3D space.\nastropy\/coordinates\/matching.py:        If a string, will store the KD-Tree used in the search with the name\nastropy\/coordinates\/matching.py:        to this function. If False, the KD-Trees are not saved.\nastropy\/coordinates\/matching.py:        The 3D distance between the coordinates. Shape matches ``idx1`` and\nastropy\/coordinates\/matching.py:    # so that if the conversion does happen, the KD tree of coord2 at least gets\nastropy\/coordinates\/matching.py:    # this is the *cartesian* 3D distance that corresponds to the given angle\nastropy\/coordinates\/matching.py:        If a string, will store the KD-Tree used in the search with the name\nastropy\/coordinates\/matching.py:        to this function. If False, the KD-Trees are not saved.\nastropy\/coordinates\/matching.py:        The 3D distance between the coordinates. Shape matches ``idx1``\nastropy\/coordinates\/matching.py:        this is the 3D distance on the unit sphere, rather than a\nastropy\/coordinates\/matching.py:    # so that if the conversion does happen, the KD tree of coord2 at least gets\nastropy\/coordinates\/matching.py:        # just use the stored KD-Tree\nastropy\/coordinates\/matching.py:            # save the KD-Tree in coords2, *not* ucoords2\nastropy\/coordinates\/matching.py:    # this is the *cartesian* 3D distance that corresponds to the given angle\nastropy\/coordinates\/matching.py:    a 3D cartesian KD-Tree from various sorts of astropy coordinate objects.\nastropy\/coordinates\/matching.py:        The coordinates to build the KD-Tree for.\nastropy\/coordinates\/matching.py:    attrname_or_kdt : bool or str or KDTree\nastropy\/coordinates\/matching.py:        If a string, will store the KD-Tree used for the computation in the\nastropy\/coordinates\/matching.py:        KD-Tree, it will just be used directly.\nastropy\/coordinates\/matching.py:        being put in the KD-Tree.  If None, whatever unit it's already in\nastropy\/coordinates\/matching.py:    kdt : `~scipy.spatial.cKDTree` or `~scipy.spatial.KDTree`\nastropy\/coordinates\/matching.py:        The KD-Tree representing the 3D cartesian representation of the input\nastropy\/coordinates\/matching.py:        KDTree = spatial.cKDTree\nastropy\/coordinates\/matching.py:        warn('C-based KD tree not found, falling back on (much slower) '\nastropy\/coordinates\/matching.py:        KDTree = spatial.KDTree\nastropy\/coordinates\/matching.py:    # figure out where any cached KDTree might be\nastropy\/coordinates\/matching.py:        if kdt is not None and not isinstance(kdt, KDTree):\nastropy\/coordinates\/matching.py:            raise TypeError('The `attrname_or_kdt` \"{0}\" is not a scipy KD tree!'.format(attrname_or_kdt))\nastropy\/coordinates\/matching.py:    elif isinstance(attrname_or_kdt, KDTree):\nastropy\/coordinates\/matching.py:        raise TypeError('Invalid `attrname_or_kdt` argument for KD-Tree:' +\nastropy\/coordinates\/matching.py:        # need to build the cartesian KD-tree for the catalog\nastropy\/coordinates\/matching.py:        kdt = KDTree(flatxyz.value.T)\nastropy\/coordinates\/builtin_frames\/icrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/icrs.py:from .baseradec import _base_radec_docstring, BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/icrs.py:class ICRS(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/galactocentric.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/galactocentric.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                          DifferentialAttribute)\nastropy\/coordinates\/builtin_frames\/galactocentric.py:        {\\rm Dec} = -28:56:10.23~{\\rm deg}\nastropy\/coordinates\/builtin_frames\/galactocentric.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/builtin_frames\/galactocentric.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/builtin_frames\/galactocentric.py:    galcen_v_sun : `~astropy.coordinates.representation.CartesianDifferential`, optional, must be keyword\nastropy\/coordinates\/builtin_frames\/galactocentric.py:        r.CartesianDifferential: [\nastropy\/coordinates\/builtin_frames\/galactocentric.py:    default_differential = r.CartesianDifferential\nastropy\/coordinates\/builtin_frames\/galactocentric.py:    galcen_v_sun = DifferentialAttribute(\nastropy\/coordinates\/builtin_frames\/galactocentric.py:        default=r.CartesianDifferential([11.1, 220+12.24, 7.25] * u.km\/u.s),\nastropy\/coordinates\/builtin_frames\/galactocentric.py:        allowed_classes=[r.CartesianDifferential])\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                          \"argument\", AstropyDeprecationWarning)\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                      \"'.galcen_coord.ra' instead.\", AstropyDeprecationWarning)\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                      \"'.galcen_coord.dec' instead.\", AstropyDeprecationWarning)\nastropy\/coordinates\/builtin_frames\/galactocentric.py:        offset_v = r.CartesianDifferential.from_cartesian(\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                           \"requires a 3D coordinate, e.g. (angle, angle, \"\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                       (r.UnitSphericalDifferential,\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                        r.UnitSphericalCosLatDifferential,\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                        r.RadialDifferential))):\nastropy\/coordinates\/builtin_frames\/galactocentric.py:                           \"requires a 3D velocity, e.g., proper motion \"\nastropy\/coordinates\/builtin_frames\/gcrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/gcrs.py:from .utils import DEFAULT_OBSTIME, EQUINOX_J2000\nastropy\/coordinates\/builtin_frames\/gcrs.py:from .baseradec import _base_radec_docstring, BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/gcrs.py:class GCRS(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/gcrs.py:        Defaults to [0, 0, 0], meaning \"true\" GCRS.\nastropy\/coordinates\/builtin_frames\/gcrs.py:        units.  Defaults to [0, 0, 0], meaning \"true\" GCRS.\nastropy\/coordinates\/builtin_frames\/gcrs.py:    obstime = TimeAttribute(default=DEFAULT_OBSTIME)\nastropy\/coordinates\/builtin_frames\/gcrs.py:class PrecessedGeocentric(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/gcrs.py:        Defaults to [0, 0, 0], meaning \"true\" Geocentric.\nastropy\/coordinates\/builtin_frames\/gcrs.py:        Defaults to [0, 0, 0], meaning \"true\" Geocentric.\nastropy\/coordinates\/builtin_frames\/gcrs.py:    obstime = TimeAttribute(default=DEFAULT_OBSTIME)\nastropy\/coordinates\/builtin_frames\/lsr.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/lsr.py:from ..attributes import DifferentialAttribute\nastropy\/coordinates\/builtin_frames\/lsr.py:from .baseradec import _base_radec_docstring, BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/lsr.py:v_bary_Schoenrich2010 = r.CartesianDifferential([11.1, 12.24, 7.25]*u.km\/u.s)\nastropy\/coordinates\/builtin_frames\/lsr.py:class LSR(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_bary : `~astropy.coordinates.representation.CartesianDifferential`\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_bary = DifferentialAttribute(default=v_bary_Schoenrich2010,\nastropy\/coordinates\/builtin_frames\/lsr.py:                                   allowed_classes=[r.CartesianDifferential])\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_offset = v_bary_icrs.data.represent_as(r.CartesianDifferential)\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_offset = v_bary_icrs.data.represent_as(r.CartesianDifferential)\nastropy\/coordinates\/builtin_frames\/lsr.py:        The Distance for this object along the line-of-sight.\nastropy\/coordinates\/builtin_frames\/lsr.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/builtin_frames\/lsr.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_bary : `~astropy.coordinates.representation.CartesianDifferential`\nastropy\/coordinates\/builtin_frames\/lsr.py:        r.SphericalCosLatDifferential: [\nastropy\/coordinates\/builtin_frames\/lsr.py:        r.SphericalDifferential: [\nastropy\/coordinates\/builtin_frames\/lsr.py:        r.CartesianDifferential: [\nastropy\/coordinates\/builtin_frames\/lsr.py:    frame_specific_representation_info[r.UnitSphericalCosLatDifferential] = \\\nastropy\/coordinates\/builtin_frames\/lsr.py:        frame_specific_representation_info[r.SphericalCosLatDifferential]\nastropy\/coordinates\/builtin_frames\/lsr.py:    frame_specific_representation_info[r.UnitSphericalDifferential] = \\\nastropy\/coordinates\/builtin_frames\/lsr.py:        frame_specific_representation_info[r.SphericalDifferential]\nastropy\/coordinates\/builtin_frames\/lsr.py:    default_differential = r.SphericalCosLatDifferential\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_bary = DifferentialAttribute(default=v_bary_Schoenrich2010)\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_offset = v_bary_gal.data.represent_as(r.CartesianDifferential)\nastropy\/coordinates\/builtin_frames\/lsr.py:    v_offset = v_bary_gal.data.represent_as(r.CartesianDifferential)\nastropy\/coordinates\/builtin_frames\/cirs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/cirs.py:from .baseradec import _base_radec_docstring, BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/cirs.py:from .utils import DEFAULT_OBSTIME\nastropy\/coordinates\/builtin_frames\/cirs.py:class CIRS(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/cirs.py:    obstime = TimeAttribute(default=DEFAULT_OBSTIME)\nastropy\/coordinates\/earth.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/earth.py:from .representation import CartesianRepresentation, CartesianDifferential\nastropy\/coordinates\/earth.py:ELLIPSOIDS = ('WGS84', 'GRS80', 'WGS72')\nastropy\/coordinates\/earth.py:    if ellipsoid not in ELLIPSOIDS:\nastropy\/coordinates\/earth.py:                         .format(ellipsoid, ELLIPSOIDS))\nastropy\/coordinates\/earth.py:        # TODO: needs copy argument and better dealing with inputs.\nastropy\/coordinates\/earth.py:            NY) or a city name (e.g., Danbury, CT), or etc.\nastropy\/coordinates\/earth.py:            Reference ellipsoid to use.  Default is the one the coordinates\nastropy\/coordinates\/earth.py:        itrs.data.differentials['s'] = CartesianDifferential(zeros)\nastropy\/coordinates\/builtin_frames\/galactic_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/galactic_transforms.py:from ..transformations import DynamicMatrixTransform\nastropy\/coordinates\/builtin_frames\/galactic_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, FK5, Galactic)\nastropy\/coordinates\/builtin_frames\/galactic_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, Galactic, FK5)\nastropy\/coordinates\/builtin_frames\/galactic_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, FK4NoETerms, Galactic)\nastropy\/coordinates\/builtin_frames\/galactic_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, Galactic, FK4NoETerms)\nastropy\/coordinates\/builtin_frames\/supergalactic_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/fk4.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/fk4.py:from ..transformations import (FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/builtin_frames\/fk4.py:                               FunctionTransform, DynamicMatrixTransform)\nastropy\/coordinates\/builtin_frames\/fk4.py:from .baseradec import _base_radec_docstring, BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/fk4.py:class FK4(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/fk4.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, FK4, FK4)\nastropy\/coordinates\/builtin_frames\/fk4.py:class FK4NoETerms(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/fk4.py:@frame_transform_graph.transform(DynamicMatrixTransform, FK4NoETerms, FK4NoETerms)\nastropy\/coordinates\/builtin_frames\/fk4.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, FK4, FK4NoETerms)\nastropy\/coordinates\/builtin_frames\/fk4.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, FK4NoETerms, FK4)\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:from ..transformations import FunctionTransformWithFiniteDifference\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, CIRS, AltAz)\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, AltAz, CIRS)\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:        # treat the output of atoiq as an \"astrometric\" RA\/DEC, so to get the\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:        # actual RA\/Dec from the observers vantage point, we have to reverse\nastropy\/coordinates\/builtin_frames\/cirs_observed_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, AltAz, AltAz)\nastropy\/coordinates\/builtin_frames\/icrs_fk5_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/icrs_fk5_transforms.py:from ..transformations import DynamicMatrixTransform\nastropy\/coordinates\/builtin_frames\/icrs_fk5_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, ICRS, FK5)\nastropy\/coordinates\/builtin_frames\/icrs_fk5_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, FK5, ICRS)\nastropy\/coordinates\/builtin_frames\/fk5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/fk5.py:from ..transformations import DynamicMatrixTransform\nastropy\/coordinates\/builtin_frames\/fk5.py:from .baseradec import _base_radec_docstring, BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/fk5.py:class FK5(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/fk5.py:# This is the \"self-transform\".  Defined at module level because the decorator\nastropy\/coordinates\/builtin_frames\/fk5.py:@frame_transform_graph.transform(DynamicMatrixTransform, FK5, FK5)\nastropy\/coordinates\/builtin_frames\/altaz.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/altaz.py:_90DEG = 90*u.deg\nastropy\/coordinates\/builtin_frames\/altaz.py:        The Distance for this object along the line-of-sight.\nastropy\/coordinates\/builtin_frames\/altaz.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/builtin_frames\/altaz.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/builtin_frames\/altaz.py:        r.SphericalCosLatDifferential: [\nastropy\/coordinates\/builtin_frames\/altaz.py:        r.SphericalDifferential: [\nastropy\/coordinates\/builtin_frames\/altaz.py:        r.CartesianDifferential: [\nastropy\/coordinates\/builtin_frames\/altaz.py:    frame_specific_representation_info[r.UnitSphericalCosLatDifferential] = \\\nastropy\/coordinates\/builtin_frames\/altaz.py:        frame_specific_representation_info[r.SphericalCosLatDifferential]\nastropy\/coordinates\/builtin_frames\/altaz.py:    frame_specific_representation_info[r.UnitSphericalDifferential] = \\\nastropy\/coordinates\/builtin_frames\/altaz.py:        frame_specific_representation_info[r.SphericalDifferential]\nastropy\/coordinates\/builtin_frames\/altaz.py:    default_differential = r.SphericalCosLatDifferential\nastropy\/coordinates\/builtin_frames\/altaz.py:        return _90DEG.to(self.alt.unit) - self.alt\nastropy\/modeling\/rotations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/rotations.py:__all__ = ['RotateCelestial2Native', 'RotateNative2Celestial', 'Rotation2D',\nastropy\/modeling\/rotations.py:        where each character denotes an axis in 3D space.\nastropy\/modeling\/rotations.py:class Rotation2D(Model):\nastropy\/modeling\/rotations.py:    Perform a 2D rotation given an angle.\nastropy\/modeling\/rotations.py:        # 1-element 1-D array on output for consistency with most other models\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:from ..transformations import FunctionTransformWithFiniteDifference\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, GCRS, CIRS)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, CIRS, GCRS)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, CIRS, ITRS)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, CIRS)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, ITRS)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:# TODO: implement GCRS<->CIRS if there's call for it.  The thing that's awkward\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, GCRS, PrecessedGeocentric)\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, PrecessedGeocentric, GCRS)\nastropy\/modeling\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/__init__.py:performing model evaluation and fitting. It supports 1D and 2D models\nastropy\/coordinates\/builtin_frames\/ecliptic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/ecliptic.py:from .utils import EQUINOX_J2000, DEFAULT_OBSTIME\nastropy\/coordinates\/builtin_frames\/ecliptic.py:    differential_cls : `BaseDifferential`, dict, optional\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        ``differential_cls=CartesianDifferential`` will make the classes\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        r.SphericalCosLatDifferential: [\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        r.SphericalDifferential: [\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        r.CartesianDifferential: [\nastropy\/coordinates\/builtin_frames\/ecliptic.py:    frame_specific_representation_info[r.UnitSphericalCosLatDifferential] = \\\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        frame_specific_representation_info[r.SphericalCosLatDifferential]\nastropy\/coordinates\/builtin_frames\/ecliptic.py:    frame_specific_representation_info[r.UnitSphericalDifferential] = \\\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        frame_specific_representation_info[r.SphericalDifferential]\nastropy\/coordinates\/builtin_frames\/ecliptic.py:    default_differential = r.SphericalCosLatDifferential\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        The date to assume for this frame.  Determines the location of the\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        The date to assume for this frame.  Determines the location of the\nastropy\/coordinates\/builtin_frames\/ecliptic.py:        The date to assume for this frame.  Determines the location of the\nastropy\/coordinates\/builtin_frames\/ecliptic.py:    obstime = TimeAttribute(default=DEFAULT_OBSTIME)\nastropy\/coordinates\/builtin_frames\/fk4_fk5_transforms.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/fk4_fk5_transforms.py:from ..transformations import DynamicMatrixTransform\nastropy\/coordinates\/builtin_frames\/fk4_fk5_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, FK4NoETerms, FK5)\nastropy\/coordinates\/builtin_frames\/fk4_fk5_transforms.py:@frame_transform_graph.transform(DynamicMatrixTransform, FK5, FK4NoETerms)\nastropy\/coordinates\/builtin_frames\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/utils.py:DEFAULT_OBSTIME = Time('J2000', scale='utc')\nastropy\/coordinates\/builtin_frames\/utils.py:_DEFAULT_PM = (0.035, 0.29)*u.arcsec\nastropy\/coordinates\/builtin_frames\/utils.py:                'valid. Defaulting to polar motion from the 50-yr mean for those. '\nastropy\/coordinates\/builtin_frames\/utils.py:        xp.ravel()[status.ravel() == iers.TIME_BEFORE_IERS_RANGE] = _DEFAULT_PM[0]\nastropy\/coordinates\/builtin_frames\/utils.py:        yp.ravel()[status.ravel() == iers.TIME_BEFORE_IERS_RANGE] = _DEFAULT_PM[1]\nastropy\/coordinates\/builtin_frames\/utils.py:    if np.any(status == iers.TIME_BEYOND_IERS_RANGE):\nastropy\/coordinates\/builtin_frames\/utils.py:                'valid. Defaulting to polar motion from the 50-yr mean for those. '\nastropy\/coordinates\/builtin_frames\/utils.py:        xp.ravel()[status.ravel() == iers.TIME_BEYOND_IERS_RANGE] = _DEFAULT_PM[0]\nastropy\/coordinates\/builtin_frames\/utils.py:        yp.ravel()[status.ravel() == iers.TIME_BEYOND_IERS_RANGE] = _DEFAULT_PM[1]\nastropy\/coordinates\/builtin_frames\/utils.py:        First part of two part Julian date (TDB)\nastropy\/coordinates\/builtin_frames\/utils.py:        Second part of two part Julian date (TDB)\nastropy\/coordinates\/builtin_frames\/utils.py:    # RA, Dec to cartesian unit vectors\nastropy\/coordinates\/builtin_frames\/utils.py:    # ICRS astrometric RA, Dec\nastropy\/coordinates\/builtin_frames\/utils.py:    # CIRS (GCRS) RA, Dec\nastropy\/coordinates\/name_resolve.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/name_resolve.py:        # TODO: Implement me\nastropy\/coordinates\/name_resolve.py:    subpackage. Default is to search all databases, but this can be\nastropy\/coordinates\/name_resolve.py:        The string Declination parsed from the HTTP response.\nastropy\/coordinates\/name_resolve.py:            # Retrieve ascii name resolve data from CDS\nastropy\/coordinates\/builtin_frames\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/__init__.py:from .baseradec import BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/__init__.py:           'BaseEclipticFrame', 'BaseRADecFrame']\nastropy\/coordinates\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/lombscargle\/implementations\/main.py:METHODS = {'slow': lombscargle_slow,\nastropy\/stats\/lombscargle\/implementations\/main.py:    if method not in METHODS:\nastropy\/stats\/lombscargle\/implementations\/main.py:    PLS = METHODS[method](*args, **kwds)\nastropy\/modeling\/blackbody.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/blackbody.py:For blackbody representation as a model, see :class:`BlackBody1D`.\nastropy\/modeling\/blackbody.py:from collections import OrderedDict\nastropy\/modeling\/blackbody.py:from .core import Fittable1DModel\nastropy\/modeling\/blackbody.py:__all__ = ['BlackBody1D', 'blackbody_nu', 'blackbody_lambda']\nastropy\/modeling\/blackbody.py:class BlackBody1D(Fittable1DModel):\nastropy\/modeling\/blackbody.py:    >>> bb = models.BlackBody1D()\nastropy\/modeling\/blackbody.py:        from astropy.modeling.models import BlackBody1D\nastropy\/modeling\/blackbody.py:        bb = BlackBody1D(temperature=5778*u.K)\nastropy\/modeling\/blackbody.py:            Desired integral for the blackbody.\nastropy\/modeling\/blackbody.py:        return OrderedDict([('temperature', u.K),\nastropy\/modeling\/blackbody.py:    ZeroDivisionError\nastropy\/modeling\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/utils.py:__all__ = ['ExpressionTree', 'AliasDict', 'check_broadcast',\nastropy\/modeling\/utils.py:        TODO: Document this better.\nastropy\/modeling\/utils.py:                    # TODO: Explain and\/or refactor this better\nastropy\/modeling\/utils.py:class AliasDict(MutableMapping):\nastropy\/modeling\/utils.py:    >>> alias_dict = AliasDict(parent, aliases)\nastropy\/modeling\/utils.py:    In particular, updates on the `AliasDict` to a key that is equal to\nastropy\/modeling\/utils.py:    assigning to a key ``'a'`` on the `AliasDict` does not impact the\nastropy\/modeling\/utils.py:    storage, for example an `OrderedDict`.  However, even in this case\nastropy\/modeling\/utils.py:        # TODO:\nastropy\/modeling\/utils.py:    for example `~astropy.modeling.models.Gaussian1D.bounding_box`).\nastropy\/modeling\/utils.py:        of lower and upper bounds for 1-D models, or an N-tuple of 2-tuples\nastropy\/modeling\/utils.py:        for N-D models.\nastropy\/modeling\/utils.py:        ensure it is always an N-tuple (even for the 1-D case).\nastropy\/modeling\/utils.py:    Calculates the extent of a box encapsulating a rotated 2D ellipse.\nastropy\/modeling\/utils.py:        from astropy.modeling.models import Ellipse2D\nastropy\/modeling\/utils.py:        model = Ellipse2D(amplitude, x0, y0, a, b, theta)\nastropy\/modeling\/utils.py:        if param.kind in (param.VAR_POSITIONAL, param.VAR_KEYWORD):\nastropy\/stats\/histogram.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/histogram.py:        - 'freedman' : use the Freedman-Diaconis rule to determine bins\nastropy\/stats\/histogram.py:        # TODO: if weights is specified, we need to modify things.\nastropy\/stats\/histogram.py:        \\Delta_b = \\frac{3.5\\sigma}{n^{1\/3}}\nastropy\/stats\/histogram.py:    .. [1] Scott, David W. (1979). \"On optimal and data-based histograms\".\nastropy\/stats\/histogram.py:    r\"\"\"Return the optimal histogram bin width using the Freedman-Diaconis rule\nastropy\/stats\/histogram.py:    The Freedman-Diaconis rule is a normal reference rule like Scott's\nastropy\/stats\/histogram.py:        optimal bin width using the Freedman-Diaconis rule\nastropy\/stats\/histogram.py:        \\Delta_b = \\frac{2(q_{75} - q_{25})}{n^{1\/3}}\nastropy\/stats\/histogram.py:    .. [1] D. Freedman & P. Diaconis (1981)\nastropy\/stats\/histogram.py:    .. [1] Knuth, K.H. \"Optimal Data-Based Binning for Histograms\".\nastropy\/coordinates\/builtin_frames\/hcrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/builtin_frames\/hcrs.py:from .utils import DEFAULT_OBSTIME\nastropy\/coordinates\/builtin_frames\/hcrs.py:from .baseradec import _base_radec_docstring, BaseRADecFrame\nastropy\/coordinates\/builtin_frames\/hcrs.py:class HCRS(BaseRADecFrame):\nastropy\/coordinates\/builtin_frames\/hcrs.py:    obstime = TimeAttribute(default=DEFAULT_OBSTIME)\nastropy\/coordinates\/attributes.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/attributes.py:# Dependencies\nastropy\/coordinates\/attributes.py:from ..utils.exceptions import AstropyDeprecationWarning\nastropy\/coordinates\/attributes.py:from ..utils import OrderedDescriptor, ShapedLikeNDArray\nastropy\/coordinates\/attributes.py:           'DifferentialAttribute']\nastropy\/coordinates\/attributes.py:class Attribute(OrderedDescriptor):\nastropy\/coordinates\/attributes.py:        Default value for the attribute if not provided\nastropy\/coordinates\/attributes.py:                    if isinstance(out, ShapedLikeNDArray):\nastropy\/coordinates\/attributes.py:        Default value for the attribute if not provided\nastropy\/coordinates\/attributes.py:        Default value for the attribute if not provided\nastropy\/coordinates\/attributes.py:        Default value for the attribute if not provided\nastropy\/coordinates\/attributes.py:        Default value for the attribute if not provided\nastropy\/coordinates\/attributes.py:        Default value for the attribute if not provided\nastropy\/coordinates\/attributes.py:class DifferentialAttribute(Attribute):\nastropy\/coordinates\/attributes.py:    any `~astropy.coordinates.BaseDifferential` subclass instance is valid.\nastropy\/coordinates\/attributes.py:        Default value for the attribute if not provided\nastropy\/coordinates\/attributes.py:            self.allowed_classes = BaseDifferential\nastropy\/coordinates\/attributes.py:            raise TypeError('Tried to set a DifferentialAttribute with '\nastropy\/coordinates\/attributes.py:                            'an unsupported Differential type {0}. Allowed '\nastropy\/coordinates\/attributes.py:                      AstropyDeprecationWarning)\nastropy\/coordinates\/attributes.py:                      AstropyDeprecationWarning)\nastropy\/coordinates\/attributes.py:                      \"QuantityAttribute.\", AstropyDeprecationWarning)\nastropy\/coordinates\/attributes.py:                      AstropyDeprecationWarning)\nastropy\/coordinates\/attributes.py:from .representation import CartesianRepresentation, BaseDifferential\nastropy\/modeling\/fitting.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/fitting.py:from .optimizers import (DEFAULT_MAXITER, DEFAULT_EPS, DEFAULT_ACC)\nastropy\/modeling\/fitting.py:# TODO: I have ongoing branch elsewhere that's refactoring this module so that\nastropy\/modeling\/fitting.py:            case x, y and\/or z have units. Default is None.\nastropy\/modeling\/fitting.py:                    # TODO: See above comment\nastropy\/modeling\/fitting.py:                # Don't modify in-place in case rhs was the original dependent\nastropy\/modeling\/fitting.py:        # TODO: Only Polynomial models currently have an _order attribute;\nastropy\/modeling\/fitting.py:            Data measurements (1D case) or input coordinates (2D case).\nastropy\/modeling\/fitting.py:            Data measurements (2D case).\nastropy\/modeling\/fitting.py:            Data used to perform the fitting after outlier removal.\nastropy\/modeling\/fitting.py:    covariance matrix of the parameters as a 2D numpy array.  The order of the\nastropy\/modeling\/fitting.py:                 maxiter=DEFAULT_MAXITER, acc=DEFAULT_ACC,\nastropy\/modeling\/fitting.py:                 epsilon=DEFAULT_EPS, estimate_jacobian=False):\nastropy\/modeling\/fitting.py:            case x, y and\/or z have units. Default is None.\nastropy\/modeling\/fitting.py:            self.objective_function, init_values, args=farg, Dfun=dfunc,\nastropy\/modeling\/fitting.py:            case x, y and\/or z have units. Default is None.\nastropy\/modeling\/fitting.py:            case x, y and\/or z have units. Default is None.\nastropy\/modeling\/fitting.py:            # For a 1-D model the y coordinate's model-set-axis is expected to\nastropy\/modeling\/fitting.py:            # That is, each model should be represented by a column.  TODO:\nastropy\/modeling\/fitting.py:# TODO: These utility functions are really particular to handling\nastropy\/modeling\/fitting.py:# TODO: Most of this code should be entirely rewritten; it should not be as\nastropy\/stats\/jackknife.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/jackknife.py:        Original sample (1-D array) from which the jackknife resamples will be\nastropy\/stats\/jackknife.py:        Resampling Plans\". Technical Report No. 63, Division of Biostatistics,\nastropy\/stats\/jackknife.py:        Stanford University, December, 1980.\nastropy\/stats\/jackknife.py:        Original sample (1-D array).\nastropy\/stats\/jackknife.py:        Must be a real-valued number in (0,1). Default value is 0.95.\nastropy\/stats\/lombscargle\/implementations\/chi2_impl.py:    .. [3] Scargle, J.D. 1982, ApJ 263:835-853\nastropy\/coordinates\/angle_utilities.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/angle_utilities.py:        # TODO: in principle, the parser should be invalidated if we change unit\nastropy\/coordinates\/angle_utilities.py:        # system (from CDS to FITS, say).  Might want to keep a link to the\nastropy\/coordinates\/angle_utilities.py:            'DEGREE',\nastropy\/coordinates\/angle_utilities.py:            'SECOND',\nastropy\/coordinates\/angle_utilities.py:        # NOTE THE ORDERING OF THESE RULES IS IMPORTANT!!\nastropy\/coordinates\/angle_utilities.py:        t_DEGREE = r'd(eg(ree(s)?)?)?|\u00b0'\nastropy\/coordinates\/angle_utilities.py:        t_SECOND = r's(ec(ond(s)?)?)?|\u2033|\\\"|\u02e2'\nastropy\/coordinates\/angle_utilities.py:                | sign UINT HOUR UINT MINUTE ufloat SECOND\nastropy\/coordinates\/angle_utilities.py:            dms : sign UINT DEGREE\nastropy\/coordinates\/angle_utilities.py:                | sign UINT DEGREE ufloat\nastropy\/coordinates\/angle_utilities.py:                | sign UINT DEGREE UINT MINUTE\nastropy\/coordinates\/angle_utilities.py:                | sign UINT DEGREE UFLOAT MINUTE\nastropy\/coordinates\/angle_utilities.py:                | sign UINT DEGREE UINT MINUTE ufloat\nastropy\/coordinates\/angle_utilities.py:                | sign UINT DEGREE UINT MINUTE ufloat SECOND\nastropy\/coordinates\/angle_utilities.py:                | generic DEGREE\nastropy\/coordinates\/angle_utilities.py:            arcsecond : generic SECOND\nastropy\/coordinates\/angle_utilities.py:    Convert an angle in Radians to Degrees.\nastropy\/stats\/lombscargle\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/lombscargle\/implementations\/scipy_impl.py:    .. [3] Scargle, J.D. 1982, ApJ 263:835-853\nastropy\/modeling\/optimizers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/optimizers.py:DEFAULT_MAXITER = 100\nastropy\/modeling\/optimizers.py:DEFAULT_EPS = np.sqrt(np.finfo(float).eps)\nastropy\/modeling\/optimizers.py:# Default requested accuracy\nastropy\/modeling\/optimizers.py:DEFAULT_ACC = 1e-07\nastropy\/modeling\/optimizers.py:DEFAULT_BOUNDS = (-10 ** 12, 10 ** 12)\nastropy\/modeling\/optimizers.py:        self._maxiter = DEFAULT_MAXITER\nastropy\/modeling\/optimizers.py:        self._eps = DEFAULT_EPS\nastropy\/modeling\/optimizers.py:        self._acc = DEFAULT_ACC\nastropy\/modeling\/optimizers.py:                i[0] = DEFAULT_BOUNDS[0]\nastropy\/modeling\/optimizers.py:                i[1] = DEFAULT_BOUNDS[1]\nastropy\/coordinates\/distances.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/distances.py:__all__ = ['Distance']\nastropy\/coordinates\/distances.py:class Distance(u.SpecificTypeQuantity):\nastropy\/coordinates\/distances.py:        cosmologies).  Default: ``False``.\nastropy\/coordinates\/distances.py:    >>> d1 = Distance(10, u.Mpc)\nastropy\/coordinates\/distances.py:    >>> d2 = Distance(40, unit=u.au)\nastropy\/coordinates\/distances.py:    >>> d3 = Distance(value=5, unit=u.kpc)\nastropy\/coordinates\/distances.py:    >>> d4 = Distance(z=0.23)\nastropy\/coordinates\/distances.py:    >>> d5 = Distance(z=0.23, cosmology=WMAP5)\nastropy\/coordinates\/distances.py:    >>> d6 = Distance(distmod=24.47)\nastropy\/coordinates\/distances.py:    >>> d7 = Distance(Distance(10 * u.Mpc))\nastropy\/coordinates\/distances.py:    >>> d8 = Distance(parallax=21.34*u.mas)\nastropy\/coordinates\/distances.py:                                 'or `distmod` in Distance constructor.')\nastropy\/coordinates\/distances.py:                                 'provided in Distance constructor')\nastropy\/coordinates\/distances.py:                         '`parallax` in Distance constructor.')\nastropy\/coordinates\/distances.py:                                 '`parallax` were given to Distance '\nastropy\/coordinates\/distances.py:            raise ValueError(\"Distance must be >= 0.  Use the argument \"\nastropy\/modeling\/powerlaws.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/powerlaws.py:from collections import OrderedDict\nastropy\/modeling\/powerlaws.py:from .core import Fittable1DModel\nastropy\/modeling\/powerlaws.py:__all__ = ['PowerLaw1D', 'BrokenPowerLaw1D', 'SmoothlyBrokenPowerLaw1D',\nastropy\/modeling\/powerlaws.py:           'ExponentialCutoffPowerLaw1D', 'LogParabola1D']\nastropy\/modeling\/powerlaws.py:class PowerLaw1D(Fittable1DModel):\nastropy\/modeling\/powerlaws.py:    BrokenPowerLaw1D, ExponentialCutoffPowerLaw1D, LogParabola1D\nastropy\/modeling\/powerlaws.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/powerlaws.py:class BrokenPowerLaw1D(Fittable1DModel):\nastropy\/modeling\/powerlaws.py:    PowerLaw1D, ExponentialCutoffPowerLaw1D, LogParabola1D\nastropy\/modeling\/powerlaws.py:        return OrderedDict([('x_break', inputs_unit['x']),\nastropy\/modeling\/powerlaws.py:class SmoothlyBrokenPowerLaw1D(Fittable1DModel):\nastropy\/modeling\/powerlaws.py:    BrokenPowerLaw1D\nastropy\/modeling\/powerlaws.py:    :math:`\\\\alpha_2` for ``alpha_2`` and :math:`\\\\Delta` for\nastropy\/modeling\/powerlaws.py:                        1 + \\\\left( \\\\frac{x}{x_b}\\\\right)^{1 \/ \\\\Delta}\nastropy\/modeling\/powerlaws.py:                   \\\\right\\\\}^{(\\\\alpha_1 - \\\\alpha_2) \\\\Delta}\nastropy\/modeling\/powerlaws.py:            \\\\sim \\\\Delta\nastropy\/modeling\/powerlaws.py:    hence the :math:`\\\\Delta` parameter sets the \"smoothness\" of the\nastropy\/modeling\/powerlaws.py:        f = models.SmoothlyBrokenPowerLaw1D(amplitude=1, x_break=20,\nastropy\/modeling\/powerlaws.py:        # SmoothlyBrokenPowerLaw1D.evaluate)\nastropy\/modeling\/powerlaws.py:        threshold = 30  # (see comments in SmoothlyBrokenPowerLaw1D.evaluate)\nastropy\/modeling\/powerlaws.py:        return OrderedDict([('x_break', inputs_unit['x']),\nastropy\/modeling\/powerlaws.py:class ExponentialCutoffPowerLaw1D(Fittable1DModel):\nastropy\/modeling\/powerlaws.py:    PowerLaw1D, BrokenPowerLaw1D, LogParabola1D\nastropy\/modeling\/powerlaws.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/powerlaws.py:class LogParabola1D(Fittable1DModel):\nastropy\/modeling\/powerlaws.py:    PowerLaw1D, BrokenPowerLaw1D, ExponentialCutoffPowerLaw1D\nastropy\/modeling\/powerlaws.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/stats\/circstats.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/circstats.py:        If ``True``, central circular moments are computed. Default value is\nastropy\/stats\/circstats.py:    .. [3] M. Chirstman., C. Miller. \"Testing a Sample of Directions for\nastropy\/stats\/circstats.py:    .. [4] D. Wilkie. \"Rayleigh Test for Randomness of Circular Data\". Applied\nastropy\/stats\/circstats.py:    .. [3] M. Chirstman., C. Miller. \"Testing a Sample of Directions for\nastropy\/time\/tests\/test_delta.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_delta.py:from .. import (Time, TimeDelta, OperandTypeError, ScaleValueError,\nastropy\/time\/tests\/test_delta.py:                TIME_SCALES, TIME_DELTA_SCALES)\nastropy\/time\/tests\/test_delta.py:class TestTimeDelta():\nastropy\/time\/tests\/test_delta.py:    \"\"\"Test TimeDelta class\"\"\"\nastropy\/time\/tests\/test_delta.py:        self.dt = TimeDelta(100.0, format='sec')\nastropy\/time\/tests\/test_delta.py:        self.dt_array = TimeDelta(np.arange(100, 1000, 100), format='sec')\nastropy\/time\/tests\/test_delta.py:        assert (repr(dt).startswith(\"<TimeDelta object: scale='tai' \"\nastropy\/time\/tests\/test_delta.py:        dt = TimeDelta(100.0, format='jd')\nastropy\/time\/tests\/test_delta.py:        dt2 = TimeDelta([100.0, 200.0], format='jd')\nastropy\/time\/tests\/test_delta.py:        dt = TimeDelta(100.0, format='jd')\nastropy\/time\/tests\/test_delta.py:        dt2 = TimeDelta([100.0, 200.0], format='jd')\nastropy\/time\/tests\/test_delta.py:        \"\"\"Test copying the values of a TimeDelta object by passing it into the\nastropy\/time\/tests\/test_delta.py:        dt2 = TimeDelta(dt, copy=False)\nastropy\/time\/tests\/test_delta.py:        dt2 = TimeDelta(dt, copy=True)\nastropy\/time\/tests\/test_delta.py:        dt2 = TimeDelta(dt, format='sec')\nastropy\/time\/tests\/test_delta.py:        dt = TimeDelta(1000., format='sec')\nastropy\/time\/tests\/test_delta.py:        dt = TimeDelta(86400.0, format='sec')\nastropy\/time\/tests\/test_delta.py:class TestTimeDeltaScales():\nastropy\/time\/tests\/test_delta.py:    \"\"\"Test scale conversion for Time Delta.\nastropy\/time\/tests\/test_delta.py:        for scale in list(TIME_DELTA_SCALES) + [None]:\nastropy\/time\/tests\/test_delta.py:            TimeDelta([0., 1., 10.], format='sec', scale=scale)\nastropy\/time\/tests\/test_delta.py:            TimeDelta([0., 1., 10.], format='sec', scale='utc')\nastropy\/time\/tests\/test_delta.py:        if scale1 in TIME_DELTA_SCALES:\nastropy\/time\/tests\/test_delta.py:        \"\"\"dT(X) +\/- dT2(Y) -- Add\/substract JDs for dT(X) and dT(Y).X\nastropy\/time\/tests\/test_delta.py:        This is always allowed and just adds JDs, i.e., the scale of\nastropy\/time\/tests\/test_delta.py:        the TimeDelta or time-like Quantity will be taken to be X.\nastropy\/time\/tests\/test_delta.py:        dt_none = TimeDelta([0., 1., -1., 1000.], format='sec')\nastropy\/time\/tests\/test_delta.py:        \"\"\"TimeDelta or Quantity holding 1 day always means 24*60*60 seconds\nastropy\/time\/tests\/test_delta.py:        dt_day = TimeDelta(1., format='jd')\nastropy\/time\/tests\/test_comparisons.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_comparisons.py:from .. import Time, TimeDelta, OperandTypeError\nastropy\/time\/tests\/test_comparisons.py:    \"\"\"Test Comparisons of Time and TimeDelta classes\"\"\"\nastropy\/time\/tests\/test_comparisons.py:        dt_gt_td0 = dt > TimeDelta(0., format='sec')\nastropy\/modeling\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/setup_package.py:MODELING_ROOT = os.path.relpath(os.path.dirname(__file__))\nastropy\/modeling\/setup_package.py:MODELING_SRC = join(MODELING_ROOT, 'src')\nastropy\/modeling\/setup_package.py:SRC_FILES = [join(MODELING_SRC, 'projections.c.templ'),\nastropy\/modeling\/setup_package.py:GEN_FILES = [join(MODELING_SRC, 'projections.c')]\nastropy\/modeling\/setup_package.py:    # TODO: Move this to setup_helpers\nastropy\/modeling\/setup_package.py:        # Determine modification times\nastropy\/modeling\/setup_package.py:    env = Environment(loader=FileSystemLoader(MODELING_SRC))\nastropy\/modeling\/setup_package.py:    with open(join(MODELING_SRC, 'projections.c'), 'w') as fd:\nastropy\/modeling\/setup_package.py:        join(MODELING_SRC, 'wcsconfig.h')\nastropy\/modeling\/setup_package.py:    cfg = setup_helpers.DistutilsExtensionArgs()\nastropy\/modeling\/setup_package.py:    cfg['include_dirs'].append(MODELING_SRC)\nastropy\/modeling\/setup_package.py:    cfg['sources'].extend(join(MODELING_SRC, x) for x in astropy_files)\nastropy\/stats\/biweight.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/biweight.py:        u_{i} = \\frac{(x_i - M)}{c * MAD}\nastropy\/stats\/biweight.py:    where :math:`c` is the tuning constant and :math:`MAD` is the\nastropy\/stats\/biweight.py:        u_{i} = \\frac{(x_i - M)}{c * MAD}\nastropy\/stats\/biweight.py:    where :math:`c` is the tuning constant and :math:`MAD` is the\nastropy\/stats\/biweight.py:        u_{i} = \\frac{(x_i - M)}{c * MAD}\nastropy\/stats\/biweight.py:    where :math:`c` is the tuning constant and :math:`MAD` is the\nastropy\/stats\/biweight.py:        u_{i} = \\frac{(x_i - M_x)}{c * MAD_x}\nastropy\/stats\/biweight.py:        v_{i} = \\frac{(y_i - M_y)}{c * MAD_y}\nastropy\/stats\/biweight.py:    where :math:`c` is the biweight tuning constant and :math:`MAD_x`\nastropy\/stats\/biweight.py:    and :math:`MAD_y` are the `median absolute deviation\nastropy\/stats\/biweight.py:    data : 2D or 1D array-like\nastropy\/stats\/biweight.py:        Input data either as a 2D or 1D array.  For a 2D array, it\nastropy\/stats\/biweight.py:        should have a shape (N_variables, N_observations).  A 1D array\nastropy\/stats\/biweight.py:    M : float or 1D array-like, optional\nastropy\/stats\/biweight.py:        array.  If ``M`` is an array, then its must be a 1D array\nastropy\/stats\/biweight.py:        A 2D array representing the biweight midcovariances between each\nastropy\/stats\/biweight.py:    # ensure data is 2D\nastropy\/stats\/biweight.py:        raise ValueError('The input array must be 2D or 1D.')\nastropy\/stats\/biweight.py:        raise ValueError('M must be a scalar or 1D array.')\nastropy\/stats\/biweight.py:    x, y : 1D array-like\nastropy\/stats\/biweight.py:        Input arrays for the two variables.  ``x`` and ``y`` must be 1D\nastropy\/stats\/biweight.py:        raise ValueError('x must be a 1D array.')\nastropy\/stats\/biweight.py:        raise ValueError('y must be a 1D array.')\nastropy\/modeling\/statistic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/statistic.py:        Independent variable \"y\" to evaluate the model on, for 2D models.\nastropy\/coordinates\/tests\/test_sites.py:    assert exc.value.args[0] == \"Site 'kec' not in database. Use the 'names' attribute to see available sites. Did you mean one of: 'keck'?'\"\nastropy\/coordinates\/tests\/test_pickle.py:          coord.Distance,\nastropy\/coordinates\/tests\/test_pickle.py:          coord.DynamicMatrixTransform,\nastropy\/stats\/lombscargle\/core.py:        Conference on Intelligent Data Understanding (2012)\nastropy\/stats\/lombscargle\/core.py:        \"\"\"Determine a suitable frequency grid for data.\nastropy\/stats\/lombscargle\/core.py:        - \"davies\" : the Davies upper bound from Baluev (2008) [1]_.\nastropy\/stats\/lombscargle\/core.py:        - \"davies\" : the Davies upper bound from Baluev (2008) [1]_.\nastropy\/coordinates\/transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/transformations.py:from collections import defaultdict, OrderedDict\nastropy\/coordinates\/transformations.py:           'StaticMatrixTransform', 'DynamicMatrixTransform',\nastropy\/coordinates\/transformations.py:           'FunctionTransformWithFiniteDifference', 'CompositeTransform']\nastropy\/coordinates\/transformations.py:        # use Dijkstra's algorithm to find shortest path in all other cases\nastropy\/coordinates\/transformations.py:        # (used as edge weights in Dijkstra's algorithm)\nastropy\/coordinates\/transformations.py:        Converts this transform graph to the graphviz_ DOT format.\nastropy\/coordinates\/transformations.py:            graphviz_ for details) or 'plain' to just save the DOT graph\nastropy\/coordinates\/transformations.py:            blue, ``DynamicMatrixTransform``: green.\nastropy\/coordinates\/transformations.py:            A string with the DOT format graph.\nastropy\/coordinates\/transformations.py:# <-------------------Define the builtin transform classes-------------------->\nastropy\/coordinates\/transformations.py:        Does the actual coordinate transformation from the ``fromsys`` class to\nastropy\/coordinates\/transformations.py:class FunctionTransformWithFiniteDifference(FunctionTransform):\nastropy\/coordinates\/transformations.py:        :math:`\\frac{x(t + \\Delta t \/ 2) - x(t + \\Delta t \/ 2)}{\\Delta t}`, or\nastropy\/coordinates\/transformations.py:        if False, :math:`\\frac{x(t + \\Delta t) - x(t)}{\\Delta t}`.  The latter\nastropy\/coordinates\/transformations.py:                                     CartesianDifferential)\nastropy\/coordinates\/transformations.py:            newdiff = CartesianDifferential(diffxyz)\nastropy\/coordinates\/transformations.py:                                     CartesianDifferential,\nastropy\/coordinates\/transformations.py:                                     SphericalDifferential,\nastropy\/coordinates\/transformations.py:                                     SphericalCosLatDifferential,\nastropy\/coordinates\/transformations.py:                                     RadialDifferential)\nastropy\/coordinates\/transformations.py:        _unit_diffs = (SphericalDifferential._unit_differential,\nastropy\/coordinates\/transformations.py:                       SphericalCosLatDifferential._unit_differential)\nastropy\/coordinates\/transformations.py:                        isinstance(data.differentials['s'], RadialDifferential))\nastropy\/coordinates\/transformations.py:        # If it's a RadialDifferential, we flat-out ignore the differentials\nastropy\/coordinates\/transformations.py:        diffs = dict([(k, diff.represent_as(CartesianDifferential, data))\nastropy\/coordinates\/transformations.py:        # TODO: if we decide to allow arithmetic between representations that\nastropy\/coordinates\/transformations.py:        # having a RadialDifferential\nastropy\/coordinates\/transformations.py:        (optionally) an attached velocity ``CartesianDifferential`` to represent\nastropy\/coordinates\/transformations.py:    This is distinct from DynamicMatrixTransform in that this kind of matrix is\nastropy\/coordinates\/transformations.py:class DynamicMatrixTransform(BaseAffineTransform):\nastropy\/coordinates\/transformations.py:            # TODO: caching this information when creating the transform may\nastropy\/coordinates\/transformations.py:trans_to_color = OrderedDict()\nastropy\/coordinates\/transformations.py:trans_to_color[FunctionTransformWithFiniteDifference] = '#d95f02'  # red-ish\nastropy\/coordinates\/transformations.py:trans_to_color[DynamicMatrixTransform] = '#1b9e77'  # green-ish\nastropy\/modeling\/tabular.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tabular.py:For convenience `Tabular1D` and `Tabular2D` are provided.\nastropy\/modeling\/tabular.py:>>> t2 = Tabular2D(points, lookup_table=table, bounds_error=False,\nastropy\/modeling\/tabular.py:__all__ = ['tabular_model', 'Tabular1D', 'Tabular2D']\nastropy\/modeling\/tabular.py:        2-dimensional data. Default is \"linear\".\nastropy\/modeling\/tabular.py:        >>> from astropy.modeling.models import Tabular1D, Tabular2D\nastropy\/modeling\/tabular.py:        >>> t1 = Tabular1D(points=[1, 2, 3], lookup_table=[10, 20, 30])\nastropy\/modeling\/tabular.py:        >>> t2 = Tabular2D(points=[[1, 2, 3], [2, 3, 4]],\nastropy\/modeling\/tabular.py:        Dimensions of the lookup table.\nastropy\/modeling\/tabular.py:    >>> tab = tabular_model(2, name='Tabular2D')\nastropy\/modeling\/tabular.py:    <class 'abc.Tabular2D'>\nastropy\/modeling\/tabular.py:    Name: Tabular2D\nastropy\/modeling\/tabular.py:Tabular1D = tabular_model(1, name='Tabular1D')\nastropy\/modeling\/tabular.py:Tabular2D = tabular_model(2, name='Tabular2D')\nastropy\/modeling\/tabular.py:        2-dimensional data. Default is \"linear\".\nastropy\/modeling\/tabular.py:Tabular1D.__doc__ = \"\"\"\nastropy\/modeling\/tabular.py:    Tabular model in 1D.\nastropy\/modeling\/tabular.py:Tabular2D.__doc__ = \"\"\"\nastropy\/modeling\/tabular.py:    Tabular model in 2D.\nastropy\/modeling\/tests\/test_quantities_model.py:from ..functional_models import Gaussian1D\nastropy\/modeling\/tests\/test_quantities_model.py:    g = Gaussian1D(mean=3 * u.m, stddev=3 * u.cm, amplitude=3 * u.Jy)\nastropy\/modeling\/tests\/test_quantities_model.py:    g = Gaussian1D(amplitude=[1 * u.J, 2. * u.J],\nastropy\/coordinates\/earth_orientation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/earth_orientation.py:    Eccentricity of the Earth's orbit at the requested Julian Date.\nastropy\/coordinates\/earth_orientation.py:    requested Julian Date.\nastropy\/coordinates\/earth_orientation.py:    Computes the obliquity of the Earth at the requested Julian Date.\nastropy\/coordinates\/earth_orientation.py:    * Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351. 2000\nastropy\/coordinates\/earth_orientation.py:# TODO: replace this with SOFA equivalent\nastropy\/coordinates\/earth_orientation.py:                  ('nD', int),\nastropy\/coordinates\/earth_orientation.py:                  ('nD', int),\nastropy\/coordinates\/earth_orientation.py:#l lprime F D Omega longitude_sin longitude_sin*t longitude_cos obliquity_cos obliquity_cos*t,obliquity_sin\nastropy\/coordinates\/earth_orientation.py:# TODO: replace w\/SOFA equivalent\nastropy\/coordinates\/earth_orientation.py:        epoch at which to compute the nutation components as a JD\nastropy\/coordinates\/earth_orientation.py:    # Fundamental (Delaunay) arguments from Simon et al. (1994) via SOFA\nastropy\/coordinates\/earth_orientation.py:    D = ((1072260.70369 + 1602961601.2090 * t) % 1296000) \/ _asecperrad\nastropy\/coordinates\/earth_orientation.py:    arg = dat.nl * el + dat.nlp * elp + dat.nF * F + dat.nD * D + dat.nOm * Om\nastropy\/coordinates\/earth_orientation.py:    # TODO: implement higher precision 2006\/2000A model if requested\/needed\nastropy\/time\/tests\/test_guess.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_funcs.py:        D, f = funcs.kuiper_two(np.random.random(500) * 0.5,\nastropy\/stats\/tests\/test_funcs.py:            D, f = funcs.kuiper_two(np.random.random(N), np.random.random(M))\nastropy\/modeling\/tests\/test_quantities_parameters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_quantities_parameters.py:from ..core import Model, Fittable1DModel, InputParameterError\nastropy\/modeling\/tests\/test_quantities_parameters.py:from ..parameters import Parameter, ParameterDefinitionError\nastropy\/modeling\/tests\/test_quantities_parameters.py:from ..models import (Gaussian1D, Pix2Sky_TAN, RotateNative2Celestial,\nastropy\/modeling\/tests\/test_quantities_parameters.py:                      Rotation2D)\nastropy\/modeling\/tests\/test_quantities_parameters.py:class BaseTestModel(Fittable1DModel):\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1 * u.J, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1 * u.J, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1 * u.Jy, 3, 0.1)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1, 3, 0.1)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1 * u.Jy, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    # TODO: determine whether this is the desired behavior?\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1 * u.Jy, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    with pytest.raises(ParameterDefinitionError) as exc:\nastropy\/modeling\/tests\/test_quantities_parameters.py:        class TestC(Fittable1DModel):\nastropy\/modeling\/tests\/test_quantities_parameters.py:    # TODO: decide whether the default property should return a value or\nastropy\/modeling\/tests\/test_quantities_parameters.py:    # TODO: but how do we know what those units are if we don't return a\nastropy\/modeling\/tests\/test_quantities_parameters.py:    # TODO: this illustrates why the default doesn't make sense anymore\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1 * u.J, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D(1 * u.J, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    g = Gaussian1D([1, 2] * u.J, [1, 2] * u.m, [0.1, 0.2] * u.m)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    rot = Rotation2D(23)\nastropy\/stats\/tests\/test_histogram.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_representation_methods.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_representation_methods.py:                SphericalDifferential)\nastropy\/coordinates\/tests\/test_representation_methods.py:        self.diff = SphericalDifferential(\nastropy\/coordinates\/tests\/test_representation_methods.py:        # Doing it on the CartesianRepresentation just for variety's sake.\nastropy\/coordinates\/tests\/test_representation_methods.py:        # Do this on a copy, to keep self.s0 unchanged.\nastropy\/coordinates\/tests\/test_iau_fullstack.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_iau_fullstack.py:    assert np.all(addecs < tol), 'largest Dec change is {0} mas, > {1}'.format(np.max(addecs.arcsec*1000), tol)\nastropy\/coordinates\/tests\/accuracy\/test_ecliptic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/accuracy\/test_ecliptic.py:    # this is 1D so we allow it to be somewhat smaller\nastropy\/coordinates\/tests\/test_angles.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_angles.py:    def string(self, unit=DEGREE, decimal=False, sep=\" \", precision=5,\nastropy\/coordinates\/tests\/test_angles.py:    res = 'Angle as DMS: 3d36m29.7888s'\nastropy\/coordinates\/tests\/test_angles.py:    assert \"Angle as DMS: {0}\".format(angle.to_string(unit=u.degree)) == res\nastropy\/coordinates\/tests\/test_angles.py:    res = 'Angle as DMS: 3:36:29.7888'\nastropy\/coordinates\/tests\/test_angles.py:    assert \"Angle as DMS: {0}\".format(angle.to_string(unit=u.degree, sep=\":\")) == res\nastropy\/coordinates\/tests\/test_angles.py:    res = 'Angle as DMS: 3:36:29.79'\nastropy\/coordinates\/tests\/test_angles.py:    assert \"Angle as DMS: {0}\".format(angle.to_string(unit=u.degree, sep=\":\",\nastropy\/coordinates\/tests\/test_angles.py:    res = 'Angle as DMS: 3d36m29.7888s'\nastropy\/coordinates\/tests\/test_angles.py:    assert \"Angle as DMS: {0}\".format(angle.to_string(unit=u.degree,\nastropy\/coordinates\/tests\/test_angles.py:    res = 'Angle as DMS: 3-36|29.7888'\nastropy\/coordinates\/tests\/test_angles.py:    assert \"Angle as DMS: {0}\".format(angle.to_string(unit=u.degree, sep=[\"-\", \"|\"],\nastropy\/coordinates\/tests\/test_angles.py:    res = 'Angle as DMS: 3-36-29.7888'\nastropy\/coordinates\/tests\/test_angles.py:    assert \"Angle as DMS: {0}\".format(angle.to_string(unit=u.degree, sep=\"-\",\nastropy\/coordinates\/tests\/test_angles.py:    res = 'Angle as DMS: 03d36m29.7888s'\nastropy\/coordinates\/tests\/test_angles.py:    assert \"Angle as DMS: {0}\".format(angle.to_string(unit=u.degree, precision=4,\nastropy\/coordinates\/tests\/test_angles.py:    # TODO: adjust in 0.3 for whatever behavior is decided on\nastropy\/coordinates\/tests\/test_angles.py:    # TODO: again, fix based on >24 behavior\nastropy\/coordinates\/tests\/test_angles.py:    # TODO: this was the \"smart\" initializer behavior - adjust in 0.3 appropriately\nastropy\/coordinates\/tests\/test_angles.py:    # Test for DMS parser\nastropy\/coordinates\/tests\/test_angles.py:    # Test for DM parser\nastropy\/coordinates\/tests\/test_angles.py:    # Test for DMS parser\nastropy\/coordinates\/tests\/test_angles.py:    # Test for DMS parser\nastropy\/coordinates\/tests\/test_angles.py:    # Test for DMS parser\nastropy\/coordinates\/tests\/test_angles.py:    # Test for DMS parser\nastropy\/coordinates\/tests\/test_angles.py:    # Default wrapping at 360d with an array input\nastropy\/modeling\/tests\/test_parameters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_parameters.py:    # TODO: shouldn't setting a max < min give an error?\nastropy\/modeling\/tests\/test_parameters.py:        information to create a 1D Chebyshev model and perform the same fit.\nastropy\/modeling\/tests\/test_parameters.py:        self.model = models.Chebyshev1D(order - 1)\nastropy\/modeling\/tests\/test_parameters.py:        self.gmodel = models.Gaussian1D(2, mean=3, stddev=4)\nastropy\/modeling\/tests\/test_parameters.py:    def testPolynomial1D(self):\nastropy\/modeling\/tests\/test_parameters.py:        p1 = models.Polynomial1D(3, **d)\nastropy\/modeling\/tests\/test_parameters.py:        p1 = models.Polynomial1D(3, n_models=3)\nastropy\/modeling\/tests\/test_parameters.py:        p1 = models.Polynomial1D(3, n_models=3)\nastropy\/modeling\/tests\/test_parameters.py:        p2 = models.Polynomial2D(degree=3)\nastropy\/modeling\/tests\/test_parameters.py:        p2 = models.Polynomial2D(2, **kw)\nastropy\/modeling\/tests\/test_parameters.py:        self.gmodel = models.Gaussian1D([12, 10], [3.5, 5.2], stddev=[.4, .7],\nastropy\/modeling\/tests\/test_projections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_projections.py:PIX_COORDINATES = [-10, 30]\nastropy\/modeling\/tests\/test_projections.py:    wcslibout = w.wcs.p2s([PIX_COORDINATES], 1)\nastropy\/modeling\/tests\/test_projections.py:    wcslibout = w.wcs.p2s([PIX_COORDINATES], 1)\nastropy\/modeling\/tests\/test_projections.py:    phi, theta = tanprj(*PIX_COORDINATES)\nastropy\/modeling\/tests\/test_projections.py:    wcslibout = w.wcs.p2s([PIX_COORDINATES], 1)\nastropy\/modeling\/tests\/test_projections.py:    wcslibout = w.wcs.p2s([PIX_COORDINATES], 1)\nastropy\/modeling\/tests\/test_projections.py:    phi, theta = tanprj(*PIX_COORDINATES * u.deg)\nastropy\/modeling\/tests\/test_projections.py:    phi, theta = tanprj(*(PIX_COORDINATES * u.deg).to(u.rad))\nastropy\/modeling\/tests\/test_projections.py:    phi, theta = tanprj(*(PIX_COORDINATES * u.deg).to(u.arcmin))\nastropy\/modeling\/tests\/test_projections.py:        ID = 'AZP'\nastropy\/modeling\/tests\/test_projections.py:                               \"1904-66_{0}.hdr\".format(ID))\nastropy\/modeling\/tests\/test_projections.py:        ID = \"CYP\"\nastropy\/modeling\/tests\/test_projections.py:                               \"1904-66_{0}.hdr\".format(ID))\nastropy\/modeling\/tests\/test_projections.py:def test_AffineTransformation2D():\nastropy\/modeling\/tests\/test_projections.py:    model = projections.AffineTransformation2D(\nastropy\/modeling\/tests\/test_projections.py:def test_AffineTransformation2D_inverse():\nastropy\/modeling\/tests\/test_projections.py:    model1 = projections.AffineTransformation2D(\nastropy\/modeling\/tests\/test_projections.py:    model2 = projections.AffineTransformation2D(\nastropy\/modeling\/tests\/test_projections.py:    qaff = projections.AffineTransformation2D(matrix=[[1, 2], [2, 1]] * u.deg)\nastropy\/modeling\/tests\/test_projections.py:    qaff = projections.AffineTransformation2D(matrix=[[1, 2], [2, 1]] * u.deg,\nastropy\/modeling\/tests\/test_projections.py:    aff = projections.AffineTransformation2D(matrix=[[1, 2], [2, 1]], translation=[1, 2])\nastropy\/modeling\/tests\/test_projections.py:    # test the case of WCS PC and CDELT transformations\nastropy\/modeling\/tests\/test_projections.py:    qaff = projections.AffineTransformation2D(matrix=matrix * u.deg,\nastropy\/modeling\/tests\/test_projections.py:    inv_qaff = projections.AffineTransformation2D(matrix=inv_matrix * u.pix,\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:TODO: check if these tests pass on 32-bit machines and implement\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:    \"\"\"Check that Astropy gives consistent results with an IDL hor2eq example.\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      IDL> hor2eq, ten(37,54,41), ten(264,55,06), 2451545.0d, ra, dec, \/verb, obs='kpno', pres=781.0, temp=273.0\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Julian Date =  2451545.000000\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Ra, Dec:  07 36 55.6  +15 25 02   (Apparent Coords)\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Ra, Dec:  07 36 55.2  +15 25 08   (J2000.0000)\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Ra, Dec:  07 36 55.2  +15 25 08   (J2000)\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      IDL> print, ra, dec\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      IDL> hor2eq, ten(37,54,41), ten(264,55,06), 2451545.0d, ra, dec, \/verb, obs='kpno', pres=0.0, temp=273.0\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Julian Date =  2451545.000000\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Ra, Dec:  07 36 59.3  +15 25 31   (Apparent Coords)\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Ra, Dec:  07 36 58.9  +15 25 37   (J2000.0000)\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      Ra, Dec:  07 36 58.9  +15 25 37   (J2000)\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:      IDL> print, ra, dec\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:    # TODO: why is this difference so large?\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:                             height=2093.093 * u.m)  # TODO: height correct?\nastropy\/coordinates\/tests\/accuracy\/test_altaz_icrs.py:    \"\"\"TODO: Current output is completely incorrect ... xfailing this test for now.\nastropy\/coordinates\/tests\/test_funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_sky_coord.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_sky_coord.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/coordinates\/tests\/test_sky_coord.py:DEC = 2.0 * u.deg\nastropy\/coordinates\/tests\/test_sky_coord.py:C_ICRS = ICRS(RA, DEC)\nastropy\/coordinates\/tests\/test_sky_coord.py:    OLDER_SCIPY = False\nastropy\/coordinates\/tests\/test_sky_coord.py:    OLDER_SCIPY = True\nastropy\/coordinates\/tests\/test_sky_coord.py:                  SkyCoord(RA, DEC, 'fk4', equinox='J1980')):\nastropy\/coordinates\/tests\/test_sky_coord.py:        s_icrs = SkyCoord(RA, DEC, frame='icrs')\nastropy\/coordinates\/tests\/test_sky_coord.py:    sc = SkyCoord(frame0, RA, DEC, **attrs0)\nastropy\/coordinates\/tests\/test_sky_coord.py:FRAME_DEPRECATION_WARNING = (\"Passing a frame as a positional argument is now \"\nastropy\/coordinates\/tests\/test_sky_coord.py:    Different ways of providing the frame.\nastropy\/coordinates\/tests\/test_sky_coord.py:    sc = SkyCoord(RA, DEC, frame='icrs')\nastropy\/coordinates\/tests\/test_sky_coord.py:    sc = SkyCoord(RA, DEC, frame=ICRS)\nastropy\/coordinates\/tests\/test_sky_coord.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/coordinates\/tests\/test_sky_coord.py:        sc = SkyCoord(RA, DEC, 'icrs')\nastropy\/coordinates\/tests\/test_sky_coord.py:    assert str(w[0].message) == FRAME_DEPRECATION_WARNING\nastropy\/coordinates\/tests\/test_sky_coord.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/coordinates\/tests\/test_sky_coord.py:        sc = SkyCoord(RA, DEC, ICRS)\nastropy\/coordinates\/tests\/test_sky_coord.py:    assert str(w[0].message) == FRAME_DEPRECATION_WARNING\nastropy\/coordinates\/tests\/test_sky_coord.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/coordinates\/tests\/test_sky_coord.py:        sc = SkyCoord('icrs', RA, DEC)\nastropy\/coordinates\/tests\/test_sky_coord.py:    assert str(w[0].message) == FRAME_DEPRECATION_WARNING\nastropy\/coordinates\/tests\/test_sky_coord.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/coordinates\/tests\/test_sky_coord.py:        sc = SkyCoord(ICRS, RA, DEC)\nastropy\/coordinates\/tests\/test_sky_coord.py:    assert str(w[0].message) == FRAME_DEPRECATION_WARNING\nastropy\/coordinates\/tests\/test_sky_coord.py:    sc2 = SkyCoord(sc.frame)  # Doesn't have equinox there so we get FK4 defaults\nastropy\/coordinates\/tests\/test_sky_coord.py:    Driven by #3106.\nastropy\/coordinates\/tests\/test_sky_coord.py:@pytest.mark.skipif(str('OLDER_SCIPY'))\nastropy\/coordinates\/tests\/test_sky_coord.py:        tab.add_column(Column(data=np.random.rand(1000), unit='deg', name='DEC[J2000]'))\nastropy\/coordinates\/tests\/test_sky_coord.py:    npt.assert_array_equal(sc.dec.deg, tab['DEC[J2000]'])\nastropy\/coordinates\/tests\/test_sky_coord.py:    tab['DEC[J2000]'].unit = None\nastropy\/coordinates\/tests\/test_sky_coord.py:    npt.assert_array_equal(sc.dec.deg, tab['DEC[J2000]'])\nastropy\/coordinates\/tests\/test_sky_coord.py:    npt.assert_array_equal(sc3.dec.deg, tab['DEC[J2000]'])\nastropy\/coordinates\/tests\/accuracy\/test_fk4_no_e_fk4.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_angular_separation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_angular_separation.py:from .. import Angle, Distance\nastropy\/coordinates\/tests\/test_angular_separation.py:    Test 3D separation functionality\nastropy\/coordinates\/tests\/test_angular_separation.py:    assert isinstance(sep3d, Distance)\nastropy\/stats\/tests\/test_biweight.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_biweight.py:    \"\"\"Test a 2D array with the axis keyword.\"\"\"\nastropy\/stats\/tests\/test_biweight.py:    \"\"\"Test a 3D array with the axis keyword.\"\"\"\nastropy\/stats\/tests\/test_biweight.py:    \"\"\"Test a 2D array with the axis keyword.\"\"\"\nastropy\/stats\/tests\/test_biweight.py:    \"\"\"Test a 3D array with the axis keyword.\"\"\"\nastropy\/stats\/tests\/test_biweight.py:    Test that biweight_midcovariance raises error with a 3D array.\nastropy\/stats\/tests\/test_biweight.py:    assert 'The input array must be 2D or 1D.' in str(e.value)\nastropy\/stats\/tests\/test_biweight.py:    or 1D array.\nastropy\/stats\/tests\/test_biweight.py:    assert 'M must be a scalar or 1D array.' in str(e.value)\nastropy\/stats\/tests\/test_biweight.py:        assert 'x must be a 1D array.' in str(e.value)\nastropy\/stats\/tests\/test_biweight.py:        assert 'y must be a 1D array.' in str(e.value)\nastropy\/coordinates\/tests\/test_shape_manipulation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_regression.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_regression.py:from .test_matching import HAS_SCIPY, OLDER_SCIPY\nastropy\/coordinates\/tests\/test_regression.py:    # de = SkyCoord.from_name('Deneb')\nastropy\/coordinates\/tests\/test_regression.py:@pytest.mark.skipif(OLDER_SCIPY, reason='Scipy too old')\nastropy\/coordinates\/tests\/test_regression.py:    Dc = -0.065838*u.arcsec\nastropy\/coordinates\/tests\/test_regression.py:    Dd = +0.335299*u.arcsec\nastropy\/coordinates\/tests\/test_regression.py:    # Dc * tan(obliquity), as given on p.170\nastropy\/coordinates\/tests\/test_regression.py:    Dctano = -0.028553*u.arcsec\nastropy\/coordinates\/tests\/test_regression.py:    fk4noe_dec = (fk4.dec - (Dd*np.cos(fk4.ra) -\nastropy\/coordinates\/tests\/test_regression.py:                             Dc*np.sin(fk4.ra))*np.sin(fk4.dec) -\nastropy\/coordinates\/tests\/test_regression.py:                  Dctano*np.cos(fk4.dec))\nastropy\/coordinates\/tests\/test_regression.py:    fk4noe_ra = fk4.ra - (Dc*np.cos(fk4.ra) +\nastropy\/coordinates\/tests\/test_regression.py:                          Dd*np.sin(fk4.ra)) \/ np.cos(fk4.dec)\nastropy\/coordinates\/tests\/test_regression.py:    # ensure we can represent all Representations and transform to ND frames\nastropy\/coordinates\/tests\/test_regression.py:@pytest.mark.skipif(OLDER_SCIPY, reason='Scipy too old')\nastropy\/coordinates\/tests\/test_regression.py:@pytest.mark.skipif(OLDER_SCIPY, reason='Scipy too old')\nastropy\/coordinates\/tests\/test_regression.py:    from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/coordinates\/tests\/test_regression.py:            if issubclass(w.category, AstropyDeprecationWarning):\nastropy\/coordinates\/tests\/test_regression.py:            assert False, \"Deprecation warning not raised\"\nastropy\/coordinates\/tests\/test_regression.py:            if issubclass(w.category, AstropyDeprecationWarning):\nastropy\/coordinates\/tests\/test_regression.py:            assert False, \"Deprecation warning not raised\"\nastropy\/coordinates\/tests\/test_regression.py:            if issubclass(w.category, AstropyDeprecationWarning):\nastropy\/coordinates\/tests\/test_regression.py:            assert False, \"Deprecation warning not raised\"\nastropy\/modeling\/tests\/test_functional_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_functional_models.py:from ...utils.exceptions import AstropyDeprecationWarning\nastropy\/modeling\/tests\/test_functional_models.py:def test_Trapezoid1D():\nastropy\/modeling\/tests\/test_functional_models.py:    model = models.Trapezoid1D(amplitude=4.2, x_0=2.0, width=1.0, slope=3)\nastropy\/modeling\/tests\/test_functional_models.py:def test_Gaussian2D():\nastropy\/modeling\/tests\/test_functional_models.py:    Test rotated elliptical Gaussian2D model.\nastropy\/modeling\/tests\/test_functional_models.py:    model = models.Gaussian2D(4.2, 1.7, 3.1, x_stddev=5.1, y_stddev=3.3,\nastropy\/modeling\/tests\/test_functional_models.py:def test_Gaussian2DCovariance():\nastropy\/modeling\/tests\/test_functional_models.py:    Test rotated elliptical Gaussian2D model when cov_matrix is input.\nastropy\/modeling\/tests\/test_functional_models.py:    model = models.Gaussian2D(17., 2.0, 2.5, cov_matrix=cov_matrix)\nastropy\/modeling\/tests\/test_functional_models.py:def test_Gaussian2DRotation():\nastropy\/modeling\/tests\/test_functional_models.py:    rotation = models.Rotation2D(angle=theta.degree)\nastropy\/modeling\/tests\/test_functional_models.py:    g1 = models.Gaussian2D(theta=0, **pars)\nastropy\/modeling\/tests\/test_functional_models.py:    g2 = models.Gaussian2D(theta=theta.radian, **pars)\nastropy\/modeling\/tests\/test_functional_models.py:def test_Gaussian2D_invalid_inputs():\nastropy\/modeling\/tests\/test_functional_models.py:    models.Gaussian2D()\nastropy\/modeling\/tests\/test_functional_models.py:    models.Gaussian2D(x_stddev=x_stddev, y_stddev=y_stddev, theta=theta)\nastropy\/modeling\/tests\/test_functional_models.py:    models.Gaussian2D(x_stddev=None, y_stddev=y_stddev, theta=theta)\nastropy\/modeling\/tests\/test_functional_models.py:    models.Gaussian2D(x_stddev=x_stddev, y_stddev=None, theta=theta)\nastropy\/modeling\/tests\/test_functional_models.py:    models.Gaussian2D(x_stddev=x_stddev, y_stddev=y_stddev, theta=None)\nastropy\/modeling\/tests\/test_functional_models.py:    models.Gaussian2D(cov_matrix=cov_matrix)\nastropy\/modeling\/tests\/test_functional_models.py:        models.Gaussian2D(x_stddev=0, cov_matrix=cov_matrix)\nastropy\/modeling\/tests\/test_functional_models.py:        models.Gaussian2D(y_stddev=0, cov_matrix=cov_matrix)\nastropy\/modeling\/tests\/test_functional_models.py:        models.Gaussian2D(theta=0, cov_matrix=cov_matrix)\nastropy\/modeling\/tests\/test_functional_models.py:    m1 = models.Moffat1D(**kwargs)\nastropy\/modeling\/tests\/test_functional_models.py:    m2 = models.Moffat2D(**kwargs)\nastropy\/modeling\/tests\/test_functional_models.py:def test_Ellipse2D():\nastropy\/modeling\/tests\/test_functional_models.py:    \"\"\"Test Ellipse2D model.\"\"\"\nastropy\/modeling\/tests\/test_functional_models.py:    em = models.Ellipse2D(amplitude, x0, y0, 7, 3, theta.radian)\nastropy\/modeling\/tests\/test_functional_models.py:    rotation = models.Rotation2D(angle=theta.degree)\nastropy\/modeling\/tests\/test_functional_models.py:    point1 = [2, 0]      # Rotation2D center is (0, 0)\nastropy\/modeling\/tests\/test_functional_models.py:    e1 = models.Ellipse2D(amplitude, x0, y0, 7, 3, theta=0.)\nastropy\/modeling\/tests\/test_functional_models.py:    e2 = models.Ellipse2D(amplitude, x0, y0, 7, 3, theta=theta.radian)\nastropy\/modeling\/tests\/test_functional_models.py:def test_Ellipse2D_circular():\nastropy\/modeling\/tests\/test_functional_models.py:    \"\"\"Test that circular Ellipse2D agrees with Disk2D [3736].\"\"\"\nastropy\/modeling\/tests\/test_functional_models.py:    ellipse = models.Ellipse2D(amplitude, radius, radius, radius, radius,\nastropy\/modeling\/tests\/test_functional_models.py:    disk = models.Disk2D(amplitude, radius, radius, radius)(x, y)\nastropy\/modeling\/tests\/test_functional_models.py:def test_Ring2D_rout():\nastropy\/modeling\/tests\/test_functional_models.py:    m = models.Ring2D(amplitude=1, x_0=1, y_0=1, r_in=2, r_out=5)\nastropy\/modeling\/tests\/test_functional_models.py:def test_Voigt1D():\nastropy\/modeling\/tests\/test_functional_models.py:    voi = models.Voigt1D(amplitude_L=-0.5, x_0=1.0, fwhm_L=5.0, fwhm_G=5.0)\nastropy\/modeling\/tests\/test_functional_models.py:    voi_init = models.Voigt1D(amplitude_L=-1.0, x_0=1.0, fwhm_L=5.0, fwhm_G=5.0)\nastropy\/modeling\/tests\/test_functional_models.py:    models_2d = [models.AiryDisk2D, models.Sersic2D]\nastropy\/modeling\/tests\/test_functional_models.py:    models_1d = [models.Sersic1D]\nastropy\/modeling\/tests\/test_functional_models.py:        class CompoundModel2D(models.Const2D + model_2d):\nastropy\/modeling\/tests\/test_functional_models.py:        f = CompoundModel2D()(x, y)\nastropy\/modeling\/tests\/test_functional_models.py:        class CompoundModel1D(models.Const1D + model_1d):\nastropy\/modeling\/tests\/test_functional_models.py:        f = CompoundModel1D()(x)\nastropy\/coordinates\/tests\/test_api_ape5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_api_ape5.py:    from ... coordinates import Angle, Longitude, Latitude, Distance\nastropy\/coordinates\/tests\/test_api_ape5.py:    # Distance is optional.\nastropy\/coordinates\/tests\/test_api_ape5.py:    SphericalRepresentation(Longitude(8, u.hour), Latitude(5, u.deg), Distance(10, u.kpc))\nastropy\/coordinates\/tests\/test_api_ape5.py:    # Default is to copy arrays, but optionally, it can be a reference\nastropy\/coordinates\/tests\/test_api_ape5.py:    # converted to Angle\/Distance\nastropy\/coordinates\/tests\/test_api_ape5.py:    assert isinstance(c1.distance, Distance)\nastropy\/coordinates\/tests\/test_api_ape5.py:    c2.lat[:] = [0] * u.deg  # possible, but NOT SUPPORTED\nastropy\/coordinates\/tests\/test_api_ape5.py:    # Dec. This works simply as a shorthand for the longer form above\nastropy\/coordinates\/tests\/test_api_ape5.py:    # while `separation_3d` includes the 3D distance information\nastropy\/coordinates\/tests\/test_api_ape5.py:    from ..transformations import DynamicMatrixTransform\nastropy\/coordinates\/tests\/test_api_ape5.py:    # it's a *different* RA and Dec\nastropy\/coordinates\/tests\/test_api_ape5.py:    @frame_transform_graph.transform(DynamicMatrixTransform, SomeNewSystem, FK5)\nastropy\/coordinates\/tests\/test_api_ape5.py:    # sc = coords.SkyCoord('SDSS J123456.89-012345.6', frame='icrs')\nastropy\/coordinates\/tests\/test_api_ape5.py:    # assert str(m31icrs) == '<SkyCoord (ICRS) RA=10.68471 deg, Dec=41.26875 deg>'\nastropy\/modeling\/tests\/test_separable.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_separable.py:rot = models.Rotation2D(2, name='rotation')\nastropy\/modeling\/tests\/test_separable.py:p2 = models.Polynomial2D(1, name='p2')\nastropy\/modeling\/tests\/test_separable.py:p22 = models.Polynomial2D(2, name='p22')\nastropy\/modeling\/tests\/test_separable.py:p1 = models.Polynomial1D(1, name='p1')\nastropy\/modeling\/tests\/test_input.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_input.py:from ..core import Model, FittableModel, Fittable1DModel\nastropy\/modeling\/tests\/test_input.py:    (models.Polynomial1D, [2]),\nastropy\/modeling\/tests\/test_input.py:    (models.Legendre1D, [2]),\nastropy\/modeling\/tests\/test_input.py:    (models.Chebyshev1D, [2]),\nastropy\/modeling\/tests\/test_input.py:    (models.Polynomial2D, [2]),\nastropy\/modeling\/tests\/test_input.py:    (models.Legendre2D, [1, 2]),\nastropy\/modeling\/tests\/test_input.py:    (models.Chebyshev2D, [1, 2])\nastropy\/modeling\/tests\/test_input.py:    def test_input1D(self, model, params):\nastropy\/modeling\/tests\/test_input.py:    def test_input2D(self, model, params):\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 set 1D x, 1pset\"\"\"\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(3)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 set 1D x, 2 sets 1D y, 2 param_sets\"\"\"\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(3, n_models=2)\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(3, model_set_axis=0, **params)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 pset, 1 set 1D x, 1 set 1D y, Chebyshev 1D polynomial\"\"\"\nastropy\/modeling\/tests\/test_input.py:        ch1 = models.Chebyshev1D(3)\nastropy\/modeling\/tests\/test_input.py:        1 pset, 1 set 1D x, 1 set 1D y, Legendre 1D polynomial\nastropy\/modeling\/tests\/test_input.py:        leg1 = models.Legendre1D(3)\nastropy\/modeling\/tests\/test_input.py:        p2 = models.Polynomial2D(2)\nastropy\/modeling\/tests\/test_input.py:            p1 = models.Polynomial1D(5)\nastropy\/modeling\/tests\/test_input.py:            p1 = models.Polynomial1D(5, n_models=2)\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(5, n_models=2)\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(5, model_set_axis=0, **params)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 set 1D x, 1 set 1D y, 1 pset NonLinearFitter\"\"\"\nastropy\/modeling\/tests\/test_input.py:        g1 = models.Gaussian1D(10, mean=3, stddev=.2)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 set 1D x, 1 set 1D y, 2 param_sets, NonLinearFitter\"\"\"\nastropy\/modeling\/tests\/test_input.py:            g1 = models.Gaussian1D([10.2, 10], mean=[3, 3.2], stddev=[.23, .2],\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 set 2d x, 1set 2D y, 1 pset, NonLinearFitter\"\"\"\nastropy\/modeling\/tests\/test_input.py:        g2 = models.Gaussian2D(10, x_mean=3, y_mean=4, x_stddev=.3,\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 set 2d x, 1set 2D y, 2 param_sets, NonLinearFitter\"\"\"\nastropy\/modeling\/tests\/test_input.py:            g2 = models.Gaussian2D([10, 10], [3, 3], [4, 4], x_stddev=[.3, .3],\nastropy\/modeling\/tests\/test_input.py:            N param sets , 1 set 1D x --> N 1D y data\nastropy\/modeling\/tests\/test_input.py:        g1 = models.Gaussian1D([10, 10], [3, 3], [.2, .2], n_models=2)\nastropy\/modeling\/tests\/test_input.py:        This case covers: N param sets , N sets 1D x --> N N sets 1D y data\nastropy\/modeling\/tests\/test_input.py:        g1 = models.Gaussian1D([10, 10], [3, 3], [.2, .2], n_models=2)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 data set, 1 pset, Polynomial1D\"\"\"\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(4)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"N data sets, N param_sets, Polynomial1D\"\"\"\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(4, n_models=2)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"1 pset, 1 2D data set, Polynomial2D\"\"\"\nastropy\/modeling\/tests\/test_input.py:        p2 = models.Polynomial2D(5)\nastropy\/modeling\/tests\/test_input.py:        \"\"\"N param_sets, N 2D data sets, Poly2d\"\"\"\nastropy\/modeling\/tests\/test_input.py:        p2 = models.Polynomial2D(5, n_models=2)\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(5, n_models=2)\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(5)\nastropy\/modeling\/tests\/test_input.py:        p1 = models.Polynomial1D(5)\nastropy\/modeling\/tests\/test_input.py:        g = models.Gaussian2D(1., 5., 4., cov_matrix=cov)\nastropy\/modeling\/tests\/test_input.py:class TModel_1_1(Fittable1DModel):\nastropy\/modeling\/tests\/test_input.py:            # Doesn't broadcast\nastropy\/modeling\/tests\/test_input.py:            # Doesn't broadcast\nastropy\/modeling\/tests\/test_input.py:        Scalar parameters with a scalar input should return a 1-D array with\nastropy\/modeling\/tests\/test_input.py:            # Doesn't broadcast with the shape of the parameters, (3,)\nastropy\/modeling\/tests\/test_input.py:class TestSingleInputDoubleOutputSingleModel:\nastropy\/modeling\/tests\/test_input.py:            # Doesn't broadcast\nastropy\/modeling\/tests\/test_input.py:            # Doesn't broadcast\nastropy\/coordinates\/tests\/test_matrix_utilities.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_quantities_rotations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_quantities_rotations.py:    w.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/modeling\/tests\/test_quantities_rotations.py:def test_Rotation2D():\nastropy\/modeling\/tests\/test_quantities_rotations.py:    model = models.Rotation2D(angle=90 * u.deg)\nastropy\/modeling\/tests\/test_quantities_rotations.py:def test_Rotation2D_inverse():\nastropy\/modeling\/tests\/test_quantities_rotations.py:    model = models.Rotation2D(angle=234.23494 * u.deg)\nastropy\/coordinates\/tests\/test_matching.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_matching.py:    OLDER_SCIPY = False\nastropy\/coordinates\/tests\/test_matching.py:    OLDER_SCIPY = True\nastropy\/coordinates\/tests\/test_matching.py:    assert 'KD' in e.value.args[0]\nastropy\/coordinates\/tests\/test_matching.py:@pytest.mark.skipif(str('OLDER_SCIPY'))\nastropy\/coordinates\/tests\/test_matching.py:@pytest.mark.skipif(str('OLDER_SCIPY'))\nastropy\/coordinates\/tests\/test_matching.py:@pytest.mark.skipif(str('OLDER_SCIPY'))\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                UnitSphericalRepresentation, SphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                CartesianDifferential, UnitSphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                SphericalCosLatDifferential, UnitSphericalCosLatDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                PhysicsSphericalDifferential, CylindricalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                RadialRepresentation, RadialDifferential, Longitude, Latitude)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:from ..representation import DIFFERENTIAL_CLASSES\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        # work on multi-D representations.\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:class TestSphericalDifferential():\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    # these test cases are subclassed for SphericalCosLatDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls = SphericalCosLatDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls = SphericalDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.SD_cls is SphericalCosLatDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.SD_cls.get_name() == 'sphericalcoslat'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.SD_cls is SphericalDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.SD_cls.get_name() == 'spherical'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert self.SD_cls.get_name() in DIFFERENTIAL_CLASSES\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon = self.SD_cls(1.*u.arcsec, 0.*u.arcsec, 0.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon2 = self.SD_cls.from_cartesian(o_lonc, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lat = self.SD_cls(0.*u.arcsec, 1.*u.arcsec, 0.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_distance = self.SD_cls(0.*u.arcsec, 0.*u.arcsec, 1.*u.mpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon = self.SD_cls(1.*u.arcsec, 0.*u.arcsec, 0.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon2 = self.SD_cls(1*u.mas\/u.yr, 0*u.mas\/u.yr, 0*u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon3 = self.SD_cls.from_cartesian(o_lon3c, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        expected0 = self.SD_cls(1.*u.mas\/u.yr, 0.*u.mas\/u.yr, 0.*u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls(1.*u.arcsec, 0., 0.)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls(1.*u.arcsec, 0.*u.arcsec, 0.*u.kpc,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls(1.*u.arcsec, 0.*u.arcsec, 0.*u.kpc,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls(1.*u.arcsec, 0.*u.arcsec, 0.*u.kpc,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls(np.ones(2)*u.arcsec,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls(1.*u.arcsec, 1.*u.s, 0.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls(1.*u.kpc, 1.*u.arcsec, 0.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o = self.SD_cls(1.*u.arcsec, 1.*u.arcsec, 0.*u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o = self.SD_cls(1.*u.arcsec, 1.*u.arcsec, 0.*u.km)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls.to_cartesian(c)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls.from_cartesian(c)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls.from_cartesian(c, SphericalRepresentation)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.SD_cls.from_cartesian(c, c)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:class TestUnitSphericalDifferential():\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.USD_cls = UnitSphericalCosLatDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.USD_cls = UnitSphericalDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.USD_cls is UnitSphericalCosLatDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.USD_cls.get_name() == 'unitsphericalcoslat'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.USD_cls is UnitSphericalDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            assert self.USD_cls.get_name() == 'unitspherical'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert self.USD_cls.get_name() in DIFFERENTIAL_CLASSES\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon = self.USD_cls(1.*u.arcsec, 0.*u.arcsec)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon2 = self.USD_cls.from_cartesian(o_lonc, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lat = self.USD_cls(0.*u.arcsec, 1.*u.arcsec)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon = self.USD_cls(1.*u.arcsec, 0.*u.arcsec)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert type(o_lon_by_2) is self.USD_cls\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert type(o_lon_rec) is self.USD_cls\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert type(o_lon_0) is self.USD_cls\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon2 = self.USD_cls(1.*u.mas\/u.yr, 0.*u.mas\/u.yr)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_lon3 = self.USD_cls.from_cartesian(o_lon3c, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        expected0 = self.USD_cls(1.*u.mas\/u.yr, 0.*u.mas\/u.yr)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            self.USD_cls(0.*u.deg, 10.*u.deg\/u.yr)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:class TestRadialDifferential():\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert RadialDifferential.get_name() == 'radial'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert RadialDifferential.get_name() in DIFFERENTIAL_CLASSES\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_distance = RadialDifferential(1.*u.mpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_recover = RadialDifferential.from_cartesian(o_distancec, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:class TestPhysicsSphericalDifferential():\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    \"\"\"Test copied from SphericalDifferential, so less extensive.\"\"\"\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert PhysicsSphericalDifferential.get_name() == 'physicsspherical'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert PhysicsSphericalDifferential.get_name() in DIFFERENTIAL_CLASSES\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_phi = PhysicsSphericalDifferential(1*u.arcsec, 0*u.arcsec, 0*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_phi2 = PhysicsSphericalDifferential.from_cartesian(o_phic, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_theta = PhysicsSphericalDifferential(0*u.arcsec, 1*u.arcsec, 0*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_r = PhysicsSphericalDifferential(0*u.arcsec, 0*u.arcsec, 1*u.mpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            PhysicsSphericalDifferential(1.*u.arcsec, 0., 0.)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:class TestCylindricalDifferential():\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    \"\"\"Test copied from SphericalDifferential, so less extensive.\"\"\"\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert CylindricalDifferential.get_name() == 'cylindrical'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert CylindricalDifferential.get_name() in DIFFERENTIAL_CLASSES\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_rho = CylindricalDifferential(1.*u.mpc, 0.*u.arcsec, 0.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_phi = CylindricalDifferential(0.*u.kpc, 1.*u.arcsec, 0.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_phi2 = CylindricalDifferential.from_cartesian(o_phic, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        o_z = CylindricalDifferential(0.*u.kpc, 0.*u.arcsec, 1.*u.mpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            CylindricalDifferential(1.*u.pc, 1.*u.arcsec, 3.*u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:class TestCartesianDifferential():\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    \"\"\"Test copied from SphericalDifferential, so less extensive.\"\"\"\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert CartesianDifferential.get_name() == 'cartesian'\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert CartesianDifferential.get_name() in DIFFERENTIAL_CLASSES\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                ('x', CartesianDifferential(1.*u.pc, 0.*u.pc, 0.*u.pc)),\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                ('y', CartesianDifferential([0., 1., 0.], unit=u.pc)),\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                ('z', CartesianDifferential(np.array([[0., 0., 1.]]) * u.pc,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            differential2 = CartesianDifferential.from_cartesian(o_c)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            differential3 = CartesianDifferential.from_cartesian(o_c, base=o_c)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            CartesianDifferential(1.*u.kpc\/u.s, 2.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            CartesianDifferential(1.*u.kpc\/u.s, 2.*u.kpc, 3.*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            CartesianDifferential(1.*u.kpc, 2.*u.kpc, 3.*u.kpc, xyz_axis=1)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:class TestDifferentialConversion():\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    @pytest.mark.parametrize('sd_cls', [SphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                                        SphericalCosLatDifferential])\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        so = SphericalDifferential(1.*u.deg, 2.*u.deg, 0.1*u.kpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        so_coslat = so.represent_as(SphericalCosLatDifferential, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        so2 = so_coslat.represent_as(SphericalDifferential, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        so3 = SphericalDifferential.from_representation(so_coslat, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        so_coslat2 = SphericalCosLatDifferential.from_representation(so, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        uo = so.represent_as(UnitSphericalDifferential)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        uo_coslat = so.represent_as(UnitSphericalCosLatDifferential, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        uo2 = uo_coslat.represent_as(UnitSphericalDifferential, base=us)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        uo3 = UnitSphericalDifferential.from_representation(uo_coslat, base=us)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        uo_coslat2 = UnitSphericalCosLatDifferential.from_representation(\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        uo_coslat3 = uo.represent_as(UnitSphericalCosLatDifferential, base=us)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    @pytest.mark.parametrize('sd_cls', [SphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                                        SphericalCosLatDifferential])\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    @pytest.mark.parametrize('sd_cls', [SphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                                        SphericalCosLatDifferential])\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        # Conversion needs no base for SphericalDifferential, but does\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        # need one (to get the latitude) for SphericalCosLatDifferential.\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        if sd_cls is SphericalDifferential:\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            usd_cls = UnitSphericalDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            usd_cls = UnitSphericalCosLatDifferential\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        po = so.represent_as(PhysicsSphericalDifferential, base=base_s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        po2 = PhysicsSphericalDifferential.from_representation(so, base=base_p)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        po2 = so.represent_as(PhysicsSphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        sro = RadialDifferential.from_representation(so)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        pro = RadialDifferential.from_representation(po)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        sro2 = so.represent_as(RadialDifferential)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        pro2 = po.represent_as(RadialDifferential)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        [(SphericalDifferential, UnitSphericalDifferential),\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:         (SphericalCosLatDifferential, UnitSphericalCosLatDifferential)])\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        ro_r = so1.represent_as(RadialDifferential)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        assert np.all(representation_equal(ro_r, RadialDifferential(5.*u.pc)))\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    @pytest.mark.parametrize('sd_cls', [SphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                                        SphericalCosLatDifferential])\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        cyo = so.represent_as(CylindricalDifferential, base=s)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        cyo2 = CylindricalDifferential.from_representation(so, base=cy)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:    @pytest.mark.parametrize('sd_cls', [SphericalDifferential,\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:                                        SphericalCosLatDifferential])\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        if sd_cls is SphericalDifferential:\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            uo = UnitSphericalDifferential(2.*u.deg, 1.*u.deg)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:            uo = UnitSphericalCosLatDifferential(2.*u.deg, 1.*u.deg)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:        ro = RadialDifferential(1.*u.mpc)\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:     CartesianDifferential([.1, .2, .3]*u.km\/u.s)],\nastropy\/coordinates\/tests\/test_representation_arithmetic.py:     SphericalDifferential(1.*u.deg, 2.*u.deg, 0.1*u.kpc)]\nastropy\/modeling\/tests\/test_quantities_fitting.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_quantities_fitting.py:from ..models import Gaussian1D\nastropy\/modeling\/tests\/test_quantities_fitting.py:    g_init = Gaussian1D()\nastropy\/modeling\/tests\/test_quantities_fitting.py:    # TODO: update actual numerical results once implemented, but these should\nastropy\/modeling\/tests\/test_quantities_fitting.py:    g_init = Gaussian1D(amplitude=1. * u.mJy, mean=3 * u.cm, stddev=2 * u.mm)\nastropy\/modeling\/tests\/test_quantities_fitting.py:    # TODO: update actual numerical results once implemented, but these should\nastropy\/modeling\/tests\/test_quantities_fitting.py:    g_init = Gaussian1D(amplitude=1. * u.mJy, mean=3 * u.cm, stddev=2 * u.mm)\nastropy\/modeling\/tests\/test_quantities_fitting.py:    g_init = Gaussian1D(amplitude=1., mean=3, stddev=2)\nastropy\/modeling\/tests\/test_quantities_fitting.py:    g_init = Gaussian1D(amplitude=1., mean=3 * u.m, stddev=2 * u.m)\nastropy\/modeling\/tests\/test_quantities_fitting.py:    g_init = Gaussian1D(amplitude=1. * u.Jy, mean=3 * u.m, stddev=2 * u.cm)\nastropy\/coordinates\/tests\/test_frames.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_frames.py:from ...utils import OrderedDescriptorContainer\nastropy\/coordinates\/tests\/test_frames.py:    class TestAttributes(metaclass=OrderedDescriptorContainer):\nastropy\/coordinates\/tests\/test_frames.py:    # Defaults\nastropy\/coordinates\/tests\/test_frames.py:    assert isinstance(rep2.differentials['s'], r.CylindricalDifferential)\nastropy\/coordinates\/tests\/test_frames.py:    # TODO: this should probably fail in the future once we figure out a better\nastropy\/coordinates\/tests\/test_frames.py:    # RadialDifferential's\nastropy\/coordinates\/tests\/test_frames.py:    #                          r.SphericalCosLatDifferential)\nastropy\/coordinates\/tests\/test_frames.py:    # assert isinstance(rep2.differentials['s'], r.SphericalCosLatDifferential)\nastropy\/coordinates\/tests\/test_frames.py:    dif = r.CartesianDifferential([1, 2, 3]*u.km\/u.s)\nastropy\/coordinates\/tests\/test_frames.py:    assert isinstance(sph.differentials['s'], r.SphericalDifferential)\nastropy\/coordinates\/tests\/test_frames.py:    assert isinstance(sph.differentials['s'], r.SphericalCosLatDifferential)\nastropy\/coordinates\/tests\/test_frames.py:    dif1 = r.CartesianDifferential([1, 2, 3]*u.km\/u.s)\nastropy\/coordinates\/tests\/test_frames.py:    dif2 = r.CartesianDifferential([1, 2, 3]*u.km\/u.s**2)\nastropy\/modeling\/tests\/test_polynomial.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_polynomial.py:from ..polynomial import (Chebyshev1D, Hermite1D, Legendre1D, Polynomial1D,\nastropy\/modeling\/tests\/test_polynomial.py:                          Chebyshev2D, Hermite2D, Legendre2D, Polynomial2D, SIP,\nastropy\/modeling\/tests\/test_polynomial.py:from ..functional_models import Linear1D\nastropy\/modeling\/tests\/test_polynomial.py:    Chebyshev1D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Hermite1D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Legendre1D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Polynomial1D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Linear1D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Chebyshev2D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Hermite2D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Legendre2D: {\nastropy\/modeling\/tests\/test_polynomial.py:    Polynomial2D: {\nastropy\/modeling\/tests\/test_polynomial.py:    # TODO: Most of these test cases have some pretty repetitive setup that we\nastropy\/modeling\/tests\/test_polynomial.py:    def test_linear_fitter_1D(self, model_class, constraints):\nastropy\/modeling\/tests\/test_polynomial.py:    def test_non_linear_fitter_1D(self, model_class, constraints):\nastropy\/modeling\/tests\/test_polynomial.py:    def test_linear_fitter_2D(self, model_class, constraints):\nastropy\/modeling\/tests\/test_polynomial.py:    def test_non_linear_fitter_2D(self, model_class, constraints):\nastropy\/modeling\/tests\/test_polynomial.py:    if '1D' in model_class.__name__:\nastropy\/modeling\/tests\/test_polynomial.py:    a_order = a_pars.pop('A_ORDER')\nastropy\/modeling\/tests\/test_polynomial.py:    b_order = b_pars.pop('B_ORDER')\nastropy\/modeling\/tests\/test_polynomial.py:    a_order = a_pars.pop('A_ORDER')\nastropy\/modeling\/tests\/test_polynomial.py:    b_order = b_pars.pop('B_ORDER')\nastropy\/modeling\/tests\/test_polynomial.py:    ap_order = ap_pars.pop('AP_ORDER')\nastropy\/modeling\/tests\/test_polynomial.py:    bp_order = bp_pars.pop('BP_ORDER')\nastropy\/modeling\/tests\/test_polynomial.py:    del a_pars['A_DMAX']\nastropy\/modeling\/tests\/test_polynomial.py:    del b_pars['B_DMAX']\nastropy\/modeling\/tests\/test_polynomial.py:@pytest.mark.parametrize('cls', (Polynomial1D, Chebyshev1D, Legendre1D,\nastropy\/modeling\/tests\/test_polynomial.py:                                 Polynomial2D, Chebyshev2D, Legendre2D))\nastropy\/modeling\/tests\/test_polynomial.py:    if cls.n_inputs == 1:  # Test 1D polynomials\nastropy\/modeling\/tests\/test_polynomial.py:    elif cls.n_inputs == 2:  # Test 2D polynomials\nastropy\/modeling\/tests\/test_polynomial.py:    Ensure that OrthoPolynomialBase (ie. Chebyshev2D & Legendre2D) models get\nastropy\/modeling\/tests\/test_polynomial.py:    simple_model = Chebyshev2D(2, 2)\nastropy\/modeling\/tests\/test_polynomial.py:    compound_model = Identity(2) | Chebyshev2D(2, 2)\nastropy\/coordinates\/tests\/test_atc_replacements.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_compound.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_compound.py:from ..core import Model, ModelDefinitionError\nastropy\/modeling\/tests\/test_compound.py:from ..models import (Const1D, Shift, Scale, Rotation2D, Gaussian1D,\nastropy\/modeling\/tests\/test_compound.py:                      Gaussian2D, Polynomial1D, Polynomial2D,\nastropy\/modeling\/tests\/test_compound.py:                      Chebyshev2D, Legendre2D, Chebyshev1D, Legendre1D,\nastropy\/modeling\/tests\/test_compound.py:                      AffineTransformation2D, Identity, Mapping)\nastropy\/modeling\/tests\/test_compound.py:    # Const1D is perhaps the simplest model to test basic arithmetic with.\nastropy\/modeling\/tests\/test_compound.py:    # TODO: Should define more tests later on for more complicated\nastropy\/modeling\/tests\/test_compound.py:    S = expr(Const1D, Const1D)\nastropy\/modeling\/tests\/test_compound.py:    s = expr(Const1D((2, 2), n_models=2), Const1D((3, 3), n_models=2))\nastropy\/modeling\/tests\/test_compound.py:        s = expr(Const1D((2, 2), n_models=2), Const1D(3, n_models=1))\nastropy\/modeling\/tests\/test_compound.py:    s = expr(Const1D(2), Const1D(3))\nastropy\/modeling\/tests\/test_compound.py:    S1 = expr(Const1D, Const1D(3))\nastropy\/modeling\/tests\/test_compound.py:    S2 = expr(Const1D(2), Const1D)\nastropy\/modeling\/tests\/test_compound.py:    # TODO: We may wish to fix that eventually, so that if a parameter has a\nastropy\/modeling\/tests\/test_compound.py:    R = Rotation2D | Rotation2D\nastropy\/modeling\/tests\/test_compound.py:    g2 = Gaussian1D() + Gaussian1D()\nastropy\/modeling\/tests\/test_compound.py:    g3 = g2 + Gaussian1D()\nastropy\/modeling\/tests\/test_compound.py:    p = Polynomial1D + Polynomial1D\nastropy\/modeling\/tests\/test_compound.py:    G = Gaussian1D\nastropy\/modeling\/tests\/test_compound.py:    G2 = Gaussian2D\nastropy\/modeling\/tests\/test_compound.py:    g = Gaussian1D(1, 2, 3, name='g')\nastropy\/modeling\/tests\/test_compound.py:    p = Polynomial1D(2, name='p')\nastropy\/modeling\/tests\/test_compound.py:    M = Gaussian1D + Const1D\nastropy\/modeling\/tests\/test_compound.py:    assert M[0] is Gaussian1D\nastropy\/modeling\/tests\/test_compound.py:    assert M[1] is Const1D\nastropy\/modeling\/tests\/test_compound.py:    assert M['Gaussian1D'] is M[0]\nastropy\/modeling\/tests\/test_compound.py:    assert M['Const1D'] is M[1]\nastropy\/modeling\/tests\/test_compound.py:    M = Gaussian1D + p\nastropy\/modeling\/tests\/test_compound.py:    assert M[0] is Gaussian1D\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(M['p'], Polynomial1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[0], Gaussian1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[1], Polynomial1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m['g'], Gaussian1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m['p'], Polynomial1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[-1], Polynomial1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[-2], Gaussian1D)\nastropy\/modeling\/tests\/test_compound.py:# TODO: It would be good if there were an easier way to interrogate a compound\nastropy\/modeling\/tests\/test_compound.py:    A = Const1D.rename('A')\nastropy\/modeling\/tests\/test_compound.py:    B = Const1D.rename('B')\nastropy\/modeling\/tests\/test_compound.py:    C = Const1D.rename('C')\nastropy\/modeling\/tests\/test_compound.py:    D = Const1D.rename('D')\nastropy\/modeling\/tests\/test_compound.py:    E = Const1D.rename('E')\nastropy\/modeling\/tests\/test_compound.py:    F = Const1D.rename('F')\nastropy\/modeling\/tests\/test_compound.py:    M = A + B - C * D \/ E ** F\nastropy\/modeling\/tests\/test_compound.py:    assert M['C':'D'](3, 4)(0) == 12\nastropy\/modeling\/tests\/test_compound.py:    assert M['C':'D'].param_names == ('amplitude_2', 'amplitude_3')\nastropy\/modeling\/tests\/test_compound.py:    assert M['D':'E'](4, 5)(0) == 0.8\nastropy\/modeling\/tests\/test_compound.py:    assert M['D':'E'].param_names == ('amplitude_3', 'amplitude_4')\nastropy\/modeling\/tests\/test_compound.py:    A = Const1D.rename('A')\nastropy\/modeling\/tests\/test_compound.py:    B = Const1D.rename('B')\nastropy\/modeling\/tests\/test_compound.py:    C = Const1D.rename('C')\nastropy\/modeling\/tests\/test_compound.py:    D = Const1D.rename('D')\nastropy\/modeling\/tests\/test_compound.py:    E = Const1D.rename('E')\nastropy\/modeling\/tests\/test_compound.py:    F = Const1D.rename('F')\nastropy\/modeling\/tests\/test_compound.py:    M = A + B - C * D \/ E ** F\nastropy\/modeling\/tests\/test_compound.py:    assert m['C':'D'](0) == 12\nastropy\/modeling\/tests\/test_compound.py:    assert m['C':'D'].param_names == ('amplitude_2', 'amplitude_3')\nastropy\/modeling\/tests\/test_compound.py:    assert np.all(m['C':'D'].parameters == [3, 4])\nastropy\/modeling\/tests\/test_compound.py:    assert m['D':'E'](0) == 0.8\nastropy\/modeling\/tests\/test_compound.py:    assert m['D':'E'].param_names == ('amplitude_3', 'amplitude_4')\nastropy\/modeling\/tests\/test_compound.py:    assert np.all(m['D':'E'].parameters == [4, 5])\nastropy\/modeling\/tests\/test_compound.py:    M = Gaussian1D + Const1D\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[0], Gaussian1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[1], Const1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m['Gaussian1D'], Gaussian1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m['Const1D'], Const1D)\nastropy\/modeling\/tests\/test_compound.py:    g = Gaussian1D(1, 2, 3, name='g')\nastropy\/modeling\/tests\/test_compound.py:    p = Polynomial1D(2, name='p')\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[-1], Polynomial1D)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(m[-2], Gaussian1D)\nastropy\/modeling\/tests\/test_compound.py:    t = (Shift(2) & Shift(3)) | (Scale(2) & Scale(3)) | Rotation2D(90)\nastropy\/modeling\/tests\/test_compound.py:    Gaussian1D(1, 2, 3) | Gaussian1D(4, 5, 6)])\nastropy\/modeling\/tests\/test_compound.py:    x, y = Rotation2D(90)(1, 2)\nastropy\/modeling\/tests\/test_compound.py:    RS = Rotation2D | Mapping((1, 0))\nastropy\/modeling\/tests\/test_compound.py:    M = Rotation2D & Scale\nastropy\/modeling\/tests\/test_compound.py:    RS = Rotation2D & Scale\nastropy\/modeling\/tests\/test_compound.py:    rotation = Rotation2D(angle=90)\nastropy\/modeling\/tests\/test_compound.py:    TestModel = ident1 & Shift | Rotation2D\nastropy\/modeling\/tests\/test_compound.py:    model_c = Rotation2D(3, name='c')\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:    ModelDefinitionErrors being raised, but that was before we prevented\nastropy\/modeling\/tests\/test_compound.py:    model_c = Gaussian1D(3, 0, 0.1, name='c')\nastropy\/modeling\/tests\/test_compound.py:    p2 = Polynomial2D(1, c0_0=1, c1_0=2, c0_1=3)\nastropy\/modeling\/tests\/test_compound.py:    p1 = Polynomial2D(1, c0_0=1, c1_0=2, c0_1=3)\nastropy\/modeling\/tests\/test_compound.py:    aff = AffineTransformation2D(matrix=[[1, 2], [3, 4]], name='rotation')\nastropy\/modeling\/tests\/test_compound.py:    rot = AffineTransformation2D([[0, -1], [1, 0]])\nastropy\/modeling\/tests\/test_compound.py:    inspect.classify_class_attrs(Gaussian1D + Gaussian1D)\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:        Rotation2D | Gaussian1D\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:        Rotation2D(90) | Gaussian1D(1, 0, 0.1)\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:        Rotation2D + Gaussian1D\nastropy\/modeling\/tests\/test_compound.py:    with pytest.raises(ModelDefinitionError):\nastropy\/modeling\/tests\/test_compound.py:        Rotation2D(90) + Gaussian1D(1, 0, 0.1)\nastropy\/modeling\/tests\/test_compound.py:        [Gaussian1D(bounds={'stddev': (0, 0.3)}, fixed={'mean': True}) +\nastropy\/modeling\/tests\/test_compound.py:            Gaussian1D(fixed={'mean': True}),\nastropy\/modeling\/tests\/test_compound.py:    poly = Polynomial1D(1, c0=1, c1=2)\nastropy\/modeling\/tests\/test_compound.py:@pytest.mark.parametrize('poly', [Chebyshev2D(1, 2), Polynomial2D(2), Legendre2D(1, 2),\nastropy\/modeling\/tests\/test_compound.py:                                  Chebyshev1D(5), Legendre1D(5), Polynomial1D(5)])\nastropy\/modeling\/tests\/test_compound.py:class _TestPickleModel(Gaussian1D + Gaussian1D):\nastropy\/modeling\/tests\/test_compound.py:    GG = Gaussian1D + Gaussian1D\nastropy\/modeling\/tests\/test_compound.py:    g1 = Gaussian1D(1.0, 0.0, 0.1)\nastropy\/modeling\/tests\/test_compound.py:    g2 = Gaussian1D([2.0, 3.0], [0.0, 0.0], [0.2, 0.3])\nastropy\/modeling\/tests\/data\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_transformations.py:    trans2 = t.DynamicMatrixTransform(matfunc, TCoo1, TCoo2)\nastropy\/coordinates\/tests\/test_transformations.py:    dif = r.CartesianDifferential(*np.arange(3, 6)*u.pc\/u.Myr)\nastropy\/coordinates\/tests\/test_transformations.py:                              differentials=r.CartesianDifferential(8, 9, 10,\nastropy\/coordinates\/tests\/test_transformations.py:                              differentials=r.CartesianDifferential(8, 9, 10,\nastropy\/coordinates\/tests\/test_transformations.py:     .represent_as(r.CylindricalRepresentation, r.CylindricalDifferential)\nastropy\/coordinates\/tests\/test_transformations.py:    diffs = dict([(k, diff.represent_as(r.CartesianDifferential, rep))\nastropy\/coordinates\/tests\/test_transformations.py:    diff = r.CartesianDifferential(8, 9, 10, unit=u.pc\/u.Myr)\nastropy\/coordinates\/tests\/test_transformations.py:    dif1 = r.CartesianDifferential(*np.arange(3, 6)*u.pc\/u.Myr)\nastropy\/coordinates\/tests\/test_transformations.py:    dif2 = r.CartesianDifferential(*np.arange(3, 6)*u.pc\/u.Myr**2)\nastropy\/coordinates\/tests\/test_transformations.py:        differentials=r.SphericalDifferential(d_lon=15*u.mas\/u.yr,\nastropy\/coordinates\/tests\/test_transformations.py:        differentials={'s': r.RadialDifferential(d_distance=-110*u.km\/u.s)}),\nastropy\/coordinates\/tests\/test_transformations.py:        differentials={'s': r.RadialDifferential(d_distance=-110*u.km\/u.s)})\nastropy\/coordinates\/tests\/test_transformations.py:    if isinstance(rep.differentials['s'], r.RadialDifferential):\nastropy\/coordinates\/tests\/test_transformations.py:    # TODO: replace after a final decision on PR #6280\nastropy\/coordinates\/tests\/test_transformations.py:    diff = r.CartesianDifferential([.1, .2, .3]*u.km\/u.s)\nastropy\/coordinates\/tests\/test_earth.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_earth.py:from ..earth import EarthLocation, ELLIPSOIDS\nastropy\/coordinates\/tests\/test_earth.py:    @pytest.mark.parametrize('ellipsoid', ELLIPSOIDS)\nastropy\/modeling\/tests\/test_blackbody.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_blackbody.py:from ..blackbody import BlackBody1D, blackbody_nu, blackbody_lambda, FNU\nastropy\/modeling\/tests\/test_blackbody.py:class TestBlackbody1D:\nastropy\/modeling\/tests\/test_blackbody.py:        b = BlackBody1D(temperature=temperature,\nastropy\/modeling\/tests\/test_blackbody.py:        b = BlackBody1D(3000 * u.K)\nastropy\/modeling\/tests\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/utils.py:            \"will result in an error in the future\", DeprecationWarning)\nastropy\/modeling\/tests\/test_mappings.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_mappings.py:from ..models import Shift, Rotation2D, Gaussian1D, Identity, Mapping\nastropy\/modeling\/tests\/test_mappings.py:    rotation = Rotation2D(60)\nastropy\/modeling\/tests\/test_mappings.py:    rotation = Rotation2D(angle=60)\nastropy\/modeling\/tests\/test_mappings.py:    m = Identity(1) | Mapping((0, )) | Gaussian1D(1, 5, 4)\nastropy\/modeling\/tests\/example_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/example_models.py:`~astropy.modeling.FittableModel` defined. There is a dictionary for 1D and a\nastropy\/modeling\/tests\/example_models.py:dictionary for 2D models.\nastropy\/modeling\/tests\/example_models.py:    (2D model option)\nastropy\/modeling\/tests\/example_models.py:    x test range for the model fitter. Depending on the model this can differ\nastropy\/modeling\/tests\/example_models.py:    y test range for the model fitter. Depending on the model this can differ\nastropy\/modeling\/tests\/example_models.py:    e.g. the PowerLaw model should be tested over a few magnitudes.  (2D model\nastropy\/modeling\/tests\/example_models.py:    Gaussian1D, Sine1D, Box1D, Linear1D, Lorentz1D,\nastropy\/modeling\/tests\/example_models.py:    MexicanHat1D, Trapezoid1D, Const1D, Moffat1D,\nastropy\/modeling\/tests\/example_models.py:    Gaussian2D, Const2D, Box2D, MexicanHat2D,\nastropy\/modeling\/tests\/example_models.py:    TrapezoidDisk2D, AiryDisk2D, Moffat2D, Disk2D,\nastropy\/modeling\/tests\/example_models.py:    Ring2D, Sersic1D, Sersic2D, Voigt1D, Planar2D)\nastropy\/modeling\/tests\/example_models.py:from ..polynomial import Polynomial1D, Polynomial2D\nastropy\/modeling\/tests\/example_models.py:    PowerLaw1D, BrokenPowerLaw1D, SmoothlyBrokenPowerLaw1D, ExponentialCutoffPowerLaw1D,\nastropy\/modeling\/tests\/example_models.py:    LogParabola1D)\nastropy\/modeling\/tests\/example_models.py:# 1D Models\nastropy\/modeling\/tests\/example_models.py:models_1D = {\nastropy\/modeling\/tests\/example_models.py:    Gaussian1D: {\nastropy\/modeling\/tests\/example_models.py:    Sine1D: {\nastropy\/modeling\/tests\/example_models.py:    Box1D: {\nastropy\/modeling\/tests\/example_models.py:    Linear1D: {\nastropy\/modeling\/tests\/example_models.py:    Lorentz1D: {\nastropy\/modeling\/tests\/example_models.py:    MexicanHat1D: {\nastropy\/modeling\/tests\/example_models.py:    Trapezoid1D: {\nastropy\/modeling\/tests\/example_models.py:    Const1D: {\nastropy\/modeling\/tests\/example_models.py:    Moffat1D: {\nastropy\/modeling\/tests\/example_models.py:    PowerLaw1D: {\nastropy\/modeling\/tests\/example_models.py:    BrokenPowerLaw1D: {\nastropy\/modeling\/tests\/example_models.py:    SmoothlyBrokenPowerLaw1D: {\nastropy\/modeling\/tests\/example_models.py:    ExponentialCutoffPowerLaw1D: {\nastropy\/modeling\/tests\/example_models.py:    LogParabola1D: {\nastropy\/modeling\/tests\/example_models.py:    Polynomial1D: {\nastropy\/modeling\/tests\/example_models.py:    Sersic1D: {\nastropy\/modeling\/tests\/example_models.py:    Voigt1D: {\nastropy\/modeling\/tests\/example_models.py:# 2D Models\nastropy\/modeling\/tests\/example_models.py:models_2D = {\nastropy\/modeling\/tests\/example_models.py:    Gaussian2D: {\nastropy\/modeling\/tests\/example_models.py:    Const2D: {\nastropy\/modeling\/tests\/example_models.py:    Box2D: {\nastropy\/modeling\/tests\/example_models.py:    MexicanHat2D: {\nastropy\/modeling\/tests\/example_models.py:    TrapezoidDisk2D: {\nastropy\/modeling\/tests\/example_models.py:    AiryDisk2D: {\nastropy\/modeling\/tests\/example_models.py:    Moffat2D: {\nastropy\/modeling\/tests\/example_models.py:    Polynomial2D: {\nastropy\/modeling\/tests\/example_models.py:    Disk2D: {\nastropy\/modeling\/tests\/example_models.py:    Ring2D: {\nastropy\/modeling\/tests\/example_models.py:    Sersic2D: {\nastropy\/modeling\/tests\/example_models.py:    Planar2D: {\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:                FunctionTransformWithFiniteDifference, get_sun,\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:                CartesianDifferential, SphericalDifferential,\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:                DynamicMatrixTransform)\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:    @frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:    @frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:    @frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:        trans = DynamicMatrixTransform(fk5_to_gal, FK5, Galactic2)\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:    @frame_transform_graph.transform(FunctionTransformWithFiniteDifference,\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:        trans = DynamicMatrixTransform(_gal_to_fk5, Galactic2, FK5)\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:    cdiff = acoo.data.differentials['s'].represent_as(CartesianDifferential,\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:                                      # TODO:  make these not fail when the\nastropy\/coordinates\/tests\/test_finite_difference_velocities.py:    sd = frame.data.differentials['s'].represent_as(SphericalDifferential, frame.data)\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:MOONDIST = 385000*u.km  # approximate moon semi-major orbit axis of moon\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:MOONDIST_CART = CartesianRepresentation(3**-0.5*MOONDIST, 3**-0.5*MOONDIST, 3**-0.5*MOONDIST)\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    moon = GCRS(MOONDIST_CART, obstime=testframe.obstime)\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    moon = GCRS(MOONDIST_CART, obstime=testframe.obstime)\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    moon = CIRS(MOONDIST_CART, obstime=testframe.obstime)\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    moonish = CIRS(MOONDIST_CART, obstime=testframe.obstime)\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    moonish = GCRS(MOONDIST_CART, obstime=testframe.obstime)\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    moonoffset = [0, 0, MOONDIST.value]*MOONDIST.unit\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    assert 1000*u.km < np.abs(moonaa.distance - MOONDIST).to(u.au) < 7000*u.km\nastropy\/coordinates\/tests\/test_intermediate_transformations.py:    Moon positions were originally created using JPL DE432s ephemeris.\nastropy\/coordinates\/tests\/accuracy\/test_fk4_no_e_fk5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_celestial_transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_celestial_transformations.py:from ..distances import Distance\nastropy\/coordinates\/tests\/test_celestial_transformations.py:m31_dist = Distance(770, u.kpc)\nastropy\/coordinates\/tests\/test_celestial_transformations.py:    catalog location of M31 from NED.\nastropy\/coordinates\/tests\/test_celestial_transformations.py:    # check that ND arrays work\nastropy\/coordinates\/tests\/accuracy\/test_icrs_fk5.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_sigma_clipping.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_solar_system.py:from ..solar_system import (get_body, get_moon, BODY_NAME_TO_KERNEL_SPEC,\nastropy\/coordinates\/tests\/test_solar_system.py:    HAS_SKYFIELD = False\nastropy\/coordinates\/tests\/test_solar_system.py:    HAS_SKYFIELD = True\nastropy\/coordinates\/tests\/test_solar_system.py:@pytest.mark.skipif(str('not HAS_SKYFIELD'))\nastropy\/coordinates\/tests\/test_solar_system.py:        kspec = BODY_NAME_TO_KERNEL_SPEC[bodyname]\nastropy\/coordinates\/tests\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_quantities_evaluation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_quantities_evaluation.py:from ..models import Gaussian1D\nastropy\/modeling\/tests\/test_quantities_evaluation.py:    g = Gaussian1D(1, 1, 0.1)\nastropy\/modeling\/tests\/test_quantities_evaluation.py:    gq = Gaussian1D(1 * u.J, 1 * u.m, 0.1 * u.m)\nastropy\/modeling\/tests\/test_quantities_evaluation.py:    # TODO: determine what error message should be here\nastropy\/modeling\/tests\/test_quantities_evaluation.py:    g = Gaussian1D(1 * u.Jy, 10 * u.nm, 2 * u.nm)\nastropy\/stats\/tests\/test_jackknife.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_models.py:from .example_models import models_1D, models_2D\nastropy\/modeling\/tests\/test_models.py:    \"\"\"Test bounding box evaluation for a 3D model\"\"\"\nastropy\/modeling\/tests\/test_models.py:    class Ellipsoid3D(models.custom_model(ellipsoid)):\nastropy\/modeling\/tests\/test_models.py:    model = Ellipsoid3D()\nastropy\/modeling\/tests\/test_models.py:class Fittable2DModelTester:\nastropy\/modeling\/tests\/test_models.py:    def test_input2D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:    def test_eval2D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:    def test_bounding_box2D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:    def test_fitter2D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:    def test_deriv_2D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:            pytest.skip(\"Derivative function is not defined for model.\")\nastropy\/modeling\/tests\/test_models.py:class Fittable1DModelTester:\nastropy\/modeling\/tests\/test_models.py:    def test_input1D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:    def test_eval1D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:    def test_bounding_box1D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:        if isinstance(model, models.Lorentz1D):\nastropy\/modeling\/tests\/test_models.py:    def test_fitter1D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:    def test_deriv_1D(self, model_class, test_parameters):\nastropy\/modeling\/tests\/test_models.py:            pytest.skip(\"Derivative function is not defined for model.\")\nastropy\/modeling\/tests\/test_models.py:                         sorted(models_1D.items(), key=lambda x: str(x[0])))\nastropy\/modeling\/tests\/test_models.py:class TestFittable1DModels(Fittable1DModelTester):\nastropy\/modeling\/tests\/test_models.py:                         sorted(models_2D.items(), key=lambda x: str(x[0])))\nastropy\/modeling\/tests\/test_models.py:class TestFittable2DModels(Fittable2DModelTester):\nastropy\/modeling\/tests\/test_models.py:    m = models.Voigt1D(x_0=5, amplitude_L=10, fwhm_L=0.5, fwhm_G=0.9)\nastropy\/modeling\/tests\/test_models.py:    m = models.Gaussian1D(1.5, 2.5, 3.5)\nastropy\/modeling\/tests\/test_models.py:    assert repr(m) == '<Gaussian1D(amplitude=1.5, mean=2.5, stddev=3.5)>'\nastropy\/modeling\/tests\/test_models.py:    Test Tabular1D model.\nastropy\/modeling\/tests\/test_models.py:    # test 2D arrays as input\nastropy\/modeling\/tests\/test_models.py:    t = models.Tabular2D(lookup_table=a)\nastropy\/modeling\/tests\/test_models.py:    p = models.Polynomial2D(2) & models.Polynomial2D(2)\nastropy\/modeling\/tests\/test_models.py:    # test the order of bbox is not reversed for 1D models\nastropy\/modeling\/tests\/test_models.py:    p = models.Polynomial1D(1, c0=12, c1=2.3)\nastropy\/modeling\/tests\/test_core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_core.py:    model = models.Gaussian1D(4, 2, 1)\nastropy\/modeling\/tests\/test_core.py:        models.Gaussian1D(1, 2, 3, wrong=4)\nastropy\/modeling\/tests\/test_core.py:    p = models.Polynomial1D(1, c0=-2, c1=3)\nastropy\/modeling\/tests\/test_core.py:    inv = models.Polynomial1D(1, c0=(2.\/3.), c1=(1.\/3.))\nastropy\/modeling\/tests\/test_core.py:    model = models.Gaussian2D(x_stddev=6.1, y_stddev=3.9, theta=np.pi \/ 3)\nastropy\/modeling\/tests\/test_core.py:                    # this case is tested in Fittable2DModelTester\nastropy\/modeling\/tests\/test_core.py:    model = models.Gaussian1D()\nastropy\/modeling\/tests\/test_core.py:                    # this case is tested in Fittable1DModelTester\nastropy\/modeling\/tests\/test_core.py:    class Ellipsoid3D(custom_model(ellipsoid)):\nastropy\/modeling\/tests\/test_core.py:    model = Ellipsoid3D()\nastropy\/modeling\/tests\/test_core.py:    # 1D models\nastropy\/modeling\/tests\/test_core.py:    g1 = models.Gaussian1D()\nastropy\/modeling\/tests\/test_core.py:    # 2D models\nastropy\/modeling\/tests\/test_core.py:    g2 = models.Gaussian2D()\nastropy\/modeling\/tests\/test_core.py:    assert models.Gaussian1D.n_submodels() == 1\nastropy\/modeling\/tests\/test_core.py:    assert models.Gaussian2D.n_submodels() == 1\nastropy\/modeling\/tests\/test_core.py:    model = (models.Gaussian1D(10, 2,3) | models.Shift(2)) & models.Rotation2D(21.3)\nastropy\/coordinates\/tests\/test_name_resolve.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_name_resolve.py:%V z 1593 0.005327 [0.000060] D 2002LEDA.........0P\nastropy\/coordinates\/tests\/test_name_resolve.py:%D 1.673 1.657 75 (32767) (I) C 2006AJ....131.1163S\nastropy\/coordinates\/tests\/test_name_resolve.py:%T 5 =32800000 D 2011A&A...532A..74B\nastropy\/coordinates\/tests\/test_name_resolve.py:#====Done (2013-Feb-12,16:37:11z)====\"\"\"\nastropy\/coordinates\/tests\/test_name_resolve.py:#====Done (2013-Feb-12,16:37:42z)====\"\"\"\nastropy\/coordinates\/tests\/test_name_resolve.py:%V z 1593 0.005327 [0.000060] D 2002LEDA.........0P\nastropy\/coordinates\/tests\/test_name_resolve.py:%D 1.673 1.657 75 (32767) (I) C 2006AJ....131.1163S\nastropy\/coordinates\/tests\/test_name_resolve.py:%T 5 =32800000 D 2011A&A...532A..74B\nastropy\/coordinates\/tests\/test_name_resolve.py:#!N=NED : *** Could not access the server ***\nastropy\/coordinates\/tests\/test_name_resolve.py:#====Done (2013-Feb-12,16:39:48z)====\"\"\"\nastropy\/coordinates\/tests\/test_name_resolve.py:%S A1V+A2Vm =0.0000D200.0030.0110000000100000 C 2001AJ....122.3466M\nastropy\/coordinates\/tests\/test_name_resolve.py:#!N=NED: ****object name not recognized by NED name interpreter\nastropy\/coordinates\/tests\/test_name_resolve.py:#!N=NED: ***Not recognized by NED: castor\nastropy\/coordinates\/tests\/test_name_resolve.py:#====Done (2013-Feb-12,16:52:02z)====\"\"\"\nastropy\/coordinates\/tests\/test_name_resolve.py:%S A1V+A2Vm =0.0000D200.0030.0110000000100000 C 2001AJ....122.3466M\nastropy\/coordinates\/tests\/test_name_resolve.py:#====Done (2013-Feb-12,17:00:39z)====\"\"\"\nastropy\/stats\/tests\/test_bayesian_blocks.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/stats\/tests\/test_bayesian_blocks.py:    # Event Data\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:       R            D            pmRA     pmDE                               Di      pmGLon   pmGLat   RV      U      V      W\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:                differential_cls=r.UnitSphericalDifferential)\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:                differential_cls={'s': r.UnitSphericalDifferential})\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:    icrs.set_representation_cls(s=r.UnitSphericalDifferential)\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:             differential_cls=r.CartesianDifferential)\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:                differential_cls=r.CartesianDifferential)\nastropy\/coordinates\/tests\/test_frames_with_velocity.py:                 differential_cls=r.CartesianDifferential)\nastropy\/modeling\/tests\/test_models_quantities.py:from collections import OrderedDict\nastropy\/modeling\/tests\/test_models_quantities.py:from ..functional_models import (Gaussian1D,\nastropy\/modeling\/tests\/test_models_quantities.py:                                 Sersic1D, Sine1D, Linear1D,\nastropy\/modeling\/tests\/test_models_quantities.py:                                 Lorentz1D, Voigt1D, Const1D,\nastropy\/modeling\/tests\/test_models_quantities.py:                                 Box1D, Trapezoid1D, MexicanHat1D,\nastropy\/modeling\/tests\/test_models_quantities.py:                                 Moffat1D, Gaussian2D, Const2D, Ellipse2D,\nastropy\/modeling\/tests\/test_models_quantities.py:                                 Disk2D, Ring2D, Box2D, TrapezoidDisk2D,\nastropy\/modeling\/tests\/test_models_quantities.py:                                 MexicanHat2D, AiryDisk2D, Moffat2D, Sersic2D)\nastropy\/modeling\/tests\/test_models_quantities.py:from ..powerlaws import (PowerLaw1D, BrokenPowerLaw1D, SmoothlyBrokenPowerLaw1D,\nastropy\/modeling\/tests\/test_models_quantities.py:                         ExponentialCutoffPowerLaw1D, LogParabola1D)\nastropy\/modeling\/tests\/test_models_quantities.py:from ..polynomial import Polynomial1D, Polynomial2D\nastropy\/modeling\/tests\/test_models_quantities.py:FUNC_MODELS_1D = [\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Gaussian1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Sersic1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Sine1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Linear1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Lorentz1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Voigt1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Const1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Box1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Trapezoid1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': MexicanHat1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Moffat1D,\nastropy\/modeling\/tests\/test_models_quantities.py:FUNC_MODELS_2D = [\nastropy\/modeling\/tests\/test_models_quantities.py: {'class': Gaussian2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Const2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Disk2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': TrapezoidDisk2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Ellipse2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Ring2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Box2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': MexicanHat2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': AiryDisk2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Moffat2D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': Sersic2D,\nastropy\/modeling\/tests\/test_models_quantities.py:POWERLAW_MODELS = [\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': PowerLaw1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': BrokenPowerLaw1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': SmoothlyBrokenPowerLaw1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': ExponentialCutoffPowerLaw1D,\nastropy\/modeling\/tests\/test_models_quantities.py:{'class': LogParabola1D,\nastropy\/modeling\/tests\/test_models_quantities.py:POLY_MODELS = [\nastropy\/modeling\/tests\/test_models_quantities.py:    {'class': Polynomial1D,\nastropy\/modeling\/tests\/test_models_quantities.py:    {'class': Polynomial1D,\nastropy\/modeling\/tests\/test_models_quantities.py:    {'class': Polynomial1D,\nastropy\/modeling\/tests\/test_models_quantities.py:    {'class': Polynomial2D,\nastropy\/modeling\/tests\/test_models_quantities.py:    {'class': Polynomial2D,\nastropy\/modeling\/tests\/test_models_quantities.py:    {'class': Polynomial2D,\nastropy\/modeling\/tests\/test_models_quantities.py:MODELS = FUNC_MODELS_1D + FUNC_MODELS_2D + POWERLAW_MODELS\nastropy\/modeling\/tests\/test_models_quantities.py:SCIPY_MODELS = set([Sersic1D, Sersic2D, AiryDisk2D])\nastropy\/modeling\/tests\/test_models_quantities.py:@pytest.mark.parametrize('model', MODELS)\nastropy\/modeling\/tests\/test_models_quantities.py:    if not HAS_SCIPY and model['class'] in SCIPY_MODELS:\nastropy\/modeling\/tests\/test_models_quantities.py:            kwargs = OrderedDict(zip(('x', 'y'), args))\nastropy\/modeling\/tests\/test_models_quantities.py:            kwargs = OrderedDict(zip(('x', 'y', 'z'), args))\nastropy\/modeling\/tests\/test_models_quantities.py:@pytest.mark.parametrize('model', MODELS)\nastropy\/modeling\/tests\/test_models_quantities.py:    if not HAS_SCIPY and model['class'] in SCIPY_MODELS:\nastropy\/modeling\/tests\/test_models_quantities.py:@pytest.mark.parametrize('model', MODELS)\nastropy\/modeling\/tests\/test_models_quantities.py:    if not HAS_SCIPY and model['class'] in SCIPY_MODELS:\nastropy\/modeling\/tests\/test_models_quantities.py:@pytest.mark.parametrize('model', MODELS)\nastropy\/modeling\/tests\/test_models_quantities.py:    if not HAS_SCIPY and model['class'] in SCIPY_MODELS:\nastropy\/modeling\/tests\/test_models_quantities.py:@pytest.mark.parametrize('model', MODELS)\nastropy\/modeling\/tests\/test_models_quantities.py:    if not HAS_SCIPY and model['class'] in SCIPY_MODELS:\nastropy\/modeling\/tests\/test_models_quantities.py:@pytest.mark.parametrize('model', MODELS)\nastropy\/coordinates\/tests\/accuracy\/test_galactic_fk4.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_arrays.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_arrays.py:    Test transformation on coordinates with array content (first length-2 1D, then a 3D array)\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:from ..distances import Distance\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:    # Dec rotations\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:    # Done in xyz space because dec must be [-90,90]\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:m31_dist = Distance(770, u.kpc)\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:    catalog location of M31 from NED, via SkyOffsetFrames\nastropy\/coordinates\/tests\/test_skyoffset_transformations.py:    # TODO: remove this when the SkyOffsetFrame's support velocities\nastropy\/modeling\/tests\/test_fitters.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_fitters.py:from ..core import Fittable2DModel, Parameter\nastropy\/modeling\/tests\/test_fitters.py:_RANDOM_SEED = 0x1337\nastropy\/modeling\/tests\/test_fitters.py:class TestPolynomial2D:\nastropy\/modeling\/tests\/test_fitters.py:    \"\"\"Tests for 2D polynomail fitting.\"\"\"\nastropy\/modeling\/tests\/test_fitters.py:        self.model = models.Polynomial2D(2)\nastropy\/modeling\/tests\/test_fitters.py:    def test_poly2D_fitting(self):\nastropy\/modeling\/tests\/test_fitters.py:    def test_polynomial2D_nonlinear_fitting(self):\nastropy\/modeling\/tests\/test_fitters.py:class TestICheb2D:\nastropy\/modeling\/tests\/test_fitters.py:    Tests 2D Chebyshev polynomial fitting\nastropy\/modeling\/tests\/test_fitters.py:    Create a 2D polynomial (z) using Polynomial2DModel and default coefficients\nastropy\/modeling\/tests\/test_fitters.py:    Fit z using a ICheb2D model\nastropy\/modeling\/tests\/test_fitters.py:    Evaluate the ICheb2D polynomial and compare with the initial z\nastropy\/modeling\/tests\/test_fitters.py:        self.pmodel = models.Polynomial2D(2)\nastropy\/modeling\/tests\/test_fitters.py:        self.cheb2 = models.Chebyshev2D(2, 2)\nastropy\/modeling\/tests\/test_fitters.py:    def test_poly2D_cheb2D(self):\nastropy\/modeling\/tests\/test_fitters.py:    def test_chebyshev2D_nonlinear_fitting(self):\nastropy\/modeling\/tests\/test_fitters.py:        cheb2d = models.Chebyshev2D(2, 2)\nastropy\/modeling\/tests\/test_fitters.py:    def test_chebyshev2D_nonlinear_fitting_with_weights(self):\nastropy\/modeling\/tests\/test_fitters.py:        cheb2d = models.Chebyshev2D(2, 2)\nastropy\/modeling\/tests\/test_fitters.py:        self.g1 = models.Gaussian1D(10, mean=14.9, stddev=.3)\nastropy\/modeling\/tests\/test_fitters.py:        self.g2 = models.Gaussian1D(10, mean=13, stddev=.4)\nastropy\/modeling\/tests\/test_fitters.py:        with NumpyRNGContext(_RANDOM_SEED):\nastropy\/modeling\/tests\/test_fitters.py:    def test_chebyshev1D(self):\nastropy\/modeling\/tests\/test_fitters.py:        \"\"\"Tests fitting a 1D Chebyshev polynomial to some real world data.\"\"\"\nastropy\/modeling\/tests\/test_fitters.py:        initial_model = models.Chebyshev1D(order - 1,\nastropy\/modeling\/tests\/test_fitters.py:        init_model = models.Polynomial1D(degree=2, c0=[1, 1], n_models=2)\nastropy\/modeling\/tests\/test_fitters.py:        with NumpyRNGContext(_RANDOM_SEED):\nastropy\/modeling\/tests\/test_fitters.py:        \"\"\"Tests fitted multiple 2-D models simultaneously.\"\"\"\nastropy\/modeling\/tests\/test_fitters.py:        init_model = models.Polynomial2D(degree=2, c0_0=[1, 1], n_models=2)\nastropy\/modeling\/tests\/test_fitters.py:        with NumpyRNGContext(_RANDOM_SEED):\nastropy\/modeling\/tests\/test_fitters.py:        init_model = models.Polynomial1D(degree=2, c1=1)\nastropy\/modeling\/tests\/test_fitters.py:        init_model = models.Polynomial1D(degree=2, c1=[1, -2], n_models=2)\nastropy\/modeling\/tests\/test_fitters.py:        init_model = models.Polynomial2D(degree=2, c1_0=[1, 2], c0_1=[-0.5, 1],\nastropy\/modeling\/tests\/test_fitters.py:        with NumpyRNGContext(_RANDOM_SEED):\nastropy\/modeling\/tests\/test_fitters.py:        self.gauss = models.Gaussian1D(100, 5, stddev=1)\nastropy\/modeling\/tests\/test_fitters.py:        `Gaussian1D`.\nastropy\/modeling\/tests\/test_fitters.py:        g1e = models.Gaussian1D(100, 5.0, stddev=1)\nastropy\/modeling\/tests\/test_fitters.py:        `Gaussian1D`.\nastropy\/modeling\/tests\/test_fitters.py:        g1e = models.Gaussian1D(100, 5.0, stddev=1)\nastropy\/modeling\/tests\/test_fitters.py:        g1 = models.Gaussian1D(100, 5, stddev=1)\nastropy\/modeling\/tests\/test_fitters.py:        class Rosenbrock(Fittable2DModel):\nastropy\/modeling\/tests\/test_fitters.py:        with NumpyRNGContext(_RANDOM_SEED):\nastropy\/modeling\/tests\/test_fitters.py:        with NumpyRNGContext(_RANDOM_SEED):\nastropy\/modeling\/tests\/test_fitters.py:        mod = models.Linear1D(a, b)\nastropy\/modeling\/tests\/test_fitters.py:class Test1DFittingWithOutlierRemoval:\nastropy\/modeling\/tests\/test_fitters.py:        g_init = models.Gaussian1D(amplitude=1., mean=0, stddev=1.)\nastropy\/modeling\/tests\/test_fitters.py:class Test2DFittingWithOutlierRemoval:\nastropy\/modeling\/tests\/test_fitters.py:        def Gaussian_2D(p, pos):\nastropy\/modeling\/tests\/test_fitters.py:        self.z = Gaussian_2D(self.model_params, np.array([self.y, self.x]))\nastropy\/modeling\/tests\/test_fitters.py:        g2_init = models.Gaussian2D(amplitude=guess[0], x_mean=guess[1],\nastropy\/modeling\/tests\/test_fitters.py:    with NumpyRNGContext(_RANDOM_SEED):\nastropy\/modeling\/tests\/test_fitters.py:    g2 = models.Gaussian2D(10, 10, 9, 2, 3)\nastropy\/modeling\/tests\/test_fitters.py:    gmod = fitter(models.Gaussian2D(15, 7, 8, 1.3, 1.2), Xin, Yin, z + zsig)\nastropy\/modeling\/tests\/test_fitters.py:    p2 = models.Polynomial2D(3)\nastropy\/modeling\/tests\/test_fitters.py:    pmod = fitter(models.Polynomial2D(3), Xin, Yin, z + zsig)\nastropy\/modeling\/tests\/test_fitters.py:    model = models.Gaussian1D(10, 4, .3)\nastropy\/coordinates\/tests\/test_unit_representation.py:from collections import OrderedDict\nastropy\/coordinates\/tests\/test_unit_representation.py:        attr_classes = OrderedDict([('lon', Longitude180),\nastropy\/coordinates\/tests\/test_unit_representation.py:        attr_classes = OrderedDict([('lon', Longitude180),\nastropy\/modeling\/tests\/test_utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_utils.py:from ..models import Ellipse2D\nastropy\/modeling\/tests\/test_utils.py:# TODO: It might prove useful to implement a simple expression parser to build\nastropy\/modeling\/tests\/test_utils.py:    model = Ellipse2D(amplitude, x0, y0, a, b, theta)\nastropy\/time\/tests\/test_corrs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_corrs.py:from .. import Time, TimeDelta\nastropy\/time\/tests\/test_corrs.py:        assert isinstance(hval, TimeDelta)\nastropy\/time\/tests\/test_corrs.py:        assert isinstance(bval, TimeDelta)\nastropy\/coordinates\/funcs.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/funcs.py:    Converts 3D rectangular cartesian coordinates to spherical polar\nastropy\/coordinates\/funcs.py:    Determines the location of the sun at a given time (or times, if the input\nastropy\/coordinates\/funcs.py:    Determines the constellation(s) a given coordinate object contains.\nastropy\/coordinates\/funcs.py:    to B1875, and then uses the Delporte boundaries of the 88 modern\nastropy\/modeling\/tests\/test_constraints.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_constraints.py:from ..core import Fittable1DModel\nastropy\/modeling\/tests\/test_constraints.py:        self.g1 = models.Gaussian1D(10, 14.9, stddev=.3)\nastropy\/modeling\/tests\/test_constraints.py:        self.g2 = models.Gaussian1D(10, 13, stddev=.4)\nastropy\/modeling\/tests\/test_constraints.py:        g1 = models.Gaussian1D(10, mean=14.9, stddev=.3,\nastropy\/modeling\/tests\/test_constraints.py:        g1 = models.Gaussian1D(10, mean=14.9, stddev=.3, tied={'mean': tied})\nastropy\/modeling\/tests\/test_constraints.py:        g1 = models.Gaussian1D(10, 14.9, stddev=.3)\nastropy\/modeling\/tests\/test_constraints.py:        g2 = models.Gaussian1D(10, 13, stddev=.4)\nastropy\/modeling\/tests\/test_constraints.py:        g1 = models.Gaussian1D(9.9, 14.5, stddev=.3)\nastropy\/modeling\/tests\/test_constraints.py:        line_model = models.Linear1D(guess_slope, guess_intercept,\nastropy\/modeling\/tests\/test_constraints.py:        line_model = models.Linear1D(guess_slope, guess_intercept,\nastropy\/modeling\/tests\/test_constraints.py:        gauss = models.Gaussian2D(amplitude=10., x_mean=5., y_mean=5.,\nastropy\/modeling\/tests\/test_constraints.py:        gauss = models.Gaussian2D(amplitude=10., x_mean=5., y_mean=5.,\nastropy\/modeling\/tests\/test_constraints.py:        self.p1 = models.Polynomial1D(4)\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1)\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1,\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1)\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1,\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1,\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1,\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1,\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1)\nastropy\/modeling\/tests\/test_constraints.py:    gauss = models.Gaussian1D(amplitude=20, mean=2, stddev=1,\nastropy\/modeling\/tests\/test_constraints.py:    class MyModel(Fittable1DModel):\nastropy\/modeling\/tests\/test_constraints.py:    m = models.Gaussian1D(amplitude=3, mean=4, stddev=1,\nastropy\/modeling\/tests\/test_constraints.py:    class MyModel(Fittable1DModel):\nastropy\/modeling\/tests\/test_constraints.py:    # This is 2D Gaussian with noise to be fitted, as provided by @ysBach\nastropy\/modeling\/tests\/test_constraints.py:    g_init = models.Gaussian2D(x_mean=8, y_mean=8)\nastropy\/modeling\/models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/models.py:from .blackbody import BlackBody1D\nastropy\/modeling\/models.py:CONSTRAINTS_DOC = \"\"\"\nastropy\/modeling\/models.py:MODELS_WITH_CONSTRAINTS = [\nastropy\/modeling\/models.py:    AiryDisk2D, Moffat1D, Moffat2D, Box1D, Box2D,\nastropy\/modeling\/models.py:    Const1D, Const2D, Ellipse2D, Disk2D,\nastropy\/modeling\/models.py:    Gaussian1D, Gaussian2D,\nastropy\/modeling\/models.py:    Linear1D, Lorentz1D, MexicanHat1D, MexicanHat2D,\nastropy\/modeling\/models.py:    PowerLaw1D, Sersic1D, Sersic2D, Sine1D, Trapezoid1D, TrapezoidDisk2D,\nastropy\/modeling\/models.py:    Chebyshev1D, Chebyshev2D, Hermite1D, Hermite2D, Legendre2D, Legendre1D,\nastropy\/modeling\/models.py:    Polynomial1D, Polynomial2D, Voigt1D\nastropy\/modeling\/models.py:for item in MODELS_WITH_CONSTRAINTS:\nastropy\/modeling\/models.py:        item.__doc__ += CONSTRAINTS_DOC\nastropy\/time\/tests\/test_ut1.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_ut1.py:        assert status == iers.FROM_IERS_A_PREDICTION\nastropy\/time\/tests\/test_ut1.py:        assert status == iers.FROM_IERS_A_PREDICTION\nastropy\/modeling\/tests\/test_rotations.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/test_rotations.py:    w.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/modeling\/tests\/test_rotations.py:def test_Rotation2D():\nastropy\/modeling\/tests\/test_rotations.py:    model = models.Rotation2D(angle=90)\nastropy\/modeling\/tests\/test_rotations.py:def test_Rotation2D_inverse():\nastropy\/modeling\/tests\/test_rotations.py:    model = models.Rotation2D(angle=234.23494)\nastropy\/coordinates\/tests\/test_distance.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_distance.py:This includes tests for the Distance class and related calculations\nastropy\/coordinates\/tests\/test_distance.py:from .. import Longitude, Latitude, Distance, CartesianRepresentation\nastropy\/coordinates\/tests\/test_distance.py:    Distances can also be specified, and allow for a full 3D definition of a\nastropy\/coordinates\/tests\/test_distance.py:    # try all the different ways to initialize a Distance\nastropy\/coordinates\/tests\/test_distance.py:    distance = Distance(12, u.parsec)\nastropy\/coordinates\/tests\/test_distance.py:    Distance(40, unit=u.au)\nastropy\/coordinates\/tests\/test_distance.py:    Distance(value=5, unit=u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:        Distance(12)\nastropy\/coordinates\/tests\/test_distance.py:    # 3D position\nastropy\/coordinates\/tests\/test_distance.py:                 distance=Distance(12, u.parsec))\nastropy\/coordinates\/tests\/test_distance.py:    # c.distance = Distance(z=0.2)  # uses current cosmology\nastropy\/coordinates\/tests\/test_distance.py:    # c.distance = Distance(z=0.2, cosmology=WMAP5)\nastropy\/coordinates\/tests\/test_distance.py:    assert isinstance(sep12, Distance)\nastropy\/coordinates\/tests\/test_distance.py:    # TODO: choose between these when CartesianRepresentation gets a definite\nastropy\/coordinates\/tests\/test_distance.py:    # try different ways to initialize a Distance\nastropy\/coordinates\/tests\/test_distance.py:    d4 = Distance(z=0.23)  # uses default cosmology - as of writing, WMAP7\nastropy\/coordinates\/tests\/test_distance.py:    d5 = Distance(z=0.23, cosmology=WMAP5)\nastropy\/coordinates\/tests\/test_distance.py:    d6 = Distance(z=0.23, cosmology=WMAP5, unit=u.km)\nastropy\/coordinates\/tests\/test_distance.py:    c1 = ICRS(ra, dec, Distance(1, unit=u.kpc))\nastropy\/coordinates\/tests\/test_distance.py:        c1.distance = Distance(2, unit=u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:    c2 = ICRS(ra, dec, Distance(2, unit=u.kpc))\nastropy\/coordinates\/tests\/test_distance.py:    Distance(2 * u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance([2, 3.1], u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance([2 * u.kpc, 250. * u.pc])\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance(10, u.pc)\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance(distmod=20)\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance(distmod=-1., unit=u.au)\nastropy\/coordinates\/tests\/test_distance.py:        d = Distance(value=d, distmod=20)\nastropy\/coordinates\/tests\/test_distance.py:        d = Distance(z=.23, distmod=20)\nastropy\/coordinates\/tests\/test_distance.py:    assert Distance(distmod=1).unit == u.pc\nastropy\/coordinates\/tests\/test_distance.py:    assert Distance(distmod=11).unit == u.kpc\nastropy\/coordinates\/tests\/test_distance.py:    assert Distance(distmod=26).unit == u.Mpc\nastropy\/coordinates\/tests\/test_distance.py:    assert Distance(distmod=-21).unit == u.AU\nastropy\/coordinates\/tests\/test_distance.py:    assert Distance(distmod=[1, 11, 26]).unit == u.kpc\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance(parallax=1*u.arcsecond)\nastropy\/coordinates\/tests\/test_distance.py:        d = Distance(15*u.pc, parallax=20*u.milliarcsecond)\nastropy\/coordinates\/tests\/test_distance.py:        d = Distance(parallax=20*u.milliarcsecond, distmod=20)\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance(parallax=plx)\nastropy\/coordinates\/tests\/test_distance.py:        Distance([-2, 3.1], u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:        Distance([-2, -3.1], u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:        Distance(-2, u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance(-2, u.kpc, allow_negative=True)\nastropy\/coordinates\/tests\/test_distance.py:    a = Distance(15*u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:    b = Distance(15*u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:    c = Distance(1.*u.Mpc)\nastropy\/coordinates\/tests\/test_distance.py:    d = Distance(15*u.kpc)\nastropy\/coordinates\/tests\/test_distance.py:    assert isinstance(twice, Distance)\nastropy\/coordinates\/tests\/test_distance.py:    assert not isinstance(area, Distance)\nastropy\/extern\/configobj\/validate.py:# Michael Foord: fuzzyman AT voidspace DOT org DOT uk\nastropy\/extern\/configobj\/validate.py:# Mark Andrews: mark AT la-la DOT com\nastropy\/extern\/configobj\/validate.py:# Nicola Larosa: nico AT tekNico DOT net\nastropy\/extern\/configobj\/validate.py:# Rob Dennis: rdennis AT gmail DOT com\nastropy\/extern\/configobj\/validate.py:# Eli Courtwright: eli AT courtwright DOT org\nastropy\/extern\/configobj\/validate.py:# This software is licensed under the terms of the BSD license.\nastropy\/extern\/configobj\/validate.py:# http:\/\/opensource.org\/licenses\/BSD-3-Clause\nastropy\/extern\/configobj\/validate.py:# https:\/\/github.com\/DiffSK\/configobj\nastropy\/extern\/configobj\/validate.py:    'numToDottedQuad',\nastropy\/extern\/configobj\/validate.py:#TODO - #21 - six is part of the repo now, but we didn't switch over to it here\nastropy\/extern\/configobj\/validate.py:''', re.VERBOSE | re.DOTALL)    # two groups\nastropy\/extern\/configobj\/validate.py:''', re.VERBOSE | re.DOTALL)    # one group\nastropy\/extern\/configobj\/validate.py:def numToDottedQuad(num):\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(long(-1))\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(long(1))\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(long(16777218))\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(long(16908291))\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(long(16909060))\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(long(4294967295))\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(long(4294967296))\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(-1)\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(1)\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(16777218)\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(16908291)\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(16909060)\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(4294967295)\nastropy\/extern\/configobj\/validate.py:    >>> numToDottedQuad(4294967296)\nastropy\/extern\/configobj\/validate.py:    _func_re = re.compile(r'(.+?)\\((.*)\\)', re.DOTALL)\nastropy\/extern\/configobj\/validate.py:    _key_arg = re.compile(r'^([a-zA-Z_][a-zA-Z0-9_]*)\\s*=\\s*(.*)$',  re.DOTALL)\nastropy\/extern\/configobj\/validate.py:    _paramfinder = re.compile(_paramstring, re.VERBOSE | re.DOTALL)\nastropy\/extern\/configobj\/validate.py:    _matchfinder = re.compile(_matchstring, re.VERBOSE | re.DOTALL)\nastropy\/extern\/configobj\/validate.py:        # Default must be deleted if the value is specified too,\nastropy\/extern\/configobj\/validate.py:        Dummy check that always passes\nastropy\/extern\/configobj\/validate.py:        optionflags=doctest.IGNORE_EXCEPTION_DETAIL | doctest.ELLIPSIS)\nastropy\/coordinates\/sites.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_basic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/time\/tests\/test_basic.py:        # (internal JD1 and JD1 are now with respect to TT scale)\"\"\"\nastropy\/time\/tests\/test_basic.py:        TDB, TT, UT1, UTC).  This requires auxiliary information (latitude and\nastropy\/time\/tests\/test_basic.py:        \"\"\"Test that all transforms work.  Does not test correctness,\nastropy\/time\/tests\/test_basic.py:        Time('2000-01-01T12:23:34.0(TDB)', format='fits')\nastropy\/time\/tests\/test_basic.py:            # Delta time gives 2 seconds here as expected\nastropy\/time\/tests\/test_basic.py:        \"\"\"Year:Day_of_year format\"\"\"\nastropy\/time\/tests\/test_basic.py:        # Value take from Chandra.Time.DateTime('2010:001:00:00:00').secs\nastropy\/time\/tests\/test_basic.py:        assert 'bad day    (JD computed)' in str(w[0].message)\nastropy\/modeling\/functional_models.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/functional_models.py:from collections import OrderedDict\nastropy\/modeling\/functional_models.py:from .core import (Fittable1DModel, Fittable2DModel,\nastropy\/modeling\/functional_models.py:                   ModelDefinitionError)\nastropy\/modeling\/functional_models.py:__all__ = ['AiryDisk2D', 'Moffat1D', 'Moffat2D', 'Box1D', 'Box2D', 'Const1D',\nastropy\/modeling\/functional_models.py:           'Const2D', 'Ellipse2D', 'Disk2D', 'Gaussian1D',\nastropy\/modeling\/functional_models.py:           'Gaussian2D', 'Linear1D', 'Lorentz1D',\nastropy\/modeling\/functional_models.py:           'MexicanHat1D', 'MexicanHat2D', 'RedshiftScaleFactor',\nastropy\/modeling\/functional_models.py:           'Scale', 'Sersic1D', 'Sersic2D', 'Shift', 'Sine1D', 'Trapezoid1D',\nastropy\/modeling\/functional_models.py:           'TrapezoidDisk2D', 'Ring2D', 'Voigt1D']\nastropy\/modeling\/functional_models.py:class Gaussian1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,\nastropy\/modeling\/functional_models.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)\nastropy\/modeling\/functional_models.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,\nastropy\/modeling\/functional_models.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Gaussian1D\nastropy\/modeling\/functional_models.py:        s1 = Gaussian1D()\nastropy\/modeling\/functional_models.py:    Gaussian2D, Box1D, Moffat1D, Lorentz1D\nastropy\/modeling\/functional_models.py:        >>> from astropy.modeling.models import Gaussian1D\nastropy\/modeling\/functional_models.py:        >>> model = Gaussian1D(mean=0, stddev=2)\nastropy\/modeling\/functional_models.py:        Gaussian1D model function.\nastropy\/modeling\/functional_models.py:        Gaussian1D model function derivatives.\nastropy\/modeling\/functional_models.py:        return OrderedDict([('mean', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Gaussian2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    See [1]_ for more details about the 2D Gaussian function.\nastropy\/modeling\/functional_models.py:    Gaussian1D, Box2D, Moffat2D\nastropy\/modeling\/functional_models.py:                    # TODO: Maybe it should be possible for the covariance matrix\nastropy\/modeling\/functional_models.py:        # TODO: Investigate why setting this in Parameter above causes\nastropy\/modeling\/functional_models.py:        >>> from astropy.modeling.models import Gaussian2D\nastropy\/modeling\/functional_models.py:        >>> model = Gaussian2D(x_mean=0, y_mean=0, x_stddev=1, y_stddev=2)\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_mean', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Shift(Fittable1DModel):\nastropy\/modeling\/functional_models.py:class Scale(Fittable1DModel):\nastropy\/modeling\/functional_models.py:class RedshiftScaleFactor(Fittable1DModel):\nastropy\/modeling\/functional_models.py:class Sersic1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Gaussian1D, Moffat1D, Lorentz1D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Sersic1D\nastropy\/modeling\/functional_models.py:        s1 = Sersic1D(amplitude=1, r_eff=5)\nastropy\/modeling\/functional_models.py:                raise ImportError('Sersic1D model requires scipy > 0.11.')\nastropy\/modeling\/functional_models.py:        return OrderedDict([('r_eff', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Sine1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Const1D, Linear1D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Sine1D\nastropy\/modeling\/functional_models.py:        s1 = Sine1D(amplitude=1, frequency=.25)\nastropy\/modeling\/functional_models.py:        return OrderedDict([('frequency', inputs_unit['x'] ** -1),\nastropy\/modeling\/functional_models.py:class Linear1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Const1D\nastropy\/modeling\/functional_models.py:        return OrderedDict([('intercept', outputs_unit['y']),\nastropy\/modeling\/functional_models.py:class Planar2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Linear1D, Polynomial2D\nastropy\/modeling\/functional_models.py:class Lorentz1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Gaussian1D, Box1D, MexicanHat1D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Lorentz1D\nastropy\/modeling\/functional_models.py:        s1 = Lorentz1D()\nastropy\/modeling\/functional_models.py:            Default is chosen to include most (99%) of the\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Voigt1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Gaussian1D, Lorentz1D\nastropy\/modeling\/functional_models.py:    McLean, A. B., Mitchell, C. E. J. & Swanston, D. M. Implementation of an\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Voigt1D\nastropy\/modeling\/functional_models.py:        v1 = Voigt1D(x_0=5, amplitude_L=10, fwhm_L=0.5, fwhm_G=0.9)\nastropy\/modeling\/functional_models.py:        [0.0210, -1.1858, -0.0210, 1.1858]])   # D\nastropy\/modeling\/functional_models.py:        A, B, C, D = cls._abcd\nastropy\/modeling\/functional_models.py:        V = np.sum((C * (Y - A) + D * (X - B))\/(((Y - A) ** 2 + (X - B) ** 2)), axis=-1)\nastropy\/modeling\/functional_models.py:        A, B, C, D = cls._abcd\nastropy\/modeling\/functional_models.py:        alpha = C * (Y - A) + D * (X - B)\nastropy\/modeling\/functional_models.py:        dVdx = np.sum((D\/beta - 2 * (X - B) * alpha \/ np.square(beta)), axis=-1)\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Const1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Const2D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Const1D\nastropy\/modeling\/functional_models.py:        s1 = Const1D()\nastropy\/modeling\/functional_models.py:        return OrderedDict([('amplitude', outputs_unit['y'])])\nastropy\/modeling\/functional_models.py:class Const2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Const1D\nastropy\/modeling\/functional_models.py:        return OrderedDict([('amplitude', outputs_unit['z'])])\nastropy\/modeling\/functional_models.py:class Ellipse2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    A 2D Ellipse model.\nastropy\/modeling\/functional_models.py:    Disk2D, Box2D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Ellipse2D\nastropy\/modeling\/functional_models.py:        e = Ellipse2D(amplitude=100., x_0=x0, y_0=y0, a=a, b=b,\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Disk2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Two dimensional radial symmetric Disk model.\nastropy\/modeling\/functional_models.py:    Box2D, TrapezoidDisk2D\nastropy\/modeling\/functional_models.py:        \"\"\"Two dimensional Disk model function\"\"\"\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Ring2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Disk2D, TrapezoidDisk2D\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Delta1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    \"\"\"One dimensional Dirac delta function.\"\"\"\nastropy\/modeling\/functional_models.py:        raise ModelDefinitionError(\"Not implemented\")\nastropy\/modeling\/functional_models.py:class Delta2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    \"\"\"Two dimensional Dirac delta function.\"\"\"\nastropy\/modeling\/functional_models.py:        raise ModelDefinitionError(\"Not implemented\")\nastropy\/modeling\/functional_models.py:class Box1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Box2D, TrapezoidDisk2D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Box1D\nastropy\/modeling\/functional_models.py:        s1 = Box1D()\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Box2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Box1D, Gaussian2D, Moffat2D\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Trapezoid1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Box1D, Gaussian1D, Moffat1D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Trapezoid1D\nastropy\/modeling\/functional_models.py:        s1 = Trapezoid1D()\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class TrapezoidDisk2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Disk2D, Box2D\nastropy\/modeling\/functional_models.py:        \"\"\"Two dimensional Trapezoid Disk model function\"\"\"\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class MexicanHat1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    MexicanHat2D, Box1D, Gaussian1D, Trapezoid1D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import MexicanHat1D\nastropy\/modeling\/functional_models.py:        s1 = MexicanHat1D()\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class MexicanHat2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    MexicanHat1D, Gaussian2D\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class AiryDisk2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Box2D, TrapezoidDisk2D, Gaussian2D\nastropy\/modeling\/functional_models.py:    limiting angular resolution and is approximately 1.22 * lambda \/ D,\nastropy\/modeling\/functional_models.py:    where lambda is the wavelength of the light and D is the diameter of\nastropy\/modeling\/functional_models.py:                raise ImportError('AiryDisk2D model requires scipy > 0.11.')\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Moffat1D(Fittable1DModel):\nastropy\/modeling\/functional_models.py:    Gaussian1D, Box1D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Moffat1D\nastropy\/modeling\/functional_models.py:        s1 = Moffat1D()\nastropy\/modeling\/functional_models.py:        Derivation of the formula is available in\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Moffat2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Gaussian2D, Box2D\nastropy\/modeling\/functional_models.py:        Derivation of the formula is available in\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/modeling\/functional_models.py:class Sersic2D(Fittable2DModel):\nastropy\/modeling\/functional_models.py:    Gaussian2D, Moffat2D\nastropy\/modeling\/functional_models.py:        from astropy.modeling.models import Sersic2D\nastropy\/modeling\/functional_models.py:        mod = Sersic2D(amplitude = 1, r_eff = 25, n=4, x_0=50, y_0=50,\nastropy\/modeling\/functional_models.py:                raise ImportError('Sersic2D model requires scipy > 0.11.')\nastropy\/modeling\/functional_models.py:        return OrderedDict([('x_0', inputs_unit['x']),\nastropy\/coordinates\/tests\/test_velocity_corrs.py:    ##   HJD          VOBS   VHELIO     VLSR   VDIURNAL   VLUNAR  VANNUAL   VSOLAR\nastropy\/extern\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/__init__.py:See the README.rst in this directory of the Astropy source repository for more\nastropy\/modeling\/separable.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/separable.py:from .core import Model, _CompoundModel, ModelDefinitionError\nastropy\/modeling\/separable.py:    >>> from astropy.modeling.models import Shift, Scale, Rotation2D, Polynomial2D\nastropy\/modeling\/separable.py:    >>> is_separable(Shift(1) & Shift(2) | Rotation2D(2))\nastropy\/modeling\/separable.py:        Polynomial2D(1) & Polynomial2D(2))\nastropy\/modeling\/separable.py:        raise ModelDefinitionError(\nastropy\/modeling\/separable.py:        raise ModelDefinitionError(\nastropy\/modeling\/core.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/core.py:from collections import defaultdict, OrderedDict\nastropy\/modeling\/core.py:                     InheritDocstrings, OrderedDescriptorContainer,\nastropy\/modeling\/core.py:from ..utils.exceptions import AstropyDeprecationWarning\nastropy\/modeling\/core.py:                    ExpressionTree, AliasDict, get_inputs_and_params,\nastropy\/modeling\/core.py:__all__ = ['Model', 'FittableModel', 'Fittable1DModel', 'Fittable2DModel',\nastropy\/modeling\/core.py:           'custom_model', 'ModelDefinitionError']\nastropy\/modeling\/core.py:class ModelDefinitionError(TypeError):\nastropy\/modeling\/core.py:class _ModelMeta(OrderedDescriptorContainer, InheritDocstrings, abc.ABCMeta):\nastropy\/modeling\/core.py:    # Default empty dict for _parameters_, which will be empty on model\nastropy\/modeling\/core.py:    _parameters_ = OrderedDict()\nastropy\/modeling\/core.py:        # Make sure OrderedDescriptorContainer gets to run before doing\nastropy\/modeling\/core.py:            # Delete any ABC-related attributes--these will be restored when\nastropy\/modeling\/core.py:            # Delete custom __init__ and __call__ if they exist:\nastropy\/modeling\/core.py:            >>> from astropy.modeling.models import Rotation2D\nastropy\/modeling\/core.py:            >>> SkyRotation = Rotation2D.rename('SkyRotation')\nastropy\/modeling\/core.py:            Name: SkyRotation (Rotation2D)\nastropy\/modeling\/core.py:            >>> issubclass(SkyRotation, Rotation2D)\nastropy\/modeling\/core.py:            >>> isinstance(r, Rotation2D)\nastropy\/modeling\/core.py:        # TODO: Much of this is verbatim from _create_inverse_property--I feel\nastropy\/modeling\/core.py:                raise ModelDefinitionError(exc.args[0])\nastropy\/modeling\/core.py:            # TODO: Maybe warn in the above case?\nastropy\/modeling\/core.py:        # TODO: Might be convenient if calling the bounding box also\nastropy\/modeling\/core.py:                raise ModelDefinitionError(\nastropy\/modeling\/core.py:            # Don't create a custom __call__ for classes that already have one\nastropy\/modeling\/core.py:        Dictionary ``{parameter_name: bool}`` setting the fixed constraint\nastropy\/modeling\/core.py:        Dictionary ``{parameter_name: callable}`` of parameters which are\nastropy\/modeling\/core.py:        Dictionary ``{parameter_name: value}`` of lower and upper bounds of\nastropy\/modeling\/core.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,\nastropy\/modeling\/core.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)\nastropy\/modeling\/core.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,\nastropy\/modeling\/core.py:    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)\nastropy\/modeling\/core.py:    meta = metadata.MetaData()\nastropy\/modeling\/core.py:    # Default n_models attribute, so that __len__ is still defined even when a\nastropy\/modeling\/core.py:    # Default equivalencies to apply to input values. If set, this should be a\nastropy\/modeling\/core.py:        * for 1D: ``(x_low, x_high)``\nastropy\/modeling\/core.py:        * for 2D: ``((y_low, y_high), (x_low, x_high))``\nastropy\/modeling\/core.py:        * for 3D: ``((z_low, z_high), (y_low, y_high), (x_low, x_high))``\nastropy\/modeling\/core.py:        Setting the ``bounding_box`` limits for a 1D and 2D model:\nastropy\/modeling\/core.py:        >>> from astropy.modeling.models import Gaussian1D, Gaussian2D\nastropy\/modeling\/core.py:        >>> model_1d = Gaussian1D()\nastropy\/modeling\/core.py:        >>> model_2d = Gaussian2D(x_stddev=1, y_stddev=1)\nastropy\/modeling\/core.py:        Setting the bounding_box limits for a user-defined 3D `custom_model`:\nastropy\/modeling\/core.py:        >>> Const3D = custom_model(const3d)\nastropy\/modeling\/core.py:        >>> model_3d = Const3D()\nastropy\/modeling\/core.py:        >>> model_1d.bounding_box  # doctest: +IGNORE_EXCEPTION_DETAIL\nastropy\/modeling\/core.py:            # TODO: Ensure that negative model_set_axis arguments are respected\nastropy\/modeling\/core.py:            constraints[cons_type] = AliasDict(orig, aliases)\nastropy\/modeling\/core.py:                # Default to zero\nastropy\/modeling\/core.py:        # Determine the number of model sets: If the model_set_axis is\nastropy\/modeling\/core.py:        # TODO: This is a bit ugly, but easier to deal with than how this was\nastropy\/modeling\/core.py:            # into separate objects.  Doing things this way ensures a 1-D\nastropy\/modeling\/core.py:        # TODO: Returning an array from this method may be entirely pointless\nastropy\/modeling\/core.py:        # TODO: I think this could be reworked to preset model sets better\nastropy\/modeling\/core.py:class Fittable1DModel(FittableModel):\nastropy\/modeling\/core.py:class Fittable2DModel(FittableModel):\nastropy\/modeling\/core.py:# TODO: Support a couple unary operators--at least negation?\nastropy\/modeling\/core.py:_ORDER_OF_OPERATORS = [('|',), ('&',), ('+', '-'), ('*', '\/'), ('**',)]\nastropy\/modeling\/core.py:OPERATOR_PRECEDENCE = {}\nastropy\/modeling\/core.py:for idx, ops in enumerate(_ORDER_OF_OPERATORS):\nastropy\/modeling\/core.py:        OPERATOR_PRECEDENCE[op] = idx\nastropy\/modeling\/core.py:            # Delete _evaluate from the members dict\nastropy\/modeling\/core.py:    # TODO: Maybe we could use make_function_with_signature for evaluate, but\nastropy\/modeling\/core.py:    # TODO: This supports creating a new compound model from two existing\nastropy\/modeling\/core.py:                cm1 = Gaussian1D(1, 5, .1) + Gaussian1D()\nastropy\/modeling\/core.py:            # TODO: Any effort to restructure the tree-like data structure for\nastropy\/modeling\/core.py:        # TODO: These aren't the full rules for handling inputs and outputs, but\nastropy\/modeling\/core.py:                raise ModelDefinitionError(\nastropy\/modeling\/core.py:                raise ModelDefinitionError(\nastropy\/modeling\/core.py:        TODO: Consider fixing things so the aforementioned class-based case\nastropy\/modeling\/core.py:    # TODO: Perhaps, just perhaps, the post-order (or ???-order) ordering of\nastropy\/modeling\/core.py:        # TODO: I'm not 100% happy with this design, and maybe we need some\nastropy\/modeling\/core.py:                # TODO: Reevaluate this if it turns out to be confusing, though\nastropy\/modeling\/core.py:        # TODO: At some point might be useful to make a public version of this,\nastropy\/modeling\/core.py:        return cls._tree.format_expression(OPERATOR_PRECEDENCE)\nastropy\/modeling\/core.py:    # TODO: The way this works is highly inefficient--the inverse is created by\nastropy\/modeling\/core.py:    Define a sinusoidal model function as a custom 1D model::\nastropy\/modeling\/core.py:    The next example demonstrates a 2D Moffat function model, and also\nastropy\/modeling\/core.py:        ... def Moffat2D(x, y, amplitude=1.0, x_0=0.0, y_0=0.0, gamma=1.0,\nastropy\/modeling\/core.py:        >>> print(Moffat2D.__doc__)\nastropy\/modeling\/core.py:        >>> model = Moffat2D()\nastropy\/modeling\/core.py:            AstropyDeprecationWarning)\nastropy\/modeling\/core.py:        raise ModelDefinitionError(\nastropy\/modeling\/core.py:        raise ModelDefinitionError(\nastropy\/modeling\/core.py:        raise ModelDefinitionError(\"derivative function should accept \"\nastropy\/modeling\/core.py:    # TODO: Maybe have a clever scheme for default output name?\nastropy\/modeling\/core.py:        # Ensure that array scalars are always upgrade to 1-D arrays for the\nastropy\/utils\/collections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/ply\/cpp.py:# Author:  David Beazley (http:\/\/www.dabeaz.com)\nastropy\/extern\/ply\/cpp.py:# Default preprocessor lexer definitions.   These tokens are enough to get\nastropy\/extern\/ply\/cpp.py:   'CPP_ID','CPP_INTEGER', 'CPP_FLOAT', 'CPP_STRING', 'CPP_CHAR', 'CPP_WS', 'CPP_COMMENT1', 'CPP_COMMENT2', 'CPP_POUND','CPP_DPOUND'\nastropy\/extern\/ply\/cpp.py:t_CPP_POUND = r'\\#'\nastropy\/extern\/ply\/cpp.py:t_CPP_DPOUND = r'\\#\\#'\nastropy\/extern\/ply\/cpp.py:t_CPP_ID = r'[A-Za-z_][\\w_]*'\nastropy\/extern\/ply\/cpp.py:        self.define(\"__DATE__ \\\"%s\\\"\" % time.strftime(\"%b %d %Y\",tm))\nastropy\/extern\/ply\/cpp.py:        # Determine the token type for identifiers\nastropy\/extern\/ply\/cpp.py:            self.t_ID = tok.type\nastropy\/extern\/ply\/cpp.py:        # Determine the token type for integers\nastropy\/extern\/ply\/cpp.py:        # Determine the token type for strings enclosed in double quotes\nastropy\/extern\/ply\/cpp.py:        # Determine the token type for whitespace--if any\nastropy\/extern\/ply\/cpp.py:        # Determine the token type for newlines\nastropy\/extern\/ply\/cpp.py:            if macro.value[i].type == self.t_ID and macro.value[i].value in macro.arglist:\nastropy\/extern\/ply\/cpp.py:                        ((i+1) < len(macro.value)) and (macro.value[i+1].type == self.t_ID) and \\\nastropy\/extern\/ply\/cpp.py:            if t.type == self.t_ID:\nastropy\/extern\/ply\/cpp.py:            if tokens[i].type == self.t_ID and tokens[i].value == 'defined':\nastropy\/extern\/ply\/cpp.py:                    elif tokens[j].type == self.t_ID:\nastropy\/extern\/ply\/cpp.py:            if t.type == self.t_ID:\nastropy\/extern\/ply\/cpp.py:                while tokens[i].value[-1] not in \"0123456789abcdefABCDEF\":\nastropy\/extern\/ply\/cpp.py:    # Define a new macro\nastropy\/extern\/ply\/cpp.py:                        a[0].type = self.t_ID\nastropy\/extern\/ply\/cpp.py:                    elif astr[-3:] == \"...\" and a[0].type == self.t_ID:\nastropy\/extern\/ply\/cpp.py:                    if len(a) > 1 or a[0].type != self.t_ID:\nastropy\/modeling\/tests\/irafutil.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/modeling\/tests\/irafutil.py:class IDB:\nastropy\/modeling\/tests\/irafutil.py:class ReidentifyRecord(IDB):\nastropy\/constants\/astropyconst13.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/ply\/ctokens.py:    'ID', 'TYPEID', 'INTEGER', 'FLOAT', 'STRING', 'CHARACTER',\nastropy\/extern\/ply\/ctokens.py:    'PLUS', 'MINUS', 'TIMES', 'DIVIDE', 'MODULO',\nastropy\/extern\/ply\/ctokens.py:    'OR', 'AND', 'NOT', 'XOR', 'LSHIFT', 'RSHIFT',\nastropy\/extern\/ply\/ctokens.py:    'LOR', 'LAND', 'LNOT',\nastropy\/extern\/ply\/ctokens.py:    'EQUALS', 'TIMESEQUAL', 'DIVEQUAL', 'MODEQUAL', 'PLUSEQUAL', 'MINUSEQUAL',\nastropy\/extern\/ply\/ctokens.py:    'LSHIFTEQUAL','RSHIFTEQUAL', 'ANDEQUAL', 'XOREQUAL', 'OREQUAL',\nastropy\/extern\/ply\/ctokens.py:    'INCREMENT', 'DECREMENT',\nastropy\/extern\/ply\/ctokens.py:    # Delimeters ( ) [ ] { } , . ; :\nastropy\/extern\/ply\/ctokens.py:    'COMMA', 'PERIOD', 'SEMI', 'COLON',\nastropy\/extern\/ply\/ctokens.py:t_DIVIDE           = r'\/'\nastropy\/extern\/ply\/ctokens.py:t_MODULO           = r'%'\nastropy\/extern\/ply\/ctokens.py:t_AND              = r'&'\nastropy\/extern\/ply\/ctokens.py:t_LAND             = r'&&'\nastropy\/extern\/ply\/ctokens.py:t_DIVEQUAL         = r'\/='\nastropy\/extern\/ply\/ctokens.py:t_MODEQUAL         = r'%='\nastropy\/extern\/ply\/ctokens.py:t_ANDEQUAL         = r'&='\nastropy\/extern\/ply\/ctokens.py:t_DECREMENT        = r'--'\nastropy\/extern\/ply\/ctokens.py:# Delimeters\nastropy\/extern\/ply\/ctokens.py:t_PERIOD           = r'\\.'\nastropy\/extern\/ply\/ctokens.py:t_ID = r'[A-Za-z_][A-Za-z0-9_]*'\nastropy\/samp\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nexamples\/io\/create-mef.py:*License: BSD*\nexamples\/io\/create-mef.py:# HDUList objects are used to hold all the HDUs in a FITS file. This\nexamples\/io\/create-mef.py:# ``HDUList`` class is a subclass of Python's builtin `list`. and can be\nexamples\/io\/create-mef.py:new_hdul = fits.HDUList()\nexamples\/io\/create-mef.py:new_hdul.append(fits.ImageHDU())\nexamples\/io\/create-mef.py:new_hdul.append(fits.ImageHDU())\nexamples\/io\/create-mef.py:# Alternatively, the HDU instances can be created first (or read from an\nexamples\/io\/create-mef.py:# default PRIMARY HDU is prepended automatically if one is not specified;\nexamples\/io\/create-mef.py:hdu1 = fits.PrimaryHDU()\nexamples\/io\/create-mef.py:hdu2 = fits.ImageHDU()\nexamples\/io\/create-mef.py:new_hdul = fits.HDUList([hdu1, hdu2])\nastropy\/coordinates\/tests\/test_representation.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/coordinates\/tests\/test_representation.py:from collections import OrderedDict\nastropy\/coordinates\/tests\/test_representation.py:from ..distances import Distance\nastropy\/coordinates\/tests\/test_representation.py:                              DIFFERENTIAL_CLASSES,\nastropy\/coordinates\/tests\/test_representation.py:                              SphericalCosLatDifferential,\nastropy\/coordinates\/tests\/test_representation.py:                              CartesianDifferential,\nastropy\/coordinates\/tests\/test_representation.py:                              SphericalDifferential,\nastropy\/coordinates\/tests\/test_representation.py:#   the test file doesn't add a persistent test subclass (LogDRepresentation)\nastropy\/coordinates\/tests\/test_representation.py:        assert isinstance(s3.distance, Distance)\nastropy\/coordinates\/tests\/test_representation.py:                                     Distance(10, u.kpc))\nastropy\/coordinates\/tests\/test_representation.py:        assert isinstance(s2.distance, Distance)\nastropy\/coordinates\/tests\/test_representation.py:                                     Distance(1., u.Rsun))\nastropy\/coordinates\/tests\/test_representation.py:        assert isinstance(s1.distance, Distance)\nastropy\/coordinates\/tests\/test_representation.py:        distance = Distance([1, 2] * u.kpc)\nastropy\/coordinates\/tests\/test_representation.py:        assert isinstance(s3.r, Distance)\nastropy\/coordinates\/tests\/test_representation.py:                                            Distance(10, u.kpc))\nastropy\/coordinates\/tests\/test_representation.py:        assert isinstance(s2.r, Distance)\nastropy\/coordinates\/tests\/test_representation.py:        assert isinstance(s1.r, Distance)\nastropy\/coordinates\/tests\/test_representation.py:        r = Distance([1, 2] * u.kpc)\nastropy\/coordinates\/tests\/test_representation.py:        attr_classes = OrderedDict([('lon', Longitude180),\nastropy\/coordinates\/tests\/test_representation.py:    class LogDRepresentation(BaseRepresentation):\nastropy\/coordinates\/tests\/test_representation.py:        attr_classes = OrderedDict([('lon', Longitude),\nastropy\/coordinates\/tests\/test_representation.py:                                    ('logd', u.Dex)])\nastropy\/coordinates\/tests\/test_representation.py:            return cls(lon=lon, lat=lat, logd=u.Dex(r), copy=False)\nastropy\/coordinates\/tests\/test_representation.py:    ld1 = LogDRepresentation(90.*u.deg, 0.*u.deg, 1.*u.dex(u.kpc))\nastropy\/coordinates\/tests\/test_representation.py:    ld2 = LogDRepresentation(lon=90.*u.deg, lat=0.*u.deg, logd=1.*u.dex(u.kpc))\nastropy\/coordinates\/tests\/test_representation.py:    ld3 = LogDRepresentation.from_cartesian(c)\nastropy\/coordinates\/tests\/test_representation.py:        LogDRepresentation(0.*u.deg, 1.*u.deg)\nastropy\/coordinates\/tests\/test_representation.py:        LogDRepresentation(0.*u.deg, 1.*u.deg, 1.*u.dex(u.kpc), lon=1.*u.deg)\nastropy\/coordinates\/tests\/test_representation.py:        LogDRepresentation(0.*u.deg, 1.*u.deg, 1.*u.dex(u.kpc), True, False)\nastropy\/coordinates\/tests\/test_representation.py:        LogDRepresentation(0.*u.deg, 1.*u.deg, 1.*u.dex(u.kpc), foo='bar')\nastropy\/coordinates\/tests\/test_representation.py:        class LogDRepresentation(BaseRepresentation):\nastropy\/coordinates\/tests\/test_representation.py:            attr_classes = OrderedDict([('lon', Longitude),\nastropy\/coordinates\/tests\/test_representation.py:                                        ('logr', u.Dex)])\nastropy\/coordinates\/tests\/test_representation.py:class TestCartesianRepresentationWithDifferential:\nastropy\/coordinates\/tests\/test_representation.py:        diff = CartesianDifferential(d_x=1 * u.km\/u.s,\nastropy\/coordinates\/tests\/test_representation.py:            CartesianDifferential(d_x=1 * u.km\/u.s, d_y=2 * u.km\/u.s,\nastropy\/coordinates\/tests\/test_representation.py:        # TODO: more extensive checking of this\nastropy\/coordinates\/tests\/test_representation.py:        diff = SphericalDifferential(d_lon=1 * u.mas\/u.yr,\nastropy\/coordinates\/tests\/test_representation.py:        diff = SphericalCosLatDifferential(d_lon_coslat=1 * u.mas\/u.yr,\nastropy\/coordinates\/tests\/test_representation.py:        d1 = CartesianDifferential(*[1, 2, 3] * u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation.py:        d2 = CartesianDifferential(*[4, 5, 6] * u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation.py:        diff = CartesianDifferential(d_x=arr1, d_y=arr1, d_z=arr1)\nastropy\/coordinates\/tests\/test_representation.py:        diff = SphericalCosLatDifferential(d_lon_coslat=1 * u.mas\/u.yr,\nastropy\/coordinates\/tests\/test_representation.py:        diff = CartesianDifferential(d_x=1 * u.km\/u.s,\nastropy\/coordinates\/tests\/test_representation.py:                                    SphericalCosLatDifferential)\nastropy\/coordinates\/tests\/test_representation.py:                                    {'s': SphericalCosLatDifferential})\nastropy\/coordinates\/tests\/test_representation.py:                # TODO: Converting a CartesianDifferential to a\nastropy\/coordinates\/tests\/test_representation.py:                #       RadialDifferential fails, even on `master`\nastropy\/coordinates\/tests\/test_representation.py:                                        DIFFERENTIAL_CLASSES[name])\nastropy\/coordinates\/tests\/test_representation.py:        d = CartesianDifferential(d_x=np.arange(10) * u.m\/u.s,\nastropy\/coordinates\/tests\/test_representation.py:        d1 = CartesianDifferential(d_x=[1, 2] * u.km\/u.s,\nastropy\/coordinates\/tests\/test_representation.py:        diff = CartesianDifferential([.1, .2, .3]*u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation.py:        diff2 = CartesianDifferential([.1, .2, .3]*u.m\/u.s)\nastropy\/coordinates\/tests\/test_representation.py:        d1 = CartesianDifferential(*np.random.random((3, 5)), unit=u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation.py:        d2 = CartesianDifferential(*np.random.random((3, 5)), unit=u.km\/u.s**2)\nastropy\/coordinates\/tests\/test_representation.py:    diff = CartesianDifferential([.1, .2, .3]*u.km\/u.s)\nastropy\/coordinates\/tests\/test_representation.py:    sd = SphericalDifferential(d_lat=1*u.deg, d_lon=2*u.deg, d_distance=10*u.m)\nastropy\/extern\/ply\/yacc.py:# David M. Beazley (Dabeaz LLC)\nastropy\/extern\/ply\/yacc.py:# * Neither the name of the David Beazley or Dabeaz LLC may be used to\nastropy\/extern\/ply\/yacc.py:# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\nastropy\/extern\/ply\/yacc.py:# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nastropy\/extern\/ply\/yacc.py:# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nastropy\/extern\/ply\/yacc.py:# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nastropy\/extern\/ply\/yacc.py:# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nastropy\/extern\/ply\/yacc.py:# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nastropy\/extern\/ply\/yacc.py:# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nastropy\/extern\/ply\/yacc.py:# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nastropy\/extern\/ply\/yacc.py:# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nastropy\/extern\/ply\/yacc.py:# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nastropy\/extern\/ply\/yacc.py:# Techniques, and Tools\" (The Dragon Book).  LALR(1) has since been replaced\nastropy\/extern\/ply\/yacc.py:# by the more efficient DeRemer and Pennello algorithm.\nastropy\/extern\/ply\/yacc.py:yaccdebug   = True             # Debugging mode.  If set, yacc generates a\nastropy\/extern\/ply\/yacc.py:debug_file  = 'parser.out'     # Default name of the debugging file\nastropy\/extern\/ply\/yacc.py:tab_module  = 'parsetab'       # Default name of the table module\nastropy\/extern\/ply\/yacc.py:default_lr  = 'LALR'           # Default LR table generation method\nastropy\/extern\/ply\/yacc.py:# Null logger is used when no output is generated. Does nothing.\nastropy\/extern\/ply\/yacc.py:_warnmsg = '''PLY: Don't use global functions errok(), token(), and restart() in p_error().\nastropy\/extern\/ply\/yacc.py:    # Defaulted state support.\nastropy\/extern\/ply\/yacc.py:    # See:  http:\/\/www.gnu.org\/software\/bison\/manual\/html_node\/Default-Reductions.html#Default-Reductions\nastropy\/extern\/ply\/yacc.py:    #      #--! DEBUG\nastropy\/extern\/ply\/yacc.py:    #      #--! DEBUG\nastropy\/extern\/ply\/yacc.py:        #--! DEBUG\nastropy\/extern\/ply\/yacc.py:        debug.info('PLY: PARSE DEBUG START')\nastropy\/extern\/ply\/yacc.py:        #--! DEBUG\nastropy\/extern\/ply\/yacc.py:            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                debug.debug('Defaulted state %s: Reduce using %d', state, -t)\nastropy\/extern\/ply\/yacc.py:                #--! DEBUG\nastropy\/extern\/ply\/yacc.py:            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                    #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                    #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                    # Decrease error count on successful shift\nastropy\/extern\/ply\/yacc.py:                    #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                    #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                            #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                    #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                    debug.info('Done   : Returning %s', format_result(result))\nastropy\/extern\/ply\/yacc.py:                    debug.info('PLY: PARSE DEBUG END')\nastropy\/extern\/ply\/yacc.py:                    #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                #--! DEBUG\nastropy\/extern\/ply\/yacc.py:                #--! DEBUG\nastropy\/extern\/ply\/yacc.py:    # Optimized version of parse() method.  DO NOT EDIT THIS CODE DIRECTLY!\nastropy\/extern\/ply\/yacc.py:                    # Decrease error count on successful shift\nastropy\/extern\/ply\/yacc.py:    # DO NOT EDIT THIS CODE DIRECTLY. This code is automatically generated\nastropy\/extern\/ply\/yacc.py:                    # Decrease error count on successful shift\nastropy\/extern\/ply\/yacc.py:        # Determine the precedence level\nastropy\/extern\/ply\/yacc.py:            del syms[-2:]     # Drop %prec from the rule\nastropy\/extern\/ply\/yacc.py:            raise GrammarError('%s:%d: Duplicate rule %s. ' % (file, line, m) +\nastropy\/extern\/ply\/yacc.py:                        # Don't need to consider any more productions for this n.\nastropy\/extern\/ply\/yacc.py:    # During execution of compute_first1, the result may be incomplete.\nastropy\/extern\/ply\/yacc.py:    # non-terminal.  See the Dragon book, 2nd Ed. p. 189.\nastropy\/extern\/ply\/yacc.py:        # Diagonistic information filled in by the table generator\nastropy\/extern\/ply\/yacc.py:    # The method used here is due to DeRemer and Pennelo (1982).\nastropy\/extern\/ply\/yacc.py:    # DeRemer, F. L., and T. J. Pennelo: \"Efficient Computation of LALR(1)\nastropy\/extern\/ply\/yacc.py:    # Computes the DR(p,A) relationships for non-terminal transitions.  The input\nastropy\/extern\/ply\/yacc.py:    # Computes the READS() relation (p,A) READS (t,C).\nastropy\/extern\/ply\/yacc.py:    # Determines the lookback and includes relations\nastropy\/extern\/ply\/yacc.py:    # INCLUDES:\nastropy\/extern\/ply\/yacc.py:    # Computes the INCLUDE() relation (p,A) INCLUDES (p',B).\nastropy\/extern\/ply\/yacc.py:    # inside of other non-terminal transition states.   (p,A) INCLUDES (p', B)\nastropy\/extern\/ply\/yacc.py:        lookdict = {}          # Dictionary of lookback relations\nastropy\/extern\/ply\/yacc.py:        includedict = {}       # Dictionary of include relations\nastropy\/extern\/ply\/yacc.py:    # Follow(p,A) = Read(p,A) U U {Follow(p',B) | (p,A) INCLUDES (p',B)}\nastropy\/extern\/ply\/yacc.py:        # Determine all of the nullable nonterminals\nastropy\/extern\/ply\/yacc.py:                                        # Do a precedence check.\nastropy\/extern\/ply\/yacc.py:# This file is automatically generated. Do not edit.\nastropy\/extern\/ply\/yacc.py:    # Determine if the module is package of a package or not.\nastropy\/time\/tests\/test_pickle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/flag_collection.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/flag_collection.py:from collections import OrderedDict\nastropy\/nddata\/flag_collection.py:class FlagCollection(OrderedDict):\nastropy\/nddata\/flag_collection.py:    containing arrays of flags for the `NDData` class. Flags should be\nastropy\/nddata\/flag_collection.py:    `~collections.OrderedDict`, but with the addition of a ``shape=``\nastropy\/nddata\/flag_collection.py:    keyword argument used to pass the NDData shape.\nastropy\/nddata\/flag_collection.py:        OrderedDict.__init__(self, *args, **kwargs)\nastropy\/nddata\/flag_collection.py:                OrderedDict.__setitem__(self, item, value, **kwargs)\nastropy\/constants\/tests\/test_pickle.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/web_profile.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/web_profile.py:CROSS_DOMAIN = get_pkg_data_contents('data\/crossdomain.xml')\nastropy\/samp\/web_profile.py:            response = CROSS_DOMAIN\nastropy\/samp\/web_profile.py:    def do_HEAD(self):\nastropy\/samp\/web_profile.py:Do you give your consent? [yes|no]\"\"\".format(samp_name, request[2])\nastropy\/samp\/lockfile_helpers.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/lockfile_helpers.py:# TODO: this file should be refactored to use a more thread-safe and\nastropy\/samp\/lockfile_helpers.py:    os.chmod(lockfilename, stat.S_IREAD + stat.S_IWRITE)\nastropy\/samp\/lockfile_helpers.py:                             stat.S_IREAD + stat.S_IWRITE + stat.S_IEXEC)\nastropy\/samp\/lockfile_helpers.py:    # HUB SINGLE INSTANCE MODE\nastropy\/samp\/lockfile_helpers.py:    # HUB MULTIPLE INSTANCE MODE\nastropy\/samp\/lockfile_helpers.py:    # HUB SINGLE INSTANCE MODE\nastropy\/samp\/lockfile_helpers.py:    # HUB MULTIPLE INSTANCE MODE\nastropy\/constants\/tests\/test_prior_version.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/constants\/tests\/test_prior_version.py:    # check that the value is the CODATA2010 value\nastropy\/tests\/command.py:class FixRemoteDataOption(type):\nastropy\/tests\/command.py:        return super(FixRemoteDataOption, cls).__init__(name, bases, dct)\nastropy\/tests\/command.py:class AstropyTest(Command, metaclass=FixRemoteDataOption):\nastropy\/tests\/command.py:         \"Don't test the documentation .rst files.\"),\nastropy\/tests\/command.py:        # Don't use get_pkg_data_filename here, because it\nastropy\/tests\/test_logger.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/test_logger.py:@pytest.mark.parametrize(('level'), [None, 'DEBUG', 'INFO', 'WARN', 'ERROR'])\nastropy\/tests\/test_logger.py:            log.debug(\"Debug message\")\nastropy\/tests\/test_logger.py:    if level == 'DEBUG':\nastropy\/tests\/test_logger.py:        assert log_list[3].levelname == 'DEBUG'\nastropy\/tests\/test_logger.py:        assert log_list[3].message.startswith('Debug message')\nastropy\/tests\/test_logger.py:@pytest.mark.parametrize(('level'), [None, 'DEBUG', 'INFO', 'WARN', 'ERROR'])\nastropy\/tests\/test_logger.py:            log.debug(\"Debug message\")\nastropy\/tests\/test_logger.py:    if level == 'DEBUG':\nastropy\/tests\/test_logger.py:            'astropy.tests.test_logger', 'DEBUG', 'Debug message')\nastropy\/samp\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/utils.py:        SAMP client instance. Decorator initialization, accepting the instance\nastropy\/nddata\/nddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nddata.py:# This module implements the base NDData class.\nastropy\/nddata\/nddata.py:from .nddata_base import NDDataBase\nastropy\/nddata\/nddata.py:from .nduncertainty import NDUncertainty, UnknownUncertainty\nastropy\/nddata\/nddata.py:from ..utils.metadata import MetaData\nastropy\/nddata\/nddata.py:__all__ = ['NDData']\nastropy\/nddata\/nddata.py:class NDData(NDDataBase):\nastropy\/nddata\/nddata.py:    `~astropy.nddata.NDDataBase` interface.\nastropy\/nddata\/nddata.py:    data : `numpy.ndarray`-like or `NDData`-like\nastropy\/nddata\/nddata.py:        `NDUncertainty` - but isn't mandatory. If the uncertainty has no such\nastropy\/nddata\/nddata.py:        Defaults to ``None``.\nastropy\/nddata\/nddata.py:        Defaults to ``None``.\nastropy\/nddata\/nddata.py:        Default is ``None``.\nastropy\/nddata\/nddata.py:        an empty `collections.OrderedDict` is created.\nastropy\/nddata\/nddata.py:        Default is ``None``.\nastropy\/nddata\/nddata.py:        Default is ``None``.\nastropy\/nddata\/nddata.py:        Default is ``False``.\nastropy\/nddata\/nddata.py:    ``data`` in a `NDData` object can be accessed through the `data`\nastropy\/nddata\/nddata.py:        >>> from astropy.nddata import NDData\nastropy\/nddata\/nddata.py:        >>> nd = NDData([1,2,3])\nastropy\/nddata\/nddata.py:        >>> nd2 = NDData(q, unit=u.cm)\nastropy\/nddata\/nddata.py:    NDDataRef\nastropy\/nddata\/nddata.py:    NDDataArray\nastropy\/nddata\/nddata.py:    # Instead of a custom property use the MetaData descriptor also used for\nastropy\/nddata\/nddata.py:    meta = MetaData(doc=_meta_doc, copy=False)\nastropy\/nddata\/nddata.py:        # Rather pointless since the NDDataBase does not implement any setting\nastropy\/nddata\/nddata.py:        # but before the NDDataBase did call the uncertainty\nastropy\/nddata\/nddata.py:        # to the superclass NDDataBase should be in here.\nastropy\/nddata\/nddata.py:        if isinstance(data, NDData):  # don't use self.__class__ (issue #4137)\nastropy\/nddata\/nddata.py:            # unit just overwrite the unit parameter with the NDData.unit\nastropy\/nddata\/nddata.py:                log.info(\"overwriting NDData's current \"\nastropy\/nddata\/nddata.py:                log.info(\"overwriting NDData's current \"\nastropy\/nddata\/nddata.py:                log.info(\"overwriting NDData's current \"\nastropy\/nddata\/nddata.py:                log.info(\"overwriting NDData's current \"\nastropy\/nddata\/nddata.py:                log.info(\"overwriting NDData's current \"\nastropy\/nddata\/nddata.py:            # Data doesn't look like a numpy array, try converting it to\nastropy\/nddata\/nddata.py:            # Data might have been copied before but no way of validating\nastropy\/nddata\/nddata.py:        self.meta = meta  # TODO: Make this call the setter sometime\nastropy\/nddata\/nddata.py:        `~astropy.nddata.NDUncertainty` but isn't mandatory.\nastropy\/nddata\/nddata.py:            # If it is a subclass of NDUncertainty we must set the\nastropy\/nddata\/nddata.py:            if isinstance(value, NDUncertainty):\nastropy\/nddata\/nddata.py:                # steal the uncertainty from another NDData object\nastropy\/nddata\/nddata.py:                # Then link it to this NDData instance (internally this needs\nastropy\/nddata\/nddata.py:                # to be saved as weakref but that's done by NDUncertainty\nastropy\/tests\/tests\/test_run_tests.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/tests\/test_run_tests.py:# TODO: Temporarily disabled, as this seems to non-deterministically fail\nastropy\/tests\/tests\/test_run_tests.py:#     with pytest.raises(DeprecationWarning):\nastropy\/tests\/tests\/test_run_tests.py:#         warnings.warn('test warning', DeprecationWarning)\nastropy\/tests\/tests\/test_run_tests.py:    with pytest.raises(doctest.DocTestFailure):\nastropy\/tests\/tests\/test_imports.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/image_tests.py:IMAGE_REFERENCE_DIR = (ROOT.format(server='data.astropy.org', mpl_version='1.5.x') + ',' +\nastropy\/nddata\/tests\/test_utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_utils.py:                     Cutout2D)\nastropy\/nddata\/tests\/test_utils.py:    Test add_array_2D utility function.\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 1D array.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 1D array with func=np.mean.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 2D array.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 2D array with func=np.mean.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:        Test trimming of 2D array when size is not perfectly divisible\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 1D array.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 1D array with conserve_sum=False.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 2D array.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:        \"\"\"Test 2D array with conserve_sum=False.\"\"\"\nastropy\/nddata\/tests\/test_utils.py:class TestCutout2D:\nastropy\/nddata\/tests\/test_utils.py:        wcs.wcs.ctype = ['RA---TAN', 'DEC--TAN']\nastropy\/nddata\/tests\/test_utils.py:            c = Cutout2D(self.data, position, size)\nastropy\/nddata\/tests\/test_utils.py:            Cutout2D(self.data, (2, 2), (1, 1, 1))\nastropy\/nddata\/tests\/test_utils.py:                Cutout2D(self.data, (2, 2), size)\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, (2, 2), size)\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, (2, 2), (0.1*u.arcsec), wcs=self.wcs)\nastropy\/nddata\/tests\/test_utils.py:            Cutout2D(self.data, (2, 2), (3, 3 * u.arcsec))\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, (0, 0), (3, 3), mode='trim')\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, (0, 0), (3, 3), mode='partial')\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, (0, 0), (3, 3), mode='partial',\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(data, (2, 3), (3, 3))\nastropy\/nddata\/tests\/test_utils.py:        c2 = Cutout2D(self.data, (2, 3), (3, 3), copy=True)\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, position, (3, 3))\nastropy\/nddata\/tests\/test_utils.py:            Cutout2D(self.data, self.position, (3, 3))\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, self.position, (3, 3), wcs=self.wcs)\nastropy\/nddata\/tests\/test_utils.py:        c = Cutout2D(self.data, self.position, (3, 3), wcs=self.wcs,\nastropy\/nddata\/tests\/test_compat.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_compat.py:# This module contains tests of a class equivalent to pre-1.0 NDData.\nastropy\/nddata\/tests\/test_compat.py:from ..nddata import NDData\nastropy\/nddata\/tests\/test_compat.py:from ..compat import NDDataArray\nastropy\/nddata\/tests\/test_compat.py:from ..nduncertainty import StdDevUncertainty\nastropy\/nddata\/tests\/test_compat.py:NDDATA_ATTRIBUTES = ['mask', 'flags', 'uncertainty', 'unit', 'shape', 'size',\nastropy\/nddata\/tests\/test_compat.py:    ndd = NDDataArray([1, 2, 3])\nastropy\/nddata\/tests\/test_compat.py:    for attr in NDDATA_ATTRIBUTES:\nastropy\/nddata\/tests\/test_compat.py:    nd = NDDataArray(np.zeros((10, 10)))\nastropy\/nddata\/tests\/test_compat.py:    nd = NDDataArray(data=np.zeros((10, 10)))\nastropy\/nddata\/tests\/test_compat.py:    nd = NDDataArray(meta={}, data=np.zeros((10, 10)))\nastropy\/nddata\/tests\/test_compat.py:    uncertainty = StdDevUncertainty(0.1 + np.zeros_like(data))\nastropy\/nddata\/tests\/test_compat.py:    nd = NDDataArray(data, uncertainty)\nastropy\/nddata\/tests\/test_compat.py:    nd = NDDataArray(np.array([[1, 2, 3], [4, 5, 6]]))\nastropy\/nddata\/tests\/test_compat.py:    ndd = NDDataArray([1, 1], flags=flags_in)\nastropy\/nddata\/tests\/test_compat.py:        NDDataArray(np.zeros((10, 10)), flags=np.ones(shape))\nastropy\/nddata\/tests\/test_compat.py:    d = NDDataArray(np.ones((5, 5)))\nastropy\/nddata\/tests\/test_compat.py:    d.uncertainty = StdDevUncertainty(0.1 + np.zeros_like(d))\nastropy\/nddata\/tests\/test_compat.py:    # and NDData accepts only bool ndarray as mask\nastropy\/nddata\/tests\/test_compat.py:class SubNDData(NDDataArray):\nastropy\/nddata\/tests\/test_compat.py:    Subclass for test initialization of subclasses in NDData._arithmetic and\nastropy\/nddata\/tests\/test_compat.py:    NDData.convert_unit_to\nastropy\/nddata\/tests\/test_compat.py:    arr1 = SubNDData(data, unit='m', wcs=5)\nastropy\/nddata\/tests\/test_compat.py:    ndd1 = NDDataArray([1., 4., 9.],\nastropy\/nddata\/tests\/test_compat.py:                       uncertainty=StdDevUncertainty([1., 2., 3.]),\nastropy\/nddata\/tests\/test_compat.py:    ndd2 = NDDataArray(ndd1)\nastropy\/nddata\/tests\/test_compat.py:    ndd1 = NDData([1., 4., 9.],\nastropy\/nddata\/tests\/test_compat.py:                  uncertainty=StdDevUncertainty([1., 2., 3.]))\nastropy\/nddata\/tests\/test_compat.py:    ndd2 = NDDataArray(ndd1)\nastropy\/samp\/hub.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/hub.py:__all__ = ['SAMPHubServer', 'WebProfileDialog']\nastropy\/samp\/hub.py:        Defines the Hub running mode. If ``mode`` is ``'single'`` then the Hub\nastropy\/samp\/hub.py:        ``.samp-1`` directory, of the form ``samp-hub-<UUID>``, where\nastropy\/samp\/hub.py:        ``<UUID>`` is a unique UUID assigned to the hub.\nastropy\/samp\/hub.py:        # Generate random ID for the hub\nastropy\/samp\/hub.py:        The unique hub ID.\nastropy\/samp\/hub.py:            # TODO: Some sort of duck-typing on the web_profile_dialog object\nastropy\/samp\/hub.py:        # TODO: What happens if not all threads are stopped after timeout?\nastropy\/samp\/hub.py:            # Dictionary stored with the public id\nastropy\/samp\/hub.py:                raise SAMPProxyError(6, \"Invalid client ID\")\nastropy\/samp\/hub.py:                raise SAMPProxyError(6, \"Invalid client ID\")\nastropy\/samp\/hub.py:            raise SAMPHubError(\"Invalid client ID\")\nastropy\/samp\/hub.py:class WebProfileDialog:\nastropy\/nddata\/tests\/test_nddata_base.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_nddata_base.py:# Tests of NDDataBase\nastropy\/nddata\/tests\/test_nddata_base.py:from ..nddata_base import NDDataBase\nastropy\/nddata\/tests\/test_nddata_base.py:class MinimalSubclass(NDDataBase):\nastropy\/samp\/client.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/client.py:    # TODO: define what is meant by callable\nastropy\/samp\/client.py:            Sender public ID.\nastropy\/samp\/client.py:            Sender public ID.\nastropy\/samp\/client.py:            Message ID received.\nastropy\/samp\/client.py:            Responder public ID.\nastropy\/samp\/client.py:        notification sender ID, ``msg_id`` is the Hub message-id (calls only,\nastropy\/samp\/client.py:            Dictionary containing additional metadata to declare associated\nastropy\/samp\/client.py:        notification sender ID, ``mtype`` is the message MType, ``params`` is\nastropy\/samp\/client.py:            Dictionary containing additional metadata to declare associated\nastropy\/samp\/client.py:        notification sender ID, ``msg_id`` is the Hub message-id, ``mtype`` is\nastropy\/samp\/client.py:            Dictionary containing additional metadata to declare associated\nastropy\/samp\/client.py:        the message responder ID, ``msg_tag`` is the message-tag provided at\nastropy\/samp\/client.py:        Declares the MTypes the client wishes to subscribe to, implicitly\nastropy\/samp\/client.py:            Dictionary containing the list of MTypes to subscribe to, with the\nastropy\/samp\/client.py:        Declare the client application metadata supported.\nastropy\/samp\/client.py:            Dictionary containing the client application metadata as defined in\nastropy\/samp\/client.py:        Return public client ID obtained at registration time\nastropy\/samp\/client.py:            Client public ID.\nastropy\/samp\/hub_proxy.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/hub_proxy.py:        Disconnect from the current SAMP Hub.\nastropy\/samp\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/constants.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/constants.py:Defines constants used in `astropy.samp`.\nastropy\/nddata\/tests\/test_decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_decorators.py:from ..nddata import NDData\nastropy\/nddata\/tests\/test_decorators.py:class CCDData(NDData):\nastropy\/nddata\/tests\/test_decorators.py:    nddata_in = NDData(data_in, wcs=wcs_in, unit=unit_in)\nastropy\/nddata\/tests\/test_decorators.py:    nddata_in = NDData(data_in, wcs=wcs_in, unit=unit_in)\nastropy\/nddata\/tests\/test_decorators.py:                                 \"an NDData property, using explicitly specified value\")\nastropy\/nddata\/tests\/test_decorators.py:    nddata_in = NDData(data_in, wcs=wcs_in, unit=unit_in, mask=[0, 1, 0])\nastropy\/nddata\/tests\/test_decorators.py:    nddata_in = NDData(data_in)\nastropy\/nddata\/tests\/test_decorators.py:    nddata_in = NDData(data_in)\nastropy\/nddata\/tests\/test_decorators.py:    assert isinstance(nddata_out, NDData)\nastropy\/nddata\/tests\/test_decorators.py:    class MyData(NDData):\nastropy\/nddata\/tests\/test_decorators.py:    @support_nddata(accepts=MyData)\nastropy\/nddata\/tests\/test_decorators.py:    nddata_in = NDData(data_in)\nastropy\/nddata\/tests\/test_decorators.py:    mydata_in = MyData(data_in)\nastropy\/nddata\/tests\/test_decorators.py:    assert exc.value.args[0] == \"Only NDData sub-classes that inherit from MyData can be used by this function\"\nastropy\/nddata\/tests\/test_decorators.py:    # accepts CCDData but was given just an NDData\nastropy\/nddata\/tests\/test_decorators.py:        @support_nddata(accepts=CCDData)\nastropy\/nddata\/tests\/test_decorators.py:        test(NDData(np.ones((3, 3))))\nastropy\/nddata\/tests\/test_decorators.py:    # NDData here so we don't get into troubles when creating a CCDData without\nastropy\/nddata\/tests\/test_decorators.py:        test(NDData(np.ones((3, 3))))  # do NOT use CCDData here.\nastropy\/nddata\/tests\/test_decorators.py:    assert isinstance(test(NDData(np.ones((3, 3)))), NDData)\nastropy\/nddata\/tests\/test_decorators.py:    ndd = NDData(np.ones((3, 3)))\nastropy\/nddata\/tests\/test_decorators.py:        assert func(NDData(1, wcs=[1, 2]), [1, 2, 3]) == [1, 2, 3]\nastropy\/nddata\/tests\/test_decorators.py:        assert func(NDData(1, wcs=[1, 2])) == [1, 2]\nastropy\/nddata\/tests\/test_decorators.py:    # Accepts flags attribute but NDData doesn't have one\nastropy\/nddata\/tests\/test_decorators.py:    ndd = NDData(np.ones((3, 3)))\nastropy\/nddata\/tests\/test_decorators.py:    ndd = NDData(np.ones((3, 3)))\nastropy\/nddata\/tests\/test_decorators.py:    # Meta is always set (OrderedDict) so it has a special case that it's\nastropy\/nddata\/tests\/test_decorators.py:    ndd = NDData(np.ones((3, 3)))\nastropy\/tests\/helper.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/helper.py:from ..utils.exceptions import (AstropyDeprecationWarning,\nastropy\/tests\/helper.py:                                AstropyPendingDeprecationWarning)\nastropy\/tests\/helper.py:        @raises(ZeroDivisionError)\nastropy\/tests\/helper.py:        If set to `True`, ``AstropyDeprecationWarning`` and\nastropy\/tests\/helper.py:        ``AstropyPendingDeprecationWarning`` are also turned into exceptions.\nastropy\/tests\/helper.py:        is given, ``AstropyDeprecationWarning`` and\nastropy\/tests\/helper.py:        ``AstropyPendingDeprecationWarning`` are also ignored for the modules.\nastropy\/tests\/helper.py:        Dictionary mapping tuple of ``(major, minor)`` Python version to\nastropy\/tests\/helper.py:    Turn all DeprecationWarnings (which indicate deprecated uses of\nastropy\/tests\/helper.py:    # Hide the next couple of DeprecationWarnings\nastropy\/tests\/helper.py:    warnings.simplefilter('ignore', DeprecationWarning)\nastropy\/tests\/helper.py:    # Now, turn DeprecationWarnings into exceptions\nastropy\/tests\/helper.py:    _all_warns = [DeprecationWarning]\nastropy\/tests\/helper.py:        _all_warns += [AstropyDeprecationWarning,\nastropy\/tests\/helper.py:                       AstropyPendingDeprecationWarning]\nastropy\/tests\/helper.py:                warnings.filterwarnings(\"ignore\", s, DeprecationWarning)\nastropy\/tests\/helper.py:          \"Did not pickle {0}\".format(key)\nastropy\/nddata\/tests\/test_nddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_nddata.py:from collections import OrderedDict\nastropy\/nddata\/tests\/test_nddata.py:from ..nddata import NDData\nastropy\/nddata\/tests\/test_nddata.py:from ..nduncertainty import NDUncertainty, StdDevUncertainty\nastropy\/nddata\/tests\/test_nddata.py:class FakeUncertainty(NDUncertainty):\nastropy\/nddata\/tests\/test_nddata.py:    These attributes are checked for by NDData.\nastropy\/nddata\/tests\/test_nddata.py:    Define the minimum attributes acceptable as an uncertainty object.\nastropy\/nddata\/tests\/test_nddata.py:class BadNDDataSubclass(NDData):\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData([1, 2, 3])\nastropy\/nddata\/tests\/test_nddata.py:    # parent_nddata attribute from NDUncertainty)\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(nd)\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData([1, 2, 3])\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(nd, mask=True)\nastropy\/nddata\/tests\/test_nddata.py:        NDData()  # empty initializer should fail\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(inp)\nastropy\/nddata\/tests\/test_nddata.py:        nd = NDData(np.random.random((10, 10)))\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(np.array([[1, 2, 3], [4, 5, 6]]))\nastropy\/nddata\/tests\/test_nddata.py:    # Tests to ensure that creating a new NDData object copies by *reference*.\nastropy\/nddata\/tests\/test_nddata.py:    nd_ref = NDData(a)\nastropy\/nddata\/tests\/test_nddata.py:    nd_ref = NDData(a, copy=True)\nastropy\/nddata\/tests\/test_nddata.py:        NDData(np.random.random((10, 10)),\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(marr)\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(marr, copy=True)\nastropy\/nddata\/tests\/test_nddata.py:    ndd = NDData(quantity)\nastropy\/nddata\/tests\/test_nddata.py:        ndd = NDData(quantity, copy=True)\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(mq)\nastropy\/nddata\/tests\/test_nddata.py:    nd1 = NDData(np.array([1]))\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(nd1)\nastropy\/nddata\/tests\/test_nddata.py:    nd1 = NDData(np.ones((5, 5)))\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(nd1)\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(nd1, copy=True)\nastropy\/nddata\/tests\/test_nddata.py:    nd1 = NDData(np.array([1]), mask=False, uncertainty=10, unit=u.s,\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(nd1)\nastropy\/nddata\/tests\/test_nddata.py:    nd3 = NDData(nd1, mask=True, uncertainty=200, unit=u.km,\nastropy\/nddata\/tests\/test_nddata.py:    # There might be some incompatible subclasses of NDData around.\nastropy\/nddata\/tests\/test_nddata.py:    bnd = BadNDDataSubclass(False, True, 3, 2, 'gollum', 100)\nastropy\/nddata\/tests\/test_nddata.py:    # Before changing the NDData init this would not have raised an error but\nastropy\/nddata\/tests\/test_nddata.py:        NDData(bnd)\nastropy\/nddata\/tests\/test_nddata.py:    bnd_good = BadNDDataSubclass(np.array([1, 2]), True, 3, 2,\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(bnd_good)\nastropy\/nddata\/tests\/test_nddata.py:        NDData({'a': 'dict'})\nastropy\/nddata\/tests\/test_nddata.py:        NDData(Shape())\nastropy\/nddata\/tests\/test_nddata.py:    ndd1 = NDData(FakeNumpyArray())\nastropy\/nddata\/tests\/test_nddata.py:    # First make sure that NDData isn't converting its data to a numpy array.\nastropy\/nddata\/tests\/test_nddata.py:    # Make a new NDData initialized from an NDData\nastropy\/nddata\/tests\/test_nddata.py:    ndd2 = NDData(ndd1)\nastropy\/nddata\/tests\/test_nddata.py:    u = StdDevUncertainty(array=np.ones((5, 5)))\nastropy\/nddata\/tests\/test_nddata.py:    d = NDData(np.ones((5, 5)), uncertainty=u)\nastropy\/nddata\/tests\/test_nddata.py:    # Test conflicting uncertainties (other NDData)\nastropy\/nddata\/tests\/test_nddata.py:    u2 = StdDevUncertainty(array=np.ones((5, 5))*2)\nastropy\/nddata\/tests\/test_nddata.py:    d2 = NDData(d, uncertainty=u2)\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData([1], wcs=3)\nastropy\/nddata\/tests\/test_nddata.py:    # Test conflicting wcs (other NDData)\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(nd, wcs=2)\nastropy\/nddata\/tests\/test_nddata.py:        NDData([1], meta=3)\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData([1, 2, 3], meta={})\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData([1, 2, 3])\nastropy\/nddata\/tests\/test_nddata.py:    assert isinstance(nd.meta, OrderedDict)\nastropy\/nddata\/tests\/test_nddata.py:    # Test conflicting meta (other NDData)\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(nd, meta={'image': 'sun'})\nastropy\/nddata\/tests\/test_nddata.py:    nd3 = NDData(nd2, meta={'image': 'moon'})\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData([1], mask=False)\nastropy\/nddata\/tests\/test_nddata.py:    # Test conflicting mask (other NDData)\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(nd, mask=True)\nastropy\/nddata\/tests\/test_nddata.py:    nd3 = NDData(np.ma.array([1], mask=False), mask=True)\nastropy\/nddata\/tests\/test_nddata.py:    nd4 = NDData(mq, mask=True)\nastropy\/nddata\/tests\/test_nddata.py:        NDData(np.ones((5, 5)), unit=\"NotAValidUnit\")\nastropy\/nddata\/tests\/test_nddata.py:    NDData([1, 2, 3], unit='meter')\nastropy\/nddata\/tests\/test_nddata.py:    nd = NDData(q, unit='cm')\nastropy\/nddata\/tests\/test_nddata.py:    nd2 = NDData(mq, unit=u.s)\nastropy\/nddata\/tests\/test_nddata.py:    # (another NDData as data)\nastropy\/nddata\/tests\/test_nddata.py:    nd3 = NDData(nd, unit='km')\nastropy\/nddata\/tests\/test_nddata.py:class TestMetaNDData(MetaBaseTest):\nastropy\/nddata\/tests\/test_nddata.py:    test_class = NDData\nastropy\/nddata\/tests\/test_nddata.py:    arr1d = NDData(np.array([1, 2, 3]))\nastropy\/nddata\/tests\/test_nddata.py:    arr2d = NDData(np.array([[1, 2], [3, 4]]))\nastropy\/nddata\/tests\/test_nddata.py:    arr3d = NDData(np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]))\nastropy\/nddata\/tests\/test_nddata.py:    arr1d = NDData(np.array([1, 2, 3]))\nastropy\/nddata\/tests\/test_nddata.py:    assert repr(arr1d) == 'NDData([1, 2, 3])'\nastropy\/nddata\/tests\/test_nddata.py:    arr2d = NDData(np.array([[1, 2], [3, 4]]))\nastropy\/nddata\/tests\/test_nddata.py:        NDData([[1, 2],\nastropy\/nddata\/tests\/test_nddata.py:    arr3d = NDData(np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]))\nastropy\/nddata\/tests\/test_nddata.py:        NDData([[[1, 2],\nastropy\/nddata\/tests\/test_nddata.py:    ndd = NDData(np.ones((5, 5)))\nastropy\/nddata\/tests\/test_nddata.py:    ndd = NDData(np.ones((5, 5)))\nastropy\/nddata\/tests\/test_flag_collection.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_nduncertainty.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_nduncertainty.py:from ..nduncertainty import (StdDevUncertainty, NDUncertainty,\nastropy\/nddata\/tests\/test_nduncertainty.py:from ..nddata import NDData\nastropy\/nddata\/tests\/test_nduncertainty.py:# Additionally they should be covered by NDData, NDArithmeticMixin which rely\nastropy\/nddata\/tests\/test_nduncertainty.py:# They should be covered by NDArithmeticMixin since there is generally no need\nastropy\/nddata\/tests\/test_nduncertainty.py:# Should be covered by NDSlicingMixin.\nastropy\/nddata\/tests\/test_nduncertainty.py:# Regarding StdDevUncertainty tests:\nastropy\/nddata\/tests\/test_nduncertainty.py:# they should be covered in NDArithmeticMixin.\nastropy\/nddata\/tests\/test_nduncertainty.py:class FakeUncertainty(NDUncertainty):\nastropy\/nddata\/tests\/test_nduncertainty.py:# Test the fake (added also StdDevUncertainty which should behave identical)\nastropy\/nddata\/tests\/test_nduncertainty.py:@pytest.mark.parametrize(('UncertClass'), [FakeUncertainty, StdDevUncertainty,\nastropy\/nddata\/tests\/test_nduncertainty.py:@pytest.mark.parametrize(('UncertClass'), [FakeUncertainty, StdDevUncertainty,\nastropy\/nddata\/tests\/test_nduncertainty.py:@pytest.mark.parametrize(('UncertClass'), [FakeUncertainty, StdDevUncertainty,\nastropy\/nddata\/tests\/test_nduncertainty.py:@pytest.mark.parametrize(('UncertClass'), [FakeUncertainty, StdDevUncertainty,\nastropy\/nddata\/tests\/test_nduncertainty.py:@pytest.mark.parametrize(('UncertClass'), [FakeUncertainty, StdDevUncertainty,\nastropy\/nddata\/tests\/test_nduncertainty.py:    # TODO : Find something that can be referenced without copy :-)\nastropy\/nddata\/tests\/test_nduncertainty.py:def test_init_fake_with_StdDevUncertainty():\nastropy\/nddata\/tests\/test_nduncertainty.py:    # Different instances of uncertainties are not directly convertible so this\nastropy\/nddata\/tests\/test_nduncertainty.py:    std_uncert = StdDevUncertainty(uncert)\nastropy\/nddata\/tests\/test_nduncertainty.py:        StdDevUncertainty(fake_uncert)\nastropy\/nddata\/tests\/test_nduncertainty.py:    std_uncert = StdDevUncertainty([10, 2])\nastropy\/nddata\/tests\/test_nduncertainty.py:    std_uncert = StdDevUncertainty([10, 2])\nastropy\/nddata\/tests\/test_nduncertainty.py:    # NDData and uncertainty\nastropy\/nddata\/tests\/test_nduncertainty.py:        NDData(np.ones(100))\nastropy\/nddata\/tests\/test_nduncertainty.py:        NDData(np.ones(100), uncertainty=StdDevUncertainty(np.ones(100)))\nastropy\/nddata\/tests\/test_nduncertainty.py:    test_leak(non_leaker_nddata, NDData)\nastropy\/nddata\/tests\/test_nduncertainty.py:    test_leak(leaker_nddata, NDData)\nastropy\/nddata\/tests\/test_nduncertainty.py:    # Same for NDDataArray:\nastropy\/nddata\/tests\/test_nduncertainty.py:    from ..compat import NDDataArray\nastropy\/nddata\/tests\/test_nduncertainty.py:        NDDataArray(np.ones(100))\nastropy\/nddata\/tests\/test_nduncertainty.py:        NDDataArray(np.ones(100), uncertainty=StdDevUncertainty(np.ones(100)))\nastropy\/nddata\/tests\/test_nduncertainty.py:    test_leak(non_leaker_nddataarray, NDDataArray)\nastropy\/nddata\/tests\/test_nduncertainty.py:    test_leak(leaker_nddataarray, NDDataArray)\nastropy\/nddata\/tests\/test_nduncertainty.py:    ndd1 = NDData(1, uncertainty=1)\nastropy\/nddata\/tests\/test_nduncertainty.py:    ndd2 = NDData(2, uncertainty=ndd1.uncertainty)\nastropy\/nddata\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/__init__.py:The `astropy.nddata` subpackage provides the `~astropy.nddata.NDData`\nastropy\/nddata\/__init__.py:CCD images, IFU Data, grid-based simulation data, ...). This is more than\nastropy\/nddata\/__init__.py:        'Whether to issue a warning if `~astropy.nddata.NDData` arithmetic '\nastropy\/nddata\/__init__.py:        'Whether to issue a warning when the `~astropy.nddata.NDData` unit '\nastropy\/tests\/disable_internet.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/disable_internet.py:TODO: This module should eventually be removed once backwards compatibility\nastropy\/tests\/disable_internet.py:from ..utils.exceptions import AstropyDeprecationWarning\nastropy\/tests\/disable_internet.py:     \"for more information.\", AstropyDeprecationWarning)\nastropy\/nddata\/utils.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/utils.py:           'NoOverlapError', 'PartialOverlapError', 'Cutout2D']\nastropy\/nddata\/utils.py:        The shape of the large array (for 1D arrays, this can be an\nastropy\/nddata\/utils.py:        The shape of the small array (for 1D arrays, this can be an\nastropy\/nddata\/utils.py:        The shape of the extracted array (for 1D arrays, this can be an\nastropy\/nddata\/utils.py:        (for 1D arrays, this can be a number).\nastropy\/nddata\/utils.py:    Downsample a data array by applying a function to local blocks.\nastropy\/nddata\/utils.py:class Cutout2D:\nastropy\/nddata\/utils.py:    Create a cutout object from a 2D array.\nastropy\/nddata\/utils.py:    The returned object will contain a 2D cutout array.  If\nastropy\/nddata\/utils.py:        The 2D data array from which to extract the cutout array.\nastropy\/nddata\/utils.py:    data : 2D `~numpy.ndarray`\nastropy\/nddata\/utils.py:        The 2D cutout array.\nastropy\/nddata\/utils.py:    >>> from astropy.nddata.utils import Cutout2D\nastropy\/nddata\/utils.py:    >>> cutout1 = Cutout2D(data, (2, 2), (3, 3))\nastropy\/nddata\/utils.py:    >>> cutout2 = Cutout2D(data, (2, 2), 3)\nastropy\/nddata\/utils.py:    >>> cutout3 = Cutout2D(data, (0, 0), size)\nastropy\/nddata\/utils.py:    >>> cutout4 = Cutout2D(data, (0, 0), (3 * u.pixel, 3))\nastropy\/nddata\/utils.py:    >>> cutout5 = Cutout2D(data, (0, 0), (3, 3), mode='partial')\nastropy\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/integrated_client.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/integrated_client.py:            Recipient ID\nastropy\/samp\/integrated_client.py:            Recipient ID\nastropy\/samp\/integrated_client.py:            Recipient ID\nastropy\/samp\/integrated_client.py:            Message ID to which reply.\nastropy\/tests\/plugins\/display.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/plugins\/display.py:from collections import OrderedDict\nastropy\/tests\/plugins\/display.py:PYTEST_HEADER_MODULES = OrderedDict([('Numpy', 'numpy'),\nastropy\/tests\/plugins\/display.py:TESTED_VERSIONS = OrderedDict([('Astropy', __version__)])\nastropy\/tests\/plugins\/display.py:    # TESTED_VERSIONS can contain the affiliated package version, too\nastropy\/tests\/plugins\/display.py:    if len(TESTED_VERSIONS) > 1:\nastropy\/tests\/plugins\/display.py:        for pkg, version in TESTED_VERSIONS.items():\nastropy\/tests\/plugins\/display.py:            TESTED_VERSIONS['Astropy'])\nastropy\/tests\/plugins\/display.py:    s += \"Date: {0}\\n\\n\".format(datetime.datetime.now().isoformat()[:19])\nastropy\/tests\/plugins\/display.py:    for module_display, module_name in PYTEST_HEADER_MODULES.items():\nastropy\/tests\/plugins\/display.py:            with ignore_warnings(DeprecationWarning):\nastropy\/tests\/plugins\/config.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/plugins\/config.py:from collections import OrderedDict\nastropy\/nddata\/tests\/test_ccddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/tests\/test_ccddata.py:# This module implements the base CCDData class.\nastropy\/nddata\/tests\/test_ccddata.py:from ..nduncertainty import StdDevUncertainty, MissingDataAssociationException\nastropy\/nddata\/tests\/test_ccddata.py:from ..ccddata import CCDData\nastropy\/nddata\/tests\/test_ccddata.py:DEFAULTS = {\nastropy\/nddata\/tests\/test_ccddata.py:DEFAULT_SEED = 123\nastropy\/nddata\/tests\/test_ccddata.py:DEFAULT_DATA_SIZE = 100\nastropy\/nddata\/tests\/test_ccddata.py:DEFAULT_DATA_SCALE = 1.0\nastropy\/nddata\/tests\/test_ccddata.py:        val = DEFAULTS[key]\nastropy\/nddata\/tests\/test_ccddata.py:    Return a CCDData object with units of ADU.\nastropy\/nddata\/tests\/test_ccddata.py:    Data values are initialized to random numbers drawn from a normal\nastropy\/nddata\/tests\/test_ccddata.py:    with NumpyRNGContext(DEFAULTS['seed']):\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(data, unit=u.adu)\nastropy\/nddata\/tests\/test_ccddata.py:        CCDData()  # empty initializer should fail\nastropy\/nddata\/tests\/test_ccddata.py:        CCDData(np.zeros([100, 100]))\nastropy\/nddata\/tests\/test_ccddata.py:        CCDData([1, 2, 3], unit='', meta={1: 1}, header={2: 2})\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.zeros((10, 10)), unit=\"electron\")\nastropy\/nddata\/tests\/test_ccddata.py:    hdu = fits.PrimaryHDU(ccd_data)\nastropy\/nddata\/tests\/test_ccddata.py:    hdulist = fits.HDUList([hdu])\nastropy\/nddata\/tests\/test_ccddata.py:    cd = CCDData.read(filename, unit=u.electron)\nastropy\/nddata\/tests\/test_ccddata.py:    hdu = fits.PrimaryHDU(fake_img)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData.read(filename)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd2 = CCDData.read(filename, unit=\"photon\")\nastropy\/nddata\/tests\/test_ccddata.py:def test_initialize_from_fits_with_ADU_in_header(tmpdir):\nastropy\/nddata\/tests\/test_ccddata.py:    hdu = fits.PrimaryHDU(fake_img)\nastropy\/nddata\/tests\/test_ccddata.py:    hdu.header['bunit'] = 'ADU'\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData.read(filename)\nastropy\/nddata\/tests\/test_ccddata.py:    hdu1 = fits.PrimaryHDU()\nastropy\/nddata\/tests\/test_ccddata.py:    hdu2 = fits.ImageHDU(fake_img)\nastropy\/nddata\/tests\/test_ccddata.py:    hdus = fits.HDUList([hdu1, hdu2])\nastropy\/nddata\/tests\/test_ccddata.py:        ccd = CCDData.read(filename, unit='adu')\nastropy\/nddata\/tests\/test_ccddata.py:    hdu0 = fits.PrimaryHDU()\nastropy\/nddata\/tests\/test_ccddata.py:    hdu1 = fits.ImageHDU(fake_img1)\nastropy\/nddata\/tests\/test_ccddata.py:    hdu2 = fits.ImageHDU(fake_img2)\nastropy\/nddata\/tests\/test_ccddata.py:    hdus = fits.HDUList([hdu0, hdu1, hdu2])\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData.read(filename, hdu=2, unit='adu')\nastropy\/nddata\/tests\/test_ccddata.py:        CCDData.read(filename, unit=ccd_data.unit,\nastropy\/nddata\/tests\/test_ccddata.py:        CCDData.read(filename, unit=ccd_data.unit, scale_back=True)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_disk = CCDData.read(filename, unit=ccd_data.unit)\nastropy\/nddata\/tests\/test_ccddata.py:    hdu = fits.PrimaryHDU(ccd_data)\nastropy\/nddata\/tests\/test_ccddata.py:    hdu2 = fits.PrimaryHDU(2 * ccd_data.data)\nastropy\/nddata\/tests\/test_ccddata.py:    hdulist = fits.HDUList(hdu)\nastropy\/nddata\/tests\/test_ccddata.py:    cd = CCDData.read(filename, unit=u.electron)\nastropy\/nddata\/tests\/test_ccddata.py:    cd = CCDData.read(filename, hdu=1, unit=u.electron)\nastropy\/nddata\/tests\/test_ccddata.py:    d1 = CCDData(np.ones((5, 5)), meta=hdr, unit=u.electron)\nastropy\/nddata\/tests\/test_ccddata.py:    d1 = CCDData(np.ones((5, 5)), meta=dic, unit=u.electron)\nastropy\/nddata\/tests\/test_ccddata.py:    d1 = CCDData(np.ones((5, 5)), unit=u.electron)\nastropy\/nddata\/tests\/test_ccddata.py:        CCDData(np.ones((5, 5)), meta=hdr, unit=u.adu)\nastropy\/nddata\/tests\/test_ccddata.py:        # Uncertainty is supposed to be an instance of NDUncertainty\nastropy\/nddata\/tests\/test_ccddata.py:    assert isinstance(fits_hdulist, fits.HDUList)\nastropy\/nddata\/tests\/test_ccddata.py:        ccd_data.uncertainty = StdDevUncertainty(np.ones_like(ccd_data))\nastropy\/nddata\/tests\/test_ccddata.py:    assert isinstance(result, CCDData)\nastropy\/nddata\/tests\/test_ccddata.py:            isinstance(result.uncertainty, StdDevUncertainty))\nastropy\/nddata\/tests\/test_ccddata.py:        ccd_data.uncertainty = StdDevUncertainty(np.ones_like(ccd_data))\nastropy\/nddata\/tests\/test_ccddata.py:    assert isinstance(result, CCDData)\nastropy\/nddata\/tests\/test_ccddata.py:            isinstance(result.uncertainty, StdDevUncertainty))\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((10, 10)), unit='')\nastropy\/nddata\/tests\/test_ccddata.py:    ccd1 = CCDData(np.ones((10, 10)), unit='', wcs=2)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd2 = CCDData(np.ones((10, 10)), unit='', wcs=5)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd1 = CCDData(np.ones((10, 10)), unit='', wcs=2)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd2 = CCDData(np.ones((10, 10)), unit='', wcs=5)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_data.uncertainty = StdDevUncertainty(np.ones_like(ccd_data))\nastropy\/nddata\/tests\/test_ccddata.py:    ccddata = CCDData(a)\nastropy\/nddata\/tests\/test_ccddata.py:    # TODO: Could also be parametrized.\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((3, 3)), unit='')\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((3, 3)), unit='adu')\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((3, 3)), unit='')\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((3, 3)), unit='adu')\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((3, 3)) * 3, unit=u.m)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((3, 3)), unit=u.m)\nastropy\/nddata\/tests\/test_ccddata.py:    hdu = fits.PrimaryHDU(fake_img)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_read = CCDData.read(tmp_file, unit=\"adu\")\nastropy\/nddata\/tests\/test_ccddata.py:        ccd_from_disk = CCDData.read(tmpfile.strpath, unit=explicit_unit_name)\nastropy\/nddata\/tests\/test_ccddata.py:    Check that WCS attribute gets added to header, and that if a CCDData\nastropy\/nddata\/tests\/test_ccddata.py:    is modified, then the CCDData object is turned back into an hdu, the\nastropy\/nddata\/tests\/test_ccddata.py:    wcs.wcs.ctype = [\"RA---AIR\", \"DEC--AIR\"]\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_new = CCDData.read(tmpfile.strpath)\nastropy\/nddata\/tests\/test_ccddata.py:    # Converting CCDData object with wcs to an hdu shouldn't\nastropy\/nddata\/tests\/test_ccddata.py:    # Making a CCDData with WCS (but not WCS in the header) should lead to\nastropy\/nddata\/tests\/test_ccddata.py:    # WCS information in the header when it is converted to an HDU.\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_wcs_not_in_header = CCDData(ccd_data.data, wcs=wcs, unit=\"adu\")\nastropy\/nddata\/tests\/test_ccddata.py:        # Every keyword in the WCS should be in the header of the HDU\nastropy\/nddata\/tests\/test_ccddata.py:    # Now check that if WCS of a CCDData is modified, then the CCDData is\nastropy\/nddata\/tests\/test_ccddata.py:    # converted to an HDU, the WCS keywords in the header are overwritten\nastropy\/nddata\/tests\/test_ccddata.py:    assert ccd_new_hdu_mod_wcs.header['CDELT1'] == ccd_new.wcs.wcs.cdelt[0]\nastropy\/nddata\/tests\/test_ccddata.py:    assert ccd_new_hdu_mod_wcs.header['CDELT2'] == ccd_new.wcs.wcs.cdelt[1]\nastropy\/nddata\/tests\/test_ccddata.py:    from ..ccddata import _KEEP_THESE_KEYWORDS_IN_HEADER\nastropy\/nddata\/tests\/test_ccddata.py:    keepers = set(_KEEP_THESE_KEYWORDS_IN_HEADER)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData.read(data_file)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData.read(data_file1, unit='count')\nastropy\/nddata\/tests\/test_ccddata.py:    from ..ccddata import _KEEP_THESE_KEYWORDS_IN_HEADER\nastropy\/nddata\/tests\/test_ccddata.py:    keepers = set(_KEEP_THESE_KEYWORDS_IN_HEADER)\nastropy\/nddata\/tests\/test_ccddata.py:    CDELT1  =           0.10380000 \/ X Scale projected on detector (#\/pix)\nastropy\/nddata\/tests\/test_ccddata.py:    CDELT2  =           0.10380000 \/ Y Scale projected on detector (#\/pix)\nastropy\/nddata\/tests\/test_ccddata.py:    CUNIT1  = 'degree  '           \/ Units used in both CRVAL1 and CDELT1\nastropy\/nddata\/tests\/test_ccddata.py:    CUNIT2  = 'nm      '           \/ Units used in both CRVAL2 and CDELT2\nastropy\/nddata\/tests\/test_ccddata.py:    CD1_1   =           0.20760000 \/ Pixel Coordinate translation matrix\nastropy\/nddata\/tests\/test_ccddata.py:    CD1_2   =           0.00000000 \/ Pixel Coordinate translation matrix\nastropy\/nddata\/tests\/test_ccddata.py:    CD2_1   =           0.00000000 \/ Pixel Coordinate translation matrix\nastropy\/nddata\/tests\/test_ccddata.py:    CD2_2   =           0.10380000 \/ Pixel Coordinate translation matrix\nastropy\/nddata\/tests\/test_ccddata.py:    C2YPE2  = 'DEC--TAN'           \/ Pixel coordinate system\nastropy\/nddata\/tests\/test_ccddata.py:    RADECSYS= 'FK5     '           \/ The equatorial coordinate system\nastropy\/nddata\/tests\/test_ccddata.py:    hdul = fits.HDUList([fits.PrimaryHDU(np.ones((4241, 1104)), header=hdr)])\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData.read(filename, unit='adu')\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(ccd_data, header=a)\nastropy\/nddata\/tests\/test_ccddata.py:    Check whether the ctypes RA---TAN-SIP and DEC--TAN-SIP survive\nastropy\/nddata\/tests\/test_ccddata.py:            'CTYPE2': 'DEC--TAN-SIP'\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_original = CCDData.read(data_file)\nastropy\/nddata\/tests\/test_ccddata.py:    assert ccd_no_relax[0].header['CTYPE2'] == 'DEC--TAN'\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_after = CCDData.read(filename)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_data.uncertainty = StdDevUncertainty(ccd_data.data * 10)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_after = CCDData.read(filename)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_data.uncertainty = StdDevUncertainty(ccd_data.data * 10)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_after = CCDData.read(filename)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_data.uncertainty = StdDevUncertainty(ccd_data.data * 10)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_after = CCDData.read(filename)\nastropy\/nddata\/tests\/test_ccddata.py:    ccd_after = CCDData.read(filename, hdu_mask='Fun', hdu_uncertainty='NoFun')\nastropy\/nddata\/tests\/test_ccddata.py:        from_disk = CCDData.read(path.strpath)\nastropy\/nddata\/tests\/test_ccddata.py:    with pytest.raises(MissingDataAssociationException):\nastropy\/nddata\/tests\/test_ccddata.py:        StdDevUncertainty(np.ones((10, 10))).parent_nddata\nastropy\/nddata\/tests\/test_ccddata.py:    # TODO: Remove this test if astropy 1.0 isn't supported anymore\nastropy\/nddata\/tests\/test_ccddata.py:    ccd = CCDData(np.ones((10, 10)), unit='')\nastropy\/nddata\/tests\/test_ccddata.py:    uncert = StdDevUncertainty(np.ones((10, 10)))\nastropy\/samp\/hub_script.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/hub_script.py:    parser.add_argument(\"-k\", \"--secret\", dest=\"secret\", metavar=\"CODE\",\nastropy\/samp\/hub_script.py:    parser.add_argument(\"-d\", \"--addr\", dest=\"addr\", metavar=\"ADDR\",\nastropy\/samp\/hub_script.py:    timeout_group.add_argument(\"-t\", \"--timeout\", dest=\"timeout\", metavar=\"SECONDS\",\nastropy\/samp\/hub_script.py:                               help=\"set the Hub inactivity timeout in SECONDS. By default it \"\nastropy\/samp\/hub_script.py:    timeout_group.add_argument(\"-c\", \"--client-timeout\", dest=\"client_timeout\", metavar=\"SECONDS\",\nastropy\/samp\/hub_script.py:                               help=\"set the client inactivity timeout in SECONDS. By default it \"\nastropy\/samp\/hub_script.py:                           help=\"set the Hub instance log level (OFF, ERROR, WARNING, INFO, DEBUG).\",\nastropy\/samp\/hub_script.py:                           type=str, choices=[\"OFF\", \"ERROR\", \"WARNING\", \"INFO\", \"DEBUG\"], default='INFO')\nastropy\/samp\/hub_script.py:                                          \"samp-hub-<PID>-<ID>, where PID is the Hub process ID while ID is an \"\nastropy\/samp\/hub_script.py:                                          \"internal ID (integer).\")\nastropy\/samp\/hub_script.py:        if options.loglevel in (\"OFF\", \"ERROR\", \"WARNING\", \"DEBUG\", \"INFO\"):\nastropy\/samp\/standard_profile.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/standard_profile.py:            # SimpleXMLRPCDispatcher. To maintain backwards compatibility,\nastropy\/tests\/pytest_plugins.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/tests\/pytest_plugins.py:TODO: This entire module should eventually be removed once backwards\nastropy\/tests\/pytest_plugins.py:from ..utils.exceptions import AstropyDeprecationWarning\nastropy\/tests\/pytest_plugins.py:from .plugins.display import PYTEST_HEADER_MODULES, TESTED_VERSIONS\nastropy\/tests\/pytest_plugins.py:    \"deprecated. The variables `PYTEST_HEADER_MODULES` and `TESTED_VERSIONS`\" \\\nastropy\/tests\/pytest_plugins.py:warnings.warn(_warning_message, AstropyDeprecationWarning)\nastropy\/nddata\/mixins\/ndslicing.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/ndslicing.py:# This module implements the Slicing mixin to the NDData class.\nastropy\/nddata\/mixins\/ndslicing.py:__all__ = ['NDSlicingMixin']\nastropy\/nddata\/mixins\/ndslicing.py:class NDSlicingMixin:\nastropy\/nddata\/mixins\/ndslicing.py:    \"\"\"Mixin to provide slicing on objects using the `NDData`\nastropy\/nddata\/mixins\/ndslicing.py:    Using this Mixin with `~astropy.nddata.NDData`:\nastropy\/nddata\/mixins\/ndslicing.py:        >>> from astropy.nddata import NDData, NDSlicingMixin\nastropy\/nddata\/mixins\/ndslicing.py:        >>> class NDDataSliceable(NDSlicingMixin, NDData):\nastropy\/nddata\/mixins\/ndslicing.py:        >>> nd = NDDataSliceable([1,2,3,4,5])\nastropy\/nddata\/mixins\/ndslicing.py:        NDDataSliceable([2, 3])\nastropy\/nddata\/mixins\/ndslicing.py:        >>> nd2 = NDDataSliceable(nd, mask=mask)\nastropy\/nddata\/mixins\/ndslicing.py:        NDDataSliceable([3])\nastropy\/nddata\/mixins\/ndslicing.py:        NDDataSliceable([  1, 100,   3,   4,   5])\nastropy\/nddata\/mixins\/ndslicing.py:    NDDataRef\nastropy\/nddata\/mixins\/ndslicing.py:    NDDataArray\nastropy\/tests\/plugins\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nddata_base.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nddata_base.py:# This module implements the base NDDataBase class.\nastropy\/nddata\/nddata_base.py:__all__ = ['NDDataBase']\nastropy\/nddata\/nddata_base.py:class NDDataBase(metaclass=ABCMeta):\nastropy\/nddata\/nddata_base.py:    `NDData` for a subclass that defines this interface on `numpy.ndarray`-like\nastropy\/nddata\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nddata_withmixins.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nddata_withmixins.py:This module implements a class based on NDData with all Mixins.\nastropy\/nddata\/nddata_withmixins.py:from .nddata import NDData\nastropy\/nddata\/nddata_withmixins.py:from .mixins.ndslicing import NDSlicingMixin\nastropy\/nddata\/nddata_withmixins.py:from .mixins.ndarithmetic import NDArithmeticMixin\nastropy\/nddata\/nddata_withmixins.py:from .mixins.ndio import NDIOMixin\nastropy\/nddata\/nddata_withmixins.py:__all__ = ['NDDataRef']\nastropy\/nddata\/nddata_withmixins.py:class NDDataRef(NDArithmeticMixin, NDIOMixin, NDSlicingMixin, NDData):\nastropy\/nddata\/nddata_withmixins.py:    \"\"\"Implements `NDData` with all Mixins.\nastropy\/nddata\/nddata_withmixins.py:    This class implements a `NDData`-like container that supports reading and\nastropy\/nddata\/nddata_withmixins.py:    A key distinction from `NDDataArray` is that this class does not attempt\nastropy\/nddata\/nddata_withmixins.py:    NDData\nastropy\/nddata\/nddata_withmixins.py:    NDArithmeticMixin\nastropy\/nddata\/nddata_withmixins.py:    NDSlicingMixin\nastropy\/nddata\/nddata_withmixins.py:    NDIOMixin\nastropy\/nddata\/nddata_withmixins.py:    The mixins allow operation that are not possible with `NDData` or\nastropy\/nddata\/nddata_withmixins.py:    `NDDataBase`, i.e. simple arithmetics::\nastropy\/nddata\/nddata_withmixins.py:        >>> from astropy.nddata import NDDataRef, StdDevUncertainty\nastropy\/nddata\/nddata_withmixins.py:        >>> ndd1 = NDDataRef(data, uncertainty=StdDevUncertainty(data))\nastropy\/nddata\/nddata_withmixins.py:        >>> ndd2 = NDDataRef(data, uncertainty=StdDevUncertainty(data))\nastropy\/nddata\/nddata_withmixins.py:    see `NDArithmeticMixin` for a complete list of all supported arithmetic\nastropy\/nddata\/nddata_withmixins.py:    See `NDSlicingMixin` for a description how slicing works (which attributes)\nastropy\/constants\/tests\/test_constant.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/ccddata.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/ccddata.py:\"\"\"This module implements the base CCDData class.\"\"\"\nastropy\/nddata\/ccddata.py:from .compat import NDDataArray\nastropy\/nddata\/ccddata.py:from .nduncertainty import StdDevUncertainty, NDUncertainty\nastropy\/nddata\/ccddata.py:__all__ = ['CCDData', 'fits_ccddata_reader', 'fits_ccddata_writer']\nastropy\/nddata\/ccddata.py:# CCDData. Should be used with care because several functions actually break\nastropy\/nddata\/ccddata.py:    \"\"\"Decorator factory which temporarly disables the need for a unit when\nastropy\/nddata\/ccddata.py:    creating a new CCDData instance. The final result must have a unit.\nastropy\/nddata\/ccddata.py:    Should only be used on CCDData ``add``, ``subtract``, ``divide`` or\nastropy\/nddata\/ccddata.py:    ``multiply`` because only these methods from NDArithmeticMixin are\nastropy\/nddata\/ccddata.py:            # Wrap it again as CCDData so it checks the final unit.\nastropy\/nddata\/ccddata.py:        inner.__doc__ = (\"See `astropy.nddata.NDArithmeticMixin.{}`.\"\nastropy\/nddata\/ccddata.py:class CCDData(NDDataArray):\nastropy\/nddata\/ccddata.py:    \"\"\"A class describing basic CCD data.\nastropy\/nddata\/ccddata.py:    The CCDData class is based on the NDData object and includes a data array,\nastropy\/nddata\/ccddata.py:    information for a single CCD image.\nastropy\/nddata\/ccddata.py:    data : `~astropy.nddata.CCDData`-like or `numpy.ndarray`-like\nastropy\/nddata\/ccddata.py:        The actual data contained in this `~astropy.nddata.CCDData` object.\nastropy\/nddata\/ccddata.py:    uncertainty : `~astropy.nddata.StdDevUncertainty`, `numpy.ndarray` or \\\nastropy\/nddata\/ccddata.py:        Default is ``None``.\nastropy\/nddata\/ccddata.py:        Default is ``None``.\nastropy\/nddata\/ccddata.py:        Default is ``None``.\nastropy\/nddata\/ccddata.py:        Default is ``None``.\nastropy\/nddata\/ccddata.py:        Default is ``None``.\nastropy\/nddata\/ccddata.py:        ``Classmethod`` to create an CCDData instance based on a ``FITS`` file.\nastropy\/nddata\/ccddata.py:        Writes the contents of the CCDData instance into a new ``FITS`` file.\nastropy\/nddata\/ccddata.py:    `~astropy.nddata.CCDData` objects can be easily converted to a regular\nastropy\/nddata\/ccddata.py:        >>> from astropy.nddata import CCDData\nastropy\/nddata\/ccddata.py:        >>> x = CCDData([1,2,3], unit='adu')\nastropy\/nddata\/ccddata.py:    This is useful, for example, when plotting a 2D image using\nastropy\/nddata\/ccddata.py:        >>> from astropy.nddata import CCDData\nastropy\/nddata\/ccddata.py:        >>> x = CCDData([[1,2,3], [4,5,6]], unit='adu')\nastropy\/nddata\/ccddata.py:        # _CCDDataUnit contextmanager.\nastropy\/nddata\/ccddata.py:            raise ValueError(\"a unit for CCDData must be specified.\")\nastropy\/nddata\/ccddata.py:            if isinstance(value, NDUncertainty):\nastropy\/nddata\/ccddata.py:                self._uncertainty = StdDevUncertainty(value)\nastropy\/nddata\/ccddata.py:                         \"StdDevUncertainty.\")\nastropy\/nddata\/ccddata.py:                                \"NDUncertainty object or a numpy array.\")\nastropy\/nddata\/ccddata.py:        \"\"\"Creates an HDUList object from a CCDData object.\nastropy\/nddata\/ccddata.py:            If it is a string append this attribute to the HDUList as\nastropy\/nddata\/ccddata.py:            `~astropy.io.fits.ImageHDU` with the string as extension name.\nastropy\/nddata\/ccddata.py:            Default is ``'MASK'`` for mask, ``'UNCERT'`` for uncertainty and\nastropy\/nddata\/ccddata.py:            ``CTYPE`` ``RA---TAN-SIP`` and ``DEC--TAN-SIP`` requires\nastropy\/nddata\/ccddata.py:              `~astropy.nddata.StdDevUncertainty`.\nastropy\/nddata\/ccddata.py:        hdulist : `~astropy.io.fits.HDUList`\nastropy\/nddata\/ccddata.py:            # Copy here so that we can modify the HDU header by adding WCS\nastropy\/nddata\/ccddata.py:            # information without changing the header of the CCDData object.\nastropy\/nddata\/ccddata.py:            # we need to create a dummy CCDData instance to hold the FITS\nastropy\/nddata\/ccddata.py:            dummy_ccd = CCDData([1], meta=fits.Header(), unit=\"adu\")\nastropy\/nddata\/ccddata.py:        hdus = [fits.PrimaryHDU(self.data, header)]\nastropy\/nddata\/ccddata.py:            hduMask = fits.ImageHDU(self.mask.astype(np.uint8), name=hdu_mask)\nastropy\/nddata\/ccddata.py:            # used so that loading the HDUList can infer the uncertainty type.\nastropy\/nddata\/ccddata.py:            # No idea how this can be done so only allow StdDevUncertainty.\nastropy\/nddata\/ccddata.py:            if self.uncertainty.__class__.__name__ != 'StdDevUncertainty':\nastropy\/nddata\/ccddata.py:                raise ValueError('only StdDevUncertainty can be saved.')\nastropy\/nddata\/ccddata.py:            # Assuming uncertainty is an StdDevUncertainty save just the array\nastropy\/nddata\/ccddata.py:            hduUncert = fits.ImageHDU(self.uncertainty.array,\nastropy\/nddata\/ccddata.py:            raise NotImplementedError('adding the flags to a HDU is not '\nastropy\/nddata\/ccddata.py:        hdulist = fits.HDUList(hdus)\nastropy\/nddata\/ccddata.py:        Return a copy of the CCDData object.\nastropy\/nddata\/ccddata.py:    add = _arithmetic(np.add)(NDDataArray.add)\nastropy\/nddata\/ccddata.py:    subtract = _arithmetic(np.subtract)(NDDataArray.subtract)\nastropy\/nddata\/ccddata.py:    multiply = _arithmetic(np.multiply)(NDDataArray.multiply)\nastropy\/nddata\/ccddata.py:    divide = _arithmetic(np.true_divide)(NDDataArray.divide)\nastropy\/nddata\/ccddata.py:_KEEP_THESE_KEYWORDS_IN_HEADER = [\nastropy\/nddata\/ccddata.py:    'JD-OBS',\nastropy\/nddata\/ccddata.py:    'MJD-OBS',\nastropy\/nddata\/ccddata.py:    'DATE-OBS'\nastropy\/nddata\/ccddata.py:        if k not in _KEEP_THESE_KEYWORDS_IN_HEADER:\nastropy\/nddata\/ccddata.py:    Generate a CCDData object from a FITS file.\nastropy\/nddata\/ccddata.py:        FITS extension from which CCDData should be initialized. If zero and\nastropy\/nddata\/ccddata.py:        Default is ``0``.\nastropy\/nddata\/ccddata.py:        Default is ``None``.\nastropy\/nddata\/ccddata.py:        extension does not exist the uncertainty of the CCDData is ``None``.\nastropy\/nddata\/ccddata.py:        Default is ``'UNCERT'``.\nastropy\/nddata\/ccddata.py:        extension does not exist the mask of the CCDData is ``None``.\nastropy\/nddata\/ccddata.py:        Default is ``'MASK'``.\nastropy\/nddata\/ccddata.py:        Default is ``None``.\nastropy\/nddata\/ccddata.py:            uncertainty = StdDevUncertainty(hdus[hdu_uncertainty].data)\nastropy\/nddata\/ccddata.py:                    log.info(\"first HDU with data is extension \"\nastropy\/nddata\/ccddata.py:            # patch to handle FITS files using ADU for the unit instead of the\nastropy\/nddata\/ccddata.py:        ccd_data = CCDData(hdus[hdu].data, meta=hdr, unit=use_unit,\nastropy\/nddata\/ccddata.py:    Write CCDData object to FITS file.\nastropy\/nddata\/ccddata.py:        If it is a string append this attribute to the HDUList as\nastropy\/nddata\/ccddata.py:        `~astropy.io.fits.ImageHDU` with the string as extension name.\nastropy\/nddata\/ccddata.py:        Default is ``'MASK'`` for mask, ``'UNCERT'`` for uncertainty and\nastropy\/nddata\/ccddata.py:          `~astropy.nddata.StdDevUncertainty`.\nastropy\/nddata\/ccddata.py:with registry.delay_doc_updates(CCDData):\nastropy\/nddata\/ccddata.py:    registry.register_reader('fits', CCDData, fits_ccddata_reader)\nastropy\/nddata\/ccddata.py:    registry.register_writer('fits', CCDData, fits_ccddata_writer)\nastropy\/nddata\/ccddata.py:    registry.register_identifier('fits', CCDData, fits.connect.is_fits)\nastropy\/nddata\/ccddata.py:    CCDData.read.__doc__ = fits_ccddata_reader.__doc__\nastropy\/nddata\/ccddata.py:    CCDData.read.__func__.__doc__ = fits_ccddata_reader.__doc__\nastropy\/nddata\/ccddata.py:    CCDData.write.__doc__ = fits_ccddata_writer.__doc__\nastropy\/nddata\/ccddata.py:    CCDData.write.__func__.__doc__ = fits_ccddata_writer.__doc__\nastropy\/nddata\/mixins\/ndio.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/ndio.py:# This module implements the I\/O mixin to the NDData class.\nastropy\/nddata\/mixins\/ndio.py:__all__ = ['NDIOMixin']\nastropy\/nddata\/mixins\/ndio.py:class NDIOMixin:\nastropy\/nddata\/mixins\/ndio.py:    Mixin class to connect NDData to the astropy input\/output registry.\nastropy\/nddata\/mixins\/ndio.py:        NDData-derived object.\nastropy\/nddata\/mixins\/ndio.py:        This function provides the NDDataBase interface to the astropy unified\nastropy\/nddata\/mixins\/ndio.py:        This function provides the NDDataBase interface to the astropy unified\nastropy\/tests\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/compat.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/compat.py:# This module contains a class equivalent to pre-1.0 NDData.\nastropy\/nddata\/compat.py:from .nddata import NDData\nastropy\/nddata\/compat.py:from .nduncertainty import NDUncertainty\nastropy\/nddata\/compat.py:from .mixins.ndslicing import NDSlicingMixin\nastropy\/nddata\/compat.py:from .mixins.ndarithmetic import NDArithmeticMixin\nastropy\/nddata\/compat.py:from .mixins.ndio import NDIOMixin\nastropy\/nddata\/compat.py:__all__ = ['NDDataArray']\nastropy\/nddata\/compat.py:class NDDataArray(NDArithmeticMixin, NDSlicingMixin, NDIOMixin, NDData):\nastropy\/nddata\/compat.py:    An ``NDData`` object with arithmetic. This class is functionally equivalent\nastropy\/nddata\/compat.py:    to ``NDData`` in astropy  versions prior to 1.0.\nastropy\/nddata\/compat.py:    data : `~numpy.ndarray` or `NDData`\nastropy\/nddata\/compat.py:        The actual data contained in this `NDData` object. Not that this\nastropy\/nddata\/compat.py:    uncertainty : `~astropy.nddata.NDUncertainty`, optional\nastropy\/nddata\/compat.py:        # setter logic below. In base NDData all that is done is to\nastropy\/nddata\/compat.py:        # Initial flags because it is no longer handled in NDData\nastropy\/nddata\/compat.py:        # or NDDataBase.\nastropy\/nddata\/compat.py:        if isinstance(data, NDDataArray):\nastropy\/nddata\/compat.py:                log.info(\"Overwriting NDDataArrays's current \"\nastropy\/nddata\/compat.py:    # Implement uncertainty as NDUncertainty to support propagation of\nastropy\/nddata\/compat.py:            if isinstance(value, NDUncertainty):\nastropy\/nddata\/compat.py:                                \"a NDUncertainty object\")\nastropy\/nddata\/compat.py:        This allows code that requests a Numpy array to use an NDData\nastropy\/nddata\/compat.py:        Returns a new `NDData` object whose values have been converted\nastropy\/nddata\/compat.py:        result : `~astropy.nddata.NDData`\nastropy\/nddata\/decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/decorators.py:from .nddata import NDData\nastropy\/nddata\/decorators.py:SUPPORTED_PROPERTIES = ['data', 'uncertainty', 'mask', 'meta', 'unit', 'wcs',\nastropy\/nddata\/decorators.py:def support_nddata(_func=None, accepts=NDData,\nastropy\/nddata\/decorators.py:    \"\"\"Decorator to wrap functions that could accept an NDData instance with\nastropy\/nddata\/decorators.py:        Default is ``None``.\nastropy\/nddata\/decorators.py:        The class or subclass of ``NDData`` that should be unpacked before\nastropy\/nddata\/decorators.py:        Default is ``NDData``\nastropy\/nddata\/decorators.py:        Default is ``False``.\nastropy\/nddata\/decorators.py:        Default is ``None``.\nastropy\/nddata\/decorators.py:        Default is ``None``.\nastropy\/nddata\/decorators.py:    If properties of ``NDData`` are set but have no corresponding function\nastropy\/nddata\/decorators.py:    If a property is set of the ``NDData`` are set and an explicit argument is\nastropy\/nddata\/decorators.py:    However, you might have an NDData instance that has the ``wcs`` property\nastropy\/nddata\/decorators.py:    WCS separately, or an NDData instance can be passed to the ``data``\nastropy\/nddata\/decorators.py:            if param.kind in (param.VAR_POSITIONAL, param.VAR_KEYWORD):\nastropy\/nddata\/decorators.py:            if not unpack and isinstance(data, NDData):\nastropy\/nddata\/decorators.py:                raise TypeError(\"Only NDData sub-classes that inherit from {0}\"\nastropy\/nddata\/decorators.py:            # If data is an NDData instance, we can try and find properties\nastropy\/nddata\/decorators.py:                for prop in islice(SUPPORTED_PROPERTIES, 1, None):\nastropy\/nddata\/decorators.py:                    # the NDData object\nastropy\/nddata\/decorators.py:                        # NDData.\nastropy\/nddata\/decorators.py:                                \"as an NDData property{1}, using explicitly \"\nastropy\/nddata\/nduncertainty.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/nduncertainty.py:__all__ = ['MissingDataAssociationException',\nastropy\/nddata\/nduncertainty.py:           'IncompatibleUncertaintiesException', 'NDUncertainty',\nastropy\/nddata\/nduncertainty.py:           'StdDevUncertainty', 'UnknownUncertainty']\nastropy\/nddata\/nduncertainty.py:class MissingDataAssociationException(Exception):\nastropy\/nddata\/nduncertainty.py:    has not been associated with a parent `~astropy.nddata.NDData` object.\nastropy\/nddata\/nduncertainty.py:class NDUncertainty(metaclass=ABCMeta):\nastropy\/nddata\/nduncertainty.py:    \"\"\"This is the metaclass for uncertainty classes used with `NDData`.\nastropy\/nddata\/nduncertainty.py:        `NDUncertainty` subclasses are recommended.\nastropy\/nddata\/nduncertainty.py:        Default is ``None``.\nastropy\/nddata\/nduncertainty.py:        Default is ``None``.\nastropy\/nddata\/nduncertainty.py:        Default is ``True``.\nastropy\/nddata\/nduncertainty.py:        If given another `NDUncertainty`-like class as ``array`` if their\nastropy\/nddata\/nduncertainty.py:        if isinstance(array, NDUncertainty):\nastropy\/nddata\/nduncertainty.py:            # Given an NDUncertainty class or subclass check that the type\nastropy\/nddata\/nduncertainty.py:                # TODO : Clarify it (see NDData.init for same problem)?\nastropy\/nddata\/nduncertainty.py:        self.parent_nddata = None  # no associated NDData - until it is set!\nastropy\/nddata\/nduncertainty.py:        Defined as abstract property so subclasses *have* to override this.\nastropy\/nddata\/nduncertainty.py:        \"\"\"`NDData` : reference to `NDData` instance with this uncertainty.\nastropy\/nddata\/nduncertainty.py:        message = \"uncertainty is not associated with an NDData object\"\nastropy\/nddata\/nduncertainty.py:                raise MissingDataAssociationException(message)\nastropy\/nddata\/nduncertainty.py:                # The NDData is saved as weak reference so we must call it\nastropy\/nddata\/nduncertainty.py:                    log.info(\"parent_nddata should be a weakref to an NDData \"\nastropy\/nddata\/nduncertainty.py:            raise MissingDataAssociationException(message)\nastropy\/nddata\/nduncertainty.py:            # instance of NDData. Direct references should NOT be used:\nastropy\/nddata\/nduncertainty.py:            The operation that is performed on the `NDData`. Supported are\nastropy\/nddata\/nduncertainty.py:        other_nddata : `NDData` instance\nastropy\/nddata\/nduncertainty.py:        resulting_uncertainty : `NDUncertainty` instance\nastropy\/nddata\/nduncertainty.py:            Another instance of the same `NDUncertainty` subclass containing\nastropy\/nddata\/nduncertainty.py:        Checks if the other uncertainty is `NDUncertainty`-like and if so\nastropy\/nddata\/nduncertainty.py:        other_uncert : `NDUncertainty` subclass\nastropy\/nddata\/nduncertainty.py:        other_uncert : `NDUncertainty` subclass\nastropy\/nddata\/nduncertainty.py:            but converted to a compatible `NDUncertainty` subclass if\nastropy\/nddata\/nduncertainty.py:            `NDUncertainty` subclass.\nastropy\/nddata\/nduncertainty.py:        if isinstance(other_uncert, NDUncertainty):\nastropy\/nddata\/nduncertainty.py:class UnknownUncertainty(NDUncertainty):\nastropy\/nddata\/nduncertainty.py:        see `NDUncertainty`\nastropy\/nddata\/nduncertainty.py:class StdDevUncertainty(NDUncertainty):\nastropy\/nddata\/nduncertainty.py:    of `StdDevUncertainty`. The class can handle if the uncertainty has a\nastropy\/nddata\/nduncertainty.py:    unit that differs from (but is convertible to) the parents `NDData` unit.\nastropy\/nddata\/nduncertainty.py:        see `NDUncertainty`\nastropy\/nddata\/nduncertainty.py:    `StdDevUncertainty` should always be associated with an `NDData`-like\nastropy\/nddata\/nduncertainty.py:        >>> from astropy.nddata import NDData, StdDevUncertainty\nastropy\/nddata\/nduncertainty.py:        >>> ndd = NDData([1,2,3],\nastropy\/nddata\/nduncertainty.py:        ...              uncertainty=StdDevUncertainty([0.1, 0.1, 0.1]))\nastropy\/nddata\/nduncertainty.py:        StdDevUncertainty([0.1, 0.1, 0.1])\nastropy\/nddata\/nduncertainty.py:    or by setting it manually on the `NDData` instance::\nastropy\/nddata\/nduncertainty.py:        >>> ndd.uncertainty = StdDevUncertainty([0.2], unit='m', copy=True)\nastropy\/nddata\/nduncertainty.py:        StdDevUncertainty([0.2])\nastropy\/nddata\/nduncertainty.py:        StdDevUncertainty(2)\nastropy\/nddata\/nduncertainty.py:        \"\"\"`True` : `StdDevUncertainty` allows to propagate correlated \\\nastropy\/nddata\/nduncertainty.py:        \"\"\"``\"std\"`` : `StdDevUncertainty` implements standard deviation.\nastropy\/nddata\/nduncertainty.py:        if isinstance(other_uncert, StdDevUncertainty):\nastropy\/nddata\/nduncertainty.py:            # Determine the result depending on the correlation\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:from ...nduncertainty import (StdDevUncertainty, UnknownUncertainty,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:from ... import NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:from ...nddata import NDData\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# Alias NDDataAllMixins in case this will be renamed ... :-)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:NDDataArithmetic = NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:class StdDevUncertaintyUncorrelated(StdDevUncertainty):\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# Test with Data covers:\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# scalars, 1D, 2D and 3D\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Division\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic([1, 2])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# Test with Data and unit and covers:\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Division\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# Test with Data and unit and covers:\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Division is possible\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(1, wcs=wcs1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(1, wcs=wcs2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Division\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# Masks are completely separated in the NDArithmetics from the data so we need\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# masks 1D, 2D and mixed cases with broadcasting\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(1, mask=mask1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(1, mask=mask2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Division\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(1, mask=np.array([1, 0], dtype=np.bool_))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(1, mask=np.array([1, 0, 1], dtype=np.bool_))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic([1, 2, 3], uncertainty=StdDevUncertainty([1, 1, 3]))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic([2, 2, 2], uncertainty=StdDevUncertainty([2, 2, 2]))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Multiplication and Division only work with almost equal array comparisons\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# TODO: Maybe covering units too but I think that should work because of\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1, uncertainty=StdDevUncertainty(uncert1))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2, uncertainty=StdDevUncertainty(uncert2))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Multiplication and Division only work with almost equal array comparisons\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1, uncertainty=StdDevUncertainty(uncert1))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2, uncertainty=StdDevUncertainty(uncert2))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:                           uncertainty=StdDevUncertaintyUncorrelated(uncert1))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:                           uncertainty=StdDevUncertaintyUncorrelated(uncert2))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic([1, -2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1_ref = NDDataArithmetic([1, -2, 3],\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:                               uncertainty=StdDevUncertainty([0, 0, 0]))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic([2, 2, -2],\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:                           uncertainty=StdDevUncertainty([2, 2, 2]))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Division\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:# compared against correctly scaled NDDatas\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Data has same units\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        uncert1 = StdDevUncertainty(uncert1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        uncert_ref1 = StdDevUncertainty(uncert1_ref, copy=True)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        uncert2 = StdDevUncertainty(uncert2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        uncert_ref2 = StdDevUncertainty(uncert2_ref, copy=True)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1, uncertainty=uncert1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2, uncertainty=uncert2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1_ref = NDDataArithmetic(data1, uncertainty=uncert_ref1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2_ref = NDDataArithmetic(data2, uncertainty=uncert_ref2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Division\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty1 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty2 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1, meta=meta1, mask=mask1, wcs=wcs1,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2, meta=meta2, mask=mask2, wcs=wcs2,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = NDDataArithmetic(data1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty1 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty2 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1, meta=meta1, mask=mask1, wcs=wcs1,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2, meta=meta2, mask=mask2, wcs=wcs2,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty1 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty2 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1, meta=meta1, mask=mask1, wcs=wcs1,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2, meta=meta2, mask=mask2, wcs=wcs2,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty1 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    uncertainty2 = StdDevUncertainty([1, 2, 3])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd1 = NDDataArithmetic(data1, meta=meta1, mask=mask1, wcs=wcs1,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd2 = NDDataArithmetic(data2, meta=meta2, mask=mask2, wcs=wcs2,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd1 = NDDataArithmetic(np.ones((3, 3)))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd2 = NDDataArithmetic(np.ones((3, 3)))\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd3 = getattr(NDDataArithmetic, meth)(ndd1, ndd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd3 = getattr(NDDataArithmetic(-100), meth)(ndd1, ndd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd3 = getattr(NDDataArithmetic, meth)(data1, data2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    # Compare it with the instance-useage and two identical NDData-like\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd1 = NDDataArithmetic(data1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd2 = NDDataArithmetic(data2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd3 = getattr(NDDataArithmetic(-100), meth)(data1, data2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd1 = NDDataArithmetic(np.ones((3, 3)),\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    ndd2 = NDDataArithmetic(np.ones((3, 3)),\nastropy\/samp\/tests\/test_standard_profile.py:                          \"samp.description.text\": \"Client 1 Description\",\nastropy\/samp\/tests\/test_standard_profile.py:                          \"samp.description.text\": \"Client 2 Description\",\nastropy\/samp\/tests\/test_standard_profile.py:        # TODO: check that receive_response received the right data\nastropy\/samp\/tests\/web_profile_test_helpers.py:from ..hub import WebProfileDialog\nastropy\/samp\/tests\/web_profile_test_helpers.py:class AlwaysApproveWebProfileDialog(WebProfileDialog):\nastropy\/samp\/tests\/web_profile_test_helpers.py:        WebProfileDialog.__init__(self)\nexamples\/coordinates\/rv-to-gsr.py:*License: BSD*\nexamples\/coordinates\/rv-to-gsr.py:# velocity of the star HD 155967, as obtained from\nexamples\/coordinates\/rv-to-gsr.py:# `~astropy.coordinates.CartesianDifferential` object ``galcen_v_sun``:\nexamples\/coordinates\/rv-to-gsr.py:        The 3D velocity of the solar system barycenter in the GSR frame.\nexamples\/coordinates\/rv-to-gsr.py:        Defaults to the same solar motion as in the\nastropy\/utils\/tests\/test_misc.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_misc.py:    class Base(metaclass=misc.InheritDocstrings):\nastropy\/utils\/tests\/test_misc.py:        # TODO: Maybe if __doc__ is None this test should be skipped instead?\nastropy\/utils\/tests\/test_misc.py:        locale.setlocale(locale.LC_ALL, str('de_DE'))\nastropy\/utils\/tests\/test_misc.py:    with misc.set_locale('de_DE'):\nastropy\/utils\/tests\/test_console.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_metadata.py:from collections import OrderedDict\nastropy\/utils\/tests\/test_metadata.py:from ..metadata import MetaData, MergeConflictError, merge, enable_merge_strategies\nastropy\/utils\/tests\/test_metadata.py:class OrderedDictSubclass(OrderedDict):\nastropy\/utils\/tests\/test_metadata.py:        assert isinstance(d.meta, OrderedDict)\nastropy\/utils\/tests\/test_metadata.py:                                         OrderedDict([('a', 1)]),\nastropy\/utils\/tests\/test_metadata.py:                                         OrderedDictSubclass([('a', 1)])]))\nastropy\/utils\/tests\/test_metadata.py:                                         OrderedDict([('a', 1)]),\nastropy\/utils\/tests\/test_metadata.py:                                         OrderedDictSubclass([('a', 1)])]))\nastropy\/utils\/tests\/test_metadata.py:class ExampleData:\nastropy\/utils\/tests\/test_metadata.py:    meta = MetaData()\nastropy\/utils\/tests\/test_metadata.py:class TestMetaExampleData(MetaBaseTest):\nastropy\/utils\/tests\/test_metadata.py:    test_class = ExampleData\nastropy\/utils\/tests\/test_metadata.py:    data1 = ExampleData()\nastropy\/utils\/tests\/test_metadata.py:    data2 = ExampleData()\nastropy\/nddata\/mixins\/ndarithmetic.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/ndarithmetic.py:# This module implements the Arithmetic mixin to the NDData class.\nastropy\/nddata\/mixins\/ndarithmetic.py:from ..nduncertainty import NDUncertainty\nastropy\/nddata\/mixins\/ndarithmetic.py:__all__ = ['NDArithmeticMixin']\nastropy\/nddata\/mixins\/ndarithmetic.py:# Docstring templates for add, subtract, multiply, divide methods.\nastropy\/nddata\/mixins\/ndarithmetic.py:    operand, operand2 : `NDData`-like instance or convertible to one.\nastropy\/nddata\/mixins\/ndarithmetic.py:        that the uncertainties are `NDUncertainty`-like. Default is ``True``.\nastropy\/nddata\/mixins\/ndarithmetic.py:        Default is `numpy.logical_or`.\nastropy\/nddata\/mixins\/ndarithmetic.py:        Default is ``None``.\nastropy\/nddata\/mixins\/ndarithmetic.py:        not successful. Default is ``'first_found'``.\nastropy\/nddata\/mixins\/ndarithmetic.py:        Default is 0.\nastropy\/nddata\/mixins\/ndarithmetic.py:    result : `~astropy.nddata.NDData`-like\nastropy\/nddata\/mixins\/ndarithmetic.py:class NDArithmeticMixin:\nastropy\/nddata\/mixins\/ndarithmetic.py:    Mixin class to add arithmetic to an NDData object.\nastropy\/nddata\/mixins\/ndarithmetic.py:    so that the subclass sees NDData as the main superclass. See\nastropy\/nddata\/mixins\/ndarithmetic.py:    `~astropy.nddata.NDDataArray` for an example.\nastropy\/nddata\/mixins\/ndarithmetic.py:        - ``uncertainty`` : has to be something that has a `NDUncertainty`-like\nastropy\/nddata\/mixins\/ndarithmetic.py:    For example for uncertainties not representing an `NDUncertainty`-like\nastropy\/nddata\/mixins\/ndarithmetic.py:    :meth:`NDArithmeticMixin.add`. ``None`` means that the result will have no\nastropy\/nddata\/mixins\/ndarithmetic.py:    Decomposing the units is not attempted, mainly due to the internal mechanics\nastropy\/nddata\/mixins\/ndarithmetic.py:    Using this Mixin with `~astropy.nddata.NDData`:\nastropy\/nddata\/mixins\/ndarithmetic.py:        >>> from astropy.nddata import NDData, NDArithmeticMixin\nastropy\/nddata\/mixins\/ndarithmetic.py:        >>> class NDDataWithMath(NDArithmeticMixin, NDData):\nastropy\/nddata\/mixins\/ndarithmetic.py:        >>> ndd = NDDataWithMath(100)\nastropy\/nddata\/mixins\/ndarithmetic.py:        NDDataWithMath(120)\nastropy\/nddata\/mixins\/ndarithmetic.py:        >>> ndd = NDDataWithMath(-4)\nastropy\/nddata\/mixins\/ndarithmetic.py:        NDDataWithMath(-0.25)\nastropy\/nddata\/mixins\/ndarithmetic.py:        >>> NDDataWithMath.subtract(5, 4)\nastropy\/nddata\/mixins\/ndarithmetic.py:        NDDataWithMath(1)\nastropy\/nddata\/mixins\/ndarithmetic.py:            The operation that is performed on the `NDData`. Supported are\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            different :meth:`NDArithmeticMixin._arithmetic_mask` (or wcs, ...)\nastropy\/nddata\/mixins\/ndarithmetic.py:            :meth:`NDArithmeticMixin.add`.\nastropy\/nddata\/mixins\/ndarithmetic.py:        # Determine the other properties\nastropy\/nddata\/mixins\/ndarithmetic.py:            see `NDArithmeticMixin._arithmetic` parameter description.\nastropy\/nddata\/mixins\/ndarithmetic.py:        operand : `NDData`-like instance\nastropy\/nddata\/mixins\/ndarithmetic.py:        # Do the calculation with or without units\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\nastropy\/nddata\/mixins\/ndarithmetic.py:        operand : `NDData`-like instance\nastropy\/nddata\/mixins\/ndarithmetic.py:            The result of :meth:`NDArithmeticMixin._arithmetic_data`.\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add` parameter description.\nastropy\/nddata\/mixins\/ndarithmetic.py:        result_uncertainty : `NDUncertainty` subclass instance or None\nastropy\/nddata\/mixins\/ndarithmetic.py:            The resulting uncertainty already saved in the same `NDUncertainty`\nastropy\/nddata\/mixins\/ndarithmetic.py:        # Make sure these uncertainties are NDUncertainties so this kind of\nastropy\/nddata\/mixins\/ndarithmetic.py:                not isinstance(self.uncertainty, NDUncertainty)):\nastropy\/nddata\/mixins\/ndarithmetic.py:                            \"subclasses of NDUncertainty.\")\nastropy\/nddata\/mixins\/ndarithmetic.py:                not isinstance(operand.uncertainty, NDUncertainty)):\nastropy\/nddata\/mixins\/ndarithmetic.py:                            \"subclasses of NDUncertainty.\")\nastropy\/nddata\/mixins\/ndarithmetic.py:        # TODO: There is no enforced requirement that actually forbids the\nastropy\/nddata\/mixins\/ndarithmetic.py:        # sign of the uncertainty DOES matter.\nastropy\/nddata\/mixins\/ndarithmetic.py:            # Delete the temporary uncertainty again.\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\nastropy\/nddata\/mixins\/ndarithmetic.py:        operand : `NDData`-like instance\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\nastropy\/nddata\/mixins\/ndarithmetic.py:        operand : `NDData` instance or subclass\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add` parameter description.\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\nastropy\/nddata\/mixins\/ndarithmetic.py:        operand : `NDData`-like instance\nastropy\/nddata\/mixins\/ndarithmetic.py:            see :meth:`NDArithmeticMixin.add`\nastropy\/nddata\/mixins\/ndarithmetic.py:            Do not override this method in subclasses.\nastropy\/nddata\/mixins\/ndarithmetic.py:        result : `~astropy.nddata.NDData`-like\nastropy\/nddata\/mixins\/ndarithmetic.py:            Depending how this method was called either ``self_or_cls``\nastropy\/nddata\/mixins\/ndarithmetic.py:            is the NDData-subclass that is used as wrapper for the result.\nastropy\/nddata\/mixins\/ndarithmetic.py:        # DO NOT OVERRIDE THIS METHOD IN SUBCLASSES.\nastropy\/nddata\/mixins\/ndarithmetic.py:        if isinstance(self_or_cls, NDArithmeticMixin):\nastropy\/nddata\/mixins\/ndarithmetic.py:        # of NDData.\nastropy\/utils\/tests\/test_xml.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_xml.py:             'DSACAT=IDR&amp;amp;DSATAB=Emitters&amp;amp;'\nastropy\/utils\/tests\/test_xml.py:              'DSACAT=IDR&DSATAB=Emitters&'\nastropy\/utils\/tests\/test_xml.py:             b'DSACAT=IDR&amp;amp;DSATAB=Emitters&amp;amp;'\nastropy\/utils\/tests\/test_xml.py:              b'DSACAT=IDR&DSATAB=Emitters&'\nastropy\/utils\/tests\/test_xml.py:    # Default is True (all XML tags escaped)\nastropy\/utils\/tests\/test_data_info.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_data_info.py:DTYPE_TESTS = ((np.array(b'abcd').dtype, STRING_TYPE_NAMES[(True, 'S')] + '4'),\nastropy\/utils\/tests\/test_data_info.py:@pytest.mark.parametrize('input,output', DTYPE_TESTS)\nastropy\/tests\/runner.py:from collections import OrderedDict\nastropy\/tests\/runner.py:from ..utils.exceptions import AstropyWarning, AstropyDeprecationWarning\nastropy\/tests\/runner.py:        The default value for the keyword argument. (Default: `None`)\nastropy\/tests\/runner.py:        cls.keywords = OrderedDict()\nastropy\/tests\/runner.py:        cls.run_tests.__doc__ = cls.RUN_TESTS_DOCSTRING.format(keywords=doc_keywords)\nastropy\/tests\/runner.py:    RUN_TESTS_DOCSTRING = \\\nastropy\/tests\/runner.py:        # Don't import pytest until it's actually needed to run the tests\nastropy\/tests\/runner.py:                          AstropyDeprecationWarning)\nastropy\/tests\/runner.py:            Turn on PDB post-mortem analysis for failing tests. Same as\nastropy\/utils\/tests\/test_decorators.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_decorators.py:from ..exceptions import AstropyDeprecationWarning, AstropyUserWarning\nastropy\/utils\/tests\/test_decorators.py:    class DummyClass:\nastropy\/utils\/tests\/test_decorators.py:    dummy = DummyClass()\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    # Creating an instance should work but raise a DeprecationWarning\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    # Creating an instance should work but raise a DeprecationWarning\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:        \"\"\"Docstring\"\"\"\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:        with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyUserWarning, AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyUserWarning, AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyUserWarning, AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_decorators.py:    with catch_warnings(AstropyDeprecationWarning) as w:\nastropy\/utils\/tests\/test_introspection.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_timer.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_timer.py:# STDLIB\nastropy\/utils\/tests\/test_timer.py:# THIRD-PARTY\nastropy\/utils\/tests\/test_timer.py:    p.time_func(2.2)  # Test OrderedDict\nastropy\/utils\/tests\/test_collections.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/errors.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/errors.py:Defines custom errors and exceptions used in `astropy.samp`.\nastropy\/samp\/tests\/test_errors.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/tests\/test_ndio.py:from ... import NDData, NDIOMixin, NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndio.py:# Alias NDDataAllMixins in case this will be renamed ... :-)\nastropy\/nddata\/mixins\/tests\/test_ndio.py:NDDataIO = NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndio.py:    ndd = NDDataIO([1, 2, 3])\nastropy\/utils\/tests\/test_codegen.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_codegen.py:        assert exc_cls is ZeroDivisionError\nexamples\/coordinates\/plot_obs-planning.py:Determining and plotting the altitude\/azimuth of a celestial object\nexamples\/coordinates\/plot_obs-planning.py:*License: BSD*\nexamples\/coordinates\/plot_obs-planning.py:# Mountain and set the time to 11pm EDT on 2012 July 12:\nexamples\/coordinates\/plot_obs-planning.py:utcoffset = -4*u.hour  # Eastern Daylight Time\nexamples\/coordinates\/plot_obs-planning.py:# and 7am EDT:\nexamples\/coordinates\/plot_obs-planning.py:plt.xlabel('Hours from EDT Midnight')\nexamples\/coordinates\/plot_obs-planning.py:# Do the same with `~astropy.coordinates.get_moon` to find when the moon is\nexamples\/coordinates\/plot_obs-planning.py:plt.xlabel('Hours from EDT Midnight')\nastropy\/utils\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/extern\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nexamples\/coordinates\/plot_galactocentric-frame.py:*License: BSD*\nexamples\/coordinates\/plot_galactocentric-frame.py:# We'll use the data for the star HD 39881 from the `Simbad\nexamples\/coordinates\/plot_galactocentric-frame.py:# and velocity to a Galactocentric frame to see if it has a large 3D velocity\nexamples\/coordinates\/plot_galactocentric-frame.py:# `~astropy.coordinates.Galactocentric` instance to see the 3D Cartesian\nexamples\/coordinates\/plot_galactocentric-frame.py:# ``z_sun`` which set the sun-Galactic center distance, the 3D velocity vector\nexamples\/coordinates\/plot_galactocentric-frame.py:# `~astropy.coordinates.CartesianDifferential` instance, as in the example\nexamples\/coordinates\/plot_galactocentric-frame.py:v_sun = coord.CartesianDifferential([11.1, 244, 7.25]*u.km\/u.s)\nexamples\/coordinates\/plot_galactocentric-frame.py:                                 galcen_v_sun=coord.CartesianDifferential(vx, vy, vz),\nexamples\/coordinates\/plot_galactocentric-frame.py:ring_dif = coord.CylindricalDifferential(\nastropy\/utils\/timer.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/timer.py:# STDLIB\nastropy\/utils\/timer.py:from collections import Iterable, OrderedDict\nastropy\/utils\/timer.py:# THIRD-PARTY\nastropy\/utils\/timer.py:    \"\"\"Decorator to time a function or method.\nastropy\/utils\/timer.py:        self._cache_good = OrderedDict()\nastropy\/utils\/timer.py:        self._cache_est = OrderedDict()\nastropy\/utils\/timer.py:        self._cache_out = OrderedDict()\nastropy\/utils\/timer.py:            If `None`, will use `~astropy.modeling.polynomial.Polynomial1D`\nastropy\/utils\/timer.py:        self._cache_est = OrderedDict()\nastropy\/utils\/timer.py:            model = modeling.models.Polynomial1D(1)\nastropy\/utils\/tests\/test_data.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/utils\/tests\/test_data.py:         'https:\/\/astropy.stsci.edu\/data\/intersphinx\/README'])\nastropy\/utils\/tests\/test_data.py:    # Download the test URL and make sure it exists, then clear just that\nastropy\/utils\/tests\/test_data.py:    # TODO: if in the future, the root data\/ directory is added in, the below\nastropy\/utils\/tests\/test_data.py:    # test should be uncommented and the README.rst should be replaced with\nastropy\/utils\/tests\/test_data.py:    # fnout2 = get_pkg_data_filename('..\/..\/data\/README.rst')\nastropy\/utils\/tests\/test_data.py:    # assert os.path.isfile(fnout2) and fnout2.endswith('README.rst')\nastropy\/utils\/tests\/test_data.py:    get_pkg_data_filename('..\/..\/..\/data\/README.rst')\nastropy\/utils\/tests\/test_data.py:    monkeypatch.setenv(str('XDG_CONFIG_HOME'), 'foo')\nastropy\/utils\/tests\/test_data.py:    monkeypatch.delenv(str('XDG_CONFIG_HOME'))\nastropy\/utils\/tests\/test_data.py:    monkeypatch.setenv(str('XDG_CACHE_HOME'), 'bar')\nastropy\/utils\/tests\/test_data.py:    monkeypatch.delenv(str('XDG_CACHE_HOME'))\nastropy\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/tests\/test_web_profile.py:from .web_profile_test_helpers import (AlwaysApproveWebProfileDialog,\nastropy\/samp\/tests\/test_web_profile.py:from ..web_profile import CROSS_DOMAIN, CLIENT_ACCESS_POLICY\nastropy\/samp\/tests\/test_web_profile.py:        self.dialog = AlwaysApproveWebProfileDialog()\nastropy\/samp\/tests\/test_web_profile.py:            assert f.read() == CROSS_DOMAIN\nastropy\/samp\/tests\/test_client.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/_erfa\/erfa_generator.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/_erfa\/erfa_generator.py:from collections import OrderedDict\nastropy\/_erfa\/erfa_generator.py:                  'eraLDBODY': \"dt_eraLDBODY\",\nastropy\/_erfa\/erfa_generator.py:NDIMS_REX = re.compile(re.escape(\"numpy.dtype([('fi0', '.*', <(.*)>)])\").replace(r'\\.\\*', '.*').replace(r'\\<', '(').replace(r'\\>', ')'))\nastropy\/_erfa\/erfa_generator.py:class FunctionDoc:\nastropy\/_erfa\/erfa_generator.py:            result = re.search(\"Given([^\\n]*):\\n(.+?)  \\n\", self.doc, re.DOTALL)\nastropy\/_erfa\/erfa_generator.py:                    arg_doc = ArgumentDoc(i)\nastropy\/_erfa\/erfa_generator.py:            result = re.search(\"Given and returned([^\\n]*):\\n(.+?)  \\n\", self.doc, re.DOTALL)\nastropy\/_erfa\/erfa_generator.py:                    arg_doc = ArgumentDoc(i)\nastropy\/_erfa\/erfa_generator.py:            result = re.search(\"Returned([^\\n]*):\\n(.+?)  \\n\", self.doc, re.DOTALL)\nastropy\/_erfa\/erfa_generator.py:                    arg_doc = ArgumentDoc(i)\nastropy\/_erfa\/erfa_generator.py:            result = re.search(\"Given and returned([^\\n]*):\\n(.+?)  \\n\", self.doc, re.DOTALL)\nastropy\/_erfa\/erfa_generator.py:                    arg_doc = ArgumentDoc(i)\nastropy\/_erfa\/erfa_generator.py:            result = re.search(\"Returned \\\\(function value\\\\)([^\\n]*):\\n(.+?)  \\n\", self.doc, re.DOTALL)\nastropy\/_erfa\/erfa_generator.py:                ret_info.append(ReturnDoc(result.group(2)))\nastropy\/_erfa\/erfa_generator.py:class ArgumentDoc:\nastropy\/_erfa\/erfa_generator.py:class ReturnDoc:\nastropy\/_erfa\/erfa_generator.py:        p = re.compile(pattern, flags=re.DOTALL | re.MULTILINE)\nastropy\/_erfa\/erfa_generator.py:        self.doc = FunctionDoc(search.group(2))\nastropy\/_erfa\/erfa_generator.py:                raise ValueError('Did not find prototype {} in file '\nastropy\/_erfa\/erfa_generator.py:    funcs = OrderedDict()\nastropy\/_erfa\/erfa_generator.py:                                              erfa_h, flags=re.DOTALL | re.MULTILINE)\nastropy\/_erfa\/erfa_generator.py:            func_names = re.findall(r' (\\w+)\\(.*?\\);', functions, flags=re.DOTALL)\nastropy\/_erfa\/erfa_generator.py:        result = re.findall(r\"#define (ERFA_\\w+?) (.+?)$\", chunk, flags=re.DOTALL | re.MULTILINE)\nastropy\/_erfa\/erfa_generator.py:            doc = re.findall(r\"\/\\* (.+?) \\*\/\\n\", chunk, flags=re.DOTALL)\nastropy\/_erfa\/erfa_generator.py:    # TODO: re-enable this when const char* return values and non-status code integer rets are possible\nastropy\/_erfa\/erfa_generator.py:    print_(\"Done!\")\nastropy\/_erfa\/erfa_generator.py:DEFAULT_ERFA_LOC = os.path.join(os.path.split(__file__)[0],\nastropy\/_erfa\/erfa_generator.py:DEFAULT_TEMPLATE_LOC = os.path.split(__file__)[0]\nastropy\/_erfa\/erfa_generator.py:    ap.add_argument('srcdir', default=DEFAULT_ERFA_LOC, nargs='?',\nastropy\/_erfa\/erfa_generator.py:                    help='Directory where the ERFA c and header files '\nastropy\/_erfa\/erfa_generator.py:                         'erfa.h). Defaults to the builtin astropy '\nastropy\/_erfa\/erfa_generator.py:                         'erfa: \"{0}\"'.format(DEFAULT_ERFA_LOC))\nastropy\/_erfa\/erfa_generator.py:                    default=DEFAULT_TEMPLATE_LOC,\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:from ... import NDData, NDSlicingMixin\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:from ...nduncertainty import NDUncertainty, StdDevUncertainty\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:# Just add the Mixin to NDData\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:# TODO: Make this use NDDataRef instead!\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:class NDDataSliceable(NDSlicingMixin, NDData):\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:# Just some uncertainty (following the StdDevUncertainty implementation of\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:class SomeUncertainty(NDUncertainty):\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data)\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data)\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data)\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    # Data is 2d but mask only 1d so this should let the IndexError when\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data, **kwarg)\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data, mask=mask, uncertainty=uncertainty, wcs=wcs,\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data, mask=mask, uncertainty=uncertainty, wcs=wcs)\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    # Slice only 1D\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    # Slice 3D\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data, mask=mask, uncertainty=uncertainty, wcs=wcs)\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data, mask=mask, uncertainty=uncertainty, wcs=wcs)\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    uncertainty = StdDevUncertainty(data.copy())\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    nd = NDDataSliceable(data, mask=mask, uncertainty=uncertainty, wcs=wcs)\nastropy\/extern\/bundled\/six.py:# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nastropy\/extern\/bundled\/six.py:# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nastropy\/extern\/bundled\/six.py:# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nastropy\/extern\/bundled\/six.py:# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nastropy\/extern\/bundled\/six.py:# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nastropy\/extern\/bundled\/six.py:class _LazyDescr(object):\nastropy\/extern\/bundled\/six.py:class MovedModule(_LazyDescr):\nastropy\/extern\/bundled\/six.py:class MovedAttribute(_LazyDescr):\nastropy\/extern\/bundled\/six.py:    MovedAttribute(\"UserDict\", \"UserDict\", \"collections\"),\nastropy\/extern\/bundled\/six.py:    MovedModule(\"tkinter_dialog\", \"Dialog\", \"tkinter.dialog\"),\nastropy\/extern\/bundled\/six.py:    MovedModule(\"tkinter_filedialog\", \"FileDialog\", \"tkinter.filedialog\"),\nastropy\/extern\/bundled\/six.py:    MovedModule(\"tkinter_simpledialog\", \"SimpleDialog\", \"tkinter.simpledialog\"),\nastropy\/extern\/bundled\/six.py:    MovedModule(\"tkinter_commondialog\", \"tkCommonDialog\",\nastropy\/extern\/bundled\/six.py:    MovedModule(\"tkinter_tkfiledialog\", \"tkFileDialog\", \"tkinter.filedialog\"),\nastropy\/extern\/bundled\/six.py:    MovedModule(\"tkinter_tksimpledialog\", \"tkSimpleDialog\",\nastropy\/extern\/bundled\/six.py:    MovedAttribute(\"OpenerDirector\", \"urllib2\", \"urllib.request\"),\nastropy\/extern\/bundled\/six.py:    MovedAttribute(\"HTTPDefaultErrorHandler\", \"urllib2\", \"urllib.request\"),\nastropy\/extern\/bundled\/six.py:    MovedAttribute(\"HTTPPasswordMgrWithDefaultRealm\", \"urllib2\", \"urllib.request\"),\nastropy\/extern\/bundled\/six.py:    MovedAttribute(\"AbstractDigestAuthHandler\", \"urllib2\", \"urllib.request\"),\nastropy\/extern\/bundled\/six.py:    MovedAttribute(\"HTTPDigestAuthHandler\", \"urllib2\", \"urllib.request\"),\nastropy\/extern\/bundled\/six.py:    MovedAttribute(\"ProxyDigestAuthHandler\", \"urllib2\", \"urllib.request\"),\nastropy\/extern\/bundled\/six.py:              updated=functools.WRAPPER_UPDATES):\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:Dwarf Galaxy (hereafter Sgr; as defined in Majewski et al. 2003).  The Sgr\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:  Dwarf Galaxy. I. Morphology of the Sagittarius Core and Tidal Arms\",\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:* Law & Majewski 2010, \"The Sagittarius Dwarf Galaxy: A Model for Evolution in a\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:* David Law's Sgr info page http:\/\/www.stsci.edu\/~dlaw\/Sgr\/\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:*License: BSD*\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:        The Distance for this object along the line-of-sight.\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:        The proper motion in Declination for this object (``pm_ra_cosdec`` must\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:    default_differential = coord.SphericalCosLatDifferential\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:        coord.SphericalCosLatDifferential: [\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:        coord.SphericalDifferential: [\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:    frame_specific_representation_info[coord.UnitSphericalCosLatDifferential] = \\\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:        frame_specific_representation_info[coord.SphericalCosLatDifferential]\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:    frame_specific_representation_info[coord.UnitSphericalDifferential] = \\\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:        frame_specific_representation_info[coord.SphericalDifferential]\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:D = rotation_matrix(SGR_PHI, \"z\")\nexamples\/coordinates\/plot_sgr-coordinate-frame.py:SGR_MATRIX = matrix_product(A, B, C, D)\nastropy\/_erfa\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/_erfa\/setup_package.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/_erfa\/setup_package.py:ERFAPKGDIR = os.path.relpath(os.path.dirname(__file__))\nastropy\/_erfa\/setup_package.py:ERFA_SRC = os.path.abspath(os.path.join(ERFAPKGDIR, '..', '..', 'cextern', 'erfa'))\nastropy\/_erfa\/setup_package.py:SRC_FILES += [os.path.join(ERFAPKGDIR, filename)\nastropy\/_erfa\/setup_package.py:GEN_FILES = [os.path.join(ERFAPKGDIR, 'core.py'), os.path.join(ERFAPKGDIR, 'core.c')]\nastropy\/_erfa\/setup_package.py:        # Determine modification times\nastropy\/_erfa\/setup_package.py:    filename = os.path.join(ERFAPKGDIR, 'erfa_generator.py')\nastropy\/_erfa\/setup_package.py:    gen.main(gen.DEFAULT_ERFA_LOC,\nastropy\/_erfa\/setup_package.py:             os.path.join(ERFAPKGDIR, 'core.py'),\nastropy\/_erfa\/setup_package.py:             gen.DEFAULT_TEMPLATE_LOC,\nastropy\/_erfa\/setup_package.py:    sources = [os.path.join(ERFAPKGDIR, \"core.c\")]\nastropy\/_erfa\/tests\/test_erfa.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/samp\/tests\/test_hub.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst\nastropy\/_erfa\/tests\/__init__.py:# Licensed under a 3-clause BSD style license - see LICENSE.rst","role":"tool","tool_calls":null},{"content":"astropy\/io\/fits\/fitsrec.py:from numpy import char as chararray\nastropy\/io\/fits\/fitsrec.py:                    # Normally the column array is a chararray of 1 character\nastropy\/io\/fits\/fitsrec.py:                elif isinstance(raw_field, chararray.chararray):\nastropy\/io\/fits\/fitsrec.py:    Numeric-style chararray objects.\nastropy\/io\/fits\/fitsrec.py:    # Numpy >= 1.10.dev recarray no longer returns chararrays for strings\nastropy\/io\/fits\/fitsrec.py:            not isinstance(field, chararray.chararray)):\nastropy\/io\/fits\/fitsrec.py:        field = field.view(chararray.chararray)\nastropy\/io\/fits\/hdu\/table.py:from numpy import char as chararray\nastropy\/io\/fits\/hdu\/table.py:        if isinstance(field, chararray.chararray):\nastropy\/io\/fits\/hdu\/table.py:                if (not isinstance(c, chararray.chararray) and\nastropy\/io\/fits\/column.py:from numpy import char as chararray\nastropy\/io\/fits\/column.py:                          (np.ndarray, chararray.chararray, Delayed)):\nastropy\/io\/fits\/column.py:                    array = chararray.array(array, itemsize=itemsize)\nastropy\/io\/fits\/column.py:                    return chararray.array(array, itemsize=fsize, copy=False)\nastropy\/io\/fits\/column.py:                input = [chararray.array(x, itemsize=1) for x in input]\nastropy\/io\/fits\/column.py:        elif isinstance(value, chararray.chararray) and value.itemsize == 1:\nastropy\/io\/fits\/column.py:            value = chararray.array(value, itemsize=1)\nastropy\/io\/fits\/column.py:            data_output[idx] = chararray.array(encode_ascii(rowval),\nastropy\/io\/fits\/tests\/test_table.py:from numpy import char as chararray\nastropy\/io\/fits\/tests\/test_table.py:        a1 = chararray.array(['abc', 'def', 'xx'])\nastropy\/io\/fits\/tests\/test_table.py:        a1 = chararray.array(['abcd', 'def'])\nastropy\/io\/fits\/tests\/test_table.py:                           array=chararray.array(a))\nastropy\/io\/fits\/tests\/test_table.py:            # the single row.  However, this is broken for chararray because\nastropy\/io\/fits\/tests\/test_table.py:            # is a bug in chararray though and not a bug in any FITS-specific","role":"tool","tool_calls":null},{"content":"ah_bootstrap.py:            pkg_resources.working_set.add(dist, replace=True)\nah_bootstrap.py:            # replace=True option here.  These versions are old enough that all\nah_bootstrap.py:        stdout = stdout.decode(stdio_encoding, 'replace')\nah_bootstrap.py:        stderr = stderr.decode(stdio_encoding, 'replace')\nastropy\/io\/misc\/hdf5.py:        replaced; the file\/group will not be overwritten.\nastropy\/convolution\/__init__.py:    from .convolve import convolve, convolve_fft, interpolate_replace_nans, convolve_models\nastropy\/convolution\/convolve.py:    replaced with interpolated values using the kernel as an interpolation\nastropy\/convolution\/convolve.py:        masked array, the masked values will be replaced by ``fill_value``.\nastropy\/convolution\/convolve.py:        'fill' will replace the NaN pixels with a fixed numerical value (default\nastropy\/convolution\/convolve.py:    # Mark the NaN values so we can replace them later if interpolate_nan is\nastropy\/convolution\/convolve.py:    `convolve_fft` is very similar to `convolve` in that it replaces ``NaN``\nastropy\/convolution\/convolve.py:        and the kernel.  ``fill`` will replace the NaN pixels with a fixed\nastropy\/convolution\/convolve.py:def interpolate_replace_nans(array, kernel, convolve=convolve, **kwargs):\nastropy\/convolution\/convolve.py:    Given a data set containing NaNs, replace the NaNs by interpolating from\nastropy\/convolution\/convolve.py:        A copy of the original array with NaN pixels replaced with their\nastropy\/table\/table.py:    Warning class for cases when a table column is replaced via the\nastropy\/table\/table.py:            raise ValueError(\"Cannot replace column '{0}'.  Use Table.replace_column() instead.\"\nastropy\/table\/table.py:                # Set an existing column by first trying to replace, and if\nastropy\/table\/table.py:                        and not conf.replace_inplace):\nastropy\/table\/table.py:                        self._replace_column_warnings(item, value)\nastropy\/table\/table.py:    def _replace_column_warnings(self, name, col):\nastropy\/table\/table.py:        Same as replace_column but issues warnings under various circumstances.\nastropy\/table\/table.py:        warns = conf.replace_warnings\nastropy\/table\/table.py:        self.replace_column(name, col)\nastropy\/table\/table.py:            warnings.warn(\"replaced column '{}'\".format(name),\nastropy\/table\/table.py:                    msg = (\"replaced column '{}' which looks like an array slice. \"\nastropy\/table\/table.py:                msg = (\"replaced column '{}' and the number of references \"\nastropy\/table\/table.py:                msg = (\"replaced column '{}' and column attributes {} changed.\"\nastropy\/table\/table.py:    def replace_column(self, name, col):\nastropy\/table\/table.py:            Name of column to replace\nastropy\/table\/table.py:            New column object to replace the existing column\nastropy\/table\/table.py:            >>> t.replace_column('a', float_a)\nastropy\/table\/table.py:            raise ValueError('cannot replace a table index column')\nastropy\/table\/table.py:        self._replace_cols(columns)\nastropy\/table\/table.py:            self._replace_cols(columns)\nastropy\/table\/table.py:    def _replace_cols(self, columns):\nastropy\/table\/column.py:            index.replace_col(col, newcol)\nastropy\/table\/column.py:            index.replace_col(data, self)\nastropy\/table\/column.py:                    self.parent_table.replace_column(self.name, converted)\nastropy\/table\/column.py:            index.replace_col(self_data, self)\nastropy\/table\/column.py:            A copy of ``self`` with masked entries replaced by `fill_value`\nastropy\/table\/sorted_array.py:    def replace_rows(self, row_map):\nastropy\/table\/index.py:replace_rows(row_map) -> None : replace row numbers based on slice\nastropy\/table\/index.py:            # replace Time columns with approximate form and remainder\nastropy\/table\/index.py:    def replace_col(self, prev_col, new_col):\nastropy\/table\/index.py:            Column reference to replace\nastropy\/table\/index.py:    def replace(self, row, col_name, val):\nastropy\/table\/index.py:    def replace_rows(self, col_slice):\nastropy\/table\/index.py:        self.data.replace_rows(row_map)\nastropy\/table\/index.py:    def replace(self, row, col, val):\nastropy\/table\/index.py:            self.index.replace(self.orig_coords(row), col, val)\nastropy\/table\/index.py:            # replace self.index with a new object reference\nastropy\/table\/index.py:    def replace_rows(self, col_slice):\nastropy\/table\/index.py:            self.index.replace_rows([self.orig_coords(x) for x in col_slice])\nastropy\/table\/index.py:    def replace_col(self, prev_col, new_col):\nastropy\/table\/index.py:        self.index.replace_col(prev_col, new_col)\nastropy\/table\/np_utils.py:    Partial replacement for `~numpy.core.records.fromrecords` which includes\nastropy\/table\/np_utils.py:    This should not serve as a full replacement for the original function;\nastropy\/table\/tests\/test_column.py:        t['a'][0] = 'eee'  # replace item with string that gets truncated\nastropy\/table\/tests\/test_column.py:        t['a'][:] = ['ff', 'ggg']  # replace item with string that gets truncated\nastropy\/table\/tests\/test_column.py:        mc[:] = [np.ma.masked, 'ggg']  # replace item with string that gets truncated\nastropy\/table\/__init__.py:    replace_warnings = _config.ConfigItem(\nastropy\/table\/__init__.py:    replace_inplace = _config.ConfigItem(\nastropy\/table\/tests\/test_pprint.py:def test_decode_replace():\nastropy\/table\/tests\/test_pprint.py:    decoding to utf-8 and gets replaced by U+FFFD.  See\nastropy\/table\/tests\/test_pprint.py:    https:\/\/docs.python.org\/3\/library\/codecs.html#codecs.replace_errors\ndocs\/conf.py:.. |minimum_numpy_version| replace:: {0.__minimum_numpy_version__}\ndocs\/conf.py:# The version info for the project you're documenting, acts as replacement for\nastropy\/table\/tests\/test_table.py:    def test_fail_replace_column(self, table_types):\nastropy\/table\/tests\/test_table.py:        \"\"\"Raise exception when trying to replace column via table.columns object\"\"\"\nastropy\/table\/tests\/test_table.py:            t.replace_column('not there', [1, 2, 3])\nastropy\/table\/tests\/test_table.py:    def test_replace_column(self, table_types):\nastropy\/table\/tests\/test_table.py:            t.replace_column('a', col)\nastropy\/table\/tests\/test_table.py:    def test_replace_index_column(self, table_types):\nastropy\/table\/tests\/test_table.py:            t.replace_column('a', [1, 2, 3])\nastropy\/table\/tests\/test_table.py:        assert err.value.args[0] == 'cannot replace a table index column'\nastropy\/table\/tests\/test_table.py:def test_replace_column_qtable():\nastropy\/table\/tests\/test_table.py:    t.replace_column('a', a.to('cm'))\nastropy\/table\/tests\/test_table.py:def test_replace_update_column_via_setitem():\nastropy\/table\/tests\/test_table.py:    already well-tested ``replace_column`` and in-place update\nastropy\/table\/tests\/test_table.py:def test_replace_update_column_via_setitem_warnings_normal():\nastropy\/table\/tests\/test_table.py:    Test warnings related to table replace change in #5556:\nastropy\/table\/tests\/test_table.py:    Normal warning-free replace\nastropy\/table\/tests\/test_table.py:        with table.conf.set_temp('replace_warnings',\nastropy\/table\/tests\/test_table.py:            t['a'] = [10, 20, 30]  # replace column\nastropy\/table\/tests\/test_table.py:def test_replace_update_column_via_setitem_warnings_slice():\nastropy\/table\/tests\/test_table.py:    Test warnings related to table replace change in #5556:\nastropy\/table\/tests\/test_table.py:        with table.conf.set_temp('replace_warnings',\nastropy\/table\/tests\/test_table.py:            t2['a'] = [10, 20]  # replace slice\nastropy\/table\/tests\/test_table.py:            assert \"replaced column 'a' which looks like an array slice\" in str(w[0].message)\nastropy\/table\/tests\/test_table.py:def test_replace_update_column_via_setitem_warnings_attributes():\nastropy\/table\/tests\/test_table.py:    Test warnings related to table replace change in #5556:\nastropy\/table\/tests\/test_table.py:        with table.conf.set_temp('replace_warnings',\nastropy\/table\/tests\/test_table.py:        assert \"replaced column 'a' and column attributes ['unit']\" in str(w[0].message)\nastropy\/table\/tests\/test_table.py:def test_replace_update_column_via_setitem_warnings_refcount():\nastropy\/table\/tests\/test_table.py:    Test warnings related to table replace change in #5556:\nastropy\/table\/tests\/test_table.py:        with table.conf.set_temp('replace_warnings',\nastropy\/table\/tests\/test_table.py:        assert \"replaced column 'a' and the number of references\" in str(w[0].message)\nastropy\/table\/tests\/test_table.py:def test_replace_update_column_via_setitem_warnings_always():\nastropy\/table\/tests\/test_table.py:    Test warnings related to table replace change in #5556:\nastropy\/table\/tests\/test_table.py:    Test 'always' setting that raises warning for any replace.\nastropy\/table\/tests\/test_table.py:        with table.conf.set_temp('replace_warnings', ['always']):\nastropy\/table\/tests\/test_table.py:            t['a'] = [10, 20, 30]  # replace column\nastropy\/table\/tests\/test_table.py:            assert \"replaced column 'a'\" == str(w[0].message)\nastropy\/table\/tests\/test_table.py:def test_replace_update_column_via_setitem_replace_inplace():\nastropy\/table\/tests\/test_table.py:    Test the replace_inplace config option related to #5556.  In this\nastropy\/table\/tests\/test_table.py:    case no replace is done.\nastropy\/table\/tests\/test_table.py:        with table.conf.set_temp('replace_inplace', True):\nastropy\/table\/tests\/test_table.py:            with table.conf.set_temp('replace_warnings',\nastropy\/table\/tests\/test_table.py:                t['a'] = [10, 20, 30]  # normally replaces column, but not now\nastropy\/table\/pprint.py:        return val.decode('utf-8', errors='replace')\nastropy\/io\/registry.py:        This contextmanager is experimental and may be replaced by a more\nastropy\/table\/bst.py:    def replace(self, child, new_child):\nastropy\/table\/bst.py:            raise ValueError(\"Cannot call replace() on non-child\")\nastropy\/table\/bst.py:        self.replace(child, None)\nastropy\/table\/bst.py:            parent.replace(node, new_node)\nastropy\/table\/bst.py:    def replace_rows(self, row_map):\nastropy\/table\/bst.py:    def replace_rows(self, row_map):\nastropy\/io\/fits\/convenience.py:           ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/convenience.py:           ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/convenience.py:    tabledump.__doc__ += BinTableHDU._tdump_file_format.replace('\\n', '\\n    ')\nastropy\/io\/fits\/convenience.py:    return BinTableHDU.load(datafile, cdfile, hfile, replace=True)\nastropy\/io\/fits\/convenience.py:    tableload.__doc__ += BinTableHDU._tdump_file_format.replace('\\n', '\\n    ')\nastropy\/io\/fits\/setup_package.py:    # 'numpy' will be replaced with the proper path to the numpy includes\nastropy\/io\/fits\/column.py:        # This forces the data for the HDU to be read, which will replace\nastropy\/io\/fits\/column.py:        # replaces the array originally pointed to by .array), but it's the way\nastropy\/io\/fits\/column.py:                    numpy_format = numpy_format.replace('i', 'u')\nastropy\/io\/fits\/column.py:                dim = repr(dim).replace(' ', '')\nastropy\/io\/fits\/tests\/test_header.py:        out = out.replace(b'hello', u'h\u00e9llo'.encode('latin1'))\nastropy\/io\/fits\/tests\/test_header.py:        out = out.replace(b'BAR', u'B\u00c0R'.encode('latin1'))\nastropy\/io\/fits\/tests\/test_image.py:        the blanks are replaced by NaN in the float data), that the \"BLANK\"\nastropy\/io\/fits\/hdu\/image.py:        # Set to True if the data or header is replaced, indicating that\nastropy\/io\/fits\/hdu\/image.py:                self._data_replaced = True\nastropy\/io\/fits\/hdu\/image.py:            self._data_replaced = True\nastropy\/io\/fits\/hdu\/image.py:                # *after* _prewriteto(), replace these with blank cards so\nastropy\/io\/fits\/hdu\/image.py:        # as though the original image has been completely replaced\nastropy\/io\/fits\/hdu\/image.py:            Otherwise, pixels equal to this value will be replaced with\nastropy\/io\/fits\/hdu\/table.py:                            (k, data.dtype[k].kind.replace('u', 'i') +\nastropy\/io\/fits\/hdu\/table.py:                self._data_replaced = True\nastropy\/io\/fits\/hdu\/table.py:            self._data_replaced = True\nastropy\/io\/fits\/hdu\/table.py:          the field is replaced by a new line character.\nastropy\/io\/fits\/hdu\/table.py:               ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/hdu\/table.py:        dump.__doc__ += _tdump_file_format.replace('\\n', '\\n        ')\nastropy\/io\/fits\/hdu\/table.py:    def load(cls, datafile, cdfile=None, hfile=None, replace=False,\nastropy\/io\/fits\/hdu\/table.py:        replace : bool\nastropy\/io\/fits\/hdu\/table.py:            replaced with the contents of the ASCII file instead of\nastropy\/io\/fits\/hdu\/table.py:            values not present in this Header, unless ``replace=True`` in which\nastropy\/io\/fits\/hdu\/table.py:            this Header's values are completely replaced with the values from\nastropy\/io\/fits\/hdu\/table.py:            if replace:\nastropy\/io\/fits\/hdu\/table.py:        load.__doc__ += _tdump_file_format.replace('\\n', '\\n        ')\nastropy\/io\/fits\/hdu\/table.py:                kwargs[key] = words.pop(0).replace('\"\"', '')\nastropy\/io\/fits\/hdu\/table.py:                word = words.pop(0).replace('\"\"', '')\nastropy\/io\/fits\/header.py:                    'replaced with spaces upon writing.', AstropyUserWarning)\nastropy\/io\/fits\/header.py:                header_str.replace('\\0', ' ')\nastropy\/io\/fits\/header.py:                        'bytes will be replaced with spaces on write.'.format(\nastropy\/io\/fits\/header.py:               ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/header.py:           ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/header.py:            easily replaces the old usage of :meth:`Header.update` both\nastropy\/io\/fits\/header.py:                                     replace=True)\nastropy\/io\/fits\/header.py:            old API can be replaced as follows:\nastropy\/io\/fits\/header.py:            If there are blank cards at the end of the Header, replace the\nastropy\/io\/fits\/header.py:            replaced by the 'XTENSION' keyword.  Likewise if the first keyword\nastropy\/io\/fits\/header.py:            header is 'SIMPLE', the 'XTENSION' keyword is replaced by the\nastropy\/io\/fits\/header.py:            If there are blank cards at the end of the Header, replace the\nastropy\/io\/fits\/header.py:    def _relativeinsert(self, card, before=None, after=None, replace=False):\nastropy\/io\/fits\/header.py:        If replace=True, move an existing card with the same keyword.\nastropy\/io\/fits\/header.py:        if replace:\nastropy\/io\/fits\/header.py:        # Even if replace=True, the insertion idx may have changed since the\nastropy\/io\/fits\/header.py:        pattern = pattern.replace('*', r'.*').replace('?', r'.')\nastropy\/io\/fits\/header.py:        pattern = pattern.replace('...', r'\\S*') + '$'\nastropy\/io\/fits\/hdu\/base.py:        self._data_replaced = False\nastropy\/io\/fits\/hdu\/base.py:               ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/hdu\/base.py:                # the user may have replaced the previous mmap'd array\nastropy\/io\/fits\/hdu\/base.py:                if copy or self._data_replaced:\nastropy\/io\/fits\/hdu\/base.py:        self._data_replaced = False\nastropy\/io\/fits\/hdu\/base.py:            fails to replace an invalid value.  In other words, this provides\nastropy\/io\/fits\/hdu\/base.py:            a default value to use as a replacement if the keyword's current\nastropy\/io\/fits\/hdu\/base.py:            value is invalid.  If `None`, there is no replacement value and the\nastropy\/io\/fits\/hdu\/base.py:           ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/scripts\/fitscheck.py:                        filename, str(exc).replace('\\n', ' '))\nastropy\/io\/fits\/hdu\/hdulist.py:               ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/hdu\/hdulist.py:                # a segfault if they try to access it).  This replaces the\nastropy\/io\/fits\/card.py:                'delete this card from the header or replace it.')\nastropy\/io\/fits\/card.py:                'Either delete this card from the header or replace it.')\nastropy\/io\/fits\/card.py:                'delete this card from the header or replace it.')\nastropy\/io\/fits\/card.py:                'Either delete this card from the header or replace it.')\nastropy\/io\/fits\/card.py:                value = card.value.rstrip().replace(\"''\", \"'\")\nastropy\/io\/fits\/card.py:        value = self._value.replace(\"'\", \"''\")\nastropy\/io\/fits\/card.py:            exp_val_str = value.replace(\"'\", \"''\")\nastropy\/io\/fits\/fitstime.py:        The table whose Time columns are to be replaced.\nastropy\/io\/fits\/fitstime.py:        The table with replaced Time columns\nastropy\/io\/fits\/fitstime.py:            newtable.replace_column(col.info.name, Column(col.value))\nastropy\/io\/fits\/fitstime.py:        newtable.replace_column(col.info.name, Column(jd12, unit='d'))\nastropy\/io\/fits\/hdu\/compressed.py:    def _relativeinsert(self, card, before=None, after=None, replace=False):\nastropy\/io\/fits\/hdu\/compressed.py:                                replace=replace)\nastropy\/io\/fits\/hdu\/compressed.py:                                           replace=replace)\nastropy\/io\/fits\/hdu\/compressed.py:        floating point value of ``0.0`` is replaced with the special integer\nastropy\/io\/fits\/hdu\/compressed.py:        # as though the original image has been completely replaced\nastropy\/io\/fits\/hdu\/compressed.py:                        # called *after* _prewriteto(), replace these with\nastropy\/io\/fits\/tests\/test_hdulist.py:    def test_replace_memmaped_array(self):\nastropy\/io\/fits\/tests\/test_hdulist.py:    def test_replace_mmap_data(self):\nastropy\/io\/fits\/tests\/test_hdulist.py:    def test_replace_mmap_data_2(self):\nastropy\/io\/fits\/tests\/test_hdulist.py:        different file should work.  Like test_replace_mmap_data but with\nastropy\/io\/fits\/util.py:                          'file header and have been replaced by \"?\" '\nastropy\/io\/fits\/util.py:            s = s.decode('ascii', errors='replace')\nastropy\/io\/fits\/util.py:            return s.replace(u'\\ufffd', '?')\nastropy\/io\/fits\/util.py:            dt = s.dtype.str.replace('S', 'U')\nastropy\/io\/fits\/util.py:        mode = mode.replace('+', '')\nastropy\/io\/fits\/tests\/test_table.py:                    s.replace('\\x00', ' '))\nastropy\/io\/fits\/tests\/test_table.py:            f.write(raw_bytes.replace(b'(2,2,3)', b'(2,2,2)'))\nastropy\/io\/fits\/tests\/test_table.py:        Blank values in numerical columns of ASCII tables should be replaced\nastropy\/io\/fits\/tests\/test_table.py:        value, they should be replaced with zeros.\nastropy\/io\/fits\/tests\/test_table.py:            nulled = h.read().replace(u'2       ', u'        ')\nastropy\/io\/fits\/tests\/test_table.py:            nulled = h.read().replace(u'3.00000000', u'          ')\nastropy\/io\/fits\/tests\/test_fitscheck.py:        # replace checksums with wrong ones\nastropy\/io\/fits\/tests\/test_fitstime.py:            t.replace_column('a', getattr(t['a'], scale))\nastropy\/io\/fits\/diff.py:               ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/diff.py:               ``rtol`` replaces the deprecated ``tolerance`` argument.\nastropy\/io\/votable\/xmlutil.py:    This is rather simplistic at the moment, since it just replaces\nastropy\/io\/votable\/tree.py:        function so the resizing strategy can be easily replaced.\nastropy\/io\/votable\/tests\/vo_test.py:            dtype[1] = dtype[1].replace(str('<'), str('>'))\nastropy\/io\/votable\/validator\/html.py:                content = content.replace(result.get_dirpath() + '\/', '')\nastropy\/wcs\/wcs.py:            header_string = header_string.replace('END' + ' ' * 77, '')\nastropy\/wcs\/wcs.py:        # have to be replaced with\nastropy\/wcs\/setup_package.py:    s = s.decode('ascii').encode('ascii', 'backslashreplace')\nastropy\/wcs\/setup_package.py:    s = s.replace(b'\\n', b'\\\\n')\nastropy\/wcs\/setup_package.py:    s = s.replace(b'\\0', b'\\\\0')\nastropy\/visualization\/interval.py:        sampled from the array (with replacement).\nastropy\/visualization\/interval.py:        # If needed, limit the number of samples. We sample with replacement\nastropy\/visualization\/interval.py:        sampled from the array (with replacement).\nastropy\/wcs\/tests\/extension\/test_extension.py:    code = code.strip().replace('\\n', '; ')\nastropy\/visualization\/tests\/test_lupton_rgb.py:    Simulates saturation on an image, so we can test 'replace_saturated_pixels'\nastropy\/visualization\/tests\/test_lupton_rgb.py:        pytest.skip('replaceSaturatedPixels is not implemented in astropy yet')\nastropy\/visualization\/tests\/test_lupton_rgb.py:        lupton_rgb.replaceSaturatedPixels(self.image_r, self.image_g, self.image_b, 1, 2000)\nastropy\/visualization\/tests\/test_lupton_rgb.py:        # Check that we replaced those NaNs with some reasonable value\nastropy\/io\/ascii\/core.py:    Internal class to replace the csv writer ``writerow`` and ``writerows``\nastropy\/io\/ascii\/core.py:    # empty fields and is then replaced post-write with doubled-quotechar.\nastropy\/io\/ascii\/core.py:    replace_sentinel = '2b=48Av%0-V3p>bX'\nastropy\/io\/ascii\/core.py:        # If QUOTE_MINIMAL and space-delimited then replace empty fields with\nastropy\/io\/ascii\/core.py:                    values[i] = self.replace_sentinel\nastropy\/io\/ascii\/core.py:        # If QUOTE_MINIMAL and space-delimited then replace empty fields with\nastropy\/io\/ascii\/core.py:                        values[i] = self.replace_sentinel\nastropy\/io\/ascii\/core.py:        If it has empty fields that have been replaced then change those\nastropy\/io\/ascii\/core.py:            row_string = re.sub(self.replace_sentinel, self.quotechar2, row_string)\nastropy\/io\/ascii\/core.py:        If splitting on whitespace then replace unquoted tabs with space first\"\"\"\nastropy\/io\/ascii\/core.py:            line = _replace_tab_with_space(line, self.escapechar, self.quotechar)\nastropy\/io\/ascii\/core.py:def _replace_tab_with_space(line, escapechar, quotechar):\nastropy\/io\/ascii\/core.py:        String containing tabs to be replaced with spaces.\nastropy\/io\/ascii\/core.py:        A copy of ``line`` with tabs replaced by spaces, preserving quoted substrings.\nastropy\/io\/ascii\/core.py:        In the second step all replacements are done for the appropriate columns.\nastropy\/io\/ascii\/core.py:            for replacement in reversed(self.fill_values):\nastropy\/io\/ascii\/core.py:                if len(replacement) < 2:\nastropy\/io\/ascii\/core.py:                elif len(replacement) == 2:\nastropy\/io\/ascii\/core.py:                    affect_cols = replacement[2:]\nastropy\/io\/ascii\/core.py:                    cols[i].fill_values[replacement[0]] = str(replacement[1])\nastropy\/io\/ascii\/core.py:    def _replace_vals(self, cols):\nastropy\/io\/ascii\/core.py:        self._replace_vals(self.cols)\nastropy\/io\/ascii\/core.py:    replace_char = ' '\nastropy\/io\/ascii\/core.py:    # case the continuation character is just replaced with replace_char.\nastropy\/io\/ascii\/core.py:                line = line.replace(self.continuation_char, self.replace_char)\nastropy\/io\/ascii\/core.py:                parts.append(line.replace(self.continuation_char, self.replace_char))\nastropy\/io\/ascii\/core.py:            # Test if it looks like (match, replace_string, optional_colname),\nastropy\/config\/configuration.py:    Determines if a config file can be safely replaced because it doesn't\nastropy\/io\/ascii\/ipac.py:    replace masked values with a string or number of your choice as\nastropy\/io\/ascii\/daophot.py:    replace_char = ' '\nastropy\/io\/ascii\/daophot.py:        replace_char = self.replace_char\nastropy\/io\/ascii\/daophot.py:                    line = line.replace(continuation_char, replace_char)\nastropy\/io\/ascii\/daophot.py:                    line = line.replace(multiline_char, replace_char)\nastropy\/io\/ascii\/latex.py:    re_string = re.compile(latex.replace('\\\\', '\\\\\\\\'))\nastropy\/io\/ascii\/latex.py:        line = line.replace(r'\\tablehead', '')\nastropy\/io\/ascii\/latex.py:        return line.replace(r'\\colhead', '')\nastropy\/visualization\/wcsaxes\/coordinates_map.py:                name = wcs.wcs.ctype[coord_index][:4].replace('-', '')\nastropy\/io\/ascii\/html.py:        Return an iterator of the values with replacements based on fill_values\nastropy\/logger.py:        this replaces the output from ``warnings.warn``.\nastropy\/time\/formats.py:            subfmt_in = subfmt_in.replace(strptime_code, regex)\nastropy\/time\/formats.py:                dt = (dt - dt.utcoffset()).replace(tzinfo=None)\nastropy\/samp\/standard_profile.py:                trace = str(trace.encode('ASCII', 'backslashreplace'), 'ASCII')\nastropy\/samp\/lockfile_helpers.py:                                       .replace(\"\\\\\", \"\"), allow_none=1)\nastropy\/modeling\/tests\/test_quantities_parameters.py:    # Instantiating with different units works, and just replaces the original unit\nastropy\/io\/ascii\/tests\/test_html.py:    Test that passing fill_values should replace any matching row\nastropy\/io\/ascii\/tests\/test_html.py:    Test that passing optional column in fill_values should only replace\nastropy\/io\/ascii\/tests\/test_html.py:    Test that passing masked values in fill_values should only replace\nastropy\/io\/ascii\/tests\/test_html.py:    columns with correctly replaced fill_values.\nastropy\/io\/ascii\/tests\/test_html.py:    Test that passing masked values in fill_values should only replace\nastropy\/coordinates\/earth_orientation.py:# TODO: replace this with SOFA equivalent\nastropy\/coordinates\/earth_orientation.py:# TODO: replace w\/SOFA equivalent\nastropy\/units\/utils.py:    return s.replace('\\n', ' ')\nastropy\/samp\/hub.py:        to replace the terminal-based message with e.g. a GUI pop-up. Two\nastropy\/coordinates\/angle_utilities.py:            t.value = float(t.value.replace('\u2212', '-'))\nastropy\/coordinates\/earth.py:            If not False, force replacement of the cached registry with a\nastropy\/coordinates\/builtin_frames\/__init__.py:    docstr = dedent(docstr) + '    ' + graphstr.replace('\\n', '\\n    ')\nastropy\/coordinates\/matrix_utilities.py:    this function can be replaced by ``m1 @ m2 @ m3``.\nastropy\/coordinates\/baseframe.py:                data_repr = data_repr.replace(nmrepr, nmpref)\nastropy\/coordinates\/baseframe.py:                    diffrepr[0] = diffrepr[0].replace(rep_nm, frm_nm)\nastropy\/samp\/hub_proxy.py:            url = hub_params[\"samp.hub.xmlrpc.url\"].replace(\"\\\\\", \"\")\nastropy\/coordinates\/tests\/test_api_ape5.py:    # The above is essentially a replacement of the below, but tweaked so that\nastropy\/coordinates\/tests\/test_atc_replacements.py:\"\"\"Test replacements for ERFA functions atciqz and aticq.\"\"\"\nastropy\/coordinates\/tests\/test_atc_replacements.py:    \"\"\"Check replacements against erfa versions for consistency.\"\"\"\nastropy\/coordinates\/tests\/test_transformations.py:    # TODO: replace after a final decision on PR #6280\nastropy\/modeling\/blackbody.py:        # with.  (As noted in #4393 ideally this would be replaced by a version\nastropy\/modeling\/polynomial.py:        ap_coeff_params = dict((k.replace('AP_', 'c'), v)\nastropy\/modeling\/polynomial.py:        bp_coeff_params = dict((k.replace('BP_', 'c'), v)\nastropy\/io\/ascii\/tests\/test_write.py:'''.replace('\\n', os.linesep)\nastropy\/io\/ascii\/tests\/test_write.py:    assert out.getvalue() == expected.replace(\nastropy\/io\/ascii\/tests\/test_write.py:        'colhead{s}', r'colhead{$\\mathrm{s}$}').replace(\nastropy\/io\/ascii\/tests\/test_compressed.py:    t_uncomp = read(os.path.join(ROOT, filename.replace('.gz', '')))\nastropy\/io\/ascii\/tests\/test_compressed.py:    t_uncomp = read(os.path.join(ROOT, filename.replace('.bz2', '')))\nastropy\/io\/ascii\/tests\/test_compressed.py:    t_uncomp = read(os.path.join(ROOT, filename.replace('.xz', '')))\nastropy\/io\/ascii\/tests\/test_read.py:    # This is a NoHeader format table and so `names` should replace\nastropy\/io\/ascii\/tests\/test_read.py:    # gives the column names 'c', 'd', which get replaced by 'a', 'b'\nastropy\/io\/ascii\/tests\/test_read.py:    # gives the column names 'c', 'd', which get replaced by 'a', 'b'\nastropy\/coordinates\/representation.py:        # so that is the formmater we need to replace.\nastropy\/units\/quantity.py:                                    \"to quantities with in-place replacement \"\nastropy\/units\/quantity.py:            latex_value = latex_value.replace('...', r'\\dots')\nastropy\/units\/tests\/test_quantity_ufuncs.py:        # can also replace in last position if no scaling is needed\nastropy\/units\/tests\/test_quantity_ufuncs.py:        # in np<1.13, without __array_ufunc__, one cannot replace input with\nastropy\/stats\/__init__.py:*not* to replace `scipy.stats` if its implementation satisfies\nastropy\/stats\/lombscargle\/_statistics.py:        s = rng.randint(0, len(y), len(y))  # sample with replacement\nastropy\/io\/ascii\/tests\/test_c_reader.py:    If passed as a parameter, names should replace any\nastropy\/io\/ascii\/tests\/test_c_reader.py:        table = read_basic(text.replace(' ', sep), delimiter=sep, parallel=parallel)\nastropy\/io\/ascii\/tests\/test_c_reader.py:    table = read_basic(text.replace('\"', \"'\"), quotechar=\"'\", parallel=parallel)\nastropy\/io\/ascii\/tests\/test_c_reader.py:        table = read_basic(text.replace('\\n', newline), parallel=parallel)\nastropy\/io\/ascii\/tests\/test_c_reader.py:        table = read_commented_header(text.replace('\\n', newline), parallel=parallel)\nastropy\/io\/ascii\/tests\/test_c_reader.py:        table = read_rdb(text.replace('\\n', newline), parallel=parallel)\nastropy\/units\/astrophys.py:# covariances between e and h.  Eventually, this may also be replaced with\nastropy\/units\/format\/latex.py:        return name.replace('_', r'\\_')\nastropy\/time\/core.py:    # The usual tuple of attributes needed for serialization is replaced\nastropy\/time\/core.py:        # If current output subformat is not in the new format then replace\nastropy\/units\/format\/unicode_format.py:            parts.append(m.replace('-', '\u2212'))\nastropy\/stats\/funcs.py:    replacement (\"case bootstrapping\"). These can all be run through a function\nastropy\/stats\/funcs.py:        # numpy.cumprod. This could be replaced by factorial again as soon as\nastropy\/units\/core.py:        return self.name.encode('ascii', 'replace')\nastropy\/tests\/runner.py:                                        package.replace('.', os.path.sep))\nastropy\/tests\/runner.py:                    docs_path, kwargs['package'].replace('.', os.path.sep))\nastropy\/tests\/command.py:        coveragerc_content = coveragerc_content.replace(\nastropy\/tests\/helper.py:    # directory, so we replace all the paths with the true source\nastropy\/utils\/console.py:    line = line.replace('\\t', ' ' * tabwidth)\nastropy\/nddata\/nddata.py:    the unit parameter is not ``None``, then the implicit parameter is replaced\nastropy\/utils\/data_info.py:                col_index.replace(key, self.name, val)\nastropy\/utils\/data_info.py:                    new_index.replace_rows(item)\nastropy\/utils\/decorators.py:    from the function signature and the ``new_name`` replaced it at the\nastropy\/utils\/decorators.py:    It is also possible to replace multiple arguments. The ``old_name``,\nastropy\/utils\/decorators.py:                    raise TypeError('cannot replace argument \"{0}\" of kind '\nastropy\/utils\/decorators.py:        The docstring that will replace the docstring of the decorated\nastropy\/nddata\/decorators.py:                # Finally, replace data by the data attribute\nastropy\/utils\/xml\/unescaper.py:        clean_url = clean_url.replace(key, _bytes_entities[key])\nastropy\/utils\/iers\/iers.py:                # Replace *replace* current values from the first predictive index through\nastropy\/utils\/iers\/iers.py:                # the end of the current table.  This replacement is much faster than just\nastropy\/utils\/iers\/iers.py:                n_replace = len(self) - fpi\nastropy\/utils\/iers\/iers.py:                self[fpi:] = new_table[new_fpi:new_fpi + n_replace]\nastropy\/utils\/iers\/iers.py:                if new_table['MJD'][new_fpi + n_replace] - self['MJD'][-1] != 1.0 * u.d:\nastropy\/utils\/iers\/iers.py:                for row in new_table[new_fpi + n_replace:]:\nastropy\/utils\/iers\/iers.py:        # If there is overlap then replace IERS-A values from available IERS-B\nastropy\/extern\/configobj\/validate.py:# this could be replaced if six is used for compatibility, or there are no\nastropy\/utils\/xml\/writer.py:        s = s.replace(\"&\", \"&amp;\")\nastropy\/utils\/xml\/writer.py:        s = s.replace(\"<\", \"&lt;\")\nastropy\/utils\/xml\/writer.py:        s = s.replace(\">\", \"&gt;\")\nastropy\/utils\/xml\/writer.py:        s = s.replace(\"&\", \"&amp;\")\nastropy\/utils\/xml\/writer.py:        s = s.replace(\"'\", \"&apos;\")\nastropy\/utils\/xml\/writer.py:        s = s.replace(\"\\\"\", \"&quot;\")\nastropy\/utils\/xml\/writer.py:        s = s.replace(\"<\", \"&lt;\")\nastropy\/utils\/xml\/writer.py:        s = s.replace(\">\", \"&gt;\")\nastropy\/utils\/xml\/writer.py:        pass  # replaced by the constructor\nastropy\/utils\/xml\/writer.py:                d[attr.replace('_', '-')] = str(getattr(obj, attr))\nastropy\/utils\/xml\/check.py:    replaces non-valid characters with underscores.\nastropy\/extern\/configobj\/configobj.py:# Sentinel for use in getattr calls to replace hasattr\nastropy\/extern\/configobj\/configobj.py:# this could be replaced if six is used for compatibility, or there are no\nastropy\/extern\/configobj\/configobj.py:                    replacement = v\nastropy\/extern\/configobj\/configobj.py:                    replacement = recursive_interpolate(k, v, s, backtrail)\nastropy\/extern\/configobj\/configobj.py:                value = ''.join((value[:start], replacement, value[end:]))\nastropy\/extern\/configobj\/configobj.py:                new_search_start = start + len(replacement)\nastropy\/extern\/configobj\/configobj.py:        ...     newkey = key.replace('XXXX', 'CLIENT1')\nastropy\/extern\/configobj\/configobj.py:        ...         val = val.replace('XXXX', 'CLIENT1')\nastropy\/extern\/configobj\/configobj.py:    present\/missing. (Whole missing sections will be replaced with ``False``)\nastropy\/tests\/tests\/test_run_tests.py:def test_doctest_float_replacement(tmpdir):\nastropy\/tests\/plugins\/display.py:        plat = plat.decode(stdoutencoding, 'replace')\nastropy\/utils\/iers\/tests\/test_iers.py:            # finals2000A-2016-02-30-test has been replaced at this point.\nastropy\/utils\/tests\/test_decorators.py:    Tests the compatibility replacement for functools.wraps which supports\nastropy\/utils\/tests\/test_decorators.py:    # Cannot replace \"*args\".\nastropy\/utils\/tests\/test_decorators.py:    # Cannot replace \"**kwargs\".\nastropy\/utils\/tests\/test_decorators.py:    # A first test that replaces an empty docstring\nastropy\/utils\/tests\/test_decorators.py:    # Test that it replaces an existing docstring\nastropy\/utils\/tests\/test_decorators.py:    # A first test that replaces an empty docstring\nastropy\/utils\/tests\/test_decorators.py:    # Test that it replaces an existing docstring\nastropy\/extern\/bundled\/six.py:        return unicode(s.replace(r'\\\\', r'\\\\\\\\'), \"unicode_escape\")\nastropy\/extern\/bundled\/six.py:    # metaclass for one level of class instantiation that replaces itself with\nastropy\/utils\/tests\/test_data.py:    # test should be uncommented and the README.rst should be replaced with\nastropy\/_erfa\/erfa_generator.py:NDIMS_REX = re.compile(re.escape(\"numpy.dtype([('fi0', '.*', <(.*)>)])\").replace(r'\\.\\*', '.*').replace(r'\\<', '(').replace(r'\\>', ')'))\nastropy\/_erfa\/erfa_generator.py:        self.doc = doc.replace(\"**\", \"  \").replace(\"\/*\\n\", \"\").replace(\"*\/\", \"\")\nastropy\/_erfa\/erfa_generator.py:        return self.doc.replace(\"  \\n\", \"\\n\")\nastropy\/_erfa\/erfa_generator.py:        self.name = name.replace(\"ERFA_\", \"\")\nastropy\/_erfa\/erfa_generator.py:        self.value = value.replace(\"ERFA_\", \"\")\nastropy\/nddata\/tests\/test_nddata.py:    # Check that it replaces a mask from init\nastropy\/extern\/ply\/yacc.py:# Techniques, and Tools\" (The Dragon Book).  LALR(1) has since been replaced\nastropy\/extern\/ply\/yacc.py:                # the tokenstack and replace it with an 'error' token.\nastropy\/extern\/ply\/yacc.py:                # the tokenstack and replace it with an 'error' token.\nastropy\/extern\/ply\/yacc.py:                # the tokenstack and replace it with an 'error' token.\nastropy\/extern\/ply\/cpp.py:    # replace with one space or a number of '\\n'\nastropy\/extern\/ply\/cpp.py:    # replace with '\/n'\nastropy\/extern\/ply\/cpp.py:# Given an input string, this function replaces all trigraph sequences.\nastropy\/extern\/ply\/cpp.py:# When a macro is created, the macro replacement token sequence is\nastropy\/extern\/ply\/cpp.py:    # representing the replacement macro tokens\nastropy\/extern\/ply\/cpp.py:        # Make string expansion patches.  These do not alter the length of the replacement sequence\nastropy\/extern\/ply\/cpp.py:                str_expansion[argnum] = ('\"%s\"' % \"\".join([x.value for x in args[argnum]])).replace(\"\\\\\",\"\\\\\\\\\")\nastropy\/extern\/ply\/cpp.py:        # has been sorted in reverse order of patch location since replacements will cause the\nastropy\/extern\/ply\/cpp.py:        # size of the replacement sequence to expand from the patch point.\nastropy\/extern\/ply\/cpp.py:                                # Get macro replacement text\nastropy\/extern\/ply\/cpp.py:        expr = expr.replace(\"&&\",\" and \")\nastropy\/extern\/ply\/cpp.py:        expr = expr.replace(\"||\",\" or \")\nastropy\/extern\/ply\/cpp.py:        expr = expr.replace(\"!\",\" not \")","role":"tool","tool_calls":null}],"task":"default","reward":0.0,"generation_ms":0.0,"scoring_ms":0.180721283,"total_ms":0.180721283,"info":{"instance_id":"astropy__astropy-6938","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/io\/fits\/fitsrec.py\": {\"old_start\": 1261, \"old_count\": 7, \"new_start\": 1261, \"new_count\": 7, \"hunks\": [{\"old_start\": 1261, \"old_count\": 7, \"new_start\": 1261, \"new_count\": 7}]}}","file_localization_reward":0.0}
{"example_id":0,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"Modeling's `separability_matrix` does not compute separability correctly for nested CompoundModels\nConsider the following model:\r\n\r\n```python\r\nfrom astropy.modeling import models as m\r\nfrom astropy.modeling.separable import separability_matrix\r\n\r\ncm = m.Linear1D(10) & m.Linear1D(5)\r\n```\r\n\r\nIt's separability matrix as you might expect is a diagonal:\r\n\r\n```python\r\n>>> separability_matrix(cm)\r\narray([[ True, False],\r\n       [False,  True]])\r\n```\r\n\r\nIf I make the model more complex:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5))\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True, False],\r\n       [False, False, False,  True]])\r\n```\r\n\r\nThe output matrix is again, as expected, the outputs and inputs to the linear models are separable and independent of each other.\r\n\r\nIf however, I nest these compound models:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & cm)\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True,  True],\r\n       [False, False,  True,  True]])\r\n```\r\nSuddenly the inputs and outputs are no longer separable?\r\n\r\nThis feels like a bug to me, but I might be missing something?\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-44b5f98d4172409c91b7cf7c56c44fca\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'separability_matrix' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-4760109a28314588b6e6b72267f56a38\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'CompoundModel' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-dcba942a9ec849c8a15dac0ddec40e04\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"find . -name \\\\\\\"separable*.py\\\\\\\" -type f\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"astropy\/modeling\/separable.py:__all__ = [\"is_separable\", \"separability_matrix\"]\nastropy\/modeling\/separable.py:def separability_matrix(transform):\nastropy\/modeling\/separable.py:    >>> separability_matrix(Shift(1) & Shift(2) | Scale(1) & Scale(2))\nastropy\/modeling\/separable.py:    >>> separability_matrix(Shift(1) & Shift(2) | Rotation2D(2))\nastropy\/modeling\/separable.py:    >>> separability_matrix(Shift(1) & Shift(2) | Mapping([0, 1, 0, 1]) | \\\nastropy\/modeling\/separable.py:    >>> separability_matrix(Shift(1) & Shift(2) | Mapping([0, 1, 0, 1]))\nastropy\/modeling\/separable.py:    if (transform_matrix := transform._calculate_separability_matrix()) is not NotImplemented:\nastropy\/modeling\/core.py:    def _calculate_separability_matrix(self):\nastropy\/modeling\/tests\/test_models.py:from astropy.modeling.separable import separability_matrix\nastropy\/modeling\/tests\/test_models.py:    def _calculate_separability_matrix(self):\nastropy\/modeling\/tests\/test_models.py:def test_custom_separability_matrix():\nastropy\/modeling\/tests\/test_models.py:    original = separability_matrix(ModelDefault(slope=1, intercept=2))\nastropy\/modeling\/tests\/test_models.py:    custom = separability_matrix(ModelCustom(slope=1, intercept=2))\nastropy\/modeling\/tests\/test_separable.py:                                        _cstack, _arith_oper, separability_matrix)\nastropy\/modeling\/tests\/test_separable.py:    assert_allclose(separability_matrix(compound_model), result[1])\nastropy\/modeling\/tests\/test_separable.py:    assert np.all(separability_matrix(model_c()) == [True, True])\nastropy\/modeling\/tests\/test_core.py:from astropy.modeling.separable import separability_matrix\nastropy\/modeling\/tests\/test_core.py:    assert (separability_matrix(m) == [[True, True],\nastropy\/modeling\/tests\/test_core.py:    assert (separability_matrix(m) == [[True, True, True],","role":"tool","tool_calls":null},{"content":"astropy\/modeling\/utils.py:    Operators for CompoundModels. This dictionary is structured so that\nastropy\/modeling\/bounding_box.py:        # NOTE: CompoundModel does not currently support units during\nastropy\/modeling\/bounding_box.py:        #   for CompoundModel(s).\nastropy\/modeling\/convolution.py:from .core import CompoundModel, SPECIAL_OPERATORS\nastropy\/modeling\/convolution.py:class Convolution(CompoundModel):\nastropy\/modeling\/tests\/test_core.py:from astropy.modeling.core import (Model, CompoundModel, custom_model,\nastropy\/modeling\/tests\/test_core.py:def test_print_special_operator_CompoundModel(capsys):\nastropy\/modeling\/tests\/test_core.py:    true_out = \"Model: CompoundModel\\n\" +\\\nastropy\/modeling\/tests\/test_core.py:    assert isinstance(model, CompoundModel)\nastropy\/modeling\/tests\/test_compound.py:from astropy.modeling.core import Model, ModelDefinitionError, CompoundModel\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(s, CompoundModel)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(S1, CompoundModel)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(S2, CompoundModel)\nastropy\/modeling\/tests\/test_compound.py:    assert isinstance(r1, CompoundModel)\nastropy\/modeling\/tests\/test_compound.py:    Test that CompoundModel.n_submodels properly returns the number\nastropy\/modeling\/tests\/test_compound.py:        CompoundModel('#', g1, g1)\nastropy\/modeling\/separable.py:from .core import Model, ModelDefinitionError, CompoundModel\nastropy\/modeling\/separable.py:    elif isinstance(transform, CompoundModel):\nastropy\/modeling\/core.py:           'CompoundModel', 'fix_inputs', 'custom_model', 'ModelDefinitionError',\nastropy\/modeling\/core.py:    return lambda left, right: CompoundModel(oper, left, right, **kwargs)\nastropy\/modeling\/core.py:        if isinstance(self, CompoundModel):\nastropy\/modeling\/core.py:        return (not isinstance(self, CompoundModel))\nastropy\/modeling\/core.py:        # prepare for model evaluation (overridden in CompoundModel)\nastropy\/modeling\/core.py:        # post-process evaluation results (overridden in CompoundModel)\nastropy\/modeling\/core.py:        if isinstance(model, CompoundModel):\nastropy\/modeling\/core.py:        `CompoundModel`\nastropy\/modeling\/core.py:            A `CompoundModel` composed of the current model plus\nastropy\/modeling\/core.py:class CompoundModel(Model):\nastropy\/modeling\/core.py:        \"\"\" Return the names of submodels in a ``CompoundModel``.\"\"\"\nastropy\/modeling\/core.py:            \"CompoundModel.both_inverses_exist is deprecated. \"\nastropy\/modeling\/core.py:        CompoundModel specific input setup that needs to occur prior to\nastropy\/modeling\/core.py:        CompoundModel specific post evaluation processing of outputs\nastropy\/modeling\/core.py:        \"\"\" Postorder traversal of the CompoundModel tree.\"\"\"\nastropy\/modeling\/core.py:        if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:        if isinstance(self.right, CompoundModel):\nastropy\/modeling\/core.py:            if not isinstance(node, CompoundModel):\nastropy\/modeling\/core.py:                if isinstance(node, CompoundModel):\nastropy\/modeling\/core.py:                    if (isinstance(node.left, CompoundModel) and\nastropy\/modeling\/core.py:                    if (isinstance(node.right, CompoundModel) and\nastropy\/modeling\/core.py:        if isinstance(branch, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:                if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.right, CompoundModel):\nastropy\/modeling\/core.py:                    if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:                    if isinstance(self.right, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:                if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.right, CompoundModel):\nastropy\/modeling\/core.py:                if isinstance(self.right, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.right, CompoundModel):\nastropy\/modeling\/core.py:                    if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:                    if isinstance(self.right, CompoundModel):\nastropy\/modeling\/core.py:            if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:                if isinstance(self.left, CompoundModel):\nastropy\/modeling\/core.py:        Construct a new `~astropy.modeling.CompoundModel` instance from an\nastropy\/modeling\/core.py:        existing CompoundModel, replacing the named submodel with a new model.\nastropy\/modeling\/core.py:        necessary to rebuild the CompoundModel from the replaced node all the\nastropy\/modeling\/core.py:        way back to the base. The original CompoundModel is left untouched.\nastropy\/modeling\/core.py:            # although it would fail trying to construct the new CompoundModel\nastropy\/modeling\/core.py:                model = CompoundModel(branch.op, branch.left, branch.right,\nastropy\/modeling\/core.py:        model = CompoundModel(self.op, left, right)\nastropy\/modeling\/core.py:        `~astropy.modeling.CompoundModel.with_units_from_data`.\nastropy\/modeling\/core.py:        `~astropy.modeling.CompoundModel.without_units_for_data` passed as\nastropy\/modeling\/core.py:    \"\"\"Find the route down a CompoundModel's tree to the model with the\nastropy\/modeling\/core.py:    if isinstance(tree, CompoundModel):\nastropy\/modeling\/core.py:    model = CompoundModel('fix_inputs', modelinstance, values)\nastropy\/convolution\/convolve.py:from astropy.modeling.core import SPECIAL_OPERATORS, CompoundModel\nastropy\/convolution\/convolve.py:    default : `~astropy.modeling.core.CompoundModel`\nastropy\/convolution\/convolve.py:    return CompoundModel(operator, model, kernel)\nastropy\/convolution\/convolve.py:    default : `~astropy.modeling.core.CompoundModel`\nastropy\/io\/misc\/asdf\/tags\/transform\/compound.py:from astropy.modeling.core import Model, CompoundModel\nastropy\/io\/misc\/asdf\/tags\/transform\/compound.py:    types = [CompoundModel]\nastropy\/io\/misc\/asdf\/tags\/transform\/compound.py:            model = CompoundModel('fix_inputs', left, right)\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:from astropy.modeling.core import CompoundModel\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:            if not isinstance(model, CompoundModel):\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:        if not isinstance(model, CompoundModel):\nastropy\/io\/misc\/asdf\/tags\/transform\/basic.py:        if not isinstance(model, CompoundModel):\nastropy\/io\/misc\/asdf\/tags\/transform\/tests\/test_transform.py:    not available at the time that the CompoundModel is","role":"tool","tool_calls":null},{"content":".\/astropy\/modeling\/separable.py","role":"tool","tool_calls":null},{"content":"\n\n<files>\nastropy\/modeling\/separable.py\nastropy\/modeling\/core.py\nastropy\/modeling\/tests\/test_separable.py\n<\/files>","role":"assistant","tool_calls":null}],"task":"default","reward":0.5,"generation_ms":46328.8147449493,"scoring_ms":0.1220703125,"total_ms":46328.9368152618,"info":{"instance_id":"astropy__astropy-12907","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/modeling\/separable.py\": {\"old_start\": 242, \"old_count\": 7, \"new_start\": 242, \"new_count\": 7, \"hunks\": [{\"old_start\": 242, \"old_count\": 7, \"new_start\": 242, \"new_count\": 7}]}}","file_localization_reward":0.5}
{"example_id":1,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"Please support header rows in RestructuredText output\n### Description\r\n\r\nIt would be great if the following would work:\r\n\r\n```Python\r\n>>> from astropy.table import QTable\r\n>>> import astropy.units as u\r\n>>> import sys\r\n>>> tbl = QTable({'wave': [350,950]*u.nm, 'response': [0.7, 1.2]*u.count})\r\n>>> tbl.write(sys.stdout,  format=\"ascii.rst\")\r\n===== ========\r\n wave response\r\n===== ========\r\n350.0      0.7\r\n950.0      1.2\r\n===== ========\r\n>>> tbl.write(sys.stdout,  format=\"ascii.fixed_width\", header_rows=[\"name\", \"unit\"])\r\n|  wave | response |\r\n|    nm |       ct |\r\n| 350.0 |      0.7 |\r\n| 950.0 |      1.2 |\r\n>>> tbl.write(sys.stdout,  format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/table\/connect.py\", line 129, in __call__\r\n    self.registry.write(instance, *args, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/registry\/core.py\", line 369, in write\r\n    return writer(data, *args, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/ascii\/connect.py\", line 26, in io_write\r\n    return write(table, filename, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/ascii\/ui.py\", line 856, in write\r\n    writer = get_writer(Writer=Writer, fast_writer=fast_writer, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/ascii\/ui.py\", line 800, in get_writer\r\n    writer = core._get_writer(Writer, fast_writer, **kwargs)\r\n  File \"\/usr\/lib\/python3\/dist-packages\/astropy\/io\/ascii\/core.py\", line 1719, in _get_writer\r\n    writer = Writer(**writer_kwargs)\r\nTypeError: RST.__init__() got an unexpected keyword argument 'header_rows'\r\n```\r\n\r\n\r\n### Additional context\r\n\r\nRestructuredText output is a great way to fill autogenerated documentation with content, so having this flexible makes the life easier `:-)`\r\n\r\n\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-5048c945605f48b6ac2cec2395b16843\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'RST' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-1e59a96bd0444520912e1fdb833dcb1e\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'header_rows' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-7cf2fa751a89426f92b6f245ce417259\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'Writer' -t py | grep 'rst'\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"docs\/conf.py:# This is added to the end of RST files - a good place to put substitutions to\nastropy\/time\/tests\/test_ut1.py:class TestTimeUT1SpecificIERSTable:\nastropy\/io\/misc\/asdf\/tags\/coordinates\/frames.py:class ICRSType(CoordType):\nastropy\/io\/misc\/asdf\/tags\/coordinates\/frames.py:class ICRSType10(AstropyType):\nastropy\/io\/ascii\/ui.py:    # same for RST.\nastropy\/io\/ascii\/ui.py:        rst.RST,\nastropy\/units\/format\/ogip_parsetab.py:_lr_signature = 'CLOSE_PAREN DIVISION LIT10 OPEN_PAREN SIGN STAR STARSTAR UFLOAT UINT UNIT UNKNOWN WHITESPACE\\n            main : UNKNOWN\\n                 | complete_expression\\n                 | scale_factor complete_expression\\n                 | scale_factor WHITESPACE complete_expression\\n            \\n            complete_expression : product_of_units\\n            \\n            product_of_units : unit_expression\\n                             | division unit_expression\\n                             | product_of_units product unit_expression\\n                             | product_of_units division unit_expression\\n            \\n            unit_expression : unit\\n                            | UNIT OPEN_PAREN complete_expression CLOSE_PAREN\\n                            | OPEN_PAREN complete_expression CLOSE_PAREN\\n                            | UNIT OPEN_PAREN complete_expression CLOSE_PAREN power numeric_power\\n                            | OPEN_PAREN complete_expression CLOSE_PAREN power numeric_power\\n            \\n            scale_factor : LIT10 power numeric_power\\n                         | LIT10\\n                         | signed_float\\n                         | signed_float power numeric_power\\n                         | signed_int power numeric_power\\n            \\n            division : DIVISION\\n                     | WHITESPACE DIVISION\\n                     | WHITESPACE DIVISION WHITESPACE\\n                     | DIVISION WHITESPACE\\n            \\n            product : WHITESPACE\\n                    | STAR\\n                    | WHITESPACE STAR\\n                    | WHITESPACE STAR WHITESPACE\\n                    | STAR WHITESPACE\\n            \\n            power : STARSTAR\\n            \\n            unit : UNIT\\n                 | UNIT power numeric_power\\n            \\n            numeric_power : UINT\\n                          | signed_float\\n                          | OPEN_PAREN signed_int CLOSE_PAREN\\n                          | OPEN_PAREN signed_float CLOSE_PAREN\\n                          | OPEN_PAREN signed_float division UINT CLOSE_PAREN\\n            \\n            sign : SIGN\\n                 |\\n            \\n            signed_int : SIGN UINT\\n            \\n            signed_float : sign UINT\\n                         | sign UFLOAT\\n            '\nastropy\/units\/format\/ogip_parsetab.py:_lr_action_items = {'UNKNOWN':([0,],[2,]),'LIT10':([0,],[7,]),'SIGN':([0,25,26,27,28,34,47,59,63,],[13,48,-29,48,48,48,13,48,48,]),'UNIT':([0,4,7,8,11,16,17,19,20,21,22,23,24,30,31,33,36,38,39,42,43,44,45,46,49,50,54,55,60,61,67,],[15,15,-16,-17,15,15,-20,15,-21,15,15,-24,-25,-40,-41,15,-23,-20,-22,-26,-28,-15,-32,-33,-18,-19,-22,-27,-34,-35,-36,]),'OPEN_PAREN':([0,4,7,8,11,15,16,17,19,20,21,22,23,24,25,26,27,28,30,31,33,34,36,38,39,42,43,44,45,46,49,50,54,55,59,60,61,63,67,],[16,16,-16,-17,16,33,16,-20,16,-21,16,16,-24,-25,47,-29,47,47,-40,-41,16,47,-23,-20,-22,-26,-28,-15,-32,-33,-18,-19,-22,-27,47,-34,-35,47,-36,]),'DIVISION':([0,4,5,6,7,8,10,14,15,16,19,23,29,30,31,33,40,41,44,45,46,49,50,52,53,57,58,60,61,64,66,67,],[17,17,20,17,-16,-17,-6,-10,-30,17,38,20,-7,-40,-41,17,-8,-9,-15,-32,-33,-18,-19,-31,-12,17,-11,-34,-35,-14,-13,-36,]),'WHITESPACE':([0,4,6,7,8,10,14,15,16,17,19,20,24,29,30,31,33,38,40,41,42,44,45,46,49,50,52,53,57,58,60,61,64,66,67,],[5,19,23,-16,-17,-6,-10,-30,5,36,5,39,43,-7,-40,-41,5,54,-8,-9,55,-15,-32,-33,-18,-19,-31,-12,5,-11,-34,-35,-14,-13,-36,]),'UINT':([0,12,13,17,20,25,26,27,28,34,36,39,47,48,59,62,63,],[-38,30,32,-20,-21,45,-29,45,45,45,-23,-22,-38,-37,45,65,45,]),'UFLOAT':([0,12,13,25,26,27,28,34,47,48,59,63,],[-38,31,-37,-38,-29,-38,-38,-38,-38,-37,-38,-38,]),'$end':([1,2,3,6,10,14,15,18,29,30,31,37,40,41,45,46,52,53,58,60,61,64,66,67,],[0,-1,-2,-5,-6,-10,-30,-3,-7,-40,-41,-4,-8,-9,-32,-33,-31,-12,-11,-34,-35,-14,-13,-36,]),'CLOSE_PAREN':([6,10,14,15,29,30,31,32,35,40,41,45,46,51,52,53,56,57,58,60,61,64,65,66,67,],[-5,-6,-10,-30,-7,-40,-41,-39,53,-8,-9,-32,-33,58,-31,-12,60,61,-11,-34,-35,-14,67,-13,-36,]),'STAR':([6,10,14,15,23,29,30,31,40,41,45,46,52,53,58,60,61,64,66,67,],[24,-6,-10,-30,42,-7,-40,-41,-8,-9,-32,-33,-31,-12,-11,-34,-35,-14,-13,-36,]),'STARSTAR':([7,8,9,15,30,31,32,53,58,],[26,26,26,26,-40,-41,-39,26,26,]),}\nastropy\/units\/format\/ogip_parsetab.py:  ('power -> STARSTAR','power',1,'p_power','ogip.py',297),\nastropy\/io\/ascii\/__init__.py:from .rst import RST\nastropy\/units\/format\/ogip_lextab.py:_lextokens    = set(('CLOSE_PAREN', 'DIVISION', 'LIT10', 'OPEN_PAREN', 'SIGN', 'STAR', 'STARSTAR', 'UFLOAT', 'UINT', 'UNIT', 'UNKNOWN', 'WHITESPACE'))\nastropy\/units\/format\/ogip_lextab.py:_lexstatere   = {'INITIAL': [('(?P<t_UFLOAT>(((\\\\d+\\\\.?\\\\d*)|(\\\\.\\\\d+))([eE][+-]?\\\\d+))|(((\\\\d+\\\\.\\\\d*)|(\\\\.\\\\d+))([eE][+-]?\\\\d+)?))|(?P<t_UINT>\\\\d+)|(?P<t_SIGN>[+-](?=\\\\d))|(?P<t_X>[x\u00d7])|(?P<t_LIT10>10)|(?P<t_UNKNOWN>[Uu][Nn][Kk][Nn][Oo][Ww][Nn])|(?P<t_UNIT>[a-zA-Z][a-zA-Z_]*)|(?P<t_WHITESPACE>[ \\t]+)|(?P<t_STARSTAR>\\\\*\\\\*)|(?P<t_OPEN_PAREN>\\\\()|(?P<t_CLOSE_PAREN>\\\\))|(?P<t_STAR>\\\\*)|(?P<t_DIVISION>\/)', [None, ('t_UFLOAT', 'UFLOAT'), None, None, None, None, None, None, None, None, None, None, ('t_UINT', 'UINT'), ('t_SIGN', 'SIGN'), ('t_X', 'X'), ('t_LIT10', 'LIT10'), ('t_UNKNOWN', 'UNKNOWN'), ('t_UNIT', 'UNIT'), (None, 'WHITESPACE'), (None, 'STARSTAR'), (None, 'OPEN_PAREN'), (None, 'CLOSE_PAREN'), (None, 'STAR'), (None, 'DIVISION')])]}\nastropy\/io\/ascii\/rst.py:class SimpleRSTHeader(FixedWidthHeader):\nastropy\/io\/ascii\/rst.py:class SimpleRSTData(FixedWidthData):\nastropy\/io\/ascii\/rst.py:class RST(FixedWidth):\nastropy\/io\/ascii\/rst.py:    data_class = SimpleRSTData\nastropy\/io\/ascii\/rst.py:    header_class = SimpleRSTHeader\nastropy\/units\/format\/ogip.py:        \"STARSTAR\",\nastropy\/units\/format\/ogip.py:        t_STARSTAR = r\"\\*\\*\"\nastropy\/units\/format\/ogip.py:            power : STARSTAR\nastropy\/io\/ascii\/tests\/test_rst.py:    \"\"\"Normal SimpleRST Table\"\"\"\nastropy\/io\/ascii\/tests\/test_rst.py:    reader = ascii.get_reader(Reader=ascii.RST)\nastropy\/io\/ascii\/tests\/test_rst.py:    \"\"\"Normal SimpleRST Table with provided column names\"\"\"\nastropy\/io\/ascii\/tests\/test_rst.py:    reader = ascii.get_reader(Reader=ascii.RST, names=(\"name1\", \"name2\"))\nastropy\/io\/ascii\/tests\/test_rst.py:    \"\"\"Normal SimpleRST Table with provided column names\"\"\"\nastropy\/io\/ascii\/tests\/test_rst.py:        Reader=ascii.RST,\nastropy\/io\/ascii\/tests\/test_rst.py:    \"\"\"Nice, typical SimpleRST table with col name excluded\"\"\"\nastropy\/io\/ascii\/tests\/test_rst.py:    reader = ascii.get_reader(Reader=ascii.RST, exclude_names=(\"Col1\",))\nastropy\/io\/ascii\/tests\/test_rst.py:    reader = ascii.get_reader(Reader=ascii.RST)\nastropy\/io\/ascii\/tests\/test_rst.py:    reader = ascii.get_reader(Reader=ascii.RST)\nastropy\/io\/ascii\/tests\/test_rst.py:    reader = ascii.get_reader(Reader=ascii.RST)\nastropy\/io\/ascii\/tests\/test_rst.py:    reader = ascii.get_reader(Reader=ascii.RST)\nastropy\/io\/ascii\/tests\/test_rst.py:dat = ascii.read(table, Reader=ascii.RST)\nastropy\/io\/ascii\/tests\/test_rst.py:    \"\"\"Write a table as a normal SimpleRST Table\"\"\"\nastropy\/io\/ascii\/tests\/test_rst.py:    ascii.write(dat, out, Writer=ascii.RST)\nastropy\/extern\/ply\/yacc.py:        self.First        = {}      # A dictionary of precomputed FIRST(x) symbols\nastropy\/extern\/ply\/yacc.py:    # Compute the value of FIRST1(beta) where beta is a tuple of symbols.\nastropy\/extern\/ply\/yacc.py:    # Compute the value of FIRST1(X) for all symbols","role":"tool","tool_calls":null},{"content":"astropy\/io\/ascii\/fixedwidth.py:        header_rows = getattr(self, \"header_rows\", [\"name\"])\nastropy\/io\/ascii\/fixedwidth.py:            line = self.get_line(lines, start_line + header_rows.index(\"name\"))\nastropy\/io\/ascii\/fixedwidth.py:        for ii, attr in enumerate(header_rows):\nastropy\/io\/ascii\/fixedwidth.py:        default_header_rows = [] if self.header.start_line is None else [\"name\"]\nastropy\/io\/ascii\/fixedwidth.py:        header_rows = getattr(self, \"header_rows\", default_header_rows)\nastropy\/io\/ascii\/fixedwidth.py:        for col_attr in header_rows:\nastropy\/io\/ascii\/fixedwidth.py:        header_rows=None,\nastropy\/io\/ascii\/fixedwidth.py:        if header_rows is None:\nastropy\/io\/ascii\/fixedwidth.py:            header_rows = [\"name\"]\nastropy\/io\/ascii\/fixedwidth.py:        self.header.header_rows = header_rows\nastropy\/io\/ascii\/fixedwidth.py:        self.data.header_rows = header_rows\nastropy\/io\/ascii\/fixedwidth.py:            self.data.start_line = len(header_rows)\nastropy\/io\/ascii\/fixedwidth.py:            header_rows=[],\nastropy\/io\/ascii\/fixedwidth.py:        header_rows=None,\nastropy\/io\/ascii\/fixedwidth.py:            delimiter_pad=delimiter_pad, bookend=bookend, header_rows=header_rows\nastropy\/io\/ascii\/fixedwidth.py:            position_line = len(self.header.header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:def test_fixed_width_header_rows():\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    header_rows = [\"dtype\", \"name\", \"unit\", \"format\", \"description\"]\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    dat = ascii.read(tbl, format=\"fixed_width\", delimiter=\"|\", header_rows=header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    ascii.write(dat, out, format=\"fixed_width\", delimiter=\"|\", header_rows=header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:def test_fixed_width_two_line_header_rows():\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    header_rows = [\"dtype\", \"unit\", \"format\", \"description\", \"name\"]\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    dat = ascii.read(tbl, format=\"fixed_width_two_line\", header_rows=header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    ascii.write(dat, out, format=\"fixed_width_two_line\", header_rows=header_rows)\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:def test_fixed_width_no_header_header_rows():\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:    with pytest.raises(TypeError, match=r\"unexpected keyword argument 'header_rows'\"):\nastropy\/io\/ascii\/tests\/test_fixedwidth.py:        ascii.read(tbl, format=\"fixed_width_no_header\", header_rows=[\"unit\"])","role":"tool","tool_calls":null},{"content":"astropy\/io\/ascii\/tests\/test_rst.py:    ascii.write(dat, out, Writer=ascii.RST)","role":"tool","tool_calls":null},{"content":"\n\n<files>\nastropy\/io\/ascii\/rst.py\nastropy\/io\/ascii\/ui.py\nastropy\/io\/ascii\/tests\/test_rst.py\n<\/files>","role":"assistant","tool_calls":null}],"task":"default","reward":0.5,"generation_ms":36545.7627773285,"scoring_ms":0.1907348633,"total_ms":36545.9535121918,"info":{"instance_id":"astropy__astropy-14182","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/io\/ascii\/rst.py\": {\"old_start\": 27, \"old_count\": 40, \"new_start\": 27, \"new_count\": 61, \"hunks\": [{\"old_start\": 27, \"old_count\": 7, \"new_start\": 27, \"new_count\": 6}, {\"old_start\": 39, \"old_count\": 12, \"new_start\": 38, \"new_count\": 29}, {\"old_start\": 57, \"old_count\": 10, \"new_start\": 73, \"new_count\": 15}]}}","file_localization_reward":0.5}
{"example_id":2,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"ascii.qdp Table format assumes QDP commands are upper case\n### Description\n\nascii.qdp assumes that commands in a QDP file are upper case, for example, for errors they must be \"READ SERR 1 2\" whereas QDP itself is not case sensitive and case use \"read serr 1 2\". \r\n\r\nAs many QDP files are created by hand, the expectation that all commands be all-caps should be removed.\n\n### Expected behavior\n\nThe following qdp file should read into a `Table` with errors, rather than crashing.\r\n```\r\nread serr 1 2 \r\n1 0.5 1 0.5\r\n```\n\n### How to Reproduce\n\nCreate a QDP file:\r\n```\r\n> cat > test.qdp\r\nread serr 1 2 \r\n1 0.5 1 0.5\r\n<EOF>\r\n\r\n > python\r\nPython 3.10.9 (main, Dec  7 2022, 02:03:23) [Clang 13.0.0 (clang-1300.0.29.30)] on darwin\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> from astropy.table import Table\r\n>>> Table.read('test.qdp',format='ascii.qdp')\r\nWARNING: table_id not specified. Reading the first available table [astropy.io.ascii.qdp]\r\nTraceback (most recent call last):\r\n...\r\n    raise ValueError(f'Unrecognized QDP line: {line}')\r\nValueError: Unrecognized QDP line: read serr 1 2\r\n```\r\n\r\nRunning \"qdp test.qdp\" works just fine.\r\n\n\n### Versions\n\nPython 3.10.9 (main, Dec  7 2022, 02:03:23) [Clang 13.0.0 (clang-1300.0.29.30)]\r\nastropy 5.1\r\nNumpy 1.24.1\r\npyerfa 2.0.0.1\r\nScipy 1.10.0\r\nMatplotlib 3.6.3\r\n\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-537482746a0840569843d3fd7d6220a9\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'ascii\\\\\\\\.qdp' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"astropy\/io\/ascii\/qdp.py:        t = Table.read(example_qdp, format='ascii.qdp', table_id=1, names=['a', 'b', 'c', 'd'])\nastropy\/io\/ascii\/tests\/test_qdp.py:from astropy.io.ascii.qdp import _get_lines_from_file, _read_table_qdp, _write_table_qdp\nastropy\/io\/ascii\/tests\/test_qdp.py:        example_qdp, format=\"ascii.qdp\", table_id=1, names=[\"a\", \"b\", \"c\", \"d\"]\nastropy\/io\/ascii\/tests\/test_qdp.py:        example_qdp, format=\"ascii.qdp\", table_id=1, names=[\"a\", \"b\", \"c\", \"d\"]\nastropy\/io\/ascii\/tests\/test_qdp.py:        example_qdp, format=\"ascii.qdp\", table_id=1, names=[\"a\", \"b\", \"c\", \"d\"], sep=\",\"\nastropy\/io\/ascii\/tests\/test_qdp.py:    t1.write(test_file, format=\"ascii.qdp\")\nastropy\/io\/ascii\/tests\/test_qdp.py:        t2 = Table.read(test_file, format=\"ascii.qdp\")\nastropy\/io\/ascii\/tests\/test_qdp.py:    t1.write(test_file, format=\"ascii.qdp\")\nastropy\/io\/ascii\/tests\/test_qdp.py:    t2 = Table.read(test_file, table_id=0, format=\"ascii.qdp\", names=[\"a\"])","role":"tool","tool_calls":null},{"content":"\n\n<files>\nastropy\/io\/ascii\/qdp.py\nastropy\/io\/ascii\/tests\/test_qdp.py\n<\/files>","role":"assistant","tool_calls":null}],"task":"default","reward":0.6666666667,"generation_ms":44959.3601226807,"scoring_ms":0.2105236053,"total_ms":44959.570646286,"info":{"instance_id":"astropy__astropy-14365","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/io\/ascii\/qdp.py\": {\"old_start\": 68, \"old_count\": 245, \"new_start\": 68, \"new_count\": 245, \"hunks\": [{\"old_start\": 68, \"old_count\": 7, \"new_start\": 68, \"new_count\": 7}, {\"old_start\": 306, \"old_count\": 7, \"new_start\": 306, \"new_count\": 7}]}}","file_localization_reward":0.6666666667}
{"example_id":3,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"In v5.3, NDDataRef mask propagation fails when one of the operand does not have a mask\n### Description\n\nThis applies to v5.3. \r\n\r\nIt looks like when one of the operand does not have a mask, the mask propagation when doing arithmetic, in particular with `handle_mask=np.bitwise_or` fails.  This is not a problem in v5.2.\r\n\r\nI don't know enough about how all that works, but it seems from the error that the operand without a mask is set as a mask of None's and then the bitwise_or tries to operate on an integer and a None and fails.\n\n### Expected behavior\n\nWhen one of the operand does not have mask, the mask that exists should just be copied over to the output.  Or whatever was done in that situation in v5.2 where there's no problem.\n\n### How to Reproduce\n\nThis is with v5.3.   With v5.2, there are no errors.\r\n\r\n```\r\n>>> import numpy as np\r\n>>> from astropy.nddata import NDDataRef\r\n\r\n>>> array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\r\n>>> mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\r\n\r\n>>> nref_nomask = NDDataRef(array)\r\n>>> nref_mask = NDDataRef(array, mask=mask)\r\n\r\n# multiply no mask by constant (no mask * no mask)\r\n>>> nref_nomask.multiply(1., handle_mask=np.bitwise_or).mask   # returns nothing, no mask,  OK\r\n\r\n# multiply no mask by itself (no mask * no mask)\r\n>>> nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask # return nothing, no mask, OK\r\n\r\n# multiply mask by constant (mask * no mask)\r\n>>> nref_mask.multiply(1., handle_mask=np.bitwise_or).mask\r\n...\r\nTypeError: unsupported operand type(s) for |: 'int' and 'NoneType'\r\n\r\n# multiply mask by itself (mask * mask)\r\n>>> nref_mask.multiply(nref_mask, handle_mask=np.bitwise_or).mask\r\narray([[ 0,  1, 64],\r\n       [ 8,  0,  1],\r\n       [ 2,  1,  0]])\r\n\r\n# multiply mask by no mask (mask * no mask)\r\n>>> nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask\r\n...\r\nTypeError: unsupported operand type(s) for |: 'int' and 'NoneType'\r\n```\r\n\n\n### Versions\n\n>>> import sys; print(\"Python\", sys.version)\r\nPython 3.10.11 | packaged by conda-forge | (main, May 10 2023, 19:07:22) [Clang 14.0.6 ]\r\n>>> import astropy; print(\"astropy\", astropy.__version__)\r\nastropy 5.3\r\n>>> import numpy; print(\"Numpy\", numpy.__version__)\r\nNumpy 1.24.3\r\n>>> import erfa; print(\"pyerfa\", erfa.__version__)\r\npyerfa 2.0.0.3\r\n>>> import scipy; print(\"Scipy\", scipy.__version__)\r\nScipy 1.10.1\r\n>>> import matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\nMatplotlib 3.7.1\r\n\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-4f4532a8786546049edfe36fcdb6fbfa\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'NDDataRef' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-25a12b8f1dae49988adf60c7c2ae07ae\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'multiply' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-143ccd3281fd4e22b163711168f2d88b\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'handle_mask' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"astropy\/nddata\/nddata_withmixins.py:__all__ = [\"NDDataRef\"]\nastropy\/nddata\/nddata_withmixins.py:class NDDataRef(NDArithmeticMixin, NDIOMixin, NDSlicingMixin, NDData):\nastropy\/nddata\/nddata_withmixins.py:        >>> from astropy.nddata import NDDataRef, StdDevUncertainty\nastropy\/nddata\/nddata_withmixins.py:        >>> ndd1 = NDDataRef(data, uncertainty=StdDevUncertainty(data))\nastropy\/nddata\/nddata_withmixins.py:        >>> ndd2 = NDDataRef(data, uncertainty=StdDevUncertainty(data))\nastropy\/nddata\/nddata.py:    NDDataRef\nastropy\/nddata\/mixins\/ndslicing.py:    NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:from astropy.nddata import NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:NDDataArithmetic = NDDataRef\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:# TODO: Make this use NDDataRef instead!\nastropy\/nddata\/mixins\/tests\/test_ndio.py:from astropy.nddata import NDData, NDDataRef, NDIOMixin  # noqa: F401\nastropy\/nddata\/mixins\/tests\/test_ndio.py:NDDataIO = NDDataRef","role":"tool","tool_calls":null},{"content":"astropy\/visualization\/stretch.py:            np.multiply(values, self.slope, out=values)\nastropy\/visualization\/stretch.py:        np.multiply(values, self.exp - 1.0, out=values)\nastropy\/visualization\/stretch.py:            np.multiply(values, self.exp, out=values)\nastropy\/visualization\/stretch.py:        np.multiply(values, np.log(self.exp + 1.0), out=values)\nastropy\/visualization\/stretch.py:        np.multiply(values, self.contrast, out=values)\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_multiply_scalar(self, number):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check if multiplying a kernel with a scalar works correctly.\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_multiply_scalar_type(self, number):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check if multiplying a kernel with a scalar works correctly.\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_rmultiply_scalar_type(self, number):\nastropy\/convolution\/tests\/test_kernel_class.py:        Check if multiplying a kernel with a scalar works correctly.\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_multiply_kernel1d(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        \"\"\"Test that multiplying two 1D kernels raises an exception.\"\"\"\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_multiply_kernel2d(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        \"\"\"Test that multiplying two 2D kernels raises an exception.\"\"\"\nastropy\/convolution\/tests\/test_kernel_class.py:    def test_multiply_kernel1d_kernel2d(self):\nastropy\/convolution\/tests\/test_kernel_class.py:        Test that multiplying a 1D kernel with a 2D kernel raises an\nastropy\/io\/fits\/fitsrec.py:                np.multiply(field, bscale, field)\nastropy\/io\/fits\/hdu\/compressed.py:                np.multiply(data, self._orig_bscale, data)\nastropy\/io\/fits\/hdu\/image.py:                np.multiply(data, self._orig_bscale, data)\nastropy\/io\/fits\/hdu\/image.py:                # The offset needs to multiply the length of all remaining axes\nastropy\/io\/fits\/hdu\/table.py:                    array_size = int(np.multiply.reduce(dtype[col].shape))\nastropy\/extern\/configobj\/validate.py:    From now on we multiply the value to avoid comparing decimals\nastropy\/convolution\/core.py:    Add, subtract or multiply two kernels.\nastropy\/extern\/ply\/yacc.py:                self.log.warning('Token %r multiply defined', n)\nastropy\/stats\/funcs.py:Factor with which to multiply Gaussian 1-sigma standard deviation to\nastropy\/stats\/funcs.py:Factor with which to multiply Gaussian full width at half maximum (FWHM)\nastropy\/stats\/funcs.py:        DN or ADU, then multiply by the gain to get the value in electrons.\nastropy\/stats\/funcs.py:        DN or ADU, then multiply by the gain to get the value in electrons.\nastropy\/modeling\/functional_models.py:        Factor by which to multiply a coordinate.\nastropy\/modeling\/functional_models.py:    factor = Parameter(default=1, description=\"Factor by which to multiply a model\")\nastropy\/modeling\/functional_models.py:        \"\"\"One dimensional inverse multiply model function.\"\"\"\nastropy\/modeling\/functional_models.py:        \"\"\"One dimensional multiply model function.\"\"\"\nastropy\/modeling\/functional_models.py:        \"\"\"One dimensional multiply model derivative with respect to parameter.\"\"\"\nastropy\/modeling\/functional_models.py:        # multiply by * u.rad but this would be slower overall).\nastropy\/modeling\/functional_models.py:        # multiply by * u.rad but this would be slower overall).\nastropy\/modeling\/functional_models.py:        # multiply by * u.rad but this would be slower overall).\nastropy\/modeling\/functional_models.py:        # multiply by * u.rad but this would be slower overall).\nastropy\/modeling\/functional_models.py:        # multiply by * u.rad but this would be slower overall).\nastropy\/modeling\/functional_models.py:        # multiply by * u.rad but this would be slower overall).\nastropy\/modeling\/functional_models.py:        # for the legacy definition we multiply with np.pi * fwhm_L \/ 2 * amplitude_L\nastropy\/modeling\/functional_models.py:            # This is slightly faster than using ones_like and multiplying\nastropy\/modeling\/functional_models.py:            # This is slightly faster than using ones_like and multiplying\nastropy\/units\/function\/core.py:                    \"Cannot multiply a function unit with a physical dimension \"\nastropy\/units\/function\/core.py:            \"Cannot multiply function quantities which are not dimensionless \"\nastropy\/coordinates\/matrix_utilities.py:    \"\"\"Matrix multiply all arguments together.\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:    # Compute the pn matrix, and then multiply by its transpose.\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:    # compute the pmatrix, and then multiply by its transpose\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:    # Compute the pmatrix, and then multiply by its transpose,\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:    # compute the pmatrix, and then multiply by its transpose\nastropy\/coordinates\/builtin_frames\/intermediate_rotation_transforms.py:    # compute the pmatrix, and then multiply by its transpose\nastropy\/coordinates\/tests\/test_angles.py:    # these operate in a single dimension. Attempting to multiply or divide two\nastropy\/coordinates\/tests\/test_angles.py:def test_multiply_divide():\nastropy\/coordinates\/earth.py:in SI seconds, so multiply by the ratio of stellar to solar day.\nastropy\/coordinates\/spectral_quantity.py:                function is np.multiply\nastropy\/units\/function\/logarithmic.py:        # Add function units, thus multiplying physical units. If no unit is\nastropy\/coordinates\/angle_utilities.py:    # multiplying both sin_A and cos_A by x=sin_b * sin_c prevents \/0 errors\nastropy\/time\/tests\/test_precision.py:    \"\"\"Test precision with multiply and divide\"\"\"\nastropy\/units\/quantity.py:    Quantities can also be created by multiplying a number or array with a\nastropy\/time\/formats.py:            # On purpose, multiply with 1.\/day_unit because typically it is\nastropy\/time\/formats.py:        # and 1\/86400 is not exactly representable as a float64, so multiplying\nastropy\/units\/tests\/test_logarithmic.py:        # And multiplying with a dimensionless array is also OK.\nastropy\/units\/tests\/test_quantity_ufuncs.py:    def test_multiply_scalar(self):\nastropy\/units\/tests\/test_quantity_ufuncs.py:        assert np.multiply(4.0 * u.m, 2.0 \/ u.s) == 8.0 * u.m \/ u.s\nastropy\/units\/tests\/test_quantity_ufuncs.py:        assert np.multiply(4.0 * u.m, 2.0) == 8.0 * u.m\nastropy\/units\/tests\/test_quantity_ufuncs.py:        assert np.multiply(4.0, 2.0 \/ u.s) == 8.0 \/ u.s\nastropy\/units\/tests\/test_quantity_ufuncs.py:    def test_multiply_array(self):\nastropy\/units\/tests\/test_quantity_ufuncs.py:            np.multiply(np.arange(3.0) * u.m, 2.0 \/ u.s)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        np.multiply(2.0 \/ u.s, s, out=s)\nastropy\/units\/tests\/test_quantity_ufuncs.py:            np.multiply.at(s, i, 1 * u.s)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        np.multiply.at(s, i, 2.0 * u.dimensionless_unscaled)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        np.multiply.at(check, i, 2)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        np.multiply.at(s, i, 2.0)\nastropy\/units\/tests\/test_quantity_ufuncs.py:            np.multiply.reduce(s)\nastropy\/units\/tests\/test_quantity_ufuncs.py:            np.multiply.accumulate(s)\nastropy\/units\/tests\/test_quantity_ufuncs.py:            np.multiply.reduceat(s, i)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        s_multiply_reduce = np.multiply.reduce(s)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        check_multiply_reduce = np.multiply.reduce(check)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        assert s_multiply_reduce.value == check_multiply_reduce\nastropy\/units\/tests\/test_quantity_ufuncs.py:        assert s_multiply_reduce.unit is u.dimensionless_unscaled\nastropy\/units\/tests\/test_quantity_ufuncs.py:        s_multiply_accumulate = np.multiply.accumulate(s)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        check_multiply_accumulate = np.multiply.accumulate(check)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        assert np.all(s_multiply_accumulate.value == check_multiply_accumulate)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        assert s_multiply_accumulate.unit is u.dimensionless_unscaled\nastropy\/units\/tests\/test_quantity_ufuncs.py:        s_multiply_reduceat = np.multiply.reduceat(s, i)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        check_multiply_reduceat = np.multiply.reduceat(check, i)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        assert np.all(s_multiply_reduceat.value == check_multiply_reduceat)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        assert s_multiply_reduceat.unit is u.dimensionless_unscaled\nastropy\/units\/tests\/test_quantity_ufuncs.py:        s12_multiply_outer = np.multiply.outer(s1, s2)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        check12_multiply_outer = np.multiply.outer(check1, check2)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        assert np.all(s12_multiply_outer.value == check12_multiply_outer)\nastropy\/units\/tests\/test_quantity_ufuncs.py:        assert s12_multiply_outer.unit == s1.unit * s2.unit\nastropy\/units\/tests\/test_quantity_ufuncs.py:    @pytest.mark.parametrize(\"ufunc\", (np.add, np.multiply, np.less))\nastropy\/units\/tests\/test_units.py:    \"name, symbol, multiplying_factor\",\nastropy\/units\/tests\/test_units.py:def test_si_prefixes(name, symbol, multiplying_factor):\nastropy\/units\/tests\/test_units.py:    assert u.isclose(value_ratio, multiplying_factor)\nastropy\/extern\/ply\/lex.py:                self.log.warning(\"Token '%s' multiply defined\", n)\nastropy\/time\/utils.py:        If given, multiply the sum by it.\nastropy\/time\/utils.py:    multiply by that possibly inaccurate factor, the value is divided by the\nastropy\/time\/utils.py:    multiply.  With this scheme, one has precise conversion factors for all\nastropy\/units\/quantity_helper\/helpers.py:UFUNC_HELPERS[np.multiply] = helper_multiplication\nastropy\/modeling\/math_functions.py:    \"multiply\",\nastropy\/time\/core.py:                # The various ways we could multiply all failed;\nastropy\/nddata\/nddata_withmixins.py:    (indexing) and simple arithmetic (add, subtract, divide and multiply).\nastropy\/nddata\/nduncertainty.py:            `numpy.add`, `numpy.subtract`, `numpy.multiply` and\nastropy\/nddata\/nduncertainty.py:            elif operation.__name__ == \"multiply\":\nastropy\/nddata\/nduncertainty.py:                result = self._propagate_multiply(\nastropy\/nddata\/nduncertainty.py:    def _propagate_multiply(self, other_uncert, result_data, correlation):\nastropy\/nddata\/nduncertainty.py:    def _propagate_multiply(self, other_uncert, result_data, correlation):\nastropy\/nddata\/nduncertainty.py:    def _propagate_multiply_divide(\nastropy\/nddata\/nduncertainty.py:    def _propagate_multiply(self, other_uncert, result_data, correlation):\nastropy\/nddata\/nduncertainty.py:        return super()._propagate_multiply_divide(\nastropy\/nddata\/nduncertainty.py:        return super()._propagate_multiply_divide(\nastropy\/nddata\/nduncertainty.py:    def _propagate_multiply(self, other_uncert, result_data, correlation):\nastropy\/nddata\/nduncertainty.py:        return super()._propagate_multiply_divide(\nastropy\/nddata\/nduncertainty.py:        return super()._propagate_multiply_divide(\nastropy\/nddata\/nduncertainty.py:    def _propagate_multiply(self, other_uncert, result_data, correlation):\nastropy\/nddata\/nduncertainty.py:        return super()._propagate_multiply_divide(\nastropy\/nddata\/nduncertainty.py:        return super()._propagate_multiply_divide(\nastropy\/cosmology\/flrw\/base.py:        redshift ``z`` and multiplying by a solid angle.\nastropy\/nddata\/mixins\/tests\/test_ndslicing.py:    def _propagate_multiply(self, data, final_data):\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd5 = nd1.multiply(nd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd5 = nd1.multiply(nd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd1.multiply(nd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd5 = nd1.multiply(nd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd5 = nd1.multiply(nd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        nd1.multiply(nd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd1.multiply(nd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd4 = nd2.multiply(nd1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd1.multiply(nd2, uncertainty_correlation=cor)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd4 = nd2.multiply(nd1, uncertainty_correlation=cor)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd1.multiply(nd2, uncertainty_correlation=cor)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd4 = nd2.multiply(nd1, uncertainty_correlation=cor)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd1.multiply(nd2, uncertainty_correlation=cor)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd4 = nd2.multiply(nd1, uncertainty_correlation=cor)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd1.multiply(nd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3_ref = nd1_ref.multiply(nd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd2.multiply(nd1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3_ref = nd2.multiply(nd1_ref)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd1.multiply(nd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3_ref = nd1_ref.multiply(nd2_ref)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd2.multiply(nd1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3_ref = nd2_ref.multiply(nd1_ref)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd1.multiply(nd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3_ref = nd1_ref.multiply(nd2_ref)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd2.multiply(nd1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3_ref = nd2_ref.multiply(nd1_ref)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd1.multiply(nd2)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3_ref = nd1_ref.multiply(nd2_ref)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd2.multiply(nd1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3_ref = nd2_ref.multiply(nd1_ref)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:@pytest.mark.parametrize(\"meth\", [\"add\", \"subtract\", \"divide\", \"multiply\"])\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:@pytest.mark.parametrize(\"meth\", [\"add\", \"subtract\", \"divide\", \"multiply\"])\nastropy\/nddata\/mixins\/ndarithmetic.py:# Docstring templates for add, subtract, multiply, divide methods.\nastropy\/nddata\/mixins\/ndarithmetic.py:            `numpy.add`, `numpy.subtract`, `numpy.multiply` and\nastropy\/nddata\/mixins\/ndarithmetic.py:    def multiply(self, operand, operand2=None, **kwargs):\nastropy\/nddata\/mixins\/ndarithmetic.py:            np.multiply, operand, operand2, **kwargs\nastropy\/nddata\/ccddata.py:        - ``np.multiply``\nastropy\/nddata\/ccddata.py:    ``multiply`` because only these methods from NDArithmeticMixin are\nastropy\/nddata\/ccddata.py:    multiply = _arithmetic(np.multiply)(NDDataArray.multiply)\nastropy\/nddata\/tests\/test_nduncertainty.py:    def _propagate_multiply(self, data, final_data):\nastropy\/utils\/masked\/function_helpers.py:    return np.multiply.outer(np.ravel(a), np.ravel(b), out=out)\nastropy\/utils\/masked\/core.py:        return np.multiply.accumulate(self, axis=axis, dtype=dtype, out=out)\nastropy\/utils\/masked\/tests\/test_functions.py:    # multiply.reduce does not work with units, so test only for plain array.\nastropy\/utils\/masked\/tests\/test_functions.py:    def test_multiply_reduce(self, axis):\nastropy\/utils\/masked\/tests\/test_functions.py:        ma_reduce = np.multiply.reduce(self.ma, axis=axis)\nastropy\/utils\/masked\/tests\/test_functions.py:        expected_data = np.multiply.reduce(self.a, axis=axis)\nastropy\/nddata\/tests\/test_ccddata.py:        (\"multiply\", True),\nastropy\/nddata\/tests\/test_ccddata.py:        ccd_data.multiply(\"five\")\nastropy\/nddata\/tests\/test_ccddata.py:    assert ccd.multiply(ccd, compare_wcs=None).wcs is None\nastropy\/nddata\/tests\/test_ccddata.py:        ccd1.multiply(ccd2, compare_wcs=return_true).wcs, wcs1\nastropy\/nddata\/tests\/test_ccddata.py:        ccd1.multiply(ccd2, compare_wcs=return_false)\nastropy\/nddata\/tests\/test_ccddata.py:    result = ccd_data.multiply(operand)\nastropy\/nddata\/tests\/test_ccddata.py:    res = ccddata.multiply(b)\nastropy\/nddata\/tests\/test_ccddata.py:    np.testing.assert_array_almost_equal(res.data, np.multiply(a, b).value)\nastropy\/nddata\/tests\/test_ccddata.py:    assert res.unit == np.multiply(a, b).unit\nastropy\/nddata\/tests\/test_ccddata.py:def test_arithmetic_multiply_with_array():\nastropy\/nddata\/tests\/test_ccddata.py:    res = ccd.multiply(np.ones((3, 3)) * 2)\nastropy\/nddata\/tests\/test_ccddata.py:    result = ccd_data.multiply(1.0)\nastropy\/nddata\/tests\/test_ccddata.py:@pytest.mark.parametrize(\"operation\", [\"multiply\", \"divide\", \"add\", \"subtract\"])\nastropy\/nddata\/tests\/test_ccddata.py:@pytest.mark.parametrize(\"operation\", [\"multiply\", \"divide\", \"add\", \"subtract\"])","role":"tool","tool_calls":null},{"content":"astropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        handle_mask=None,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        handle_mask=use_abbreviation,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        handle_mask=use_abbreviation,\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd3 = nd1.add(nd2, handle_mask=mask_sad_func)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:    nd4 = nd1.add(nd2, handle_mask=mask_sad_func, mask_fun=1)\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py:        nd1.add(nd2, handle_mask=mask_sad_func, fun=1)\nastropy\/nddata\/mixins\/ndarithmetic.py:    handle_mask : callable, ``'first_found'`` or ``None``, optional\nastropy\/nddata\/mixins\/ndarithmetic.py:        handle_mask=np.logical_or,\nastropy\/nddata\/mixins\/ndarithmetic.py:        handle_mask : callable, ``'first_found'`` or ``None``, optional\nastropy\/nddata\/mixins\/ndarithmetic.py:        if handle_mask is None:\nastropy\/nddata\/mixins\/ndarithmetic.py:        elif handle_mask in [\"ff\", \"first_found\"]:\nastropy\/nddata\/mixins\/ndarithmetic.py:                operation, operand, handle_mask, axis=axis, **kwds2[\"mask\"]\nastropy\/nddata\/mixins\/ndarithmetic.py:    def _arithmetic_mask(self, operation, operand, handle_mask, axis=None, **kwds):\nastropy\/nddata\/mixins\/ndarithmetic.py:        handle_mask : callable\nastropy\/nddata\/mixins\/ndarithmetic.py:            Additional parameters given to ``handle_mask``.\nastropy\/nddata\/mixins\/ndarithmetic.py:            ``handle_mask`` must create (and copy) the returned mask.\nastropy\/nddata\/mixins\/ndarithmetic.py:        ) or handle_mask is None:\nastropy\/nddata\/mixins\/ndarithmetic.py:            return handle_mask(self.mask, operand.mask, **kwds)\nastropy\/nddata\/mixins\/ndarithmetic.py:            # for collapse operations, use astropy.utils.masked rather than handle_mask","role":"tool","tool_calls":null},{"content":"\n\n<files>\nastropy\/nddata\/nddata_withmixins.py\nastropy\/nddata\/mixins\/ndarithmetic.py\nastropy\/nddata\/mixins\/tests\/test_ndarithmetic.py\nastropy\/nddata\/nduncertainty.py\n<\/files>","role":"assistant","tool_calls":null}],"task":"default","reward":0.4,"generation_ms":50920.8583831787,"scoring_ms":0.1614093781,"total_ms":50921.0197925568,"info":{"instance_id":"astropy__astropy-14995","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/nddata\/mixins\/ndarithmetic.py\": {\"old_start\": 520, \"old_count\": 10, \"new_start\": 520, \"new_count\": 10, \"hunks\": [{\"old_start\": 520, \"old_count\": 10, \"new_start\": 520, \"new_count\": 10}]}}","file_localization_reward":0.4}
{"example_id":4,"prompt":[{"content":"\nYou are a specialized code localization agent. Your sole objective is to identify and return the files in the codebase that are relevant to the user's query.\nYou are given access to the codebase in a linux file system.\n\n## PRIMARY DIRECTIVE\n- Find relevant files, do NOT answer the user's query directly\n- Return ONLY file paths in <files> XML tags\n- Prioritize precision: every file you return should be relevant\n- You have up to 8 turns to explore and return your answer\n\n## TOOL USAGE REQUIREMENTS\n\n### bash tool (REQUIRED for search)\n- You MUST use the bash tool to search and explore the codebase\n- Execute bash commands like: rg, grep, find, ls, cat, head, tail, sed\n- Use parallel tool calls: invoke bash tool up to 3 times concurrently in a single turn\n- NEVER exceed 3 parallel tool calls per turn\n- Common patterns:\n  * `rg \"pattern\" -t py` - search for code patterns\n  * `rg --files | grep \"keyword\"` - find files by name\n  * `cat path\/to\/file.py` - read file contents\n  * `find . -name \"*.py\" -type f` - locate files by extension\n  * `wc -l path\/to\/file.py` - count lines in a file\n  * `sed -n '1,100p' path\/to\/file.py` - read lines 1-100 of a file\n  * `head -n 100 path\/to\/file.py` - read first 100 lines\n  * `tail -n 100 path\/to\/file.py` - read last 100 lines\n\n### Reading Files (CRITICAL for context management)\n- NEVER read entire large files with `cat` - this will blow up your context window\n- ALWAYS check file size first: `wc -l path\/to\/file.py`\n- For files > 100 lines, read in chunks:\n  * Use `sed -n '1,100p' file.py` to read lines 1-100\n  * Use `sed -n '101,200p' file.py` to read lines 101-200\n  * Continue with subsequent ranges as needed (201-300, 301-400, etc.)\n- Strategic reading approach:\n  * Read the first 50-100 lines to see imports and initial structure\n  * Use `rg` to find specific patterns and their line numbers\n  * Read targeted line ranges around matches using `sed -n 'START,ENDp'`\n  * Only read additional chunks if the initial sections are relevant\n\n### Final Answer Format (REQUIRED)\n- You MUST return your final answer in <files> XML tags\n- Format: <files>path\/to\/file1.py\npath\/to\/file2.py\npath\/to\/file3.py<\/files>\n- List one file path per line inside the tags\n- Use relative paths as they appear in the repository\n- DO NOT include any other text inside the <files> tags\n\n## SEARCH STRATEGY\n\n1. **Initial Exploration**: Cast a wide net\n   - Search for keywords, function names, class names\n   - Check file names and directory structure\n   - Use up to 3 parallel bash calls to explore multiple angles\n   - Check file sizes with `wc -l` before reading\n   - Read promising files in chunks (lines 1-100) to verify relevance\n\n2. **Deep Dive**: Follow the most promising leads\n   - Use up to 3 parallel bash calls to investigate further\n   - Read files in chunks to confirm they address the query\n   - Use `rg` with line numbers to locate specific code, then read those ranges\n   - Start eliminating false positives\n\n3. **Final Verification**: Confirm your file list\n   - Verify each candidate file is truly relevant\n   - Ensure you haven't missed related files\n   - Return your answer in <files> tags\n\n## CRITICAL RULES\n- NEVER exceed 3 parallel bash tool calls in a single turn\n- NEVER respond without wrapping your file list in <files> tags\n- ALWAYS use bash tool to search (do not guess file locations)\n- NEVER read entire large files - always read in chunks (100-line ranges)\n- Check file size with `wc -l` before reading\n- Read file contents in chunks to verify relevance before including them\n- Return file paths as they appear in the repository. Do not begin the path with \".\/\"\n- Aim for high precision (all files relevant) and high recall (no relevant files missed)\n\n## EXAMPLE OUTPUT\n\nAfter exploring the codebase, return your answer like this:\n\n<files>\nsrc\/main.py\nsrc\/utils\/helper.py\ntests\/test_main.py\n<\/files>\n","role":"system"},{"content":"Possible bug in io.fits related to D exponents\nI came across the following code in ``fitsrec.py``:\r\n\r\n```python\r\n        # Replace exponent separator in floating point numbers\r\n        if 'D' in format:\r\n            output_field.replace(encode_ascii('E'), encode_ascii('D'))\r\n```\r\n\r\nI think this may be incorrect because as far as I can tell ``replace`` is not an in-place operation for ``chararray`` (it returns a copy). Commenting out this code doesn't cause any tests to fail so I think this code isn't being tested anyway.\n","role":"user"}],"completion":[{"content":"\n\n","role":"assistant","tool_calls":["{\"id\": \"chatcmpl-tool-6f31b7d161624432bd70a96dce86baed\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'chararray' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-a4c6b81e58a7401dbd6e2717a174eac6\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"rg 'replace' -t py\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}","{\"id\": \"chatcmpl-tool-c5baf802efca4ce79a21fc0de348985d\", \"function\": {\"arguments\": \"{\\\"command\\\": \\\"find . -path '*\/io\/fits\/*' -type f -name '*.py'\\\"}\", \"name\": \"bash\"}, \"type\": \"function\"}"]},{"content":"astropy\/io\/fits\/hdu\/table.py:from numpy import char as chararray\nastropy\/io\/fits\/hdu\/table.py:        if isinstance(field, chararray.chararray):\nastropy\/io\/fits\/hdu\/table.py:                if (not isinstance(c, chararray.chararray) and\nastropy\/io\/fits\/fitsrec.py:from numpy import char as chararray\nastropy\/io\/fits\/fitsrec.py:                    # Normally the column array is a chararray of 1 character\nastropy\/io\/fits\/fitsrec.py:                elif isinstance(raw_field, chararray.chararray):\nastropy\/io\/fits\/fitsrec.py:    Numeric-style chararray objects.\nastropy\/io\/fits\/fitsrec.py:    # Numpy >= 1.10.dev recarray no longer returns chararrays for strings\nastropy\/io\/fits\/fitsrec.py:            not isinstance(field, chararray.chararray)):\nastropy\/io\/fits\/fitsrec.py:        field = field.view(chararray.chararray)\nastropy\/io\/fits\/column.py:from numpy import char as chararray\nastropy\/io\/fits\/column.py:                          (np.ndarray, chararray.chararray, Delayed)):\nastropy\/io\/fits\/column.py:                    array = chararray.array(array, itemsize=itemsize)\nastropy\/io\/fits\/column.py:                    return chararray.array(array, itemsize=fsize, copy=False)\nastropy\/io\/fits\/column.py:                input = [chararray.array(x, itemsize=1) for x in input]\nastropy\/io\/fits\/column.py:        elif isinstance(value, chararray.chararray) and value.itemsize == 1:\nastropy\/io\/fits\/column.py:            value = chararray.array(value, itemsize=1)\nastropy\/io\/fits\/column.py:            data_output[idx] = chararray.array(encode_ascii(rowval),\nastropy\/io\/fits\/tests\/test_table.py:from numpy import char as chararray\nastropy\/io\/fits\/tests\/test_table.py:        a1 = chararray.array(['abc', 'def', 'xx'])\nastropy\/io\/fits\/tests\/test_table.py:        a1 = chararray.array(['abcd', 'def'])\nastropy\/io\/fits\/tests\/test_table.py:                           array=chararray.array(a))\nastropy\/io\/fits\/tests\/test_table.py:            # the single row.  However, this is broken for chararray because\nastropy\/io\/fits\/tests\/test_table.py:            # is a bug in chararray though and not a bug in any FITS-specific","role":"tool","tool_calls":null},{"content":"ah_bootstrap.py:            pkg_resources.working_set.add(dist, replace=True)\nah_bootstrap.py:            # replace=True option here.  These versions are old enough that all\nah_bootstrap.py:        stdout = stdout.decode(stdio_encoding, 'replace')\nah_bootstrap.py:        stderr = stderr.decode(stdio_encoding, 'replace')\nastropy\/_erfa\/erfa_generator.py:NDIMS_REX = re.compile(re.escape(\"numpy.dtype([('fi0', '.*', <(.*)>)])\").replace(r'\\.\\*', '.*').replace(r'\\<', '(').replace(r'\\>', ')'))\nastropy\/_erfa\/erfa_generator.py:        self.doc = doc.replace(\"**\", \"  \").replace(\"\/*\\n\", \"\").replace(\"*\/\", \"\")\nastropy\/_erfa\/erfa_generator.py:        return self.doc.replace(\"  \\n\", \"\\n\")\nastropy\/_erfa\/erfa_generator.py:        self.name = name.replace(\"ERFA_\", \"\")\nastropy\/_erfa\/erfa_generator.py:        self.value = value.replace(\"ERFA_\", \"\")\nastropy\/stats\/funcs.py:    replacement (\"case bootstrapping\"). These can all be run through a function\nastropy\/stats\/funcs.py:        # numpy.cumprod. This could be replaced by factorial again as soon as\nastropy\/wcs\/setup_package.py:    s = s.decode('ascii').encode('ascii', 'backslashreplace')\nastropy\/wcs\/setup_package.py:    s = s.replace(b'\\n', b'\\\\n')\nastropy\/wcs\/setup_package.py:    s = s.replace(b'\\0', b'\\\\0')\nastropy\/wcs\/wcs.py:            header_string = header_string.replace('END' + ' ' * 77, '')\nastropy\/wcs\/wcs.py:        # have to be replaced with\nastropy\/nddata\/nddata.py:    the unit parameter is not ``None``, then the implicit parameter is replaced\nastropy\/stats\/__init__.py:*not* to replace `scipy.stats` if its implementation satisfies\ndocs\/conf.py:.. |minimum_numpy_version| replace:: {0.__minimum_numpy_version__}\ndocs\/conf.py:# The version info for the project you're documenting, acts as replacement for\nastropy\/convolution\/convolve.py:    replaced with interpolated values using the kernel as an interpolation\nastropy\/convolution\/convolve.py:        masked array, the masked values will be replaced by ``fill_value``.\nastropy\/convolution\/convolve.py:        'fill' will replace the NaN pixels with a fixed numerical value (default\nastropy\/convolution\/convolve.py:    # Mark the NaN values so we can replace them later if interpolate_nan is\nastropy\/convolution\/convolve.py:    `convolve_fft` is very similar to `convolve` in that it replaces ``NaN``\nastropy\/convolution\/convolve.py:        and the kernel.  ``fill`` will replace the NaN pixels with a fixed\nastropy\/convolution\/convolve.py:def interpolate_replace_nans(array, kernel, convolve=convolve, **kwargs):\nastropy\/convolution\/convolve.py:    Given a data set containing NaNs, replace the NaNs by interpolating from\nastropy\/convolution\/convolve.py:        A copy of the original array with NaN pixels replaced with their\nastropy\/modeling\/tests\/test_quantities_parameters.py:    # Instantiating with different units works, and just replaces the original unit\nastropy\/modeling\/blackbody.py:        # with.  (As noted in #4393 ideally this would be replaced by a version\nastropy\/modeling\/polynomial.py:        ap_coeff_params = dict((k.replace('AP_', 'c'), v)\nastropy\/modeling\/polynomial.py:        bp_coeff_params = dict((k.replace('BP_', 'c'), v)\nastropy\/convolution\/__init__.py:    from .convolve import convolve, convolve_fft, interpolate_replace_nans, convolve_models\nastropy\/wcs\/tests\/extension\/test_extension.py:    code = code.strip().replace('\\n', '; ')\nastropy\/stats\/lombscargle\/_statistics.py:        s = rng.randint(0, len(y), len(y))  # sample with replacement\nastropy\/visualization\/interval.py:        sampled from the array (with replacement).\nastropy\/visualization\/interval.py:        # If needed, limit the number of samples. We sample with replacement\nastropy\/visualization\/interval.py:        sampled from the array (with replacement).\nastropy\/visualization\/tests\/test_lupton_rgb.py:    Simulates saturation on an image, so we can test 'replace_saturated_pixels'\nastropy\/visualization\/tests\/test_lupton_rgb.py:        pytest.skip('replaceSaturatedPixels is not implemented in astropy yet')\nastropy\/visualization\/tests\/test_lupton_rgb.py:        lupton_rgb.replaceSaturatedPixels(self.image_r, self.image_g, self.image_b, 1, 2000)\nastropy\/visualization\/tests\/test_lupton_rgb.py:        # Check that we replaced those NaNs with some reasonable value\nastropy\/visualization\/wcsaxes\/coordinates_map.py:                name = wcs.wcs.ctype[coord_index][:4].replace('-', '')\nastropy\/nddata\/decorators.py:                # Finally, replace data by the data attribute\nastropy\/nddata\/tests\/test_nddata.py:    # Check that it replaces a mask from init\nastropy\/io\/misc\/hdf5.py:        replaced; the file\/group will not be overwritten.\nastropy\/table\/bst.py:    def replace(self, child, new_child):\nastropy\/table\/bst.py:            raise ValueError(\"Cannot call replace() on non-child\")\nastropy\/table\/bst.py:        self.replace(child, None)\nastropy\/table\/bst.py:            parent.replace(node, new_node)\nastropy\/table\/bst.py:    def replace_rows(self, row_map):\nastropy\/table\/bst.py:    def replace_rows(self, row_map):\nastropy\/io\/fits\/convenience.py:           ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/convenience.py:           ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/convenience.py:    tabledump.__doc__ += BinTableHDU._tdump_file_format.replace('\\n', '\\n    ')\nastropy\/io\/fits\/convenience.py:    return BinTableHDU.load(datafile, cdfile, hfile, replace=True)\nastropy\/io\/fits\/convenience.py:    tableload.__doc__ += BinTableHDU._tdump_file_format.replace('\\n', '\\n    ')\nastropy\/io\/ascii\/tests\/test_c_reader.py:    If passed as a parameter, names should replace any\nastropy\/io\/ascii\/tests\/test_c_reader.py:        table = read_basic(text.replace(' ', sep), delimiter=sep, parallel=parallel)\nastropy\/io\/ascii\/tests\/test_c_reader.py:    table = read_basic(text.replace('\"', \"'\"), quotechar=\"'\", parallel=parallel)\nastropy\/io\/ascii\/tests\/test_c_reader.py:        table = read_basic(text.replace('\\n', newline), parallel=parallel)\nastropy\/io\/ascii\/tests\/test_c_reader.py:        table = read_commented_header(text.replace('\\n', newline), parallel=parallel)\nastropy\/io\/ascii\/tests\/test_c_reader.py:        table = read_rdb(text.replace('\\n', newline), parallel=parallel)\nastropy\/table\/table.py:    Warning class for cases when a table column is replaced via the\nastropy\/table\/table.py:            raise ValueError(\"Cannot replace column '{0}'.  Use Table.replace_column() instead.\"\nastropy\/table\/table.py:                # Set an existing column by first trying to replace, and if\nastropy\/table\/table.py:                        and not conf.replace_inplace):\nastropy\/table\/table.py:                        self._replace_column_warnings(item, value)\nastropy\/table\/table.py:    def _replace_column_warnings(self, name, col):\nastropy\/table\/table.py:        Same as replace_column but issues warnings under various circumstances.\nastropy\/table\/table.py:        warns = conf.replace_warnings\nastropy\/table\/table.py:        self.replace_column(name, col)\nastropy\/table\/table.py:            warnings.warn(\"replaced column '{}'\".format(name),\nastropy\/table\/table.py:                    msg = (\"replaced column '{}' which looks like an array slice. \"\nastropy\/table\/table.py:                msg = (\"replaced column '{}' and the number of references \"\nastropy\/table\/table.py:                msg = (\"replaced column '{}' and column attributes {} changed.\"\nastropy\/table\/table.py:    def replace_column(self, name, col):\nastropy\/table\/table.py:            Name of column to replace\nastropy\/table\/table.py:            New column object to replace the existing column\nastropy\/table\/table.py:            >>> t.replace_column('a', float_a)\nastropy\/table\/table.py:            raise ValueError('cannot replace a table index column')\nastropy\/table\/table.py:        self._replace_cols(columns)\nastropy\/table\/table.py:            self._replace_cols(columns)\nastropy\/table\/table.py:    def _replace_cols(self, columns):\nastropy\/io\/ascii\/tests\/test_read.py:    # This is a NoHeader format table and so `names` should replace\nastropy\/io\/ascii\/tests\/test_read.py:    # gives the column names 'c', 'd', which get replaced by 'a', 'b'\nastropy\/io\/ascii\/tests\/test_read.py:    # gives the column names 'c', 'd', which get replaced by 'a', 'b'\nastropy\/io\/ascii\/tests\/test_write.py:'''.replace('\\n', os.linesep)\nastropy\/io\/ascii\/tests\/test_write.py:    assert out.getvalue() == expected.replace(\nastropy\/io\/ascii\/tests\/test_write.py:        'colhead{s}', r'colhead{$\\mathrm{s}$}').replace(\nastropy\/io\/fits\/fitsrec.py:        # Now replace the original column array references with the new\nastropy\/io\/fits\/fitsrec.py:        # Before using .replace make sure that any trailing bytes in each\nastropy\/io\/fits\/fitsrec.py:        # functions like replace to potentially leave gibberish bytes in the\nastropy\/io\/fits\/fitsrec.py:        dummy = np.char.replace(dummy, encode_ascii('D'), encode_ascii('E'))\nastropy\/io\/fits\/fitsrec.py:        # always replace empty fields, see https:\/\/github.com\/astropy\/astropy\/pull\/5394\nastropy\/io\/fits\/fitsrec.py:            output_field.replace(encode_ascii('E'), encode_ascii('D'))\nastropy\/io\/ascii\/tests\/test_html.py:    Test that passing fill_values should replace any matching row\nastropy\/io\/ascii\/tests\/test_html.py:    Test that passing optional column in fill_values should only replace\nastropy\/io\/ascii\/tests\/test_html.py:    Test that passing masked values in fill_values should only replace\nastropy\/io\/ascii\/tests\/test_html.py:    columns with correctly replaced fill_values.\nastropy\/io\/ascii\/tests\/test_html.py:    Test that passing masked values in fill_values should only replace\nastropy\/table\/tests\/test_pprint.py:def test_decode_replace():\nastropy\/table\/tests\/test_pprint.py:    decoding to utf-8 and gets replaced by U+FFFD.  See\nastropy\/table\/tests\/test_pprint.py:    https:\/\/docs.python.org\/3\/library\/codecs.html#codecs.replace_errors\nastropy\/io\/fits\/card.py:                'delete this card from the header or replace it.')\nastropy\/io\/fits\/card.py:                'Either delete this card from the header or replace it.')\nastropy\/io\/fits\/card.py:                'delete this card from the header or replace it.')\nastropy\/io\/fits\/card.py:                'Either delete this card from the header or replace it.')\nastropy\/io\/fits\/card.py:                value = card.value.rstrip().replace(\"''\", \"'\")\nastropy\/io\/fits\/card.py:        value = self._value.replace(\"'\", \"''\")\nastropy\/io\/fits\/card.py:            exp_val_str = value.replace(\"'\", \"''\")\nastropy\/table\/sorted_array.py:    def replace_rows(self, row_map):\nastropy\/io\/fits\/util.py:                          'file header and have been replaced by \"?\" '\nastropy\/io\/fits\/util.py:            s = s.decode('ascii', errors='replace')\nastropy\/io\/fits\/util.py:            return s.replace(u'\\ufffd', '?')\nastropy\/io\/fits\/util.py:            dt = s.dtype.str.replace('S', 'U')\nastropy\/io\/fits\/util.py:        mode = mode.replace('+', '')\nastropy\/table\/np_utils.py:    Partial replacement for `~numpy.core.records.fromrecords` which includes\nastropy\/table\/np_utils.py:    This should not serve as a full replacement for the original function;\nastropy\/io\/fits\/scripts\/fitscheck.py:                        filename, str(exc).replace('\\n', ' '))\nastropy\/io\/fits\/header.py:                    'replaced with spaces upon writing.', AstropyUserWarning)\nastropy\/io\/fits\/header.py:                header_str.replace('\\0', ' ')\nastropy\/io\/fits\/header.py:                        'bytes will be replaced with spaces on write.'.format(\nastropy\/io\/fits\/header.py:               ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/header.py:           ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/header.py:            easily replaces the old usage of :meth:`Header.update` both\nastropy\/io\/fits\/header.py:                                     replace=True)\nastropy\/io\/fits\/header.py:            old API can be replaced as follows:\nastropy\/io\/fits\/header.py:            If there are blank cards at the end of the Header, replace the\nastropy\/io\/fits\/header.py:            replaced by the 'XTENSION' keyword.  Likewise if the first keyword\nastropy\/io\/fits\/header.py:            header is 'SIMPLE', the 'XTENSION' keyword is replaced by the\nastropy\/io\/fits\/header.py:            If there are blank cards at the end of the Header, replace the\nastropy\/io\/fits\/header.py:    def _relativeinsert(self, card, before=None, after=None, replace=False):\nastropy\/io\/fits\/header.py:        If replace=True, move an existing card with the same keyword.\nastropy\/io\/fits\/header.py:        if replace:\nastropy\/io\/fits\/header.py:        # Even if replace=True, the insertion idx may have changed since the\nastropy\/io\/fits\/header.py:        pattern = pattern.replace('*', r'.*').replace('?', r'.')\nastropy\/io\/fits\/header.py:        pattern = pattern.replace('...', r'\\S*') + '$'\nastropy\/table\/tests\/test_column.py:        t['a'][0] = 'eee'  # replace item with string that gets truncated\nastropy\/table\/tests\/test_column.py:        t['a'][:] = ['ff', 'ggg']  # replace item with string that gets truncated\nastropy\/table\/tests\/test_column.py:        mc[:] = [np.ma.masked, 'ggg']  # replace item with string that gets truncated\nastropy\/io\/fits\/fitstime.py:        The table whose Time columns are to be replaced.\nastropy\/io\/fits\/fitstime.py:        The table with replaced Time columns\nastropy\/io\/fits\/fitstime.py:            newtable.replace_column(col.info.name, Column(col.value))\nastropy\/io\/fits\/fitstime.py:        newtable.replace_column(col.info.name, Column(jd12, unit='d'))\nastropy\/table\/__init__.py:    replace_warnings = _config.ConfigItem(\nastropy\/table\/__init__.py:    replace_inplace = _config.ConfigItem(\nastropy\/table\/tests\/test_table.py:    def test_fail_replace_column(self, table_types):\nastropy\/table\/tests\/test_table.py:        \"\"\"Raise exception when trying to replace column via table.columns object\"\"\"\nastropy\/table\/tests\/test_table.py:            t.replace_column('not there', [1, 2, 3])\nastropy\/table\/tests\/test_table.py:    def test_replace_column(self, table_types):\nastropy\/table\/tests\/test_table.py:            t.replace_column('a', col)\nastropy\/table\/tests\/test_table.py:    def test_replace_index_column(self, table_types):\nastropy\/table\/tests\/test_table.py:            t.replace_column('a', [1, 2, 3])\nastropy\/table\/tests\/test_table.py:        assert err.value.args[0] == 'cannot replace a table index column'\nastropy\/table\/tests\/test_table.py:def test_replace_column_qtable():\nastropy\/table\/tests\/test_table.py:    t.replace_column('a', a.to('cm'))\nastropy\/table\/tests\/test_table.py:def test_replace_update_column_via_setitem():\nastropy\/table\/tests\/test_table.py:    already well-tested ``replace_column`` and in-place update\nastropy\/table\/tests\/test_table.py:def test_replace_update_column_via_setitem_warnings_normal():\nastropy\/table\/tests\/test_table.py:    Test warnings related to table replace change in #5556:\nastropy\/table\/tests\/test_table.py:    Normal warning-free replace\nastropy\/table\/tests\/test_table.py:        with table.conf.set_temp('replace_warnings',\nastropy\/table\/tests\/test_table.py:            t['a'] = [10, 20, 30]  # replace column\nastropy\/table\/tests\/test_table.py:def test_replace_update_column_via_setitem_warnings_slice():\nastropy\/table\/tests\/test_table.py:    Test warnings related to table replace change in #5556:\nastropy\/table\/tests\/test_table.py:        with table.conf.set_temp('replace_warnings',\nastropy\/table\/tests\/test_table.py:            t2['a'] = [10, 20]  # replace slice\nastropy\/table\/tests\/test_table.py:            assert \"replaced column 'a' which looks like an array slice\" in str(w[0].message)\nastropy\/table\/tests\/test_table.py:def test_replace_update_column_via_setitem_warnings_attributes():\nastropy\/table\/tests\/test_table.py:    Test warnings related to table replace change in #5556:\nastropy\/table\/tests\/test_table.py:        with table.conf.set_temp('replace_warnings',\nastropy\/table\/tests\/test_table.py:        assert \"replaced column 'a' and column attributes ['unit']\" in str(w[0].message)\nastropy\/table\/tests\/test_table.py:def test_replace_update_column_via_setitem_warnings_refcount():\nastropy\/table\/tests\/test_table.py:    Test warnings related to table replace change in #5556:\nastropy\/table\/tests\/test_table.py:        with table.conf.set_temp('replace_warnings',\nastropy\/table\/tests\/test_table.py:        assert \"replaced column 'a' and the number of references\" in str(w[0].message)\nastropy\/table\/tests\/test_table.py:def test_replace_update_column_via_setitem_warnings_always():\nastropy\/table\/tests\/test_table.py:    Test warnings related to table replace change in #5556:\nastropy\/table\/tests\/test_table.py:    Test 'always' setting that raises warning for any replace.\nastropy\/table\/tests\/test_table.py:        with table.conf.set_temp('replace_warnings', ['always']):\nastropy\/table\/tests\/test_table.py:            t['a'] = [10, 20, 30]  # replace column\nastropy\/table\/tests\/test_table.py:            assert \"replaced column 'a'\" == str(w[0].message)\nastropy\/table\/tests\/test_table.py:def test_replace_update_column_via_setitem_replace_inplace():\nastropy\/table\/tests\/test_table.py:    Test the replace_inplace config option related to #5556.  In this\nastropy\/table\/tests\/test_table.py:    case no replace is done.\nastropy\/table\/tests\/test_table.py:        with table.conf.set_temp('replace_inplace', True):\nastropy\/table\/tests\/test_table.py:            with table.conf.set_temp('replace_warnings',\nastropy\/table\/tests\/test_table.py:                t['a'] = [10, 20, 30]  # normally replaces column, but not now\nastropy\/table\/column.py:            index.replace_col(col, newcol)\nastropy\/table\/column.py:            index.replace_col(data, self)\nastropy\/table\/column.py:                    self.parent_table.replace_column(self.name, converted)\nastropy\/table\/column.py:            index.replace_col(self_data, self)\nastropy\/table\/column.py:            A copy of ``self`` with masked entries replaced by `fill_value`\nastropy\/table\/index.py:replace_rows(row_map) -> None : replace row numbers based on slice\nastropy\/table\/index.py:            # replace Time columns with approximate form and remainder\nastropy\/table\/index.py:    def replace_col(self, prev_col, new_col):\nastropy\/table\/index.py:            Column reference to replace\nastropy\/table\/index.py:    def replace(self, row, col_name, val):\nastropy\/table\/index.py:    def replace_rows(self, col_slice):\nastropy\/table\/index.py:        self.data.replace_rows(row_map)\nastropy\/table\/index.py:    def replace(self, row, col, val):\nastropy\/table\/index.py:            self.index.replace(self.orig_coords(row), col, val)\nastropy\/table\/index.py:            # replace self.index with a new object reference\nastropy\/table\/index.py:    def replace_rows(self, col_slice):\nastropy\/table\/index.py:            self.index.replace_rows([self.orig_coords(x) for x in col_slice])\nastropy\/table\/index.py:    def replace_col(self, prev_col, new_col):\nastropy\/table\/index.py:        self.index.replace_col(prev_col, new_col)\nastropy\/io\/ascii\/tests\/test_compressed.py:    t_uncomp = read(os.path.join(ROOT, filename.replace('.gz', '')))\nastropy\/io\/ascii\/tests\/test_compressed.py:    t_uncomp = read(os.path.join(ROOT, filename.replace('.bz2', '')))\nastropy\/io\/ascii\/tests\/test_compressed.py:    t_uncomp = read(os.path.join(ROOT, filename.replace('.xz', '')))\nastropy\/io\/ascii\/latex.py:    re_string = re.compile(latex.replace('\\\\', '\\\\\\\\'))\nastropy\/io\/ascii\/latex.py:        line = line.replace(r'\\tablehead', '')\nastropy\/io\/ascii\/latex.py:        return line.replace(r'\\colhead', '')\nastropy\/io\/fits\/diff.py:               ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/diff.py:               ``rtol`` replaces the deprecated ``tolerance`` argument.\nastropy\/io\/fits\/column.py:        # This forces the data for the HDU to be read, which will replace\nastropy\/io\/fits\/column.py:        # replaces the array originally pointed to by .array), but it's the way\nastropy\/io\/fits\/column.py:                    numpy_format = numpy_format.replace('i', 'u')\nastropy\/io\/fits\/column.py:                dim = repr(dim).replace(' ', '')\nastropy\/io\/ascii\/html.py:        Return an iterator of the values with replacements based on fill_values\nastropy\/io\/fits\/hdu\/compressed.py:    def _relativeinsert(self, card, before=None, after=None, replace=False):\nastropy\/io\/fits\/hdu\/compressed.py:                                replace=replace)\nastropy\/io\/fits\/hdu\/compressed.py:                                           replace=replace)\nastropy\/io\/fits\/hdu\/compressed.py:        floating point value of ``0.0`` is replaced with the special integer\nastropy\/io\/fits\/hdu\/compressed.py:        # as though the original image has been completely replaced\nastropy\/io\/fits\/hdu\/compressed.py:                        # called *after* _prewriteto(), replace these with\nastropy\/io\/fits\/hdu\/table.py:                            (k, data.dtype[k].kind.replace('u', 'i') +\nastropy\/io\/fits\/hdu\/table.py:                self._data_replaced = True\nastropy\/io\/fits\/hdu\/table.py:            self._data_replaced = True\nastropy\/io\/fits\/hdu\/table.py:          the field is replaced by a new line character.\nastropy\/io\/fits\/hdu\/table.py:               ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/hdu\/table.py:        dump.__doc__ += _tdump_file_format.replace('\\n', '\\n        ')\nastropy\/io\/fits\/hdu\/table.py:    def load(cls, datafile, cdfile=None, hfile=None, replace=False,\nastropy\/io\/fits\/hdu\/table.py:        replace : bool\nastropy\/io\/fits\/hdu\/table.py:            replaced with the contents of the ASCII file instead of\nastropy\/io\/fits\/hdu\/table.py:            values not present in this Header, unless ``replace=True`` in which\nastropy\/io\/fits\/hdu\/table.py:            this Header's values are completely replaced with the values from\nastropy\/io\/fits\/hdu\/table.py:            if replace:\nastropy\/io\/fits\/hdu\/table.py:        load.__doc__ += _tdump_file_format.replace('\\n', '\\n        ')\nastropy\/io\/fits\/hdu\/table.py:                kwargs[key] = words.pop(0).replace('\"\"', '')\nastropy\/io\/fits\/hdu\/table.py:                word = words.pop(0).replace('\"\"', '')\nastropy\/io\/fits\/hdu\/base.py:        self._data_replaced = False\nastropy\/io\/fits\/hdu\/base.py:               ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/hdu\/base.py:                # the user may have replaced the previous mmap'd array\nastropy\/io\/fits\/hdu\/base.py:                if copy or self._data_replaced:\nastropy\/io\/fits\/hdu\/base.py:        self._data_replaced = False\nastropy\/io\/fits\/hdu\/base.py:            fails to replace an invalid value.  In other words, this provides\nastropy\/io\/fits\/hdu\/base.py:            a default value to use as a replacement if the keyword's current\nastropy\/io\/fits\/hdu\/base.py:            value is invalid.  If `None`, there is no replacement value and the\nastropy\/io\/fits\/hdu\/base.py:           ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/hdu\/hdulist.py:               ``overwrite`` replaces the deprecated ``clobber`` argument.\nastropy\/io\/fits\/hdu\/hdulist.py:                # a segfault if they try to access it).  This replaces the\nastropy\/io\/ascii\/daophot.py:    replace_char = ' '\nastropy\/io\/ascii\/daophot.py:        replace_char = self.replace_char\nastropy\/io\/ascii\/daophot.py:                    line = line.replace(continuation_char, replace_char)\nastropy\/io\/ascii\/daophot.py:                    line = line.replace(multiline_char, replace_char)\nastropy\/io\/ascii\/ipac.py:    replace masked values with a string or number of your choice as\nastropy\/io\/fits\/hdu\/image.py:        # Set to True if the data or header is replaced, indicating that\nastropy\/io\/fits\/hdu\/image.py:                self._data_replaced = True\nastropy\/io\/fits\/hdu\/image.py:            self._data_replaced = True\nastropy\/io\/fits\/hdu\/image.py:                # *after* _prewriteto(), replace these with blank cards so\nastropy\/io\/fits\/hdu\/image.py:        # as though the original image has been completely replaced\nastropy\/io\/fits\/hdu\/image.py:            Otherwise, pixels equal to this value will be replaced with\nastropy\/io\/fits\/setup_package.py:    # 'numpy' will be replaced with the proper path to the numpy includes\nastropy\/table\/pprint.py:        return val.decode('utf-8', errors='replace')\nastropy\/io\/registry.py:        This contextmanager is experimental and may be replaced by a more\nastropy\/io\/fits\/tests\/test_fitscheck.py:        # replace checksums with wrong ones\nastropy\/io\/ascii\/core.py:    Internal class to replace the csv writer ``writerow`` and ``writerows``\nastropy\/io\/ascii\/core.py:    # empty fields and is then replaced post-write with doubled-quotechar.\nastropy\/io\/ascii\/core.py:    replace_sentinel = '2b=48Av%0-V3p>bX'\nastropy\/io\/ascii\/core.py:        # If QUOTE_MINIMAL and space-delimited then replace empty fields with\nastropy\/io\/ascii\/core.py:                    values[i] = self.replace_sentinel\nastropy\/io\/ascii\/core.py:        # If QUOTE_MINIMAL and space-delimited then replace empty fields with\nastropy\/io\/ascii\/core.py:                        values[i] = self.replace_sentinel\nastropy\/io\/ascii\/core.py:        If it has empty fields that have been replaced then change those\nastropy\/io\/ascii\/core.py:            row_string = re.sub(self.replace_sentinel, self.quotechar2, row_string)\nastropy\/io\/ascii\/core.py:        If splitting on whitespace then replace unquoted tabs with space first\"\"\"\nastropy\/io\/ascii\/core.py:            line = _replace_tab_with_space(line, self.escapechar, self.quotechar)\nastropy\/io\/ascii\/core.py:def _replace_tab_with_space(line, escapechar, quotechar):\nastropy\/io\/ascii\/core.py:        String containing tabs to be replaced with spaces.\nastropy\/io\/ascii\/core.py:        A copy of ``line`` with tabs replaced by spaces, preserving quoted substrings.\nastropy\/io\/ascii\/core.py:        In the second step all replacements are done for the appropriate columns.\nastropy\/io\/ascii\/core.py:            for replacement in reversed(self.fill_values):\nastropy\/io\/ascii\/core.py:                if len(replacement) < 2:\nastropy\/io\/ascii\/core.py:                elif len(replacement) == 2:\nastropy\/io\/ascii\/core.py:                    affect_cols = replacement[2:]\nastropy\/io\/ascii\/core.py:                    cols[i].fill_values[replacement[0]] = str(replacement[1])\nastropy\/io\/ascii\/core.py:    def _replace_vals(self, cols):\nastropy\/io\/ascii\/core.py:        self._replace_vals(self.cols)\nastropy\/io\/ascii\/core.py:    replace_char = ' '\nastropy\/io\/ascii\/core.py:    # case the continuation character is just replaced with replace_char.\nastropy\/io\/ascii\/core.py:                line = line.replace(self.continuation_char, self.replace_char)\nastropy\/io\/ascii\/core.py:                parts.append(line.replace(self.continuation_char, self.replace_char))\nastropy\/io\/ascii\/core.py:            # Test if it looks like (match, replace_string, optional_colname),\nastropy\/io\/fits\/tests\/test_image.py:        the blanks are replaced by NaN in the float data), that the \"BLANK\"\nastropy\/io\/fits\/tests\/test_hdulist.py:    def test_replace_memmaped_array(self):\nastropy\/io\/fits\/tests\/test_hdulist.py:    def test_replace_mmap_data(self):\nastropy\/io\/fits\/tests\/test_hdulist.py:    def test_replace_mmap_data_2(self):\nastropy\/io\/fits\/tests\/test_hdulist.py:        different file should work.  Like test_replace_mmap_data but with\nastropy\/io\/fits\/tests\/test_table.py:                    s.replace('\\x00', ' '))\nastropy\/io\/fits\/tests\/test_table.py:            f.write(raw_bytes.replace(b'(2,2,3)', b'(2,2,2)'))\nastropy\/io\/fits\/tests\/test_table.py:        Blank values in numerical columns of ASCII tables should be replaced\nastropy\/io\/fits\/tests\/test_table.py:        value, they should be replaced with zeros.\nastropy\/io\/fits\/tests\/test_table.py:            nulled = h.read().replace(u'2       ', u'        ')\nastropy\/io\/fits\/tests\/test_table.py:            nulled = h.read().replace(u'3.00000000', u'          ')\nastropy\/io\/fits\/tests\/test_header.py:        out = out.replace(b'hello', u'h\u00e9llo'.encode('latin1'))\nastropy\/io\/fits\/tests\/test_header.py:        out = out.replace(b'BAR', u'B\u00c0R'.encode('latin1'))\nastropy\/io\/fits\/tests\/test_fitstime.py:            t.replace_column('a', getattr(t['a'], scale))\nastropy\/logger.py:        this replaces the output from ``warnings.warn``.\nastropy\/io\/votable\/xmlutil.py:    This is rather simplistic at the moment, since it just replaces\nastropy\/io\/votable\/tree.py:        function so the resizing strategy can be easily replaced.\nastropy\/time\/core.py:    # The usual tuple of attributes needed for serialization is replaced\nastropy\/time\/core.py:        # If current output subformat is not in the new format then replace\nastropy\/config\/configuration.py:    Determines if a config file can be safely replaced because it doesn't\nastropy\/time\/formats.py:            subfmt_in = subfmt_in.replace(strptime_code, regex)\nastropy\/time\/formats.py:                dt = (dt - dt.utcoffset()).replace(tzinfo=None)\nastropy\/units\/core.py:        return self.name.encode('ascii', 'replace')\nastropy\/units\/astrophys.py:# covariances between e and h.  Eventually, this may also be replaced with\nastropy\/io\/votable\/tests\/vo_test.py:            dtype[1] = dtype[1].replace(str('<'), str('>'))\nastropy\/io\/votable\/validator\/html.py:                content = content.replace(result.get_dirpath() + '\/', '')\nastropy\/coordinates\/representation.py:        # so that is the formmater we need to replace.\nastropy\/coordinates\/earth_orientation.py:# TODO: replace this with SOFA equivalent\nastropy\/coordinates\/earth_orientation.py:# TODO: replace w\/SOFA equivalent\nastropy\/units\/tests\/test_quantity_ufuncs.py:        # can also replace in last position if no scaling is needed\nastropy\/units\/tests\/test_quantity_ufuncs.py:        # in np<1.13, without __array_ufunc__, one cannot replace input with\nastropy\/units\/utils.py:    return s.replace('\\n', ' ')\nastropy\/coordinates\/angle_utilities.py:            t.value = float(t.value.replace('\u2212', '-'))\nastropy\/coordinates\/matrix_utilities.py:    this function can be replaced by ``m1 @ m2 @ m3``.\nastropy\/units\/format\/latex.py:        return name.replace('_', r'\\_')\nastropy\/units\/format\/unicode_format.py:            parts.append(m.replace('-', '\u2212'))\nastropy\/coordinates\/earth.py:            If not False, force replacement of the cached registry with a\nastropy\/coordinates\/baseframe.py:                data_repr = data_repr.replace(nmrepr, nmpref)\nastropy\/coordinates\/baseframe.py:                    diffrepr[0] = diffrepr[0].replace(rep_nm, frm_nm)\nastropy\/coordinates\/builtin_frames\/__init__.py:    docstr = dedent(docstr) + '    ' + graphstr.replace('\\n', '\\n    ')\nastropy\/units\/quantity.py:                                    \"to quantities with in-place replacement \"\nastropy\/units\/quantity.py:            latex_value = latex_value.replace('...', r'\\dots')\nastropy\/coordinates\/tests\/test_api_ape5.py:    # The above is essentially a replacement of the below, but tweaked so that\nastropy\/coordinates\/tests\/test_atc_replacements.py:\"\"\"Test replacements for ERFA functions atciqz and aticq.\"\"\"\nastropy\/coordinates\/tests\/test_atc_replacements.py:    \"\"\"Check replacements against erfa versions for consistency.\"\"\"\nastropy\/coordinates\/tests\/test_transformations.py:    # TODO: replace after a final decision on PR #6280\nastropy\/samp\/standard_profile.py:                trace = str(trace.encode('ASCII', 'backslashreplace'), 'ASCII')\nastropy\/samp\/lockfile_helpers.py:                                       .replace(\"\\\\\", \"\"), allow_none=1)\nastropy\/utils\/tests\/test_decorators.py:    Tests the compatibility replacement for functools.wraps which supports\nastropy\/utils\/tests\/test_decorators.py:    # Cannot replace \"*args\".\nastropy\/utils\/tests\/test_decorators.py:    # Cannot replace \"**kwargs\".\nastropy\/utils\/tests\/test_decorators.py:    # A first test that replaces an empty docstring\nastropy\/utils\/tests\/test_decorators.py:    # Test that it replaces an existing docstring\nastropy\/utils\/tests\/test_decorators.py:    # A first test that replaces an empty docstring\nastropy\/utils\/tests\/test_decorators.py:    # Test that it replaces an existing docstring\nastropy\/samp\/hub.py:        to replace the terminal-based message with e.g. a GUI pop-up. Two\nastropy\/utils\/console.py:    line = line.replace('\\t', ' ' * tabwidth)\nastropy\/utils\/data_info.py:                col_index.replace(key, self.name, val)\nastropy\/utils\/data_info.py:                    new_index.replace_rows(item)\nastropy\/utils\/decorators.py:    from the function signature and the ``new_name`` replaced it at the\nastropy\/utils\/decorators.py:    It is also possible to replace multiple arguments. The ``old_name``,\nastropy\/utils\/decorators.py:                    raise TypeError('cannot replace argument \"{0}\" of kind '\nastropy\/utils\/decorators.py:        The docstring that will replace the docstring of the decorated\nastropy\/tests\/helper.py:    # directory, so we replace all the paths with the true source\nastropy\/utils\/xml\/check.py:    replaces non-valid characters with underscores.\nastropy\/utils\/xml\/writer.py:        s = s.replace(\"&\", \"&amp;\")\nastropy\/utils\/xml\/writer.py:        s = s.replace(\"<\", \"&lt;\")\nastropy\/utils\/xml\/writer.py:        s = s.replace(\">\", \"&gt;\")\nastropy\/utils\/xml\/writer.py:        s = s.replace(\"&\", \"&amp;\")\nastropy\/utils\/xml\/writer.py:        s = s.replace(\"'\", \"&apos;\")\nastropy\/utils\/xml\/writer.py:        s = s.replace(\"\\\"\", \"&quot;\")\nastropy\/utils\/xml\/writer.py:        s = s.replace(\"<\", \"&lt;\")\nastropy\/utils\/xml\/writer.py:        s = s.replace(\">\", \"&gt;\")\nastropy\/utils\/xml\/writer.py:        pass  # replaced by the constructor\nastropy\/utils\/xml\/writer.py:                d[attr.replace('_', '-')] = str(getattr(obj, attr))\nastropy\/utils\/iers\/iers.py:                # Replace *replace* current values from the first predictive index through\nastropy\/utils\/iers\/iers.py:                # the end of the current table.  This replacement is much faster than just\nastropy\/utils\/iers\/iers.py:                n_replace = len(self) - fpi\nastropy\/utils\/iers\/iers.py:                self[fpi:] = new_table[new_fpi:new_fpi + n_replace]\nastropy\/utils\/iers\/iers.py:                if new_table['MJD'][new_fpi + n_replace] - self['MJD'][-1] != 1.0 * u.d:\nastropy\/utils\/iers\/iers.py:                for row in new_table[new_fpi + n_replace:]:\nastropy\/utils\/iers\/iers.py:        # If there is overlap then replace IERS-A values from available IERS-B\nastropy\/utils\/xml\/unescaper.py:        clean_url = clean_url.replace(key, _bytes_entities[key])\nastropy\/utils\/iers\/tests\/test_iers.py:            # finals2000A-2016-02-30-test has been replaced at this point.\nastropy\/utils\/tests\/test_data.py:    # test should be uncommented and the README.rst should be replaced with\nastropy\/tests\/plugins\/display.py:        plat = plat.decode(stdoutencoding, 'replace')\nastropy\/tests\/command.py:        coveragerc_content = coveragerc_content.replace(\nastropy\/extern\/bundled\/six.py:        return unicode(s.replace(r'\\\\', r'\\\\\\\\'), \"unicode_escape\")\nastropy\/extern\/bundled\/six.py:    # metaclass for one level of class instantiation that replaces itself with\nastropy\/samp\/hub_proxy.py:            url = hub_params[\"samp.hub.xmlrpc.url\"].replace(\"\\\\\", \"\")\nastropy\/tests\/tests\/test_run_tests.py:def test_doctest_float_replacement(tmpdir):\nastropy\/tests\/runner.py:                                        package.replace('.', os.path.sep))\nastropy\/tests\/runner.py:                    docs_path, kwargs['package'].replace('.', os.path.sep))\nastropy\/extern\/configobj\/configobj.py:# Sentinel for use in getattr calls to replace hasattr\nastropy\/extern\/configobj\/configobj.py:# this could be replaced if six is used for compatibility, or there are no\nastropy\/extern\/configobj\/configobj.py:                    replacement = v\nastropy\/extern\/configobj\/configobj.py:                    replacement = recursive_interpolate(k, v, s, backtrail)\nastropy\/extern\/configobj\/configobj.py:                value = ''.join((value[:start], replacement, value[end:]))\nastropy\/extern\/configobj\/configobj.py:                new_search_start = start + len(replacement)\nastropy\/extern\/configobj\/configobj.py:        ...     newkey = key.replace('XXXX', 'CLIENT1')\nastropy\/extern\/configobj\/configobj.py:        ...         val = val.replace('XXXX', 'CLIENT1')\nastropy\/extern\/configobj\/configobj.py:    present\/missing. (Whole missing sections will be replaced with ``False``)\nastropy\/extern\/configobj\/validate.py:# this could be replaced if six is used for compatibility, or there are no\nastropy\/extern\/ply\/cpp.py:    # replace with one space or a number of '\\n'\nastropy\/extern\/ply\/cpp.py:    # replace with '\/n'\nastropy\/extern\/ply\/cpp.py:# Given an input string, this function replaces all trigraph sequences.\nastropy\/extern\/ply\/cpp.py:# When a macro is created, the macro replacement token sequence is\nastropy\/extern\/ply\/cpp.py:    # representing the replacement macro tokens\nastropy\/extern\/ply\/cpp.py:        # Make string expansion patches.  These do not alter the length of the replacement sequence\nastropy\/extern\/ply\/cpp.py:                str_expansion[argnum] = ('\"%s\"' % \"\".join([x.value for x in args[argnum]])).replace(\"\\\\\",\"\\\\\\\\\")\nastropy\/extern\/ply\/cpp.py:        # has been sorted in reverse order of patch location since replacements will cause the\nastropy\/extern\/ply\/cpp.py:        # size of the replacement sequence to expand from the patch point.\nastropy\/extern\/ply\/cpp.py:                                # Get macro replacement text\nastropy\/extern\/ply\/cpp.py:        expr = expr.replace(\"&&\",\" and \")\nastropy\/extern\/ply\/cpp.py:        expr = expr.replace(\"||\",\" or \")\nastropy\/extern\/ply\/cpp.py:        expr = expr.replace(\"!\",\" not \")\nastropy\/extern\/ply\/yacc.py:# Techniques, and Tools\" (The Dragon Book).  LALR(1) has since been replaced\nastropy\/extern\/ply\/yacc.py:                # the tokenstack and replace it with an 'error' token.\nastropy\/extern\/ply\/yacc.py:                # the tokenstack and replace it with an 'error' token.\nastropy\/extern\/ply\/yacc.py:                # the tokenstack and replace it with an 'error' token.","role":"tool","tool_calls":null},{"content":".\/astropy\/io\/fits\/connect.py\n.\/astropy\/io\/fits\/convenience.py\n.\/astropy\/io\/fits\/setup_package.py\n.\/astropy\/io\/fits\/verify.py\n.\/astropy\/io\/fits\/file.py\n.\/astropy\/io\/fits\/tests\/test_groups.py\n.\/astropy\/io\/fits\/tests\/test_compression_failures.py\n.\/astropy\/io\/fits\/tests\/test_division.py\n.\/astropy\/io\/fits\/tests\/test_fitscheck.py\n.\/astropy\/io\/fits\/tests\/test_checksum.py\n.\/astropy\/io\/fits\/tests\/test_nonstandard.py\n.\/astropy\/io\/fits\/tests\/test_util.py\n.\/astropy\/io\/fits\/tests\/test_fitsheader.py\n.\/astropy\/io\/fits\/tests\/test_image.py\n.\/astropy\/io\/fits\/tests\/test_hdulist.py\n.\/astropy\/io\/fits\/tests\/test_table.py\n.\/astropy\/io\/fits\/tests\/test_fitsinfo.py\n.\/astropy\/io\/fits\/tests\/test_header.py\n.\/astropy\/io\/fits\/tests\/test_diff.py\n.\/astropy\/io\/fits\/tests\/test_structured.py\n.\/astropy\/io\/fits\/tests\/test_core.py\n.\/astropy\/io\/fits\/tests\/test_uint.py\n.\/astropy\/io\/fits\/tests\/test_fitsdiff.py\n.\/astropy\/io\/fits\/tests\/test_fitstime.py\n.\/astropy\/io\/fits\/tests\/test_connect.py\n.\/astropy\/io\/fits\/tests\/__init__.py\n.\/astropy\/io\/fits\/tests\/test_convenience.py\n.\/astropy\/io\/fits\/_numpy_hacks.py\n.\/astropy\/io\/fits\/hdu\/compressed.py\n.\/astropy\/io\/fits\/hdu\/image.py\n.\/astropy\/io\/fits\/hdu\/table.py\n.\/astropy\/io\/fits\/hdu\/nonstandard.py\n.\/astropy\/io\/fits\/hdu\/streaming.py\n.\/astropy\/io\/fits\/hdu\/base.py\n.\/astropy\/io\/fits\/hdu\/__init__.py\n.\/astropy\/io\/fits\/hdu\/groups.py\n.\/astropy\/io\/fits\/hdu\/hdulist.py\n.\/astropy\/io\/fits\/diff.py\n.\/astropy\/io\/fits\/column.py\n.\/astropy\/io\/fits\/fitsrec.py\n.\/astropy\/io\/fits\/fitstime.py\n.\/astropy\/io\/fits\/util.py\n.\/astropy\/io\/fits\/card.py\n.\/astropy\/io\/fits\/scripts\/fitsheader.py\n.\/astropy\/io\/fits\/scripts\/fitsdiff.py\n.\/astropy\/io\/fits\/scripts\/fitscheck.py\n.\/astropy\/io\/fits\/scripts\/fitsinfo.py\n.\/astropy\/io\/fits\/scripts\/__init__.py\n.\/astropy\/io\/fits\/header.py\n.\/astropy\/io\/fits\/__init__.py","role":"tool","tool_calls":null},{"content":"\n\n<files>\nastropy\/io\/fits\/fitsrec.py\nastropy\/io\/fits\/hdu\/table.py\nastropy\/io\/fits\/column.py\nastropy\/io\/fits\/header.py\nastropy\/io\/fits\/util.py\nastropy\/io\/fits\/card.py\nastropy\/io\/fits\/tests\/test_table.py\nastropy\/io\/fits\/tests\/test_header.py\nastropy\/io\/fits\/tests\/test_util.py\n<\/files>","role":"assistant","tool_calls":null}],"task":"default","reward":0.2,"generation_ms":49451.1556625366,"scoring_ms":0.2059936523,"total_ms":49451.361656189,"info":{"instance_id":"astropy__astropy-6938","max_tokens":40960,"max_tool_calls":5,"oai_tools":[{"function":{"description":"Execute a bash command and return the results.\nUseful for finding files in the codebase and reading them.\nALWAYS use this tool to find files irrespective of the task at hand.","name":"bash","parameters":{"additionalProperties":false,"properties":{"command":{"description":"The full bash command to execute\n     Example: \"rg 'def main' -t py\" or \"ls -la\" or \"cat file.txt\"","title":"Command","type":"string"}},"required":["command"],"title":"bash_args","type":"object"}},"type":"function"}],"repo":"astropy\/astropy"},"answer":"{\"astropy\/io\/fits\/fitsrec.py\": {\"old_start\": 1261, \"old_count\": 7, \"new_start\": 1261, \"new_count\": 7, \"hunks\": [{\"old_start\": 1261, \"old_count\": 7, \"new_start\": 1261, \"new_count\": 7}]}}","file_localization_reward":0.2}
